<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="1. 静态检查与静态类型检查


静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。


静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。


2. TypeScript 与 JavaScript 的关系


TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。


关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。


重要特性：

TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。
TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。



注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = &#39;str&#39;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。


3. TypeScript 的核心优势（面试高频）


提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。


增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。


提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。


更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。


4. TypeScript 的类型推断与扩展


类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。
例：let x = 10 → TS 推断x为number；const y = { name: &#39;ts&#39; } → 推断y为{ name: string }。">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/ts/01--ts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/ts/01--ts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/ts/01--ts/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="1. 静态检查与静态类型检查 静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。
静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。
2. TypeScript 与 JavaScript 的关系 TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。
关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。
重要特性：
TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。 TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。 注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = &#39;str&#39;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。
3. TypeScript 的核心优势（面试高频） 提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。
增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。
提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。
更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。
4. TypeScript 的类型推断与扩展 类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。 例：let x = 10 → TS 推断x为number；const y = { name: &#39;ts&#39; } → 推断y为{ name: string }。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="1. 静态检查与静态类型检查


静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。


静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。


2. TypeScript 与 JavaScript 的关系


TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。


关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。


重要特性：

TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。
TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。



注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = &#39;str&#39;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。


3. TypeScript 的核心优势（面试高频）


提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。


增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。


提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。


更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。


4. TypeScript 的类型推断与扩展


类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。
例：let x = 10 → TS 推断x为number；const y = { name: &#39;ts&#39; } → 推断y为{ name: string }。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://example.org/posts/ts/01--ts/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "1. 静态检查与静态类型检查 静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。\n静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。\n2. TypeScript 与 JavaScript 的关系 TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。\n关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。\n重要特性：\nTS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。 TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。 注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = 'str'在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。\n3. TypeScript 的核心优势（面试高频） 提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。\n增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。\n提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。\n更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。\n4. TypeScript 的类型推断与扩展 类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。 例：let x = 10 → TS 推断x为number；const y = { name: 'ts' } → 推断y为{ name: string }。\n",
  "keywords": [
    
  ],
  "articleBody": "1. 静态检查与静态类型检查 静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。\n静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。\n2. TypeScript 与 JavaScript 的关系 TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。\n关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。\n重要特性：\nTS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。 TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。 注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = 'str'在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。\n3. TypeScript 的核心优势（面试高频） 提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。\n增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。\n提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。\n更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。\n4. TypeScript 的类型推断与扩展 类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。 例：let x = 10 → TS 推断x为number；const y = { name: 'ts' } → 推断y为{ name: string }。\n类型注解：当推断结果不符合预期时，可显式指定类型（:后接类型）。 例：let z: string = 'hello'；function add(a: number, b: number): number { return a + b }。\n5. TypeScript 的类型系统 基础类型（同 JS）：boolean、number、string、null、undefined、bigint、symbol。 注意：null和undefined是所有类型的子类型（默认配置下，let a: number = null不报错，可通过strictNullChecks开启严格检查）。\nTS 扩展类型：\nany：关闭类型检查，允许赋值任意类型（滥用会失去 TS 优势，建议避免）。 unknown：类型安全的any，使用前必须明确类型（如if (typeof u === 'string') { ... }）。 never：表示 “不可能发生的类型”（如抛出错误的函数返回值function error(): never { throw new Error() }）。 void：函数无返回值或返回undefined（function log(): void { console.log('hi') }）。 6. 类型定义语法 相同点：均可定义对象类型（{ name: string }）。\n核心区别：\ninterface支持声明合并（多次定义同一接口会自动合并），type不支持。 例：interface User { name: string }与interface User { age: number }合并为{ name: string; age: number }。 type可定义联合类型（A | B）、交叉类型（A \u0026 B）、字面量类型（'success' | 'error'）等，interface不行。 最佳实践：\n定义对象 / 类的结构时优先用interface（便于扩展和合并）。 需要联合、交叉等复杂类型时用type。 7. 复杂类型的创建方式 联合类型（A | B）：值可以是多种类型之一。 例：type ID = number | string（ID 可以是数字或字符串）；type Status = 'pending' | 'done'（字符串字面量联合，限制取值范围）。\n交叉类型（A \u0026 B）：合并多个类型为一个（同时具备所有类型的属性）。 例：type User = { name: string } \u0026 { age: number } → 等价于{ name: string; age: number }。\n泛型：为类型添加 “变量”，实现类型复用（解决 “类型不固定但需保持一致性” 问题）。\n例：\n// 泛型函数：保证输入和输出类型一致 function identity\u003cT\u003e(arg: T): T { return arg } // 泛型接口：定义数组中元素的类型 interface List\u003cT\u003e { data: T[] } 常见场景：函数参数与返回值关联、容器类（数组、Promise）的类型约束。\n8. TypeScript 的核心原则：结构类型系统 又称 “鸭子类型”：判断类型兼容性时，只关注值的形状（属性和方法），不关注类型名称。\n例：\ninterface Cat { meow(): void } interface Dog { meow(): void } // 与 Cat 结构相同 const animal: Cat = { meow: () =\u003e {} } // 正确：形状匹配 const dog: Dog = animal // 正确：结构相同，可互相赋值 注意：只要对象包含目标类型的必需属性，就视为兼容（允许额外属性）。\n9. TypeScript 的目标 为 JS 提供静态类型检查，在不破坏 JS 灵活性的前提下，解决动态类型导致的常见问题（如拼写错误、API 误用）。\n",
  "wordCount" : "297",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/ts/01--ts/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h3 id="1-静态检查与静态类型检查">1. <strong>静态检查与静态类型检查</strong><a hidden class="anchor" aria-hidden="true" href="#1-静态检查与静态类型检查">#</a></h3>
<ul>
<li>
<p>静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是<strong>动态检查</strong>（运行时检测错误，如 JS 中的<code>TypeError</code>）。</p>
</li>
<li>
<p>静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。</p>
</li>
</ul>
<h3 id="2-typescript-与-javascript-的关系">2. <strong>TypeScript 与 JavaScript 的关系</strong><a hidden class="anchor" aria-hidden="true" href="#2-typescript-与-javascript-的关系">#</a></h3>
<ul>
<li>
<p>TypeScript 是 JavaScript 的<strong>超集</strong>：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。</p>
</li>
<li>
<p>关键区别：TS 增加了<strong>静态类型系统</strong>，而 JS 是动态类型语言（类型检查仅在运行时发生）。</p>
</li>
<li>
<p>重要特性：</p>
<ul>
<li>TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。</li>
<li>TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。</li>
</ul>
</li>
<li>
<p>注意：TS 会对 JS 代码进行<strong>类型检查</strong>（如<code>let a = 1; a = 'str'</code>在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。</p>
</li>
</ul>
<h3 id="3-typescript-的核心优势面试高频">3. <strong>TypeScript 的核心优势（面试高频）</strong><a hidden class="anchor" aria-hidden="true" href="#3-typescript-的核心优势面试高频">#</a></h3>
<ul>
<li>
<p><strong>提前发现错误</strong>：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。</p>
</li>
<li>
<p><strong>增强代码可读性</strong>：类型注解明确变量 / 函数的预期用途，降低团队协作成本。</p>
</li>
<li>
<p><strong>提升开发效率</strong>：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。</p>
</li>
<li>
<p><strong>更好的可维护性</strong>：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。</p>
</li>
</ul>
<h3 id="4-typescript-的类型推断与扩展">4. <strong>TypeScript 的类型推断与扩展</strong><a hidden class="anchor" aria-hidden="true" href="#4-typescript-的类型推断与扩展">#</a></h3>
<ul>
<li>
<p>类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。
例：<code>let x = 10</code> → TS 推断<code>x</code>为<code>number</code>；<code>const y = { name: 'ts' }</code> → 推断<code>y</code>为<code>{ name: string }</code>。</p>
</li>
<li>
<p>类型注解：当推断结果不符合预期时，可显式指定类型（<code>:</code>后接类型）。
例：<code>let z: string = 'hello'</code>；<code>function add(a: number, b: number): number { return a + b }</code>。</p>
</li>
</ul>
<h3 id="5-typescript-的类型系统">5. <strong>TypeScript 的类型系统</strong><a hidden class="anchor" aria-hidden="true" href="#5-typescript-的类型系统">#</a></h3>
<ul>
<li>
<p><strong>基础类型</strong>（同 JS）：<code>boolean</code>、<code>number</code>、<code>string</code>、<code>null</code>、<code>undefined</code>、<code>bigint</code>、<code>symbol</code>。
注意：<code>null</code>和<code>undefined</code>是所有类型的子类型（默认配置下，<code>let a: number = null</code>不报错，可通过<code>strictNullChecks</code>开启严格检查）。</p>
</li>
<li>
<p><strong>TS 扩展类型</strong>：</p>
<ul>
<li><code>any</code>：关闭类型检查，允许赋值任意类型（滥用会失去 TS 优势，建议避免）。</li>
<li><code>unknown</code>：类型安全的<code>any</code>，使用前必须明确类型（如<code>if (typeof u === 'string') { ... }</code>）。</li>
<li><code>never</code>：表示 “不可能发生的类型”（如抛出错误的函数返回值<code>function error(): never { throw new Error() }</code>）。</li>
<li><code>void</code>：函数无返回值或返回<code>undefined</code>（<code>function log(): void { console.log('hi') }</code>）。</li>
</ul>
</li>
</ul>
<h3 id="6-类型定义语法">6. <strong>类型定义语法</strong><a hidden class="anchor" aria-hidden="true" href="#6-类型定义语法">#</a></h3>
<ul>
<li>
<p>相同点：均可定义对象类型（<code>{ name: string }</code>）。</p>
</li>
<li>
<p>核心区别：</p>
<ul>
<li><code>interface</code>支持<strong>声明合并</strong>（多次定义同一接口会自动合并），<code>type</code>不支持。
例：<code>interface User { name: string }</code>与<code>interface User { age: number }</code>合并为<code>{ name: string; age: number }</code>。</li>
<li><code>type</code>可定义<strong>联合类型</strong>（<code>A | B</code>）、<strong>交叉类型</strong>（<code>A &amp; B</code>）、<strong>字面量类型</strong>（<code>'success' | 'error'</code>）等，<code>interface</code>不行。</li>
</ul>
</li>
<li>
<p>最佳实践：</p>
<ul>
<li>定义对象 / 类的结构时优先用<code>interface</code>（便于扩展和合并）。</li>
<li>需要联合、交叉等复杂类型时用<code>type</code>。</li>
</ul>
</li>
</ul>
<h3 id="7-复杂类型的创建方式">7. <strong>复杂类型的创建方式</strong><a hidden class="anchor" aria-hidden="true" href="#7-复杂类型的创建方式">#</a></h3>
<ul>
<li>
<p><strong>联合类型</strong>（<code>A | B</code>）：值可以是多种类型之一。
例：<code>type ID = number | string</code>（ID 可以是数字或字符串）；<code>type Status = 'pending' | 'done'</code>（字符串字面量联合，限制取值范围）。</p>
</li>
<li>
<p><strong>交叉类型</strong>（<code>A &amp; B</code>）：合并多个类型为一个（同时具备所有类型的属性）。
例：<code>type User = { name: string } &amp; { age: number }</code> → 等价于<code>{ name: string; age: number }</code>。</p>
</li>
<li>
<p><strong>泛型</strong>：为类型添加 “变量”，实现类型复用（解决 “类型不固定但需保持一致性” 问题）。</p>
<p>例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// 泛型函数：保证输入和输出类型一致
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">identity</span>&lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">arg</span>: <span style="color:#66d9ef">T</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arg</span> }
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 泛型接口：定义数组中元素的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">List</span>&lt;<span style="color:#f92672">T</span>&gt; { <span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">T</span>[] }
</span></span></code></pre></div><p>常见场景：函数参数与返回值关联、容器类（数组、Promise）的类型约束。</p>
</li>
</ul>
<h3 id="8-typescript-的核心原则结构类型系统">8. <strong>TypeScript 的核心原则：结构类型系统</strong><a hidden class="anchor" aria-hidden="true" href="#8-typescript-的核心原则结构类型系统">#</a></h3>
<ul>
<li>
<p>又称 “鸭子类型”：判断类型兼容性时，只关注<strong>值的形状</strong>（属性和方法），不关注类型名称。</p>
</li>
<li>
<p>例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Cat</span> { <span style="color:#a6e22e">meow</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Dog</span> { <span style="color:#a6e22e">meow</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> } <span style="color:#75715e">// 与 Cat 结构相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">animal</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">meow</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> {} } <span style="color:#75715e">// 正确：形状匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">dog</span>: <span style="color:#66d9ef">Dog</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">animal</span> <span style="color:#75715e">// 正确：结构相同，可互相赋值
</span></span></span></code></pre></div></li>
<li>
<p>注意：只要对象包含目标类型的<strong>必需属性</strong>，就视为兼容（允许额外属性）。</p>
</li>
</ul>
<h3 id="9-typescript-的目标">9. <strong>TypeScript 的目标</strong><a hidden class="anchor" aria-hidden="true" href="#9-typescript-的目标">#</a></h3>
<p>为 JS 提供<strong>静态类型检查</strong>，在不破坏 JS 灵活性的前提下，解决动态类型导致的常见问题（如拼写错误、API 误用）。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
