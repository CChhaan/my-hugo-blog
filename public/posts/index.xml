<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://example.org/posts/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en-us</language>
    <atom:link href="https://example.org/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%80-~-%E5%9B%9B%E7%AB%A0-%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%80-~-%E5%9B%9B%E7%AB%A0-%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8git/</guid>
      <description>&lt;h2 id=&#34;git-概述&#34;&gt;Git 概述&lt;/h2&gt;
&lt;p&gt;Git 是一种分布式版本控制系统，具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;免费开源，降低使用成本，支持二次开发和定制化需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作速度快、存储效率高，通过快照式存储而非差异对比，高效处理大型项目的版本控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式架构：无需依赖中央服务器，每个开发者可拥有完整版本库，断网时仍能提交代码，多人协作更灵活。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用命令跨系统对比&#34;&gt;常用命令（跨系统对比）&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Windows&lt;/th&gt;
          &lt;th&gt;macOS/Linux&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;cd&lt;/td&gt;
          &lt;td&gt;cd&lt;/td&gt;
          &lt;td&gt;切换目录&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;cd&lt;/td&gt;
          &lt;td&gt;pwd&lt;/td&gt;
          &lt;td&gt;获取当前所在的位置&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;dir&lt;/td&gt;
          &lt;td&gt;ls&lt;/td&gt;
          &lt;td&gt;列出当前目录的文件和目录&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;mkdir&lt;/td&gt;
          &lt;td&gt;mkdir&lt;/td&gt;
          &lt;td&gt;创建新的目录&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;touch&lt;/td&gt;
          &lt;td&gt;创建文件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;copy&lt;/td&gt;
          &lt;td&gt;cp&lt;/td&gt;
          &lt;td&gt;复制文件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;move&lt;/td&gt;
          &lt;td&gt;mv&lt;/td&gt;
          &lt;td&gt;移动文件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;del&lt;/td&gt;
          &lt;td&gt;rm&lt;/td&gt;
          &lt;td&gt;删除文件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;cls&lt;/td&gt;
          &lt;td&gt;clear&lt;/td&gt;
          &lt;td&gt;清除终端显示内容&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;命令示例&#34;&gt;命令示例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 切换到上一层目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd ..
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ~表示home目录，切换到home目录下的project目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd ~/project/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 显示当前所在目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pwd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 列出当前目录下所有文件及目录，包括以小数点开头的文件，并显示完整信息（权限、所有者、创建及修改时间等）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls -al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 删除目录中所有的.html文档&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm *.html
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 创建文件，若文件不存在则创建空白文件，若已存在则仅修改最后修改时间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;touch index.html
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ls-命令说明&#34;&gt;ls 命令说明&lt;/h3&gt;
&lt;p&gt;ls 命令用于列出当前目录下的所有文件及目录，-al 参数中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a：表示显示以小数点开头的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;l：表示显示文件的完整权限、所有者以及创建、修改的时间等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vim-操作&#34;&gt;vim 操作&lt;/h2&gt;
&lt;p&gt;vim 主要通过模式切换进行输入、光标移动、选取、复制及粘贴等操作，常用模式有两种：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;h2 id=&#34;修改历史信息&#34;&gt;修改历史信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：git rebase -i &amp;lt;基准commit&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt;：进入互动模式，可编辑历史提交。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;基准commit&amp;gt;&lt;/code&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;操作过程&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行命令后，弹出 vim 编辑器，列表中&lt;strong&gt;从上到下为 “从旧到新” 的 commit&lt;/strong&gt;（与&lt;code&gt;git log&lt;/code&gt;的 “从新到旧” 相反）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;影响&lt;/strong&gt;：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;取消 rebase&lt;/strong&gt;：git reset ORIG_HEAD &amp;ndash;hard&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;把多个-commit-合并成一个-commit&#34;&gt;把多个 commit 合并成一个 commit&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行&lt;code&gt;git rebase -i &amp;lt;最早要合并的commit的前一个哈希&amp;gt;&lt;/code&gt;（如合并最近 3 个 commit，基准为&lt;code&gt;HEAD~4&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在编辑器中，将目标 commit 的&lt;code&gt;pick&lt;/code&gt;改为&lt;code&gt;squash&lt;/code&gt;（或&lt;code&gt;fixup&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存退出后，若用&lt;code&gt;squash&lt;/code&gt;：弹出编辑器，合并所有 commit 信息为一个（&lt;code&gt;fixup&lt;/code&gt;则直接使用上一个 commit 的信息）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成后，多个 commit 被合并为一个，历史更简洁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;把一个-commit-拆解成多个-commit&#34;&gt;把一个 commit 拆解成多个 commit&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%8A%E5%86%B7%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%8A%E5%86%B7%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h4 id=&#34;一工作中途切换任务的处理git-stash&#34;&gt;一、工作中途切换任务的处理（git stash）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git stash&lt;/code&gt;用于临时保存工作区和暂存区的修改（未提交的内容），以便切换分支处理其他任务，后续可恢复继续工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保存当前修改&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash                  &lt;span style=&#34;color:#75715e&#34;&gt;# 保存已跟踪文件的修改（默认不包含untracked文件）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash -u               &lt;span style=&#34;color:#75715e&#34;&gt;# 同时保存untracked文件（新文件）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash -a               &lt;span style=&#34;color:#75715e&#34;&gt;# 保存所有修改（包括untracked和ignored文件，谨慎使用）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash -m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;描述信息&amp;#34;&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;# 给stash添加描述，便于区分（推荐）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查看保存的 stash&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash list             &lt;span style=&#34;color:#75715e&#34;&gt;# 列出所有stash，格式：stash@{n}: WIP on &amp;lt;分支名&amp;gt;: &amp;lt;描述&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 示例：stash@{0}: WIP on feature/login: 完善表单验证&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;恢复 stash&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git stash pop &amp;lt;stash@{n}&amp;gt;&lt;/code&gt;：恢复指定 stash 并从列表中删除（默认恢复最新的 stash@{0}）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash apply &amp;lt;stash@{n}&amp;gt;&lt;/code&gt;：恢复指定 stash 但&lt;strong&gt;不删除&lt;/strong&gt;（可多次应用，适合多分支复用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;删除 stash&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash drop &amp;lt;stash@&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&amp;gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 删除指定stash&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git stash clear             &lt;span style=&#34;color:#75715e&#34;&gt;# 清空所有stash（谨慎！）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二移除-git-历史中的敏感信息如账号密码&#34;&gt;二、移除 Git 历史中的敏感信息（如账号密码）&lt;/h4&gt;
&lt;p&gt;当不慎提交敏感文件后，需彻底从历史中删除。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推荐方法：&lt;code&gt;git filter-repo&lt;/code&gt;（现代替代&lt;code&gt;filter-branch&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;git filter-branch&lt;/code&gt;因性能差、易出错已被官方推荐&lt;code&gt;git filter-repo&lt;/code&gt;替代（需先安装：&lt;code&gt;pip install git-filter-repo&lt;/code&gt;）。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/</guid>
      <description>&lt;h2 id=&#34;新增初始-repository&#34;&gt;新增、初始 Repository&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;：git init&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：在目录中创建一个.git目录，该目录是 Git 进行版本控制的核心。若移除.git目录，Git 将失去对该目录的控制权，可用于提供不含版控记录的内容给客户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;把文件交给-git-管控&#34;&gt;把文件交给 Git 管控&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查看目录状态&lt;/strong&gt;：git status&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示文件状态：&lt;code&gt;Untracked&lt;/code&gt;（未跟踪，新文件）、&lt;code&gt;Modified&lt;/code&gt;（已修改未暂存）、&lt;code&gt;Staged&lt;/code&gt;（已暂存待提交）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加文件到暂存区&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单个文件：git add &amp;lt;文件名&amp;gt;，将指定文件安置到暂存区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特定类型文件：git add *.html，把所有后缀为.html的文件加到暂存区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全部文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git add &amp;ndash;all（或&lt;code&gt;git add -A&lt;/code&gt;），添加项目中所有异动文件到暂存区；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git add .，添加当前目录及子目录中的异动文件到暂存区，对目录外文件无效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：git add后若再次改动文件，改动内容不会自动加入暂存区，暂存区仍为之前的版本，此时&lt;code&gt;git status&lt;/code&gt;会显示文件同时处于&lt;code&gt;Modified&lt;/code&gt;（工作区）和&lt;code&gt;Staged&lt;/code&gt;（暂存区）状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提交到存储库&lt;/strong&gt;：git commit -m &amp;lsquo;init commit&amp;rsquo;，-m后为提交说明，将暂存区内容永久保存到存储库。每次commit仅处理暂存区内容，未加入暂存区的文件不会被提交。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空提交&lt;/strong&gt;：git commit &amp;ndash;allow-empty -m &amp;ldquo;&amp;quot;，加上&amp;ndash;allow-empty参数，无文件变动时强制提交（常用于触发 CI/CD 流程或标记重要节点）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作区暂存区与存储库&#34;&gt;工作区、暂存区与存储库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关系&lt;/strong&gt;：git add将文件从工作目录移至暂存区，git commit将暂存区内容移至存储库，完成commit才算整个流程结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简化提交&lt;/strong&gt;：git commit -a -m &amp;ldquo;update content&amp;rdquo;，-a参数可缩短流程，跳过&lt;code&gt;git add&lt;/code&gt;，直接将&lt;strong&gt;已跟踪文件&lt;/strong&gt;的修改提交（新文件&lt;code&gt;Untracked&lt;/code&gt;不生效，仍需手动&lt;code&gt;add&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看记录&#34;&gt;查看记录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基本查看&lt;/strong&gt;：git log，越新的信息越靠上，显示作者、提交时间、提交说明等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精简查看&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git log --oneline&lt;/code&gt;：每行显示一条记录（哈希前缀 + 说明）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --graph --oneline&lt;/code&gt;：图形化展示分支合并历史（直观看到分支流向）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按作者筛选&lt;/strong&gt;：git log  &amp;ndash;author=&amp;ldquo;Sherly\|Eddie&amp;rdquo;，\|表示 “或者”，可查找多个人的提交记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按提交信息筛选&lt;/strong&gt;：git log &amp;ndash;grep=&amp;ldquo;LOL&amp;rdquo;，从提交信息中搜索含关键字的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按内容筛选&lt;/strong&gt;：git log -S &amp;lsquo;Ruby&amp;rsquo;，在所有提交文件中搜索符合特定条件的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按时间筛选&lt;/strong&gt;：git log &amp;ndash;since=&amp;ldquo;9am&amp;rdquo; &amp;ndash;until=&amp;ldquo;12am&amp;rdquo; &amp;ndash;after=&amp;ldquo;2017-01&amp;rdquo;，找出 2017 年 1 月之后每天早上 9 点到 12 点之间的提交。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;删除文件或变更文件名&#34;&gt;删除文件或变更文件名&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;删除文件&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统命令删除：使用rm或资源管理器删除后，git add将改动加到暂存区再提交。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%92%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%A0%87%E7%AD%BE%E5%92%8Cgitflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%92%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%A0%87%E7%AD%BE%E5%92%8Cgitflow/</guid>
      <description>&lt;h3 id=&#34;git-标签相关知识&#34;&gt;Git 标签相关知识&lt;/h3&gt;
&lt;h4 id=&#34;一标签的概念与作用&#34;&gt;一、标签的概念与作用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;标签是 Git 中指向某个 commit 的指示标，常用于标记软件开发的特定里程碑（如版本发布）。&lt;/li&gt;
&lt;li&gt;标签本质类似 “贴纸”，标签一旦创建，默认不会随新提交移动，删除标签不会影响对应的 commit 或文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二标签的类型及使用&#34;&gt;二、标签的类型及使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;轻量标签&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：仅作为指向某个 commit 的指示标，不含额外信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建方式：直接指定 commit（若不指定则默认当前 commit）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git tag &amp;lt;标签名&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;commit的SHA-1值&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git tag big_cats 51d54ff
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储：指向某个 commit 的 SHA-1 值，存于 &lt;code&gt;.git/refs/tags&lt;/code&gt; 目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有附注的标签&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：包含更多信息（如标签创建者、时间、描述等），推荐使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建方式：通过&lt;code&gt;-a &lt;/code&gt;参数创建，&lt;code&gt;-m &lt;/code&gt;可添加描述（若无&lt;code&gt;-m&lt;/code&gt;则弹出 vim 编辑器）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;git tag &amp;lt;标签名&amp;gt; [commit的SHA-1值] -a -m &amp;ldquo;描述信息&amp;rdquo;
```&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 示例：

 ```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git tag big_cats 51d64ff -a -m &amp;ldquo;big cats are comming&amp;rdquo;
```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储：指向某个 Tag 对象的 SHA-1 值，该 Tag 对象再指向对应的 commit，存于 &lt;code&gt;.git/refs/tags&lt;/code&gt; 目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标签的查看与删除&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/</guid>
      <description>&lt;h2 id=&#34;分支的基本操作&#34;&gt;分支的基本操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;查看分支&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;执行git branch命令，不带任何参数时，会输出当前项目中的所有分支，前面带有星号的分支表示当前所在分支（即 HEAD 指向的分支）。&lt;/li&gt;
&lt;li&gt;扩展命令（面试高频）：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch -r&lt;/code&gt;：查看远程分支（如&lt;code&gt;origin/main&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -a&lt;/code&gt;：查看本地 + 远程所有分支（远程分支以&lt;code&gt;remotes/&lt;/code&gt;前缀显示）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -v&lt;/code&gt;：显示各分支最后一次提交信息（哈希 + 说明）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;创建分支&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;在git branch命令后加上想要创建的分支名称，即可基于当前分支为基准创建新分支（仅创建，不切换），例如git branch cat。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;修改分支名称&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用-m参数可以修改分支名称，即使是 master 分支也能修改，且不会影响文件或目录（当前分支可省略旧名，直接&lt;code&gt;git branch -m &amp;lt;新名&amp;gt;&lt;/code&gt;），如git branch -m cat tiger。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;删除分支&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用-d参数可以删除不需要的分支，如git branch -d dog。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若要删除的分支未被完全合并，-d参数无法删除，此时可使用-D参数强制删除，如git branch -D dog。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前所在的分支不能删除，需先切换到其他分支再进行删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;切换分支&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用git checkout命令切换分支，如git checkout dog，切换的分支必须已存在，否则会出错（Git 2.23 + 推荐用&lt;code&gt;git switch &amp;lt;分支名&amp;gt;&lt;/code&gt;，更直观）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若要切换的分支不存在，可在git checkout后加上-b参数，若分支不存在则创建并切换过去，若已存在则直接切换，如git checkout -b new_branch。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：切换分支前，需 commit 或 stash 工作区的修改（否则未提交的修改会被带到新分支）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对分支的理解&#34;&gt;对分支的理解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以将分支想象成一张贴纸，贴在某个 commit 上。当进行新的 commit 后，新的 commit 会指向其前一个 commit，当前分支（HEAD 所指分支）会贴到新的 commit 上，HEAD 也会随之前进。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/</guid>
      <description>&lt;h4 id=&#34;一将内容推送到-github&#34;&gt;一、将内容推送到 GitHub&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;前置准备&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。&lt;/li&gt;
&lt;li&gt;仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关联远端仓库&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git remote add origin &amp;lt;GitHub仓库地址&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remote add&lt;/code&gt;：添加远端节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;origin&lt;/code&gt;：远端 节点的默认名称（可自定义或修改）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;远端仓库管理补充操作&#34;&gt;远端仓库管理（补充操作）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查看远端配置&lt;/strong&gt;：&lt;code&gt;git remote -v&lt;/code&gt;（显示远端名称、地址及操作类型，确认是否关联正确）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修改远端地址&lt;/strong&gt;：&lt;code&gt;git remote set-url origin &amp;lt;新地址&amp;gt;&lt;/code&gt;（如仓库迁移后更新地址）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除远端关联&lt;/strong&gt;：&lt;code&gt;git remote remove origin&lt;/code&gt;（解除与远端的绑定）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;推送内容到远端&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git push -u origin master
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;作用：将本地 &lt;code&gt;master&lt;/code&gt; 分支推送到 &lt;code&gt;origin&lt;/code&gt; 远端，若远端无 &lt;code&gt;master&lt;/code&gt; 则创建，同时通过 &lt;code&gt;-u&lt;/code&gt; 设置 upstream（上游跟踪关系）。&lt;/li&gt;
&lt;li&gt;后续推送：设置 upstream 后，直接执行 &lt;code&gt;git push&lt;/code&gt; 即可（无需重复指定远端和分支）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;upstream 作用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;本地分支通过 &lt;code&gt;-u&lt;/code&gt; 关联远端分支（如 &lt;code&gt;origin/master&lt;/code&gt;）后，&lt;code&gt;pull/push&lt;/code&gt; 会默认操作关联的远端分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;推送时重命名分支&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git push origin master:cat  &lt;span style=&#34;color:#75715e&#34;&gt;# 将本地master推送到远端并命名为cat&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二从-github-拉取更新pullfetch&#34;&gt;二、从 GitHub 拉取更新（pull/fetch）&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;本质&lt;/th&gt;
          &lt;th&gt;适用场景&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;仅获取远端更新（更新&lt;code&gt;origin/xxx&lt;/code&gt;分支），不合并&lt;/td&gt;
          &lt;td&gt;需先查看远端修改再决定是否合并（安全）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;git fetch + git merge&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;快速同步远端修改（可能产生合并 commit）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;git fetch + git rebase&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;保持历史线性（无合并 commit，推荐协作场景）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fetch&lt;/code&gt;是 “安全查看”：获取后可通过&lt;code&gt;git diff origin/main&lt;/code&gt;对比本地与远端差异，再手动&lt;code&gt;merge&lt;/code&gt;或&lt;code&gt;rebase&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pull --rebase&lt;/code&gt;优于&lt;code&gt;pull&lt;/code&gt;：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三推送失败的原因及解决&#34;&gt;三、推送失败的原因及解决&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：本地版本落后于远端（远端 有更新未同步到本地）。&lt;/li&gt;
&lt;li&gt;解决：
&lt;ol&gt;
&lt;li&gt;先拉取更新：&lt;code&gt;git pull&lt;/code&gt;（合并入远端修改后再推送）。&lt;/li&gt;
&lt;li&gt;强制推送（谨慎使用）：&lt;code&gt;git push -f&lt;/code&gt;（会覆盖远端内容，仅用于协作分支使用）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;四从服务器克隆仓库git-clone&#34;&gt;四、从服务器克隆仓库（git clone）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基本用法&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%80%E7%AB%A0-js%E7%AE%80%E5%8F%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%80%E7%AB%A0-js%E7%AE%80%E5%8F%B2/</guid>
      <description>&lt;h3 id=&#34;一dom文档对象模型&#34;&gt;一、DOM（文档对象模型）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心定义&lt;/strong&gt;：DOM 是一套对文档内容进行抽象和概念化的方法，它将 HTML/XML 文档的结构转化为一个树形的对象模型，使得程序（如 JS）可以访问和操作文档的内容、结构和样式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：作为 JS 与网页内容之间的桥梁，允许开发者通过代码动态修改文档的元素、属性、文本等（例如添加节点、修改样式、绑定事件等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二dhtml动态-html&#34;&gt;二、DHTML（动态 HTML）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本质&lt;/strong&gt;：DHTML 并非一项独立技术，而是 &lt;strong&gt;HTML、CSS 和 JavaScript 三种技术的组合术语&lt;/strong&gt;，用于描述 “动态操控网页内容和样式” 的技术方案。&lt;/li&gt;
&lt;li&gt;核心组成与目标：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTML&lt;/strong&gt;：负责标记网页的结构和内容（如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 等元素）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS&lt;/strong&gt;：负责定义元素的样式（颜色、布局、位置等）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;：负责实时操控页面元素和样式（如动态修改 CSS 属性、显示 / 隐藏元素、响应用户交互等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心价值&lt;/strong&gt;：通过三者协同，实现网页内容的动态更新，无需重新加载页面即可改变外观和行为（如表单验证、菜单切换、实时数据展示等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三api应用程序编程接口&#34;&gt;三、API（应用程序编程接口）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：API 是一组得到各方共同认可的基本约定，规定了不同组件（如软件、库、服务）之间如何交互的规则（包括可调用的函数、参数格式、返回值类型等）。&lt;/li&gt;
&lt;li&gt;举例：
&lt;ul&gt;
&lt;li&gt;DOM API：如 &lt;code&gt;document.getElementById()&lt;/code&gt;、&lt;code&gt;element.appendChild()&lt;/code&gt; 等，规定了 JS 操作文档的方法；&lt;/li&gt;
&lt;li&gt;浏览器 API：如 &lt;code&gt;fetch()&lt;/code&gt;（网络请求）、&lt;code&gt;localStorage&lt;/code&gt;（本地存储）等，提供了 JS 与浏览器功能交互的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：简化开发，使不同模块或系统能够按照统一规则协作，无需关注内部实现细节。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;一传统文档操作方法&#34;&gt;一、传统文档操作方法&lt;/h3&gt;
&lt;h4 id=&#34;1-documentwrite&#34;&gt;1. &lt;code&gt;document.write()&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：将字符串直接插入到文档中，语法简单（如 &lt;code&gt;document.write(&amp;quot;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;quot;)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;违背 “行为与表现分离” 原则，需在 HTML 中嵌入 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 调用，导致代码耦合。&lt;/li&gt;
&lt;li&gt;可能引发文档验证错误，且与 &lt;code&gt;application/xhtml+xml&lt;/code&gt; 类型文档不兼容（浏览器会忽略该方法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-innerhtml&#34;&gt;2. &lt;code&gt;innerHTML&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：读写元素内的 HTML 内容（如 &lt;code&gt;div.innerHTML = &amp;quot;&amp;lt;span&amp;gt;Hi&amp;lt;/span&amp;gt;&amp;quot;&lt;/code&gt; 可设置内容，&lt;code&gt;const html = div.innerHTML&lt;/code&gt; 可读取内容）。&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;简洁高效，适合批量操作 HTML 片段，但无法精确控制单个节点（会整体替换元素内容）。&lt;/li&gt;
&lt;li&gt;局限性：HTML 专有属性，不支持 XHTML 文档；安全性风险（可能引入 XSS 攻击，需谨慎处理用户输入）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代方案&lt;/strong&gt;：标准 DOM 方法（如 &lt;code&gt;createElement&lt;/code&gt;、&lt;code&gt;appendChild&lt;/code&gt;）虽代码量增加，但可精确控制节点，兼容性更强。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二标准-dom-操作方法&#34;&gt;二、标准 DOM 操作方法&lt;/h3&gt;
&lt;h4 id=&#34;1-核心思想&#34;&gt;1. 核心思想&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DOM 是文档的双向映射：既能读取文档结构（通过节点属性和方法），也能修改节点树（实时反映到浏览器渲染结果）。&lt;/li&gt;
&lt;li&gt;浏览器显示的是 DOM 节点树，而非原始 HTML 代码，因此修改 DOM 会直接改变页面表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-创建与插入节点&#34;&gt;2. 创建与插入节点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建元素节点&lt;/strong&gt;：&lt;code&gt;document.createElement(tagName)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;const newDiv = document.createElement(&amp;quot;div&amp;quot;);&lt;/code&gt;（创建 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 元素，初始为 “文档碎片”，未插入文档）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建文本节点&lt;/strong&gt;：&lt;code&gt;document.createTextNode(text)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;const textNode = document.createTextNode(&amp;quot;Hello DOM&amp;quot;);&lt;/code&gt;（创建包含文本的节点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入节点到文档&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%89%E7%AB%A0-dom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%89%E7%AB%A0-dom/</guid>
      <description>&lt;h3 id=&#34;一dom-的核心概念&#34;&gt;一、DOM 的核心概念&lt;/h3&gt;
&lt;p&gt;DOM（Document Object Model，文档对象模型）是一套用于抽象和概念化文档内容的接口，它将网页文档转换为可通过 JavaScript 操作的对象树结构。&lt;/p&gt;
&lt;h4 id=&#34;1-d文档document&#34;&gt;1. D：文档（Document）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当网页加载到浏览器时，浏览器会自动将 HTML/XML 文档解析为一个 &lt;strong&gt;文档对象&lt;/strong&gt;，即 DOM 的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-o对象object&#34;&gt;2. O：对象（Object）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象是包含数据和方法的集合：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;属性&lt;/strong&gt;：对象关联的变量（如 &lt;code&gt;element.id&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：对象可调用的函数（如 &lt;code&gt;element.appendChild()&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JS 中的对象类型：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户定义对象&lt;/strong&gt;：开发者创建的自定义对象；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内建对象&lt;/strong&gt;：JS 自带的对象（如 &lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Date&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;宿主对象&lt;/strong&gt;：浏览器环境提供的对象（如 &lt;code&gt;window&lt;/code&gt;、&lt;code&gt;document&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键宿主对象：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;window&lt;/code&gt;：对应浏览器窗口，属于 BOM（浏览器对象模型）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document&lt;/code&gt;：对应网页内容，是操作 DOM 的核心对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-m模型model&#34;&gt;3. M：模型（Model）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DOM 将文档表示为一棵节点树（类似家谱树），用 “父子”“兄弟” 等关系描述元素间的层次结构：
&lt;ul&gt;
&lt;li&gt;根元素是 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;，所有其他元素都是其后代；&lt;/li&gt;
&lt;li&gt;节点树清晰展示了元素的嵌套关系，便于通过 JS 遍历和操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二节点node&#34;&gt;二、节点（Node）&lt;/h3&gt;
&lt;p&gt;DOM 文档由多种节点组成，核心类型包括：&lt;/p&gt;
&lt;h4 id=&#34;1-元素节点element-node&#34;&gt;1. 元素节点（Element Node）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;文档的基本构成单位，对应 HTML 标签（如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;特点：可包含其他元素节点或文本节点，是节点树的 “骨架”。&lt;/li&gt;
&lt;li&gt;根元素：&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 是唯一不被其他元素包含的元素节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-文本节点text-node&#34;&gt;2. 文本节点（Text Node）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;包含文本内容（如文字、空格），&lt;strong&gt;总是被元素节点包含&lt;/strong&gt;（如 &lt;code&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&lt;/code&gt; 中，“Hello” 是文本节点）。&lt;/li&gt;
&lt;li&gt;注意：并非所有元素节点都包含文本节点（如空标签 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-属性节点attribute-node&#34;&gt;3. 属性节点（Attribute Node）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;描述元素的附加信息（如 &lt;code&gt;class&lt;/code&gt;、&lt;code&gt;id&lt;/code&gt;、&lt;code&gt;src&lt;/code&gt;），&lt;strong&gt;仅存在于元素的起始标签中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;特点：依赖元素节点存在，无法独立于元素存在（如 &lt;code&gt;&amp;lt;a href=&amp;quot;url&amp;quot;&amp;gt;&lt;/code&gt; 中，&lt;code&gt;href&lt;/code&gt; 是属性节点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三css-与-dom-的关联&#34;&gt;三、CSS 与 DOM 的关联&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CSS 通过节点树结构应用样式，子元素会继承父元素的样式（继承性）。&lt;/li&gt;
&lt;li&gt;为精准定位元素，常用 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;id&lt;/code&gt; 属性：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;class 属性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;可在多个元素上重复使用，用于为一组元素定义相同样式（如 &lt;code&gt;.active { color: red; }&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;一个元素可包含多个类名（用空格分隔，如 &lt;code&gt;class=&amp;quot;btn primary&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;id 属性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;每个 &lt;code&gt;id&lt;/code&gt; 在文档中唯一，用于标识单个元素（如 &lt;code&gt;id=&amp;quot;logo&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;可作为样式或 DOM 操作的 “挂钩”（如 &lt;code&gt;#logo { width: 100px; }&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四获取元素节点的-dom-方法&#34;&gt;四、获取元素节点的 DOM 方法&lt;/h3&gt;
&lt;h4 id=&#34;1-getelementbyid&#34;&gt;1. &lt;code&gt;getElementById()&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：根据元素的 &lt;code&gt;id&lt;/code&gt; 属性值获取唯一元素节点。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B9%9D%E7%AB%A0-css-dom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B9%9D%E7%AB%A0-css-dom/</guid>
      <description>&lt;h3 id=&#34;一网页的三层结构&#34;&gt;一、网页的三层结构&lt;/h3&gt;
&lt;p&gt;网页的呈现和交互由&lt;strong&gt;结构层、表示层、行为层&lt;/strong&gt;共同构成，三者各司其职又协同工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;结构层&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;由 HTML/XHTML 标记语言实现，通过标签（如 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;）描述内容的&lt;strong&gt;语义和结构&lt;/strong&gt;（如标题、段落、列表），不包含样式或行为信息。&lt;/li&gt;
&lt;li&gt;示例：&lt;code&gt;&amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt;&lt;/code&gt; 仅定义 “这是一个一级标题”，不规定其颜色、大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表示层&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;由 CSS 负责，定义内容的&lt;strong&gt;视觉呈现&lt;/strong&gt;（如颜色、字体、布局）。&lt;/li&gt;
&lt;li&gt;即使未显式编写 CSS，浏览器也会应用默认样式（如 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 默认加粗、字号较大）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行为层&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;由 JavaScript 和 DOM 控制，定义内容对&lt;strong&gt;事件的响应方式&lt;/strong&gt;（如点击、鼠标悬停）。&lt;/li&gt;
&lt;li&gt;浏览器默认也有基础行为（如链接点击跳转、表单提交），JS 可扩展或修改这些行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二通过-dom-操作样式style-属性&#34;&gt;二、通过 DOM 操作样式：&lt;code&gt;style&lt;/code&gt; 属性&lt;/h3&gt;
&lt;h4 id=&#34;1-style-属性的特性&#34;&gt;1. &lt;code&gt;style&lt;/code&gt; 属性的特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个元素节点的 &lt;code&gt;style&lt;/code&gt; 属性是一个对象，包含该元素的&lt;strong&gt;内嵌样式&lt;/strong&gt;（即通过 &lt;code&gt;style&lt;/code&gt; 属性直接定义的样式，如 &lt;code&gt;&amp;lt;div style=&amp;quot;color: red&amp;quot;&amp;gt;&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命名规则&lt;/strong&gt;：CSS 属性名中的减号（如 &lt;code&gt;font-size&lt;/code&gt;）在 &lt;code&gt;style&lt;/code&gt; 对象中需转换为&lt;strong&gt;驼峰命名法&lt;/strong&gt;（如 &lt;code&gt;style.fontSize&lt;/code&gt;），避免与 JS 语法冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局限性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;仅能获取 / 修改&lt;strong&gt;内嵌样式&lt;/strong&gt;，无法访问外部 CSS 文件或 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 标签中定义的样式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;box&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width: 100px; color: blue;&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;box&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;box&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出 &amp;#34;100px&amp;#34;（获取内嵌样式）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fontSize&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 输出 &amp;#34;&amp;#34;（非内嵌样式无法获取）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-通过-style-属性设置样式&#34;&gt;2. 通过 &lt;code&gt;style&lt;/code&gt; 属性设置样式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;style&lt;/code&gt; 对象的属性是&lt;strong&gt;可读写的&lt;/strong&gt;，可通过赋值修改样式，值需为字符串（需加引号）。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0-js%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0-js%E8%AF%AD%E6%B3%95/</guid>
      <description>&lt;h3 id=&#34;一语法&#34;&gt;一、语法&lt;/h3&gt;
&lt;h4 id=&#34;1-变量&#34;&gt;1. 变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：变量是存储可变值的容器，将值存入变量的操作称为&lt;strong&gt;赋值&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;声明与赋值：
&lt;ul&gt;
&lt;li&gt;JS 中，未声明的变量赋值时会自动声明（不推荐，易导致全局污染）。&lt;/li&gt;
&lt;li&gt;可一次性声明多个变量：&lt;code&gt;var a, b, c;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;可在声明时赋值：&lt;code&gt;var x = 10, y = &amp;quot;hello&amp;quot;;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命名规则：
&lt;ul&gt;
&lt;li&gt;区分大小写（&lt;code&gt;name&lt;/code&gt; 与 &lt;code&gt;Name&lt;/code&gt; 是不同变量）。&lt;/li&gt;
&lt;li&gt;允许包含字母、数字、&lt;code&gt;$&lt;/code&gt;、&lt;code&gt;_&lt;/code&gt;，但&lt;strong&gt;不能以数字开头&lt;/strong&gt;，不能包含空格或标点符号（&lt;code&gt;$&lt;/code&gt; 除外）。&lt;/li&gt;
&lt;li&gt;长变量名可读性优化：
&lt;ul&gt;
&lt;li&gt;下划线命名法：&lt;code&gt;user_name&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;驼峰命名法：&lt;code&gt;userName&lt;/code&gt;（第二个单词起首字母大写）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字面量&lt;/strong&gt;：直接在代码中写出的数据（如 &lt;code&gt;123&lt;/code&gt;、&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-数据类型&#34;&gt;2. 数据类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弱类型特性&lt;/strong&gt;：JS 是弱类型语言，无需声明变量类型，可随时修改变量的类型（与强类型语言需显式声明类型不同）。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字符串&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;由零个或多个字符组成，需用单引号（&lt;code&gt;&#39;&lt;/code&gt;）或双引号（&lt;code&gt;&amp;quot;&lt;/code&gt;）包裹。&lt;/li&gt;
&lt;li&gt;引号选择规则：字符串包含双引号时用单引号包裹（如 &lt;code&gt;&#39;He said &amp;quot;Hi&amp;quot;&#39;&lt;/code&gt;），反之亦然。&lt;/li&gt;
&lt;li&gt;转义字符：用反斜线（&lt;code&gt;\&lt;/code&gt;）转义特殊字符，如 &lt;code&gt;\&amp;quot;&lt;/code&gt; 表示双引号（&lt;code&gt;&amp;quot;She said \&amp;quot;Hello\&amp;quot;&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数值&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;支持整数（如 &lt;code&gt;42&lt;/code&gt;）和浮点数（如 &lt;code&gt;3.14&lt;/code&gt;），可带正负号（如 &lt;code&gt;-5&lt;/code&gt;、&lt;code&gt;-2.7&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布尔值&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;仅两个值：&lt;code&gt;true&lt;/code&gt;（真）和 &lt;code&gt;false&lt;/code&gt;（假），&lt;strong&gt;不可用引号包裹&lt;/strong&gt;（否则为字符串）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-数组&#34;&gt;3. 数组&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：用一个变量存储一组值（元素），元素可通过&lt;strong&gt;下标&lt;/strong&gt;访问（下标从 &lt;code&gt;0&lt;/code&gt; 开始）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明与初始化&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;Array&lt;/code&gt; 关键字：&lt;code&gt;var arr = new Array();&lt;/code&gt; 或 &lt;code&gt;var arr = new Array(3);&lt;/code&gt;（指定初始长度，可选）。&lt;/li&gt;
&lt;li&gt;简洁语法（推荐）：&lt;code&gt;var arr = [1, &amp;quot;a&amp;quot;, true];&lt;/code&gt;（直接用方括号包裹元素，元素类型可混合）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元素操作&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;赋值：&lt;code&gt;arr[0] = 10;&lt;/code&gt;（通过下标赋值）。&lt;/li&gt;
&lt;li&gt;嵌套数组：数组元素可是另一个数组（如 &lt;code&gt;var nested = [1, [2, 3]];&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联数组&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;用字符串作为下标（如 &lt;code&gt;arr[&amp;quot;name&amp;quot;] = &amp;quot;Alice&amp;quot;&lt;/code&gt;），本质是为数组对象添加属性。&lt;/li&gt;
&lt;li&gt;注意：不推荐修改 &lt;code&gt;Array&lt;/code&gt; 对象的属性，如需键值对存储，建议使用&lt;strong&gt;对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-对象&#34;&gt;4. 对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：由&lt;strong&gt;属性&lt;/strong&gt;（变量）和&lt;strong&gt;方法&lt;/strong&gt;（函数）组成的集合，通过属性名而非下标访问元素。&lt;/li&gt;
&lt;li&gt;声明与初始化：
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;Object&lt;/code&gt; 关键字：&lt;code&gt;var obj = new Object();&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;简洁语法（推荐）：&lt;code&gt;var obj = { name: &amp;quot;Bob&amp;quot;, age: 20 };&lt;/code&gt;（花括号包裹键值对，键值用 &lt;code&gt;:&lt;/code&gt; 分隔，键值对间用 &lt;code&gt;,&lt;/code&gt; 分隔）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性访问&lt;/strong&gt;：用点语法（&lt;code&gt;obj.name&lt;/code&gt;）或方括号（&lt;code&gt;obj[&amp;quot;name&amp;quot;]&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：属性值可以是任意类型（包括其他对象），适合通过名称而非位置管理数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二操作&#34;&gt;二、操作&lt;/h3&gt;
&lt;h4 id=&#34;1-算术操作符&#34;&gt;1. 算术操作符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基础操作符：
&lt;ul&gt;
&lt;li&gt;加法（&lt;code&gt;+&lt;/code&gt;）、减法（&lt;code&gt;-&lt;/code&gt;）、乘法（&lt;code&gt;*&lt;/code&gt;）、除法（&lt;code&gt;/&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;可组合操作，用括号改变优先级（如 &lt;code&gt;(2 + 3) * 4&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快捷操作符：
&lt;ul&gt;
&lt;li&gt;自增（&lt;code&gt;++&lt;/code&gt;）：&lt;code&gt;x++&lt;/code&gt; 等价于 &lt;code&gt;x = x + 1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;自减（&lt;code&gt;--&lt;/code&gt;）：&lt;code&gt;x--&lt;/code&gt; 等价于 &lt;code&gt;x = x - 1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;复合赋值（&lt;code&gt;+=&lt;/code&gt;）：&lt;code&gt;x += 5&lt;/code&gt; 等价于 &lt;code&gt;x = x + 5&lt;/code&gt;，也可用于字符串拼接（&lt;code&gt;str += &amp;quot;world&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字符串拼接：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 可拼接字符串（如 &lt;code&gt;&amp;quot;Hello&amp;quot; + &amp;quot; &amp;quot; + &amp;quot;World&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;数值与字符串拼接时，数值自动转为字符串（如 &lt;code&gt;123 + &amp;quot;abc&amp;quot;&lt;/code&gt; 结果为 &lt;code&gt;&amp;quot;123abc&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三条件语句&#34;&gt;三、条件语句&lt;/h3&gt;
&lt;h4 id=&#34;1-基本语法&#34;&gt;1. 基本语法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if 语句：当条件为true时执行代码块：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h3 id=&#34;一平稳退化&#34;&gt;一、平稳退化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：确保网站在浏览器不支持 JavaScript 或 JS 被禁用时，核心功能仍可正常使用（如链接可点击、内容可访问）。&lt;/li&gt;
&lt;li&gt;关键原则：
&lt;ul&gt;
&lt;li&gt;为 JS 功能提供 “退路”，例如将链接的 &lt;code&gt;href&lt;/code&gt; 属性设置为真实 URL，而非仅依赖 &lt;code&gt;onclick&lt;/code&gt; 事件。&lt;/li&gt;
&lt;li&gt;避免过度依赖 JS 实现基础功能（如导航、跳转）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-弹出窗口与平稳退化&#34;&gt;1. 弹出窗口与平稳退化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;window.open()&lt;/code&gt; 方法：用于创建新窗口，语法为&lt;code&gt;window.open(url, name, features)&lt;/code&gt;，参数分别为目标 URL、窗口名称、窗口属性（如尺寸、功能）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示例函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;popUp&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;winUrl&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  window.&lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;winUrl&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;popup&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;width=320,height=480&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用方式的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;伪协议（&lt;code&gt;javascript:&lt;/code&gt;）&lt;/strong&gt;：如 &lt;code&gt;&amp;lt;a href=&amp;quot;javascript:popUp(&#39;url&#39;)&amp;quot;&amp;gt;&lt;/code&gt;，在禁用 JS 时失效，不推荐。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空链接（&lt;code&gt;#&lt;/code&gt;）&lt;/strong&gt;：如 &lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;popUp(&#39;url&#39;);return false&amp;quot;&amp;gt;&lt;/code&gt;，禁用 JS 时点击会跳转至页面顶部，体验差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正确做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;让href指向真实 URL，onclick中通过return false阻止默认跳转，确保 JS 禁用时仍能正常访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.baidu.com&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onclick&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;popUp(&amp;#39;http://www.baidu.com&amp;#39;);return false;&amp;#34;&lt;/span&gt;&amp;gt;baidu&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二分离-javascript&#34;&gt;二、分离 JavaScript&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：将 JS 代码从 HTML 中剥离，通过外部脚本文件管理，避免 HTML 与 JS 耦合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTML 保留基础功能：链接使用真实 href，通过 class或id标识需要特殊处理的元素：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>&lt;h3 id=&#34;一abbr-与-acronym-标签&#34;&gt;一、&lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&amp;lt;acronym&amp;gt;&lt;/code&gt; 标签&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;：表示缩略语（对单词或短语的缩写，如 &amp;ldquo;Mr.&amp;rdquo; 是 &amp;ldquo;Mister&amp;rdquo; 的缩写），通常建议通过title&lt;/p&gt;
&lt;p&gt;属性提供完整含义，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;abbr&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HyperText Markup Language&amp;#34;&lt;/span&gt;&amp;gt;HTML&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;abbr&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;acronym&amp;gt;&lt;/code&gt;：专门表示首字母缩写词（由多个单词首字母组成，且发音为一个单词，如 &amp;ldquo;NASA&amp;rdquo; 读作 &amp;ldquo;nasa&amp;rdquo;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意：HTML5 中已废弃 &lt;code&gt;&amp;lt;acronym&amp;gt;&lt;/code&gt;，推荐统一使用 &lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt; 替代，因其语义更通用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二doctype-与浏览器渲染模式&#34;&gt;二、DOCTYPE 与浏览器渲染模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DOCTYPE 的作用：告知浏览器文档使用的 HTML 版本，决定浏览器以标准模式还是兼容模式渲染页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标准模式&lt;/strong&gt;：浏览器严格遵循 W3C 规范渲染页面，保证跨浏览器一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兼容模式（怪异模式）&lt;/strong&gt;：模仿早期浏览器（如 IE6）的非标准行为，允许不规范的代码正常运行（如忽略闭合标签、错误的盒模型计算）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTML5 的 DOCTYPE：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此声明简洁且默认触发标准模式，无需指定具体版本，是现代网页的推荐写法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三换行符与-dom-文本节点&#34;&gt;三、换行符与 DOM 文本节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;部分浏览器（如早期 IE、部分基于 WebKit 的浏览器）会将 HTML 中的&lt;strong&gt;换行符&lt;/strong&gt;解析为&lt;strong&gt;文本节点&lt;/strong&gt;（&lt;code&gt;nodeType = 3&lt;/code&gt;），导致 &lt;code&gt;childNodes&lt;/code&gt; 等集合中包含空文本节点。&lt;/li&gt;
&lt;li&gt;影响：遍历子节点时需注意过滤空文本节点（可通过 &lt;code&gt;nodeValue.trim() === &amp;quot;&amp;quot;&lt;/code&gt; 判断），避免逻辑错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四accesskey-属性&#34;&gt;四、&lt;code&gt;accesskey&lt;/code&gt; 属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：为元素绑定键盘快捷键，提升可访问性（尤其适合键盘用户）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;index.html&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accesskey&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;h&amp;#34;&lt;/span&gt;&amp;gt;首页&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows 系统：&lt;code&gt;Alt + 快捷键&lt;/code&gt;（如 &lt;code&gt;Alt + h&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;macOS 系统：&lt;code&gt;Ctrl + 快捷键&lt;/code&gt;（如 &lt;code&gt;Ctrl + h&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：避免与浏览器默认快捷键冲突（如 &lt;code&gt;Alt + F&lt;/code&gt; 通常打开文件菜单），且需在页面中明确提示快捷键（如通过文字说明）。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/</guid>
      <description>&lt;h3 id=&#34;一js-与网页结构的解耦原则&#34;&gt;一、JS 与网页结构的解耦原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：为网页添加行为时，JS 代码应尽量避免依赖特定的 HTML 结构（如固定的标签嵌套、类名顺序等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;好处&lt;/strong&gt;：当 HTML 结构调整时，JS 代码无需频繁修改，提高可维护性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二命名规范与注意事项&#34;&gt;二、命名规范与注意事项&lt;/h3&gt;
&lt;h4 id=&#34;1-命名原则&#34;&gt;1. 命名原则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可读性&lt;/strong&gt;：使用有意义的单词命名变量、函数（如 &lt;code&gt;calculateTotal&lt;/code&gt; 而非 &lt;code&gt;fn1&lt;/code&gt;），通过命名体现用途。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;风格统一&lt;/strong&gt;：变量和函数名推荐使用驼峰命名法（如 &lt;code&gt;userName&lt;/code&gt;、&lt;code&gt;handleClick&lt;/code&gt;），常量常用全大写（如 &lt;code&gt;MAX_SIZE&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-命名禁忌&#34;&gt;2. 命名禁忌&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;避免保留字&lt;/strong&gt;：不能使用 JS 语言的保留字（如 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt;、&lt;code&gt;class&lt;/code&gt; 等）作为变量名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免覆盖内置 API&lt;/strong&gt;：不使用现有 JS 函数 / 方法名（如 &lt;code&gt;alert&lt;/code&gt;、&lt;code&gt;push&lt;/code&gt;）作为变量名，防止覆盖内置功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三节点链表nodelist&#34;&gt;三、节点链表（NodeList）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：由 DOM 方法（如 &lt;code&gt;getElementsByTagName&lt;/code&gt;、&lt;code&gt;querySelectorAll&lt;/code&gt;）返回的节点集合，类似数组但并非真正的数组（是类数组对象）。&lt;/li&gt;
&lt;li&gt;特性：
&lt;ul&gt;
&lt;li&gt;每个节点都有自身的属性（如 &lt;code&gt;nodeType&lt;/code&gt;、&lt;code&gt;nodeName&lt;/code&gt;）和方法（如 &lt;code&gt;appendChild&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;动态性：部分 NodeList（如 &lt;code&gt;getElementsByTagName&lt;/code&gt; 返回的集合）会随 DOM 变化自动更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四共享-onload-事件addloadevent-函数&#34;&gt;四、共享 &lt;code&gt;onload&lt;/code&gt; 事件：&lt;code&gt;addLoadEvent&lt;/code&gt; 函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;code&gt;window.onload&lt;/code&gt; 只能绑定一个函数，多次赋值会覆盖之前的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;code&gt;addLoadEvent&lt;/code&gt; 函数用于将多个函数追加到 &lt;code&gt;window.onload&lt;/code&gt; 事件中，确保所有函数在页面加载完成后执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实现逻辑&#34;&gt;实现逻辑：&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addLoadEvent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;oldOnload&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; window.&lt;span style=&#34;color:#a6e22e&#34;&gt;onload&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 保存现有 onload 函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; window.&lt;span style=&#34;color:#a6e22e&#34;&gt;onload&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;function&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 若 onload 未绑定函数，直接赋值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    window.&lt;span style=&#34;color:#a6e22e&#34;&gt;onload&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 若已绑定函数，追加新函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    window.&lt;span style=&#34;color:#a6e22e&#34;&gt;onload&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;oldOnload&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 执行原有函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 执行新函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;五nodename-属性&#34;&gt;五、&lt;code&gt;nodeName&lt;/code&gt; 属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：返回元素节点的标签名，&lt;strong&gt;始终为大写字母&lt;/strong&gt;（即使 HTML 中标签是小写，如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 的 &lt;code&gt;nodeName&lt;/code&gt; 为 &lt;code&gt;&amp;quot;DIV&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：判断元素类型（如 &lt;code&gt;if (element.nodeName === &amp;quot;LI&amp;quot;)&lt;/code&gt; 检测是否为列表项）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六键盘事件与交互一致性&#34;&gt;六、键盘事件与交互一致性&lt;/h3&gt;
&lt;h4 id=&#34;1-onkeypress-事件&#34;&gt;1. &lt;code&gt;onkeypress&lt;/code&gt; 事件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;触发时机：按下键盘上的任意按键（包括字母、数字、符号等）时触发。&lt;/li&gt;
&lt;li&gt;用途：监听键盘输入（如表单验证、快捷键操作）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-键盘与鼠标事件的一致性&#34;&gt;2. 键盘与鼠标事件的一致性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;Tab&lt;/code&gt; 键聚焦到链接后按 &lt;code&gt;Enter&lt;/code&gt; 键，会触发该链接的 &lt;code&gt;onclick&lt;/code&gt; 事件，与鼠标点击效果一致。&lt;/li&gt;
&lt;li&gt;意义：确保键盘用户与鼠标用户获得相同的交互体验，提升可访问性。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/</guid>
      <description>&lt;h3 id=&#34;一元素属性操作的两种方式&#34;&gt;一、元素属性操作的两种方式&lt;/h3&gt;
&lt;h4 id=&#34;1-直接属性赋值传统方式&#34;&gt;1. 直接属性赋值（传统方式）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;code&gt;element.属性名 = 值&lt;/code&gt;（如 &lt;code&gt;input.value = &amp;quot;hello&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：大部分 HTML 元素的标准属性（如 &lt;code&gt;value&lt;/code&gt;、&lt;code&gt;src&lt;/code&gt;、&lt;code&gt;href&lt;/code&gt; 等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：简单直接，但仅支持预定义的标准属性，不支持自定义属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-setattribute-方法dom-level-1&#34;&gt;2. &lt;code&gt;setAttribute()&lt;/code&gt; 方法（DOM Level 1）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;code&gt;element.setAttribute(属性名, 属性值)&lt;/code&gt;（如 &lt;code&gt;div.setAttribute(&amp;quot;data-id&amp;quot;, &amp;quot;123&amp;quot;)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;优势：
&lt;ul&gt;
&lt;li&gt;可设置&lt;strong&gt;任意元素的任意属性&lt;/strong&gt;（包括自定义属性），兼容性更强。&lt;/li&gt;
&lt;li&gt;遵循 DOM 标准，可移植性好（适用于多种环境和编程语言）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：修改后会实时反映在 DOM 中，但不会改变原始 HTML 源代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二js-文件优化合并文件&#34;&gt;二、JS 文件优化：合并文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：减少 HTTP 请求次数，提高页面加载性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;做法&lt;/strong&gt;：将多个 &lt;code&gt;.js&lt;/code&gt; 文件合并为一个文件，通过单次请求加载。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三事件处理函数&#34;&gt;三、事件处理函数&lt;/h3&gt;
&lt;h4 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：在特定事件发生时执行指定 JS 代码（如点击、鼠标悬停等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;code&gt;元素.事件处理函数 = &amp;quot;JS 语句&amp;quot;&lt;/code&gt; 或通过 DOM 方法绑定（如 &lt;code&gt;element.onclick = function() {}&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;常用事件：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onclick&lt;/code&gt;：用户点击元素时触发；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onmouseover&lt;/code&gt;：鼠标指针悬停在元素上时触发；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onmouseout&lt;/code&gt;：鼠标指针离开元素时触发；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onload&lt;/code&gt;：页面或资源（如图片）加载完成时触发（常用于页面初始化）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-事件处理函数的返回值&#34;&gt;2. 事件处理函数的返回值&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;事件触发的 JS 代码可返回一个值，该值会传递给事件处理函数。&lt;/li&gt;
&lt;li&gt;典型应用：阻止默认行为
&lt;ul&gt;
&lt;li&gt;例如，在&amp;lt;a&amp;gt;标签的onclick中返回false，可阻止链接跳转：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-子节点获取childnodes&#34;&gt;1. 子节点获取：&lt;code&gt;childNodes&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：返回当前元素的&lt;strong&gt;所有子节点&lt;/strong&gt;（包含元素节点、文本节点、空格 / 换行节点等），结果为类数组对象。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/01--ts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/01--ts/</guid>
      <description>&lt;h3 id=&#34;1-静态检查与静态类型检查&#34;&gt;1. &lt;strong&gt;静态检查与静态类型检查&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是&lt;strong&gt;动态检查&lt;/strong&gt;（运行时检测错误，如 JS 中的&lt;code&gt;TypeError&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-typescript-与-javascript-的关系&#34;&gt;2. &lt;strong&gt;TypeScript 与 JavaScript 的关系&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TypeScript 是 JavaScript 的&lt;strong&gt;超集&lt;/strong&gt;：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键区别：TS 增加了&lt;strong&gt;静态类型系统&lt;/strong&gt;，而 JS 是动态类型语言（类型检查仅在运行时发生）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重要特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。&lt;/li&gt;
&lt;li&gt;TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：TS 会对 JS 代码进行&lt;strong&gt;类型检查&lt;/strong&gt;（如&lt;code&gt;let a = 1; a = &#39;str&#39;&lt;/code&gt;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-typescript-的核心优势面试高频&#34;&gt;3. &lt;strong&gt;TypeScript 的核心优势（面试高频）&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提前发现错误&lt;/strong&gt;：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;增强代码可读性&lt;/strong&gt;：类型注解明确变量 / 函数的预期用途，降低团队协作成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升开发效率&lt;/strong&gt;：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更好的可维护性&lt;/strong&gt;：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-typescript-的类型推断与扩展&#34;&gt;4. &lt;strong&gt;TypeScript 的类型推断与扩展&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。
例：&lt;code&gt;let x = 10&lt;/code&gt; → TS 推断&lt;code&gt;x&lt;/code&gt;为&lt;code&gt;number&lt;/code&gt;；&lt;code&gt;const y = { name: &#39;ts&#39; }&lt;/code&gt; → 推断&lt;code&gt;y&lt;/code&gt;为&lt;code&gt;{ name: string }&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/02--%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/02--%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;1-基础类型与数组类型&#34;&gt;1. &lt;strong&gt;基础类型与数组类型&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JavaScript 基础类型：&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number &lt;/code&gt;、&lt;code&gt; boolean&lt;/code&gt;（对应 JS 原始类型），TypeScript 中可直接作为类型注解使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：使用&lt;code&gt;typeof&lt;/code&gt;运算符对这些类型的值操作时，返回值与类型名一致（如&lt;code&gt;typeof &#39;abc&#39; === &#39;string&#39;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两种声明方式：&lt;code&gt;T[]&lt;/code&gt;（如&lt;code&gt;number[]&lt;/code&gt;表示数字数组）或&lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;（泛型形式，如&lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;），两者完全等价。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-特殊类型-any&#34;&gt;2. &lt;strong&gt;特殊类型&lt;/strong&gt; &lt;strong&gt;any&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;核心特性&lt;/strong&gt;：关闭类型检查，允许值被任意操作（访问任意属性、作为函数调用、赋值给任何类型等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理动态内容（如来自 API 的未知数据）。&lt;/li&gt;
&lt;li&gt;迁移 JS 项目时临时兼容无类型代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隐式&lt;code&gt;any&lt;/code&gt;&lt;/strong&gt;：未指定类型且 TS 无法推断时，编译器默认视为&lt;code&gt;any&lt;/code&gt;（可通过&lt;code&gt;noImplicitAny&lt;/code&gt;配置项禁用，强制显式声明类型，面试高频考点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;风险与替代&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滥用&lt;code&gt;any&lt;/code&gt;会失去 TS 类型检查的意义，建议优先使用&lt;code&gt;unknown&lt;/code&gt;（更安全，需显式类型断言后使用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-变量与函数的类型注解&#34;&gt;3. &lt;strong&gt;变量与函数的类型注解&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量注解： &lt;code&gt;let 变量名: 类型 = 值&lt;/code&gt;（如 &lt;code&gt;let age: number = 20&lt;/code&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多数情况可省略：TS 会自动推断类型（如&lt;code&gt;let name = &#39;ts&#39;&lt;/code&gt; → 推断为&lt;code&gt;string&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数参数类型注解：在每个参数名称后添加，用于声明函数接受的参数类型，即使参数无类型注释，TypeScript 仍会检查参数数量是否正确。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数返回类型注解：出现在参数列表之后。（如&lt;code&gt;function add(a: number, b: number): number { return a + b }&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数参数类型自动推断：当函数出现在 TypeScript 可确定调用方式的地方时，其参数会自动被赋予类型。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/03--%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/03--%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F/</guid>
      <description>&lt;h3 id=&#34;1-类型缩小与控制流分析基础&#34;&gt;1. &lt;strong&gt;类型缩小与控制流分析基础&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 会跟踪代码执行路径（如&lt;code&gt;if/else&lt;/code&gt;、&lt;code&gt;switch&lt;/code&gt;、循环等），分析变量在不同分支中的具体类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型保护：特殊表达式（如&lt;code&gt;typeof x === &#39;string&#39;&lt;/code&gt;），TS 可通过它判断变量类型，从而缩小类型范围。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型缩小：通过类型保护或赋值操作，将变量类型从 “宽泛”（如联合类型）收缩为 “具体”（如单一类型）的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-基于-typeof-运算符的类型缩小&#34;&gt;2. &lt;strong&gt;基于&lt;/strong&gt; &lt;strong&gt;typeof&lt;/strong&gt; &lt;strong&gt;运算符的类型缩小&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 可识别&lt;code&gt;typeof&lt;/code&gt;的 8 种返回值：&lt;code&gt;&amp;quot;string&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;number&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;bigint&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;boolean&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;symbol&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;undefined&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;object&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;function&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;typeof检查是一种类型保护，TypeScript 编码了typeof对不同值的操作逻辑，包括其在 JavaScript 中的一些特性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-基于真值检查的类型缩小&#34;&gt;3. &lt;strong&gt;基于真值检查的类型缩小&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JavaScript 中，if等构造会将条件强制为布尔值，0、NaN、&amp;quot;&amp;quot;（空字符串）、0n（bigint版本零）、null、undefined强制为false，其他值强制为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可通过Boolean函数或双布尔否定（!!）将值强制为布尔值，后者的优势是 TypeScript 会推断出缩小的字面布尔类型true，而前者推断为boolean类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用这种行为防范null或undefined很常见，带有!的布尔否定会从否定分支中过滤掉这些值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-基于相等性检查的类型缩小&#34;&gt;4. &lt;strong&gt;基于相等性检查的类型缩小&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TypeScript 使用switch语句和===、!==、==、!=等相等性检查来缩小类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;== null不仅检查值是否为null，还检查是否为undefined；== undefined同样检查值是null还是undefined。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-基于-in-运算符的类型缩小&#34;&gt;5. &lt;strong&gt;基于&lt;/strong&gt; &lt;strong&gt;in&lt;/strong&gt; &lt;strong&gt;运算符的类型缩小&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JavaScript 的in运算符用于确定对象或其原型链是否具有指定名称的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TypeScript 将in运算符视为缩小潜在类型的方式：对于&amp;quot;value&amp;quot; in x（&amp;ldquo;value&amp;quot;为字符串字面，x为联合类型），“true” 分支会缩小x为具有可选或必需属性value的类型，“false” 分支缩小为具有可选或缺少属性value的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-基于-instanceof-的类型缩小&#34;&gt;6. &lt;strong&gt;基于&lt;/strong&gt; &lt;strong&gt;instanceof&lt;/strong&gt; &lt;strong&gt;的类型缩小&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查值的原型链是否包含构造函数的&lt;code&gt;prototype&lt;/code&gt;，适用于&lt;code&gt;new&lt;/code&gt;创建的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;instanceof是类型保护，TypeScript 会在instanceof保护的分支中缩小类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-基于赋值的类型缩小&#34;&gt;7. &lt;strong&gt;基于赋值的类型缩小&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量赋值后，TS 会根据赋值内容缩小其类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8-用户定义的类型保护&#34;&gt;8. &lt;strong&gt;用户定义的类型保护&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义方式：创建返回类型为类型谓词的函数，谓词形式为parameterName is Type，其中parameterName必须是当前函数签名中的参数名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9-可区分的联合&#34;&gt;9. &lt;strong&gt;可区分的联合&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;联合类型中的每个成员都包含一个&lt;strong&gt;字面量类型的公共属性&lt;/strong&gt;（如&lt;code&gt;type&lt;/code&gt;字段），用于区分不同类型，TypeScript 将其视为可区分的联合，可通过检查该属性缩小联合的成员范围，switch语句中也适用这种检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10-never-类型与穷尽检查&#34;&gt;10. &lt;strong&gt;never&lt;/strong&gt; &lt;strong&gt;类型与穷尽检查&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缩小类型时，若联合的选项被全部消除，会得到never类型，表示不应该存在的状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/04--%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/04--%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h3 id=&#34;1-函数类型表达式&#34;&gt;1. 函数类型表达式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基本语法&lt;/strong&gt;：用箭头函数形式描述函数类型，如&lt;code&gt;(a: string) =&amp;gt; void&lt;/code&gt;（参数&lt;code&gt;a&lt;/code&gt;为&lt;code&gt;string&lt;/code&gt;类型，无返回值）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：参数名必须存在（仅用于标识，不影响类型匹配），未指定类型时隐式为&lt;code&gt;any&lt;/code&gt;（可通过&lt;code&gt;noImplicitAny&lt;/code&gt;禁用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greeter&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printToConsole&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) { &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;greeter&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;printToConsole&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 符合函数类型要求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型别名命名&lt;/strong&gt;：通过&lt;code&gt;type&lt;/code&gt;给函数类型命名，提升可读性和复用性：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GreetFunction&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greeter&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;GreetFunction&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* ... */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型兼容性（面试高频）&lt;/strong&gt;：函数类型兼容遵循 “参数少的可赋值给参数多的”（逆变原则简化版）：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;F1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;F2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f1&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;F1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f2&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;F2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 合法：F1参数更少，可兼容F2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-带属性的函数与调用签名&#34;&gt;2. 带属性的函数与调用签名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数类型表达式的局限&lt;/strong&gt;：仅能描述函数的调用方式，无法声明函数自身的属性（如&lt;code&gt;fn.prop&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调用签名&lt;/strong&gt;：若需描述可调用且带属性的对象，可在对象类型中编写调用签名，参数列表与返回类型间用:分隔（而非=&amp;gt;）：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescribableFunction&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#a6e22e&#34;&gt;someArg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 调用签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doSomething&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;DescribableFunction&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; returned &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myFunc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;someArg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;someArg&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myFunc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;default description&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;doSomething&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;myFunc&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 符合带属性的函数类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3-构造函数与构造签名&#34;&gt;3. 构造函数与构造签名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造函数&lt;/strong&gt;：可通过new运算符调用的函数，TypeScript 中用&lt;strong&gt;构造签名&lt;/strong&gt;描述，即在调用签名前加new关键字：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SomeConstructor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SomeObject&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 构造签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ctor&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;SomeConstructor&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ctor&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 符合构造函数调用方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可同时调用与构造的函数&lt;/strong&gt;：如Date，可组合调用签名和构造签名（可直接调用&lt;code&gt;Date()&lt;/code&gt;返回字符串，也可&lt;code&gt;new Date()&lt;/code&gt;返回实例）：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CallOrConstruct&lt;/span&gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#a6e22e&#34;&gt;n?&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 普通调用签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; Date; &lt;span style=&#34;color:#75715e&#34;&gt;// 构造签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ctor&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;CallOrConstruct&lt;/span&gt;) {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ctor&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 普通调用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ctor&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 构造调用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(Date); &lt;span style=&#34;color:#75715e&#34;&gt;// Date符合该类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;4-泛型函数&#34;&gt;4. 泛型函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：通过类型参数（如&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;）关联输入与输出类型，实现 “类型动态适配”&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 类型参数Type关联输入数组与返回值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;firstElement&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;[])&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;undefined&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型推断&lt;/strong&gt;：TS 会根据传入的实参自动推断类型参数，无需显式指定（复杂场景需手动指定）：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Input&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Input&lt;/span&gt;[], &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Input&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt;[] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parsed&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;([&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;], (&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; parseInt(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 推断Input为string，Output为number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型约束&lt;/strong&gt;：通过extends限制类型参数的范围，仅允许符合约束的类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 限制Type必须有length属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;extends&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;number&lt;/span&gt; }&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; : &lt;span style=&#34;color:#66d9ef&#34;&gt;b&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;手动指定类型参数&lt;/strong&gt;：当类型推断不明确时，可手动指定：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combine&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr1&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;[], &lt;span style=&#34;color:#a6e22e&#34;&gt;arr2&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;[])&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt;[] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;concat&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combine&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;number&lt;/span&gt;&amp;gt;([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;]); &lt;span style=&#34;color:#75715e&#34;&gt;// 手动指定Type为string | number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;泛型函数设计原则（面试常问）&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/05--%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/05--%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;一对象类型的基本定义&#34;&gt;一、对象类型的基本定义&lt;/h3&gt;
&lt;p&gt;对象类型是 TS 中描述数据结构的核心方式，主要有三种定义形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;匿名对象类型&lt;/strong&gt;
直接在参数或变量声明中定义，无需命名：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;person&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt; }) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;person&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;接口（interface）&lt;/strong&gt;
通过&lt;code&gt;interface&lt;/code&gt;关键字命名对象类型，支持&lt;strong&gt;声明合并&lt;/strong&gt;（多次定义同一接口会自动合并），可复用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;person&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Person&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* ... */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类型别名（type alias）&lt;/strong&gt;
通过&lt;code&gt;type&lt;/code&gt;关键字为对象类型命名：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;person&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Person&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* ... */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;面试高频对比&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;场景&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;interface&lt;/code&gt;&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;type&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;声明合并&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;不支持（重复声明报错）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;扩展方式&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;extends&lt;/code&gt;继承&lt;/td&gt;
          &lt;td&gt;交叉类型（&lt;code&gt;&amp;amp;&lt;/code&gt;）合并&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;适用类型&lt;/td&gt;
          &lt;td&gt;仅对象 / 类形状&lt;/td&gt;
          &lt;td&gt;任意类型（对象、联合、基础类型等）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;二对象属性的特性&#34;&gt;二、对象属性的特性&lt;/h3&gt;
&lt;p&gt;对象类型的属性可通过修饰符指定特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可选属性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标记为&lt;code&gt;?&lt;/code&gt;的属性可省略，类型为&lt;code&gt;T | undefined&lt;/code&gt;（在&lt;code&gt;strictNullChecks&lt;/code&gt;开启时需显式处理&lt;code&gt;undefined&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;User&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;age?&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 可选属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;User&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt; }; &lt;span style=&#34;color:#75715e&#34;&gt;// 合法，age可省略
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只读属性（readonly）&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/06--%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/06--%E6%B3%9B%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;一类型变量&#34;&gt;一、类型变量&lt;/h3&gt;
&lt;p&gt;类型变量是泛型的 “灵魂”，用于在&lt;strong&gt;类型层面&lt;/strong&gt;建立关联（而非值层面），解决 “同一份逻辑适配多种类型” 的问题。&lt;/p&gt;
&lt;h4 id=&#34;基本用法&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 定义泛型函数：类型变量&amp;lt;Type&amp;gt;关联输入与输出类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 两种调用方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;output1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;string&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;myString&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 显式指定类型参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;output2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 类型推断（推荐）：编译器自动推断Type为number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心价值&lt;/strong&gt;：避免重复编写不同类型的同名函数（如&lt;code&gt;identityString&lt;/code&gt;、&lt;code&gt;identityNumber&lt;/code&gt;），同时保持类型安全（对比&lt;code&gt;any&lt;/code&gt;：&lt;code&gt;any&lt;/code&gt;会丢失类型关联，泛型则保留输入与输出的类型一致性）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型推断&lt;/strong&gt;：编译器可通过传入的值自动推断类型参数，简化代码。复杂场景下若推断失败，需显式指定类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型约束&lt;/strong&gt;：函数体内必须正确使用泛型参数（视为 “任意类型” 处理）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二泛型函数的类型定义&#34;&gt;二、泛型函数的类型定义&lt;/h3&gt;
&lt;p&gt;泛型函数的类型与非泛型函数类似，需先声明类型参数，有多种表达方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;直接作为函数类型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myIdentity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用不同名称的类型变量&lt;/strong&gt;（只要数量和使用方式一致）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myIdentity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Input&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Input&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Input&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 合法：Input与Type作用相同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对象字面量的调用签名&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myIdentity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;泛型接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 接口内声明泛型调用签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GenericIdentityFn&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myIdentity&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;GenericIdentityFn&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 接口本身泛型化（更常用）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GenericIdentityFn&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myIdentity&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;GenericIdentityFn&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;number&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;identity&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 绑定类型参数为number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三泛型类&#34;&gt;三、泛型类&lt;/h3&gt;
&lt;p&gt;泛型类在类名后通过&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;声明类型参数，确保类的所有实例属性使用相同类型。&lt;/p&gt;
&lt;h4 id=&#34;基本用法-1&#34;&gt;基本用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GenericNumber&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;NumType&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;zeroValue&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;NumType&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 实例属性使用泛型类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;NumType&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;NumType&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NumType&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 方法参数与返回值使用泛型类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 实例化时指定类型参数为number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myGenericNumber&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GenericNumber&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;number&lt;/span&gt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myGenericNumber&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;zeroValue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myGenericNumber&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;注意点&#34;&gt;注意点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态成员限制：泛型类的类型参数仅作用于实例端，静态成员不能使用类的类型参数，静态成员属于类本身，而非实例，无法关联实例的类型变量。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>&lt;h3 id=&#34;一keyof-运算符&#34;&gt;一、&lt;code&gt;keyof&lt;/code&gt; 运算符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;keyof&lt;/code&gt; 用于将对象类型的所有键名转换为&lt;strong&gt;字面量联合类型&lt;/strong&gt;，是实现 “类型安全的键访问” 的基础。&lt;/p&gt;
&lt;h4 id=&#34;1-基础用法&#34;&gt;1. 基础用法&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Point&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;keyof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Point&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 等价于 type P = &amp;#34;x&amp;#34; | &amp;#34;y&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-与索引签名结合&#34;&gt;2. 与索引签名结合&lt;/h4&gt;
&lt;p&gt;当对象类型包含 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 索引签名时，&lt;code&gt;keyof&lt;/code&gt; 会返回对应的索引类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// number 索引签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Arrayish&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { [&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unknown&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;keyof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Arrayish&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// type A = number（仅允许 number 类型索引）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// string 索引签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Mapish&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { [&lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;M&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;keyof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Mapish&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// type M = string | number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;因为 JavaScript 会将数字索引自动转换为字符串（如 &lt;code&gt;obj[0]&lt;/code&gt; 等价于 &lt;code&gt;obj[&amp;quot;0&amp;quot;]&lt;/code&gt;），因此 &lt;code&gt;string&lt;/code&gt; 索引签名隐含支持 &lt;code&gt;number&lt;/code&gt; 索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;keyof&lt;/code&gt;与&lt;code&gt;Object.keys&lt;/code&gt;的区别&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;keyof&lt;/code&gt;：在类型层面工作，返回键的&lt;strong&gt;字面量联合类型&lt;/strong&gt;（编译时）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;：在值层面工作，返回键的&lt;strong&gt;字符串数组&lt;/strong&gt;（运行时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二typeof-运算符类型上下文&#34;&gt;二、&lt;code&gt;typeof&lt;/code&gt; 运算符（类型上下文）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt; 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;一条件类型&#34;&gt;一、条件类型&lt;/h3&gt;
&lt;p&gt;条件类型通过判断类型关系返回不同类型，基本形式为 &lt;code&gt;SomeType extends OtherType ? TrueType : FalseType&lt;/code&gt;，核心价值在于与泛型结合实现灵活的类型逻辑。&lt;/p&gt;
&lt;h4 id=&#34;1-基本用法&#34;&gt;1. 基本用法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当SomeType可赋值给OtherType时，返回TrueType；否则返回FalseType&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Example1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Animal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 若Dog是Animal的子类型，返回number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-与泛型结合&#34;&gt;2. 与泛型结合&lt;/h4&gt;
&lt;p&gt;条件类型与泛型结合可简化重载，实现类型与值的动态关联：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 需求：输入number返回IdLabel，输入string返回NameLabel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IdLabel&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NameLabel&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 条件类型关联输入与输出类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Label&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;string&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IdLabel&lt;/span&gt; : &lt;span style=&#34;color:#66d9ef&#34;&gt;NameLabel&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 单个函数替代重载
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createLabel&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;string&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;T&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Label&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;T&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;number&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt; } &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Label&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;T&lt;/span&gt;&amp;gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;label1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createLabel&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 类型：IdLabel（{ id: number }）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;label2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createLabel&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 类型：NameLabel（{ name: string }）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-类型推断与-infer&#34;&gt;3. 类型推断与 &lt;code&gt;infer&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过 &lt;code&gt;infer&lt;/code&gt; 关键字在条件类型中&lt;strong&gt;声明性推断类型&lt;/strong&gt;，无需显式指定提取逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示例 1：提取数组元素类型&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Flatten&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Type&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Array&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;infer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Item&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Item&lt;/span&gt; : &lt;span style=&#34;color:#66d9ef&#34;&gt;Type&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Str&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Flatten&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;[]&lt;/span&gt;&amp;gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// type Str = string（推断Item为string）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Num&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Flatten&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;number&lt;/span&gt;&amp;gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// type Num = number（不满足数组，返回原类型）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例 2：提取函数返回类型&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/ts/09--%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/ts/09--%E7%B1%BB/</guid>
      <description>&lt;h4 id=&#34;一类的字段&#34;&gt;一、类的字段&lt;/h4&gt;
&lt;p&gt;字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基本特性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;字段声明默认创建&lt;strong&gt;公共可写属性&lt;/strong&gt;，类型可显式声明（如&lt;code&gt;x: number&lt;/code&gt;）或通过初始化值推断（如&lt;code&gt;x = 0&lt;/code&gt; → 推断为&lt;code&gt;number&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;未指定类型且无初始化值时，隐式为&lt;code&gt;any&lt;/code&gt;（可通过&lt;code&gt;noImplicitAny&lt;/code&gt;禁用，强制显式声明）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化相关&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始化器&lt;/strong&gt;：字段可直接赋值（如&lt;code&gt;x = 0&lt;/code&gt;），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;strictPropertyInitialization 配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;开启时，字段必须在&lt;strong&gt;构造函数内或初始化器中&lt;/strong&gt;初始化，否则报错（防止访问未初始化的属性）。&lt;/li&gt;
&lt;li&gt;例外：用&lt;code&gt;!&lt;/code&gt;（明确赋值断言）标记 “后续会初始化” 的字段（如&lt;code&gt;name!: string&lt;/code&gt;，常用于依赖注入场景）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;readonly 修饰符&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;标记字段为只读，仅可在&lt;strong&gt;初始化器或构造函数中&lt;/strong&gt;赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;二构造函数&#34;&gt;二、构造函数&lt;/h4&gt;
&lt;p&gt;类的初始化函数，用于实例化时设置初始状态。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;与函数的异同&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;相似性：支持类型注释、默认值、重载（如多构造函数签名）。&lt;/li&gt;
&lt;li&gt;区别：
&lt;ul&gt;
&lt;li&gt;不能有类型参数（类型参数属于外部类声明）；&lt;/li&gt;
&lt;li&gt;不能有返回类型注释（默认返回类实例类型）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;super () 调用要求&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;派生类构造函数中，使用&lt;code&gt;this&lt;/code&gt;前必须调用&lt;code&gt;super()&lt;/code&gt;（调用基类构造函数），否则 TypeScript 报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;三方法与访问器&#34;&gt;三、方法与访问器&lt;/h4&gt;
&lt;p&gt;类的函数属性，用于定义行为和属性访问逻辑。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;本质是类的函数属性，支持类型注释（参数和返回值）。&lt;/li&gt;
&lt;li&gt;方法体内访问字段 / 其他方法必须通过&lt;code&gt;this.&lt;/code&gt;，否则引用外部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问器&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;包括&lt;code&gt;get&lt;/code&gt;（读取）和&lt;code&gt;set&lt;/code&gt;（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。&lt;/li&gt;
&lt;li&gt;TypeScript 推断规则：
&lt;ul&gt;
&lt;li&gt;仅有&lt;code&gt;get&lt;/code&gt;时，属性自动为&lt;code&gt;readonly&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;未指定&lt;code&gt;set&lt;/code&gt;参数类型时，从&lt;code&gt;get&lt;/code&gt;返回类型推断；&lt;/li&gt;
&lt;li&gt;4.3+ 版本支持&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;使用不同类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：无额外逻辑的&lt;code&gt;get/set&lt;/code&gt;对意义不大，建议直接用公共字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;四索引签名&#34;&gt;四、索引签名&lt;/h4&gt;
&lt;p&gt;类可声明索引签名，与对象类型索引签名规则一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;class MyClass { [s: string]: boolean | ((s: string) =&amp;gt; boolean); }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：需覆盖方法类型，使用复杂，建议将索引数据存储在类实例外。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;五类继承&#34;&gt;五、类继承&lt;/h4&gt;
&lt;p&gt;类可通过&lt;code&gt;implements&lt;/code&gt;和&lt;code&gt;extends&lt;/code&gt;实现接口约束或基类继承。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/1.this/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/1.this/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;JavaScript中this的绑定规则取决于函数的调用方式而非声明位置。核心规则包括：默认绑定（非严格模式绑定全局对象，严格模式为undefined）、隐式绑定（通过对象调用）、显式绑定（call/apply/bind）和new绑定（构造函数调用）。箭头函数例外，它继承外层作用域的this且不可更改。优先级顺序为：new绑定 &amp;gt; 显式绑定 &amp;gt; 隐式绑定 &amp;gt; 默认绑定。特殊情况下，传入null/undefined会触发默认绑定，而硬绑定函数被new调用时会替换this。理解这些规则对掌握JavaScript的执行上下文至关重要。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件&lt;/p&gt;
&lt;p&gt;this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式&lt;/p&gt;
&lt;p&gt;当一个函数被调用时，会创建一个活动记录（也称为执行上下文），这个记录会包含函数在哪里被调用，函数的调用方式，传入的参数等信息，this就是这个记录的一个属性，会在函数执行的过程中用到&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;调用位置就是函数在代码中被调用的位置，在当前正在执行的函数的前一个调用中&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;默认绑定&lt;/strong&gt;：函数直接使用不带任何修饰的函数引用进行调用（独立函数调用），只能使用默认绑定，无法应用其他规则，非严格模式下，默认绑定绑定到全局对象，在严格模式下绑定到undefined&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐式绑定&lt;/strong&gt;：当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象&lt;/p&gt;
&lt;p&gt;对象属性引用链中只有上一层或者说最后一层在调用位置中起作用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示绑定&lt;/strong&gt;：所有函数都可以使用call()和apply()方法，它们的第一个参数是一个对象，接着在调用函数时将其绑定到this&lt;/p&gt;
&lt;p&gt;如果传入一个原始值来当做this的绑定对象，这个原始值会被转换成它的对象形式，这通常被称为装箱&lt;/p&gt;
&lt;p&gt;硬绑定：一种显式的强制绑定&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以创建一个包裹函数，负责接收参数并返回值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一种是创建一个可以重复使用的辅助函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bind&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bind&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ES5提供了内置的方法Function.prototype.bind，返回一个硬编码的新函数，把指定的参数设置为this的上下文并调用原始函数&lt;/p&gt;
&lt;p&gt;JS许多内置函数或第三方库函数都提供了一个可选的参数，通常被称为上下文，其作用和bind一样，确保回调函数使用指定的this，实际上都是通过call或apply实现了显示绑定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;new绑定&lt;/strong&gt;：在JS中，构造函数只是一些使用new操作符时被调用的函数，它们并不会属于某个类，也不会实例化一个类，只是被new操作符调用的普通函数而已&lt;/p&gt;
&lt;p&gt;所有函数都可以用new调用，这种函数调用被称为构造函数调用&lt;/p&gt;
&lt;p&gt;使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个全新的对象&lt;/li&gt;
&lt;li&gt;这个新对象会被执行[[Prototype]]连接&lt;/li&gt;
&lt;li&gt;这个新对象会绑定到函数调用的this&lt;/li&gt;
&lt;li&gt;如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;bind()方法会判断硬绑定函数是否被new调用，如果是的话就会使用新创建的this替换硬绑定的this。&lt;/p&gt;
&lt;p&gt;在new中使用硬绑定函数主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数&lt;/p&gt;
&lt;p&gt;根据优先级判断this：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数是否在new中调用？如果是的话this绑定的是新创建的对象&lt;/li&gt;
&lt;li&gt;函数是否通过call，apply或者硬绑定调用？如果是的话，this绑定的是指定的对象&lt;/li&gt;
&lt;li&gt;函数是否在某个上下文对象中调用？如果是的话，this绑定的是那个上下文对象&lt;/li&gt;
&lt;li&gt;如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到undefined，否则绑定到全局对象&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;如果null或undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则&lt;/p&gt;
&lt;p&gt;apply可以用来展开数组，并当做参数传入一个函数；bind可以对参数进行柯里化，预先设置一些参数&lt;/p&gt;
&lt;p&gt;Object.create(null)可以创建一个空对象，并且不会创建Object.prototype这个委托，比{}更空&lt;/p&gt;
&lt;p&gt;忽略this绑定时传入空对象可以避免对全局对象产生影响&lt;/p&gt;
&lt;p&gt;有可能会创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认绑定规则&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;箭头函数不使用this的四种标准规则，而是根据外层作用域来决定this&lt;/p&gt;
&lt;p&gt;箭头函数的绑定无法被修改，箭头函数可以像bind一样确保函数的this绑定到指定的对象，用常见的词法作用域取代了传统的this机制&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/2.-%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/2.-%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文摘要：JavaScript对象可以通过文字声明或构造形式定义，两种方式结果相同但写法不同。JS有6种基本类型和多种对象子类型，包括内置对象如Array、Date等。对象属性存储的是名称而非值本身，可通过点语法或块访问访问。属性描述符可控制属性的可写性、可配置性等特性。通过Object.preventExtensions()、Object.seal()和Object.freeze()可实现不同级别的对象不可变性。in、hasOwnProperty()等方法可用于检查属性存在性，forEach、every等辅助迭代器可用于数组遍历。for..of循环通过内置@@iterator实现迭代访问。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;对象可以通过两种形式定义：声明文字形式和构造形式&lt;/p&gt;
&lt;p&gt;构造形式和文字形式生成的对象是一样的，唯一的区别是，在文字声明中可以添加多个键值对，但是在构造形式中必须逐个添加属性&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在JS中一共有六种主要类型：string、number、boolean、null、undefined和object&lt;/p&gt;
&lt;p&gt;简单基本类型本身并不是对象，JS中有许多特殊的对象子类型，我们称之为复杂基本类型&lt;/p&gt;
&lt;p&gt;函数就是对象的一个子类型（可调用的对象），JS中的函数是一等公民，因为他本质上和普通的对象一样（只是可调用），所以可以像操作其他对象一样操作函数&lt;/p&gt;
&lt;p&gt;数组也是对象的一种类型，具备一些额外的行为，数组中内容的组织方式比一般的对象要稍微复杂一些&lt;/p&gt;
&lt;p&gt;JS还有一些对象子类型，被称为内置对象，String、Number、Boolean、Object、Function、Array、Date、RegExp、Error&lt;/p&gt;
&lt;p&gt;这些内置函数可以当做构造函数来使用，从而可以构造一个对应子类型的新对象&lt;/p&gt;
&lt;p&gt;有必要时，语言会自动把字面量转换成对应的内置对象，也就是说并不需要显式创建一个对象&lt;/p&gt;
&lt;p&gt;null和undefined没有对应的构造形式，它们只有文字形式，Date只有构造，没有文字形式&lt;/p&gt;
&lt;p&gt;对于Object、Array、Function和RegExp来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，构造形式可以提供一些额外选项，建议只在需要那些额外选项时使用构造形式&lt;/p&gt;
&lt;p&gt;Error对象很少在代码中显式创建，一般是在抛出异常时被自动创建，也可以使用new Error()这种构造形式来创建&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性&lt;/p&gt;
&lt;p&gt;在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部，存储在对象容器内部的是这些属性的名称，它们就像指针一样，指向这些值真正的存储位置&lt;/p&gt;
&lt;p&gt;.语法通常被称为属性访问，[&amp;quot;&amp;quot;]语法通常被称为块访问，这两种语法的主要区别是.操作符要求属性名满足标识符的命名规范，[&amp;quot;&amp;quot;]语法可以接受任意UTF-8/Unicode字符串作为属性名。此外，由于[&amp;quot;&amp;quot;]语法使用字符串来访问属性，所以可以在程序中构造这个字符串&lt;/p&gt;
&lt;p&gt;在对象中，属性名永远都是字符串，如果使用string字面量以外的其他值作为属性名，那它首先会被转换为一个字符串&lt;/p&gt;
&lt;p&gt;可以在文字形式中使用[]包裹一个表达式来当做属性名（可计算属性名）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;永远不会属于一个对象，无论返回值是什么类型，每次访问对象的属性就是属性访问，属性访问返回的函数和其他函数没有任何区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;也支持[]访问形式，数组有一套更加结构化的值存储机制，数组期望的是数值下标，也就是说值存储的位置是非负整数&lt;/p&gt;
&lt;p&gt;数组也是对象，虽然每个下标都是整数，但仍然可以给数组添加命名属性，数组的length值不会发生变化&lt;/p&gt;
&lt;p&gt;完全可以把数组当成一个普通的键值对象来使用，并且不添加任何数值索引，但最好只用对象来存储键值对，只用数组来存储下标值对&lt;/p&gt;
&lt;p&gt;如果试图向数组添加一个属性，但是属性名看起来像一个数字，那他会变成一个数值下标&lt;/p&gt;
&lt;p&gt;对于JSON安全的对象来说，进行深&lt;strong&gt;拷贝&lt;/strong&gt;可以通过：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newObj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parse&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;stringify&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;someObj&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ES6定义了Object.assign()方法实现浅拷贝，第一个参数是目标对象，之后可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象。&lt;/p&gt;
&lt;p&gt;因为Object.assign()使用=操作符来赋值，所以源对象属性的一些特性不会被复制到目标对象&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在创建普通属性时&lt;strong&gt;属性描述符&lt;/strong&gt;会使用默认值，我们也可以使用Object.defineProperty()来添加一个新属性或者修改一个已有属性并对特性进行设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;writable：决定是否可以修改属性的值&lt;/li&gt;
&lt;li&gt;configurable：只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符，将其改成false是单项操作，不能撤销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	除了无法修改，configurable:false还会禁止删除这个属性&lt;/p&gt;
&lt;p&gt;​	delete只用来删除对象的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;enumerable：这个描述符控制的是属性是否会出现在对象的属性枚举中。如果把enumerable设置成false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get：对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到名称相同的属性，GET算法会执行原型链查找，如果无论如何都没有找到名称相同的属性，会返回undefined&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;put：如果已经存在这个属性，put算法大致会检查下面这些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性是否是访问操作符？如果是并且存在setter就调用setter&lt;/li&gt;
&lt;li&gt;属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出类型异常&lt;/li&gt;
&lt;li&gt;如果都不是，将该值设置为属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果对象中不存在这个属性，put操作会更加复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getter是一个隐藏函数，会在获取属性值时调用。setter也是一个隐藏函数，会在设置属性值时调用。当给一个属性定义getter、setter或者两者都有时，这个属性会被定义为访问描述符（和数据描述符相对）。对于访问描述符来说，JS会忽略它们的value和writable特性，取而代之的是关心set和get特性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	不管是对象文字语法中的get a(){}，还是defineProperty()中的显示定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值&lt;/p&gt;
&lt;p&gt;​	setter会覆盖单个属性默认的put操作，通常来说getter和setter是成对出现的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;让属性或对象是不可变的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象常量：结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改、重定义或者删除）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止扩展：使用Object.preventExtensions()可以禁止一个对象添加新属性并且保留已有属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;密封：Object.seal()会创建一个密封的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions()并把所有现有属性标记为configurable:false。所以密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Object.freeze()会创建一个冻结对象。这个方法实际上会在一个现有对象上调用Object.seal()并把所有数据访问属性标记为writable:false，这样就无法修改它们的值&lt;/p&gt;
&lt;p&gt;这个方法是可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;存在性：&lt;/p&gt;
&lt;p&gt;in操作符会检查属性是否在对象及其原型链中。hasOwnProperty()只会检查属性是否在对象中，不会检查原型链&lt;/p&gt;
&lt;p&gt;propertyIsEnumerable()方法会检查给定的属性名是否直接存在于对象中，而不是原型链上，并且满足enumerable:true&lt;/p&gt;
&lt;p&gt;Object.keys()会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames()会返回一个数组，包含所有属性，无论它们是否可枚举&lt;/p&gt;
&lt;p&gt;in和hasOwnProperty()的区别在于是否查找原型链，然而，Object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;for&amp;hellip;in循环可以用来遍历对象的可枚举属性列表（包括原型链），遍历顺序是不确定的，在不同的JS引擎中可能不一样&lt;/p&gt;
&lt;p&gt;对于数值索引的数组来说，可以使用标准的for循环来遍历值&lt;/p&gt;
&lt;p&gt;ES5中增加了一些数组的辅助迭代器，每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它对于回调函数返回值的处理方式不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forEach()会遍历数组中的所有值并忽略回调函数的返回值&lt;/li&gt;
&lt;li&gt;every()会一直运行直到回调函数返回false&lt;/li&gt;
&lt;li&gt;some()会一直运行直到回调函数返回true&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;every()和some()中特殊的返回值和普通for循环中的break语句类似，它们会提前终止遍历&lt;/p&gt;
&lt;p&gt;for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值&lt;/p&gt;
&lt;p&gt;数组有内置的@@iterator（返回迭代器对象的函数），因此for&amp;hellip;of可以直接应用在数组上&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/3.-%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/3.-%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：面向对象编程中，类作为蓝图定义了数据结构与行为的封装，通过继承实现父类与子类的特殊化关系，核心概念包括多态（方法重写与相对引用）和实例化（构造函数创建对象副本）。然而JavaScript的对象机制与传统类继承不同，采用原型关联而非复制，并不存在真正的类实例化概念。(148字)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;类继承描述了一种代码的组织结构形式，一种在软件中对真实世界中问题领域的建模方法&lt;/p&gt;
&lt;p&gt;面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包起来。这在正式的计算机科学中有时被称为数据结构&lt;/p&gt;
&lt;p&gt;我们可以实用类对数据结构进行分类，把任意数据结构看作范围更广的定义的一种特例&lt;/p&gt;
&lt;p&gt;类的另一个核心概念是多态，这个概念就是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行为&lt;/p&gt;
&lt;p&gt;类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有共有数据属性。这个对象就是类中描述的所有特性的一份副本&lt;/p&gt;
&lt;p&gt;通常不会使用一个实例对象来直接访问并操作它的类，不过至少可以判断出这个实例对象来自哪个类&lt;/p&gt;
&lt;p&gt;类通过复制操作被实例化为对象形式&lt;/p&gt;
&lt;p&gt;类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息。&lt;/p&gt;
&lt;p&gt;类构造函数属于类，而且通常和类同名，此外，构造函数大多需要用new来调，这样语言引擎才知道你想用构造一个新的类实例&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在面向类的语言中，可以先定义一个类，然后定义一个继承前者的类，后者通常被称为子类，前者通常被称为父类。&lt;/p&gt;
&lt;p&gt;定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本。但是也可以重写所有继承的行为甚至定义新行为&lt;/p&gt;
&lt;p&gt;多态是一个很广泛的话题，相对是多态的一个方面：任何方法都可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说相对，是因为我们并不会定义想要访问的绝对继承层次，而是使用相对引用查找上一层&lt;/p&gt;
&lt;p&gt;许多语言中可以用super，它的含义是超类，表示当前类的父类/祖先类，从子类的构造函数中通过super可以直接调用父类的构造函数。&lt;/p&gt;
&lt;p&gt;多态的另一方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义&lt;/p&gt;
&lt;p&gt;方法定义的多态性取决于是在哪个类的实例中引用它&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在继承和实例化时，JS的对象机制并不会自动执行复制行为，JS中只有对象，并不存在可以被实例化的类，一个对象并不会被复制到其他对象，它们会被关联起来&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/4.-%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/4.-%E5%8E%9F%E5%9E%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：JavaScript对象通过[[Prototype]]链实现原型继承机制，属性访问会沿着原型链查找。对象创建时[[Prototype]]会被赋予非空值，最终指向Object.prototype。属性赋值可能产生屏蔽效果，不同情况处理方式不同。构造函数.prototype属性用于关联新对象，但JS本质是对象互相关联而非类继承。Object.create()和__proto__等方法可操作原型链，空[[Prototype]]对象适合数据存储。JS通过原型链实现对象间的委托而非传统类继承。（150字）&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;JS中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值&lt;/p&gt;
&lt;p&gt;当试图引用对象的属性时就会触发[[Get]]操作，对于默认的[[Get]]操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。但是如果不在，就需要使用对象的[[Prototype]]链了。对于默认的[[Get]]操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的[[Prototype]]链。这个过程会持续到找到匹配的属性名或者查找完整条[[Prototype]]链，如果是后者的话，[[Get]]操作的返回值就是undefined&lt;/p&gt;
&lt;p&gt;使用for&amp;hellip;in遍历对象时，原理和查找[[Prototype]]链类似，任何可以通过原型链访问到并且是enumerable的属性都会被枚举&lt;/p&gt;
&lt;p&gt;使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链，无论属性是否可枚举&lt;/p&gt;
&lt;p&gt;所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。由于所有普通对象都源于这个Object.prototype对象，所以它包含JS中许多通用的功能&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myObject&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值&lt;/p&gt;
&lt;p&gt;如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作，如果原型链上找不到foo，foo就会被直接添加到myObject上&lt;/p&gt;
&lt;p&gt;如果属性名既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽，myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性&lt;/p&gt;
&lt;p&gt;如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = &amp;lsquo;bar&amp;rsquo;会出现三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在[[Prototype]]链上层存在名为foo的普通数据访问属性并且没有被标记为只读，那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性&lt;/li&gt;
&lt;li&gt;如果在[[Prototype]]链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在myObject上创建屏蔽属性，如果运行在严格模式下，代码会报错，否则，这天赋值语句会被忽略&lt;/li&gt;
&lt;li&gt;如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter。foo不会被添加到myObject，也不会重新定义foo这个setter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果希望在第二或三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty()来向myObject添加foo&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在JS中，类无法描述对象的行为，因为根本不存在类，对象直接定义自己的行为，JS中只有对象&lt;/p&gt;
&lt;p&gt;所有函数默认都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象，这个对象通常被称为该函数的原型，因为我们通过名为Xxx.prototype的属性引用来访问它&lt;/p&gt;
&lt;p&gt;通过调用new Xxx()创建的每个对象最终被[[Prototype]]链接到这个Xxx.prototype对象&lt;/p&gt;
&lt;p&gt;在面向类的语言中，类可以被实例化多次，但是JS没有类似的复制机制，不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行赋值，因此这些对象之间并不会完全失去联系，它们是互相关联的&lt;/p&gt;
&lt;p&gt;new函数调用实际上并没有直接创建关联，这关联只是一个意外的副作用，它只是间接完成了我们的目标：一个关联到其他对象的新对象&lt;/p&gt;
&lt;p&gt;在JS中，我们并不会讲一个对象复制到另一个对象，只是将它们关联起来，这个机制通常被称为原型继承，也可以叫做委托&lt;/p&gt;
&lt;p&gt;函数本身并不是构造函数，但当你在普通函数调用前面加上new关键字之后，就会把这个函数调用变成一个构造函数调用。&lt;/p&gt;
&lt;p&gt;new会劫持所有普通函数并用构造对象的形式来调用它&lt;/p&gt;
&lt;p&gt;Xxx.prototype默认有一个公有且不可枚举的属性.constructor，这个属性引用的是对象关联的函数。Xxx.prototype的.constructor属性只是Xxx函数在声明时的默认属性，如果创建了一个新对象并替换了函数默认的.prototype对象引用，那么新对象并不会自动获得.constructor属性。&lt;/p&gt;
&lt;p&gt;实际上，对象的.constructor属性默认指向一个函数，而这个函数也有一个叫做.prototype的引用指向这个对象。&lt;/p&gt;
&lt;p&gt;constructor并不是一个不可变的属性，它是不可枚举的，但是它的值是可写的，可以给任意[[Prototype]]链中的任意对象添加一个名为constructor的属性或者对其进行修改，可以任意对其赋值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;调用Object.create()会凭空创建一个新对象并把新对象内部的[[Prototype]]关联到指定的对象&lt;/p&gt;
&lt;p&gt;Object.setPrototypeOf()可以用标准且可靠的方法来修改对象的[[Prototype]]关联&lt;/p&gt;
&lt;p&gt;检查一个实例的继承祖先通常被称为内省或者反射&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数，instanceof回答的问题是：在a的整条[[Prototype]]链中是否有Foo.prototype指向的对象&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在a的整条[[Prototype]]链中是否出现过Foo.prototype&lt;/p&gt;
&lt;p&gt;也可以直接获取一个对象的[[Prototype]]链&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;绝大多数浏览器也支持一种非标准方法来访问内部的[[Prototype]]属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个__proto__属性引用了内部的[[Prototype]]对象，这个属性并不存在于正在使用的对象中，而是存在于内置的Object.prototype中，并且是不可枚举的，它更像一个getter/setter，是可设置属性，但通常不需要修改已有对象的[[Prototype]]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找，同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推，这一系列对象的链接被称为原型链&lt;/p&gt;
&lt;p&gt;Object.create()会创建一个新对象，并把它关联到我们指定的对象，这样可以充分发挥[[Prototype]]机制的威力并且避免不必要的麻烦&lt;/p&gt;
&lt;p&gt;Object.create(null)会创建一个拥有空[[Prototype]]链接的对象，这个对象无法进行委托。这些空[[Prototype]]对象通常被称作字典，他们完全不会受到原型链的干扰，非常适合用来存储数据&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/5.-%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/5.-%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文对比了对象关联和类继承两种编程模式的区别。对象关联采用[[Prototype]]委托机制，强调状态存储在委托者而非目标上，避免同名方法重写，提倡使用描述性方法名以提高代码可读性。同时指出委托行为存在循环委托的限制。另一方面，class语法支持super多态和extends继承，但本质上仍是语法糖，存在静态绑定super、无法声明属性和动态修改等局限性。两种模式各有特点，开发者需要根据实际需求选择合适的实现方式。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;相比于面向类，对象关联风格的代码有一些不同之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在[[Prototype]]委托中最好把状态保存在委托者而不是委托目标上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在类设计中，我们故意让父类和子类中都有同名方法，这样就可以利用重写的优势，在委托行为中我们会尽量避免在[[Prototype]]链的不同级别中使用相同的命名&lt;/p&gt;
&lt;p&gt;这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型，这样做实际上可以创建出更容易理解和维护的代码，因为方法名更清晰&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象&lt;/p&gt;
&lt;p&gt;无法在两个或两个以上互相委托的对象之间创建循环委托，如果把B关联到A然后试着把A关联到B，就会出错&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;class语法特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过super()来实现相对多态，这样任何方法都可以引用原型链上层的同名方法&lt;/li&gt;
&lt;li&gt;class字面语法不能声明属性，只能声明方法&lt;/li&gt;
&lt;li&gt;可以通过extends很自然的扩展对象类型，甚至是内置对象类型&lt;/li&gt;
&lt;li&gt;但是本质是语法糖，没法真正实现类，并且super声明时是静态绑定而不是动态绑定的，所以定义了class后不容易对其动态修改&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/1.%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/1.%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文总结《你不了解的JS》第一部分第一章的核心概念，重点介绍了JavaScript的编译原理和作用域机制。笔记指出程序状态通过变量存储和访问实现，作用域是一套管理变量的规则体系。编译过程包括分词、语法分析和代码生成三个阶段。在变量赋值时，编译器处理声明，引擎执行查询（LHS/RHS）。作用域嵌套时，引擎会逐级向上查找变量。文章还区分了RHS和LHS查询的区别，以及在不同情况下可能出现的ReferenceError和TypeError异常。严格模式会改变LHS查询失败时的默认行为。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;一核心概念&#34;&gt;一、核心概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序状态与变量&lt;/strong&gt;：存储和访问变量值的能力为程序赋予了状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用域定义&lt;/strong&gt;：一套规则体系，用于管理变量的存储方式和查找逻辑，确保代码能按规则访问变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二编译原理&#34;&gt;二、编译原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;传统编译三阶段：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分词 / 词法分析&lt;/strong&gt;：将源代码字符串分解为有意义的词法单元（如关键字、变量名、运算符等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解析 / 语法分析&lt;/strong&gt;：将词法单元流转换为抽象语法树（AST），AST 是体现程序语法结构的嵌套树状结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码生成&lt;/strong&gt;：将 AST 转换为可执行代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaScript 编译特点&lt;/strong&gt;：多数情况下，编译在代码片段执行前的几微秒内完成（即时编译）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三作用域的核心角色&#34;&gt;三、作用域的核心角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;引擎&lt;/strong&gt;：负责整个 JavaScript 程序的编译及执行全过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译器&lt;/strong&gt;：负责语法分析、代码生成等编译相关工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用域&lt;/strong&gt;：负责收集并维护所有声明的标识符（变量、函数名等），并制定规则确定当前执行的代码对这些标识符的访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四变量声明与赋值过程以var-a--2为例&#34;&gt;四、变量声明与赋值过程（以&lt;code&gt;var a = 2&lt;/code&gt;为例）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;变量声明（编译器处理）：
&lt;ul&gt;
&lt;li&gt;编译器询问当前作用域：是否已存在名为&lt;code&gt;a&lt;/code&gt;的变量。&lt;/li&gt;
&lt;li&gt;若存在，忽略该声明；若不存在，要求作用域在当前集合中声明一个新变量&lt;code&gt;a&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变量赋值（引擎处理）：
&lt;ul&gt;
&lt;li&gt;引擎询问当前作用域：是否存在名为&lt;code&gt;a&lt;/code&gt;的变量。存在则直接使用，不存在则继续向上查找。&lt;/li&gt;
&lt;li&gt;找到&lt;code&gt;a&lt;/code&gt;后，将 2 赋值给它；未找到则抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LHS 与 RHS 查询：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RHS 查询&lt;/strong&gt;：查找变量的值（如&lt;code&gt;console.log(a)&lt;/code&gt;中对&lt;code&gt;a&lt;/code&gt;的查询）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LHS 查询&lt;/strong&gt;：查找变量的容器本身，用于赋值（如&lt;code&gt;a = 2&lt;/code&gt;中对&lt;code&gt;a&lt;/code&gt;的查询）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数声明处理&lt;/strong&gt;：编译器在代码生成阶段同步处理函数的声明和值定义。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;五作用域嵌套&#34;&gt;五、作用域嵌套&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;嵌套场景&lt;/strong&gt;：当块或函数嵌套在另一个块或函数中时，形成作用域嵌套。&lt;/li&gt;
&lt;li&gt;查找规则：
&lt;ul&gt;
&lt;li&gt;引擎从当前执行作用域开始查找变量，找不到则向上一级嵌套作用域继续查找。&lt;/li&gt;
&lt;li&gt;直至找到变量或抵达全局作用域，查找过程终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;六异常类型及触发场景&#34;&gt;六、异常类型及触发场景&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ReferenceError（引用错误）：
&lt;ul&gt;
&lt;li&gt;RHS 查询：在所有嵌套作用域中未找到目标变量时抛出。&lt;/li&gt;
&lt;li&gt;LHS 查询：严格模式下，在所有作用域中未找到目标变量时抛出（非严格模式下会自动在全局作用域创建该变量，&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt;本身在非严格模式下也不会隐式创建全局变量）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TypeError（类型错误）&lt;/strong&gt;：RHS 查询找到变量，但对其值进行不合理操作（如对非函数变量调用方法）时抛出。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/2.%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/2.%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;《你不了解的JS》笔记：词法作用域与欺骗词法&lt;/p&gt;
&lt;p&gt;词法作用域由代码书写位置决定，查找从内向外进行，存在遮蔽效应。全局变量可通过window对象间接访问。欺骗词法的方式包括eval和with：eval动态修改作用域（严格模式除外），with将对象处理为临时作用域。两者都会影响性能，eval在严格模式下有独立作用域，with会将var声明泄漏到函数作用域。这些特性都可能导致代码运行效率下降。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;一词法作用域的核心特性&#34;&gt;一、词法作用域的核心特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义与本质&lt;/strong&gt;：
词法作用域是在代码&lt;strong&gt;书写阶段&lt;/strong&gt;就确定的作用域，由变量、块作用域及函数的声明位置决定，与函数的调用位置无关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查找规则&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;作用域查找从&lt;strong&gt;最内部作用域&lt;/strong&gt;开始，逐级向外（向上）进行，直到找到第一个匹配的标识符后停止（即 “就近匹配”）。&lt;/li&gt;
&lt;li&gt;仅查找&lt;strong&gt;一级标识符&lt;/strong&gt;（如&lt;code&gt;a&lt;/code&gt;，不会自动查找对象属性链如&lt;code&gt;obj.a&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遮蔽效应&lt;/strong&gt;：
在多层嵌套作用域中，内层作用域的标识符可遮蔽外层同名标识符（如内层&lt;code&gt;var a = 1&lt;/code&gt;会遮蔽外层的&lt;code&gt;var a = 2&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局变量的特殊访问&lt;/strong&gt;：
全局变量会成为全局对象（如浏览器中的&lt;code&gt;window&lt;/code&gt;）的属性，可通过&lt;code&gt;window.a&lt;/code&gt;访问被内层同名变量遮蔽的全局变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数的词法作用域&lt;/strong&gt;：
函数的词法作用域仅由其&lt;strong&gt;声明时所处的位置&lt;/strong&gt;决定，与调用位置、调用方式无关。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二欺骗词法作用域的方式&#34;&gt;二、欺骗词法作用域的方式&lt;/h3&gt;
&lt;h4 id=&#34;1-eval-函数&#34;&gt;1. eval 函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：接收字符串参数，将其视为代码片段插入到当前位置执行，仿佛该代码在书写时就存在于此。&lt;/li&gt;
&lt;li&gt;对作用域的影响：
&lt;ul&gt;
&lt;li&gt;默认情况下，若&lt;code&gt;eval&lt;/code&gt;中的代码包含变量 / 函数声明，会&lt;strong&gt;修改其所处的词法作用域&lt;/strong&gt;（新增或覆盖标识符）。&lt;/li&gt;
&lt;li&gt;严格模式下，&lt;code&gt;eval&lt;/code&gt;有&lt;strong&gt;独立的词法作用域&lt;/strong&gt;，内部声明不会影响外部作用域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常见用途&lt;/strong&gt;：执行动态生成的代码（如拼接字符串形成的逻辑）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-with-语句&#34;&gt;2. with 语句&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：作为访问对象多个属性的快捷方式，避免重复书写对象名（如&lt;code&gt;with(obj) { a = 1; b = 2 }&lt;/code&gt;等效于&lt;code&gt;obj.a = 1; obj.b = 2&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;对作用域的影响：
&lt;ul&gt;
&lt;li&gt;将传入的对象视为一个&lt;strong&gt;临时的词法作用域&lt;/strong&gt;，对象的属性被当作该作用域中的标识符。&lt;/li&gt;
&lt;li&gt;块内的&lt;code&gt;var&lt;/code&gt;声明不会被限制在&lt;code&gt;with&lt;/code&gt;块中，而是&lt;strong&gt;泄漏到外层函数作用域&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本质&lt;/strong&gt;：根据传入对象 “凭空创建” 全新的词法作用域，与&lt;code&gt;eval&lt;/code&gt;修改现有作用域的行为不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三副作用与风险&#34;&gt;三、副作用与风险&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;性能问题&lt;/strong&gt;：
&lt;code&gt;eval&lt;/code&gt;和&lt;code&gt;with&lt;/code&gt;会破坏 JS 引擎的&lt;strong&gt;词法作用域静态分析&lt;/strong&gt;（无法提前确定变量查找规则），导致无法优化代码执行，显著降低运行效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码可读性与维护性&lt;/strong&gt;：
动态修改作用域会使变量的查找逻辑变得模糊，增加调试难度，不符合词法作用域的设计初衷。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;严格模式限制&lt;/strong&gt;：
严格模式下&lt;code&gt;eval&lt;/code&gt;的作用域被隔离，&lt;code&gt;with&lt;/code&gt;被完全禁止（直接抛出错误），进一步体现了对 “欺骗词法” 行为的不推荐。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/3.%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/3.%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;《你不了解的JS》第一部分第三章探讨了函数和块作用域的概念。函数作用域允许变量在函数内部复用，并可通过隐藏内部实现遵循最小特权原则，避免命名冲突。函数声明与表达式的主要区别在于标识符绑定位置，建议为函数表达式命名以便调试。IIFE（立即执行函数表达式）是常见模式，可用于传递参数和解决变量覆盖问题。块作用域通过let和const实现变量本地化，let在循环中每次迭代重新绑定变量，const则创建不可变绑定。这些机制有助于优化变量生命周期和避免提升问题。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;一函数作用域的核心特性&#34;&gt;一、函数作用域的核心特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义与复用&lt;/strong&gt;：函数内部声明的变量，可在整个函数范围内（包括嵌套作用域）使用和复用。&lt;/li&gt;
&lt;li&gt;隐藏内部实现：
&lt;ul&gt;
&lt;li&gt;通过函数作用域封装变量和函数，遵循&lt;strong&gt;最小特权原则&lt;/strong&gt;（仅暴露必要内容，隐藏细节），减少命名冲突。&lt;/li&gt;
&lt;li&gt;第三方库通常通过&lt;strong&gt;命名空间对象&lt;/strong&gt;（将功能作为对象属性暴露）或&lt;strong&gt;模块管理器&lt;/strong&gt;（避免全局作用域污染）防止冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二函数声明与表达式的区别&#34;&gt;二、函数声明与表达式的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;区分方法：
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;function&lt;/code&gt;是声明的第一个词，则为&lt;strong&gt;函数声明&lt;/strong&gt;；否则为&lt;strong&gt;函数表达式&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键差异：
&lt;ul&gt;
&lt;li&gt;函数声明的名称标识符绑定在&lt;strong&gt;所在作用域&lt;/strong&gt;中；&lt;/li&gt;
&lt;li&gt;函数表达式的名称标识符绑定在&lt;strong&gt;自身函数内部&lt;/strong&gt;（外部不可直接访问）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匿名函数表达式的缺点：
&lt;ul&gt;
&lt;li&gt;栈追踪无有意义名称，调试困难；&lt;/li&gt;
&lt;li&gt;无法通过名称自引用（依赖&lt;code&gt;arguments.callee&lt;/code&gt;，已过时）；&lt;/li&gt;
&lt;li&gt;降低代码可读性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：始终为函数表达式命名（如&lt;code&gt;const fn = function namedFn() {}&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三立即执行函数表达式iife&#34;&gt;三、立即执行函数表达式（IIFE）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：函数表达式被声明后立即执行（如&lt;code&gt;(function() { ... })()&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见用途&lt;/p&gt;
&lt;p&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递参数，隔离作用域（避免污染外部）；&lt;/li&gt;
&lt;li&gt;确保&lt;code&gt;undefined&lt;/code&gt;标识符的准确性（通过参数占位，如&lt;code&gt;(function(undef) { ... })()&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;倒置代码执行顺序（将主逻辑作为参数传递给 IIFE）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;四块作用域的特性与实现&#34;&gt;四、块作用域的特性与实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;核心作用&lt;/strong&gt;：将变量本地化，扩展最小授权原则，从函数级隐藏扩展到块级隐藏。&lt;/li&gt;
&lt;li&gt;块作用域的优势：变量声明靠近使用位置，减少作用域污染，优化变量生命周期，避免提升带来的意外行为。&lt;/li&gt;
&lt;li&gt;实现方式：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;with 语句&lt;/strong&gt;：为对象创建临时块作用域（仅在&lt;code&gt;with&lt;/code&gt;内部有效）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;try/catch&lt;/strong&gt;：&lt;code&gt;catch&lt;/code&gt;分句创建块作用域，内部变量仅在&lt;code&gt;catch&lt;/code&gt;中有效；&lt;/li&gt;
&lt;li&gt;let 关键字：
&lt;ul&gt;
&lt;li&gt;将变量绑定到所在块作用域（如&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;块）；&lt;/li&gt;
&lt;li&gt;无提升特性（声明前访问会报错）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt;循环中，&lt;code&gt;let&lt;/code&gt;会将变量&lt;strong&gt;重新绑定到每个迭代&lt;/strong&gt;（确保迭代值独立）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;const 关键字：
&lt;ul&gt;
&lt;li&gt;同&lt;code&gt;let&lt;/code&gt;的块作用域特性，但值为常量（修改会报错）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原书中P34最上方 “点击事件因闭包导致变量问题” 的描述有误：实际是&lt;code&gt;var&lt;/code&gt;声明的变量属于函数 / 全局作用域，生命周期长，导致循环中共享同一变量；而&lt;code&gt;let&lt;/code&gt;通过块作用域解决此问题。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/4.%E6%8F%90%E5%8D%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/4.%E6%8F%90%E5%8D%87/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;JS中的变量和函数声明会在代码执行前被&amp;quot;提升&amp;quot;。引擎在编译阶段会将所有声明提前处理，但赋值操作保留原位。函数声明优先于变量声明，且会被提升到作用域顶部。需要注意的是，函数表达式不会被提升，块级函数声明也存在提升问题。开发者应避免在块内部声明函数，且重复声明时后面的函数会覆盖前面的。这些机制体现了JS编译阶段和执行阶段的差异性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;一变量和函数声明的提升机制&#34;&gt;一、变量和函数声明的提升机制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提升的本质&lt;/strong&gt;：
引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用域范围&lt;/strong&gt;：每个作用域（全局、函数、块作用域）都会独立进行提升操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二函数声明与变量声明的提升优先级&#34;&gt;二、函数声明与变量声明的提升优先级&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;函数声明优先：
&lt;ul&gt;
&lt;li&gt;函数声明的提升优先级高于变量声明，会被提升到作用域更顶部。&lt;/li&gt;
&lt;li&gt;示例：若同时存在&lt;code&gt;function a() {}&lt;/code&gt;和&lt;code&gt;var a&lt;/code&gt;，函数声明会先被提升，变量声明因重复被忽略（但变量赋值会覆盖函数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数表达式不提升：
&lt;ul&gt;
&lt;li&gt;函数表达式（如&lt;code&gt;var fn = function() {}&lt;/code&gt;）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;具名函数表达式（如&lt;code&gt;var fn = function named() {}&lt;/code&gt;）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三特殊情况与注意事项&#34;&gt;三、特殊情况与注意事项&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;重复声明的覆盖：
&lt;ul&gt;
&lt;li&gt;变量重复声明（如&lt;code&gt;var a = 1; var a = 2&lt;/code&gt;）会被忽略前序，保留最后一次赋值；&lt;/li&gt;
&lt;li&gt;函数重复声明（如&lt;code&gt;function a() {}; function a() {}&lt;/code&gt;）后序声明会覆盖前序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;块级函数声明的问题：
&lt;ul&gt;
&lt;li&gt;普通块内部的函数声明（如&lt;code&gt;if (true) { function a() {} }&lt;/code&gt;）可能被提升到所在作用域顶部（不同 JS 环境处理有差异），易导致逻辑混乱，&lt;strong&gt;应避免在块内声明函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/5.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/5.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：闭包是指函数能够记住并访问其词法作用域，即使在其作用域外执行。通过回调函数或将内部函数传递到外部都可形成闭包。示例展示了用IIFE解决循环变量共享问题，以及let在循环中的特殊行为。模块模式需满足：1)外部封闭函数被调用创建实例；2)返回内部函数形成闭包访问私有状态。ES6模块与函数模块不同，具有静态API检查机制，需定义在单独文件中，其内容如同在闭包中处理。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的&lt;/p&gt;
&lt;p&gt;无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包&lt;/p&gt;
&lt;p&gt;只要使用了回调函数，实际上就是在使用闭包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个需要调用的函数引用了其他作用域的变量，导致该作用域不会消失，并且函数可以随时引用这个作用域&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会包含有一个具有正确值的变量供我们访问！！！！！&lt;/p&gt;
&lt;p&gt;for循环头部的let声明有一个特殊行为：变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最常见的实现模块模式的方法通常被称为模块暴露&lt;/p&gt;
&lt;p&gt;模块模式需要具备两个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须有外部的封闭函数，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例&lt;/li&gt;
&lt;li&gt;封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模块模式一个简单但强大的用法是命名将要作为公共API返回的对象&lt;/p&gt;
&lt;p&gt;模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的API&lt;/p&gt;
&lt;p&gt;基于函数的模块并不是一个能被静态识别的模式，可以在运行时修改一个模块的API，ES6模块API是静态的，编辑器可以在编译器检查对导入模块的API成员的引用是否真实存在，而不会等到运行期再动态解析&lt;/p&gt;
&lt;p&gt;ES6模块没有行内格式，必须被定义在独立的文件中，模块中的内容会被当做好像包含在作用域闭包中一样来处理&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/6.%E9%99%84%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/6.%E9%99%84%E5%BD%95/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：词法作用域在代码定义时确定，关注函数声明位置；动态作用域在运行时确定，关注函数调用位置。ES6前可用try/catch模拟let的块作用域。箭头函数通过词法作用域绑定this，替代普通函数的this绑定规则，其效果类似于使用self变量或bind方法，解决了this指向问题。三种方式都能确保this正确指向外层对象（示例中的obj），但箭头函数提供了更简洁的语法实现。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ES6之前可以用catch实现let的效果&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;undefined&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;箭头函数放弃了普通this绑定的规则，取而代之的是用当前的词法作用域覆盖了this本来的值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coolFn&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(()=&amp;gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相当于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coolFn&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;timer&lt;/span&gt;()=&amp;gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相当于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coolFn&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;timer&lt;/span&gt;()=&amp;gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }.&lt;span style=&#34;color:#a6e22e&#34;&gt;bind&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;),&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/1.-%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/1.-%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/</guid>
      <description>&lt;h3 id=&#34;一分块的程序与异步机制&#34;&gt;一、分块的程序与异步机制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;分块程序的本质&lt;/strong&gt;：
将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console.log 的异步特性&lt;/strong&gt;：
部分浏览器的&lt;code&gt;console.log&lt;/code&gt;并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二事件循环&#34;&gt;二、事件循环&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;核心机制&lt;/strong&gt;：
事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个&lt;strong&gt;tick&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;若队列中有等待事件（即回调函数），则从队列中取出一个执行；&lt;/li&gt;
&lt;li&gt;无事件时，循环等待新事件加入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setTimeout 的作用&lt;/strong&gt;：
并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三并行执行&#34;&gt;三、并行执行&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;异步与并行的区别&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）；&lt;/li&gt;
&lt;li&gt;并行：关注 “同时发生”（多个操作在物理上同时进行）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程与线程&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存；&lt;/li&gt;
&lt;li&gt;JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS 的单线程特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;函数代码具有&lt;strong&gt;原子性&lt;/strong&gt;（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）；&lt;/li&gt;
&lt;li&gt;若函数执行顺序不确定，可能导致&lt;strong&gt;竞态条件&lt;/strong&gt;（因共享状态的修改顺序不可控引发的逻辑错误）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四并发&#34;&gt;四、并发&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：
两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JS 的并发形式&lt;/strong&gt;：
单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发交互的协调方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;门（Gate）：等待多个条件都满足后再执行下一步。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;baz&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 需a和b都准备好才调用baz()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门闩（Latch）：“只有第一名取胜”，仅首次满足条件时执行。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 仅a未被赋值时执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;baz&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发协作：将长期运行的进程拆分为多步 / 多批任务，允许其他并发进程插入事件循环交替运行。例如：处理长列表时，用&lt;code&gt;setTimeout(..., 0)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/2.-%E5%9B%9E%E8%B0%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/2.-%E5%9B%9E%E8%B0%83/</guid>
      <description>&lt;h3 id=&#34;一回调函数的本质&#34;&gt;一、回调函数的本质&lt;/h3&gt;
&lt;p&gt;回调函数的核心作用是&lt;strong&gt;包裹或封装程序的延续逻辑&lt;/strong&gt;—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。&lt;/p&gt;
&lt;h3 id=&#34;二回调地狱callback-hell的成因&#34;&gt;二、回调地狱（Callback Hell）的成因&lt;/h3&gt;
&lt;p&gt;回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;思维与代码的不匹配&lt;/strong&gt;：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制反转导致的信任问题&lt;/strong&gt;：
回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;无法确保回调被调用的次数（可能被多次调用或不调用）；&lt;/li&gt;
&lt;li&gt;无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）；&lt;/li&gt;
&lt;li&gt;无法确保回调的参数符合预期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三回调模式的优化设计&#34;&gt;三、回调模式的优化设计&lt;/h3&gt;
&lt;p&gt;为缓解回调地狱和信任问题，常见的回调模式设计：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;分离回调（Split Callbacks）&lt;/strong&gt;：
为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;错误优先回调（Error-First Callbacks，Node 风格）&lt;/strong&gt;：
回调函数的&lt;strong&gt;第一个参数固定为错误对象&lt;/strong&gt;，后续参数为成功结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若操作成功，错误参数为&lt;code&gt;null&lt;/code&gt;或&lt;code&gt;undefined&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若操作失败，错误参数为非空值（通常是&lt;code&gt;Error&lt;/code&gt;对象）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四回调调用的最佳实践永远异步执行&#34;&gt;四、回调调用的最佳实践：永远异步执行&lt;/h3&gt;
&lt;p&gt;即使回调逻辑可以同步完成，也应&lt;strong&gt;强制异步调用&lt;/strong&gt;（如通过&lt;code&gt;setTimeout&lt;/code&gt;或队列机制），确保回调行为的一致性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）；&lt;/li&gt;
&lt;li&gt;保证所有回调都遵循相同的异步逻辑，减少不可预测性。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/3.-promise/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/3.-promise/</guid>
      <description>&lt;h3 id=&#34;一什么是-promise&#34;&gt;一、什么是 Promise&lt;/h3&gt;
&lt;h4 id=&#34;1-未来值&#34;&gt;1. 未来值&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心特性&lt;/strong&gt;：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。&lt;/li&gt;
&lt;li&gt;状态与不可变性：
&lt;ul&gt;
&lt;li&gt;封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。&lt;/li&gt;
&lt;li&gt;一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;then 方法的双回调&lt;/strong&gt;：调用&lt;code&gt;then(onFulfilled, onRejected)&lt;/code&gt;时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-完成事件流程控制&#34;&gt;2. 完成事件（流程控制）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本质&lt;/strong&gt;：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。&lt;/li&gt;
&lt;li&gt;反控制反转：
&lt;ul&gt;
&lt;li&gt;传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过&lt;code&gt;then&lt;/code&gt;注册回调，等待 Promise 决议后触发，将控制返还给调用代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号特性&lt;/strong&gt;：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二具有-then-方法的鸭子类型&#34;&gt;二、具有 then 方法的鸭子类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;thenable 定义&lt;/strong&gt;：任何具有&lt;code&gt;then&lt;/code&gt;方法的对象或函数，被视为与 Promise 一致的 “thenable”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;鸭子类型&lt;/strong&gt;：通过值的形态（是否有&lt;code&gt;then&lt;/code&gt;方法）假定其类型，这是识别 Promise 的核心逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三promise-信任问题可靠性保障&#34;&gt;三、Promise 信任问题（可靠性保障）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;异步回调&lt;/strong&gt;：对 Promise 调用&lt;code&gt;then&lt;/code&gt;时，即使 Promise 已决议，回调也&lt;strong&gt;始终异步执行&lt;/strong&gt;（下一个事件循环 tick），确保行为一致。&lt;/li&gt;
&lt;li&gt;决议的唯一性：
&lt;ul&gt;
&lt;li&gt;Promise 只能被决议一次（首次调用&lt;code&gt;resolve&lt;/code&gt;或&lt;code&gt;reject&lt;/code&gt;生效，后续调用被忽略），因此&lt;code&gt;then&lt;/code&gt;注册的回调仅执行一次。&lt;/li&gt;
&lt;li&gt;若同一回调多次注册，会按注册次数执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;决议值的单一性：
&lt;ul&gt;
&lt;li&gt;至多有一个决议值（未显式决议时为&lt;code&gt;undefined&lt;/code&gt;），传给所有注册的回调。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;resolve&lt;/code&gt;/&lt;code&gt;reject&lt;/code&gt;时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常处理&lt;/strong&gt;：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。&lt;/li&gt;
&lt;li&gt;Promise.resolve 的作用：
&lt;ul&gt;
&lt;li&gt;传入非 Promise / 非 thenable 值：返回以该值完成的 Promise。&lt;/li&gt;
&lt;li&gt;传入真正的 Promise：直接返回该 Promise。&lt;/li&gt;
&lt;li&gt;传入 thenable：递归展开至非 thenable 的最终值，返回一个可信任的真正 Promise。&lt;/li&gt;
&lt;li&gt;作用：确保任何值通过&lt;code&gt;Promise.resolve&lt;/code&gt;过滤后都是可信任的 Promise。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四链式流promise-链式调用&#34;&gt;四、链式流（Promise 链式调用）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;链式基础：
&lt;ul&gt;
&lt;li&gt;每次调用&lt;code&gt;then&lt;/code&gt;都会创建并返回&lt;strong&gt;新的 Promise&lt;/strong&gt;，支持链式连接。&lt;/li&gt;
&lt;li&gt;完成回调的返回值会自动作为新 Promise 的完成值（若返回 Promise/thenable，会展开其决议值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;错误传播：
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;then&lt;/code&gt;仅传入完成回调，默认拒绝处理函数会 “重新抛出错误”，使错误沿链传播，直至被显式拒绝处理函数捕获。&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;then&lt;/code&gt;未传入有效完成回调，默认完成处理函数会将值传递给下一个步骤。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;catch 的本质&lt;/strong&gt;：&lt;code&gt;catch(onRejected)&lt;/code&gt;是&lt;code&gt;then(null, onRejected)&lt;/code&gt;的缩写，仅处理拒绝，自动传递完成值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;五promise-模式&#34;&gt;五、Promise 模式&lt;/h3&gt;
&lt;h4 id=&#34;1-promiseall门-模式&#34;&gt;1. Promise.all（“门” 模式）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：等待多个并行 / 并发任务&lt;strong&gt;全部完成&lt;/strong&gt;后再继续，顺序无关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;：接受一个由 Promise、thenable 或立即值组成的数组（元素会被&lt;code&gt;Promise.resolve&lt;/code&gt;规范化）。&lt;/li&gt;
&lt;li&gt;决议规则：
&lt;ul&gt;
&lt;li&gt;完成：所有成员 Promise 完成后，主 Promise 以 “成员完成值组成的数组” 完成（顺序与传入数组一致，与完成顺序无关）。&lt;/li&gt;
&lt;li&gt;拒绝：任一成员 Promise 拒绝时，主 Promise 立即以该拒绝理由拒绝（忽略其他结果）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊情况&lt;/strong&gt;：传入空数组时，主 Promise&lt;strong&gt;立即完成&lt;/strong&gt;（值为 []）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-promiserace门闩-模式&#34;&gt;2. Promise.race（“门闩” 模式）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：仅响应&lt;strong&gt;第一个决议&lt;/strong&gt;的 Promise（完成或拒绝），忽略其他。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;：接受一个由 Promise、thenable 或立即值组成的数组（元素会被&lt;code&gt;Promise.resolve&lt;/code&gt;规范化）。&lt;/li&gt;
&lt;li&gt;决议规则：
&lt;ul&gt;
&lt;li&gt;完成：第一个完成的成员 Promise 的完成值作为主 Promise 的完成值。&lt;/li&gt;
&lt;li&gt;拒绝：第一个拒绝的成员 Promise 的拒绝理由作为主 Promise 的拒绝理由。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊情况&lt;/strong&gt;：传入空数组时，主 Promise&lt;strong&gt;永远不会决议&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六promise-api-概述&#34;&gt;六、Promise API 概述&lt;/h3&gt;
&lt;h4 id=&#34;1-new-promise-构造器&#34;&gt;1. new Promise 构造器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;必须与new配合使用，参数为一个同步执行的回调函数，该回调接受两个参数（resolve和reject）：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;reject(reason)&lt;/code&gt;：直接拒绝 Promise，理由为&lt;code&gt;reason&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;resolve(value)：
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;value&lt;/code&gt;为非 Promise / 非 thenable：以&lt;code&gt;value&lt;/code&gt;完成 Promise。&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;value&lt;/code&gt;为 Promise/thenable：递归展开，采用其最终决议状态 / 值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-promiseresolve-和-promisereject静态方法&#34;&gt;2. Promise.resolve 和 Promise.reject（静态方法）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Promise.reject(reason)&lt;/strong&gt;：快捷创建已拒绝的 Promise，理由为&lt;code&gt;reason&lt;/code&gt;（不展开&lt;code&gt;reason&lt;/code&gt;，即使其为 thenable）。&lt;/li&gt;
&lt;li&gt;Promise.resolve(value)：
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;value&lt;/code&gt;为 Promise：直接返回该 Promise。&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;value&lt;/code&gt;为 thenable：展开至最终值，返回以该值决议的 Promise（完成或拒绝）。&lt;/li&gt;
&lt;li&gt;其他情况：返回以&lt;code&gt;value&lt;/code&gt;完成的 Promise。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-then-和-catch实例方法&#34;&gt;3. then 和 catch（实例方法）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;then(onFulfilled?, onRejected?)：
&lt;ul&gt;
&lt;li&gt;注册完成 / 拒绝回调，返回新 Promise。&lt;/li&gt;
&lt;li&gt;若回调为非函数：替换为默认回调（完成回调传递值，拒绝回调重新抛错）。&lt;/li&gt;
&lt;li&gt;回调返回值处理：
&lt;ul&gt;
&lt;li&gt;抛出异常：新 Promise 以该异常拒绝。&lt;/li&gt;
&lt;li&gt;返回非 Promise / 非 thenable：新 Promise 以该值完成。&lt;/li&gt;
&lt;li&gt;返回 Promise/thenable：新 Promise 采用其最终决议状态 / 值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;catch(onRejected)&lt;/strong&gt;：等价于&lt;code&gt;then(null, onRejected)&lt;/code&gt;，仅注册拒绝回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-promiseall-和-promiserace静态方法&#34;&gt;4. Promise.all 和 Promise.race（静态方法）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同 “Promise 模式” 中描述，核心为 “门” 和 “门闩” 模式，控制多 Promise 的并发协作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七promise-局限性&#34;&gt;七、Promise 局限性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;错误易被忽略：
&lt;ul&gt;
&lt;li&gt;若 Promise 链未设置错误处理函数，链中任何错误会一直传播，直至被捕获（可能导致隐性 bug）。&lt;/li&gt;
&lt;li&gt;链中无统一实体标识，无法从外部观察未处理的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单一决议值：
&lt;ul&gt;
&lt;li&gt;只能有一个完成值或拒绝理由，复杂场景需拆分多个 Promise。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无法中途取消：
&lt;ul&gt;
&lt;li&gt;一旦创建 Promise 并注册回调，若任务悬而未决，无法从外部终止其进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;轻微性能开销：
&lt;ul&gt;
&lt;li&gt;相比非 Promise 回调，因内建可靠性（如异步保证、状态管理），性能略低，但可忽略不计。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;补充说明修正与强调&#34;&gt;补充说明（修正与强调）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;“决议” 包含 “完成（fulfilled）” 和 “拒绝（rejected）” 两种状态，避免混淆为单一概念。&lt;/li&gt;
&lt;li&gt;Promise.race 传入空数组 “永远不决议” 是标准行为（因无竞争对象），需注意与 Promise.all 空数组的区别。&lt;/li&gt;
&lt;li&gt;所有回调的 “异步执行” 基于事件循环，确保宏观任务队列的顺序性，避免同步执行导致的时序混乱。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>&lt;h3 id=&#34;一生成器的基本概念与特性&#34;&gt;一、生成器的基本概念与特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义与控制方式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;生成器是一类特殊函数，声明方式为&lt;code&gt;function*&lt;/code&gt;（函数名前加&lt;code&gt;*&lt;/code&gt;），可暂停、恢复执行，不一定需要完成。&lt;/li&gt;
&lt;li&gt;通过迭代器控制生成器：调用生成器函数（如&lt;code&gt;*foo()&lt;/code&gt;）会返回一个迭代器对象（如&lt;code&gt;it&lt;/code&gt;），通过&lt;code&gt;it.next()&lt;/code&gt;启动或恢复生成器执行，直至下一个&lt;code&gt;yield&lt;/code&gt;或结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;next()&lt;/code&gt;与&lt;code&gt;yield&lt;/code&gt;的交互&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;next()&lt;/code&gt;返回一个对象&lt;code&gt;{ value, done }&lt;/code&gt;：&lt;code&gt;value&lt;/code&gt;是&lt;code&gt;yield&lt;/code&gt;产出的值，&lt;code&gt;done&lt;/code&gt;为布尔值（&lt;code&gt;true&lt;/code&gt;表示生成器执行完毕）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yield&lt;/code&gt;作为表达式可双向传递消息：&lt;code&gt;yield&lt;/code&gt;向外发送值，&lt;code&gt;next()&lt;/code&gt;可向暂停的&lt;code&gt;yield&lt;/code&gt;传入值（第一个&lt;code&gt;next()&lt;/code&gt;的参数会被忽略，因此时无暂停的&lt;code&gt;yield&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成器实例与并发&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二生成器产生值生产者与迭代器&#34;&gt;二、生成器产生值：生产者与迭代器&lt;/h3&gt;
&lt;h4 id=&#34;1-迭代器接口&#34;&gt;1. 迭代器接口&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：定义从生产者逐步获取一系列值的标准接口，核心是&lt;code&gt;next()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;next()&lt;/code&gt;返回值&lt;/strong&gt;：&lt;code&gt;{ done: boolean, value: any }&lt;/code&gt;，&lt;code&gt;done&lt;/code&gt;标识迭代是否结束，&lt;code&gt;value&lt;/code&gt;为当前迭代值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-forof循环&#34;&gt;2. &lt;code&gt;for..of&lt;/code&gt;循环&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;自动迭代标准迭代器：每次循环调用&lt;code&gt;next()&lt;/code&gt;，不传入参数，遇&lt;code&gt;done: true&lt;/code&gt;自动停止。&lt;/li&gt;
&lt;li&gt;支持内建可迭代对象：如数组（&lt;code&gt;array&lt;/code&gt;）等内建数据结构默认实现迭代器，可直接用于&lt;code&gt;for..of&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-iterable可迭代对象&#34;&gt;3. Iterable（可迭代对象）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：包含迭代器的对象，需实现&lt;code&gt;Symbol.iterator&lt;/code&gt;方法（调用时返回一个新迭代器）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;的依赖&lt;/strong&gt;：&lt;code&gt;for..of&lt;/code&gt;循环期望操作可迭代对象，通过调用其&lt;code&gt;Symbol.iterator&lt;/code&gt;获取迭代器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-生成器迭代器的特性&#34;&gt;4. 生成器迭代器的特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常终止&lt;/strong&gt;：&lt;code&gt;for..of&lt;/code&gt;因&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;或未捕获异常终止时，会向迭代器发送停止信号；可手动调用&lt;code&gt;it.return(value)&lt;/code&gt;终止生成器，返回&lt;code&gt;{ value: 传入值, done: true }&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三异步迭代生成器&#34;&gt;三、异步迭代生成器&lt;/h3&gt;
&lt;p&gt;生成器可简化异步流程，将异步操作抽象为同步形式的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;ajax&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://...&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 向生成器抛错
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 向生成器传递异步结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;yield&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 暂停等待异步结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 捕获异步错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 启动生成器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;上述代码中，&lt;code&gt;yield&lt;/code&gt;等待异步操作&lt;code&gt;foo&lt;/code&gt;完成，通过&lt;code&gt;it.next(data)&lt;/code&gt;或&lt;code&gt;it.throw(err)&lt;/code&gt;恢复执行，实现 “同步写法 + 异步执行”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四生成器与-promise-的结合&#34;&gt;四、生成器与 Promise 的结合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。&lt;/li&gt;
&lt;li&gt;实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器：
&lt;ul&gt;
&lt;li&gt;Promise 完成时，调用&lt;code&gt;it.next(结果值)&lt;/code&gt;恢复生成器；&lt;/li&gt;
&lt;li&gt;Promise 拒绝时，调用&lt;code&gt;it.throw(错误)&lt;/code&gt;向生成器抛错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五生成器委托yield&#34;&gt;五、生成器委托（&lt;code&gt;yield*&lt;/code&gt;）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;code&gt;yield* 迭代对象&lt;/code&gt;（如&lt;code&gt;yield* foo()&lt;/code&gt;，&lt;code&gt;foo&lt;/code&gt;为生成器或其他可迭代对象）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：支持双向消息与错误传递（目标迭代器的&lt;code&gt;yield&lt;/code&gt;与当前生成器的&lt;code&gt;next&lt;/code&gt;/&lt;code&gt;throw&lt;/code&gt;可交互）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六形实转换程序thunk&#34;&gt;六、形实转换程序（Thunk）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;补充说明&#34;&gt;补充说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;生成器的&lt;code&gt;yield&lt;/code&gt;数量与&lt;code&gt;next()&lt;/code&gt;调用次数关系：&lt;code&gt;next()&lt;/code&gt;调用次数比&lt;code&gt;yield&lt;/code&gt;语句多 1（最后一次&lt;code&gt;next()&lt;/code&gt;用于获取&lt;code&gt;done: true&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for..of&lt;/code&gt;与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现&lt;code&gt;Symbol.iterator&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/5.-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/5.-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</guid>
      <description>&lt;h3 id=&#34;一web-worker-基础&#34;&gt;一、Web Worker 基础&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义与作用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。&lt;/li&gt;
&lt;li&gt;每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建与类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;专用 Worker（Dedicated Worker）&lt;/strong&gt;：通过 &lt;code&gt;new Worker(&#39;script.js&#39;)&lt;/code&gt; 创建，与主程序是一对一关系，仅能与创建它的程序通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 主程序中创建专用 Worker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;w1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Worker&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;worker.js&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二worker-通信机制&#34;&gt;二、Worker 通信机制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消息传递&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不共享作用域 / 资源，通过 &lt;strong&gt;&lt;code&gt;message&lt;/code&gt; 事件&lt;/strong&gt;双向通信，数据传递基于结构化克隆或所有权转移。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主程序与 Worker 内部均通过postMessage(data)发送消息，通过onmessage监听消息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 主程序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;postMessage&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 发送消息到 Worker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;w1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onmessage&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;收到 Worker 消息：&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// worker.js 内部
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onmessage&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;收到主程序消息：&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;postMessage&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hi&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 发送消息到主程序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终止 Worker&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主程序中调用 &lt;code&gt;w1.terminate()&lt;/code&gt; 可立即终止 Worker（无清理机会）；&lt;/li&gt;
&lt;li&gt;Worker 内部可调用 &lt;code&gt;self.close()&lt;/code&gt; 主动终止自身。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三worker-运行环境&#34;&gt;三、Worker 运行环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;限制与可用资源&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;不可访问 DOM、主程序全局变量，但可使用 &lt;code&gt;navigator&lt;/code&gt;、&lt;code&gt;location&lt;/code&gt;、&lt;code&gt;JSON&lt;/code&gt;、&lt;code&gt;setTimeout&lt;/code&gt; 等，支持网络请求（如 &lt;code&gt;fetch&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;可通过 &lt;code&gt;importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;)&lt;/code&gt; 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型应用场景&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四数据传递方式&#34;&gt;四、数据传递方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结构化克隆&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/1.-%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/1.-%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;一内置类型概述&#34;&gt;一、内置类型概述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：类型是值的内部特征，决定值的行为，以区分于其他值。&lt;/li&gt;
&lt;li&gt;分类：
&lt;ul&gt;
&lt;li&gt;基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。&lt;/li&gt;
&lt;li&gt;对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二typeof-运算符&#34;&gt;二、typeof 运算符&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。&lt;/li&gt;
&lt;li&gt;特殊情况：
&lt;ul&gt;
&lt;li&gt;null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理）&lt;/li&gt;
&lt;li&gt;检测 null 值类型的复合条件：&lt;code&gt;!a &amp;amp;&amp;amp; typeof a === &#39;object&#39;&lt;/code&gt;（因 null 是假值，且是唯一用 typeof 检测返回 &amp;lsquo;object&amp;rsquo; 的基本类型值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三对象子类型&#34;&gt;三、对象子类型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;函数（function）：
&lt;ul&gt;
&lt;li&gt;是 object 的子类型，属于可调用对象。&lt;/li&gt;
&lt;li&gt;具有内部属性 [[Call]]，使其可被调用。&lt;/li&gt;
&lt;li&gt;可拥有属性，如 length 属性表示其声明的参数个数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeof function&lt;/code&gt;返回&lt;code&gt;&amp;quot;function&amp;quot;&lt;/code&gt;，是历史遗留的特殊处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组：
&lt;ul&gt;
&lt;li&gt;是 object 的子类型。&lt;/li&gt;
&lt;li&gt;元素按数字顺序索引，length 属性表示元素个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四值和类型的特性&#34;&gt;四、值和类型的特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;变量与类型的关系&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;JS 中变量无类型，只有值有类型。&lt;/li&gt;
&lt;li&gt;变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。&lt;/li&gt;
&lt;li&gt;对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undefined 与 undeclared 的区别&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;undefined：变量已在作用域中声明但未赋值。&lt;/li&gt;
&lt;li&gt;undeclared：变量未在作用域中声明过。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;typeof 的安全防范机制&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。&lt;/li&gt;
&lt;li&gt;应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他安全检查方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。&lt;/li&gt;
&lt;li&gt;依赖注入设计模式：将依赖通过参数显式传递到函数中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/2.-%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/2.-%E5%80%BC/</guid>
      <description>&lt;h3 id=&#34;一数组&#34;&gt;一、数组&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;delete&lt;/code&gt;运算符删除单元后，位置变为空白单元，数组&lt;code&gt;length&lt;/code&gt;属性不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稀疏数组&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;指含有空白 / 空缺单元的数组，空白单元值为&lt;code&gt;undefined&lt;/code&gt;，但与显式赋值为&lt;code&gt;undefined&lt;/code&gt;的单元有区别（如&lt;code&gt;[,,]&lt;/code&gt;与&lt;code&gt;[undefined, undefined]&lt;/code&gt;行为不同）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引与属性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在&lt;code&gt;length&lt;/code&gt;内，&lt;code&gt;length&lt;/code&gt;只计算数字索引的最大整数 + 1）。&lt;/li&gt;
&lt;li&gt;若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类数组转换&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类数组特征&lt;/strong&gt;：有&lt;code&gt;length&lt;/code&gt;和数字索引，但无数组方法（如&lt;code&gt;arguments&lt;/code&gt;、DOM 集合&lt;code&gt;NodeList&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;可转换为真正的数组，常用方法：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Array.prototype.slice.call(类数组)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ES6 的&lt;code&gt;Array.from(类数组)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;扩展运算符（需类数组为可迭代对象）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二字符串&#34;&gt;二、字符串&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;与数组的区别&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;是类数组（有&lt;code&gt;length&lt;/code&gt;、&lt;code&gt;indexOf()&lt;/code&gt;、&lt;code&gt;concat()&lt;/code&gt;等），但并非字符数组。&lt;/li&gt;
&lt;li&gt;字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组方法的借用&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;可借用数组的非变更方法（如&lt;code&gt;Array.prototype.indexOf.call(str, &#39;a&#39;)&lt;/code&gt;）处理字符串。&lt;/li&gt;
&lt;li&gt;不可借用数组的变更方法（因字符串不可变），需先通过&lt;code&gt;split(&#39;&#39;)&lt;/code&gt;转为数组，处理后再用&lt;code&gt;join(&#39;&#39;)&lt;/code&gt;转回字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三数字&#34;&gt;三、数字&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;类型与格式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;JS 只有一种数值类型&lt;code&gt;number&lt;/code&gt;（双精度浮点数），包含整数（如&lt;code&gt;42.0&lt;/code&gt;）和带小数的十进制数。&lt;/li&gt;
&lt;li&gt;字面量表示：
&lt;ul&gt;
&lt;li&gt;十进制：可省略小数点前的 0（&lt;code&gt;.42&lt;/code&gt;）或后多余的 0（&lt;code&gt;42.&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;特殊格式：指数形式（&lt;code&gt;1e3&lt;/code&gt;）、二进制（&lt;code&gt;0b1010&lt;/code&gt;）、八进制（&lt;code&gt;0o12&lt;/code&gt;）、十六进制（&lt;code&gt;0xa&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;显示规则&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同&lt;code&gt;toExponential()&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Number 对象方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;toFixed(n)&lt;/code&gt;：指定小数部分显示位数，不足用 0 补齐（返回字符串）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toPrecision(n)&lt;/code&gt;：指定有效数位的显示位数。&lt;/li&gt;
&lt;li&gt;注意：数字字面量调用方法时，需避免&lt;code&gt;.&lt;/code&gt;被误判为数字一部分（如&lt;code&gt;42..toFixed(2)&lt;/code&gt;或&lt;code&gt;42 .toFixed(2)&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精度与范围&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;精度问题：&lt;code&gt;0.1 + 0.2 !== 0.3&lt;/code&gt;（浮点数二进制存储导致精度丢失），可通过&lt;code&gt;Math.abs(n1 - n2) &amp;lt; Number.EPSILON&lt;/code&gt;（机器精度）判断近似相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大浮点数：&lt;code&gt;Number.MAX_VALUE&lt;/code&gt;；最小浮点数（接近 0 的正数）：&lt;code&gt;Number.MIN_VALUE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;安全整数范围：&lt;code&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt;（-2^53 + 1）到&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;（2^53 - 1），超出需用字符串处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BigInt&lt;/code&gt;解决大整数&lt;/strong&gt;：用&lt;code&gt;n&lt;/code&gt;后缀声明，支持超出安全范围的整数运算&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9007199254740993&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 9007199254740994n（精确计算）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检测方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number.isInteger(num)&lt;/code&gt;：检测是否为整数（ES6+）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.isSafeInteger(num)&lt;/code&gt;：检测是否为安全整数（ES6+）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;四特殊数值&#34;&gt;四、特殊数值&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;null 与 undefined&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;均为唯一值，名称即类型也即值。&lt;/li&gt;
&lt;li&gt;区别：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;：表示 “空值”（曾赋值，当前无值），不是标识符，不能作为变量赋值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;：表示 “未赋值”，是内置标识符（不建议手动赋值，严格模式下可能报错）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void&lt;/code&gt;运算符：表达式&lt;code&gt;void XXX&lt;/code&gt;返回&lt;code&gt;undefined&lt;/code&gt;，不改变表达式副作用（惯例用&lt;code&gt;void 0&lt;/code&gt;获取&lt;code&gt;undefined&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NaN（Not a Number）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;属于&lt;code&gt;number&lt;/code&gt;类型，代表数学运算失败的警戒值。&lt;/li&gt;
&lt;li&gt;特性：与自身不相等（&lt;code&gt;NaN !== NaN&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;检测：&lt;code&gt;isNaN()&lt;/code&gt;不可靠（误判非数字类型），&lt;code&gt;Number.isNaN()&lt;/code&gt;更准确（仅检测&lt;code&gt;NaN&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无穷数（Infinity）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;产生：正数除以 0 得&lt;code&gt;Infinity&lt;/code&gt;，负数除以 0 得&lt;code&gt;-Infinity&lt;/code&gt;；运算溢出时也会返回。&lt;/li&gt;
&lt;li&gt;特性：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Infinity / Infinity&lt;/code&gt;结果为&lt;code&gt;NaN&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有穷正数 /&lt;code&gt;Infinity&lt;/code&gt;为 0，有穷负数 /&lt;code&gt;Infinity&lt;/code&gt;为&lt;code&gt;-0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;溢出为无穷数后，无法再得到有穷数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负零（-0）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;产生：某些数学运算（如&lt;code&gt;-1 / Infinity&lt;/code&gt;）的结果，加减法不会得到&lt;code&gt;-0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;特性：
&lt;ul&gt;
&lt;li&gt;字符串化返回&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;，但从字符串转回数字时保留符号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-0 === 0&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;，ES6 的&lt;code&gt;Object.is(-0, 0)&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;（可准确区分）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;五值和引用&#34;&gt;五、值和引用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;引用本质&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;JS 中引用指向值，而非变量；多个引用可指向同一值，但引用间无相互指向关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;赋值 / 传递规则&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;由值的类型决定，与语法无关：
&lt;ul&gt;
&lt;li&gt;基本类型（&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;symbol&lt;/code&gt;）：通过&lt;strong&gt;值复制&lt;/strong&gt;（赋值 / 传递的是值的副本）。&lt;/li&gt;
&lt;li&gt;复合值（对象、函数、数组等）：通过&lt;strong&gt;引用复制&lt;/strong&gt;（赋值 / 传递的是指向值的引用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;引用无法修改另一个引用的指向（如&lt;code&gt;a = b&lt;/code&gt;后修改&lt;code&gt;a&lt;/code&gt;不影响&lt;code&gt;b&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;复合值的复制：需创建复本（如&lt;code&gt;a.slice()&lt;/code&gt;返回数组浅复本），避免引用共享。&lt;/li&gt;
&lt;li&gt;基本类型的修改：若需在函数内修改基本类型，需封装到复合值中（通过引用传递）。&lt;/li&gt;
&lt;li&gt;基本类型不可变：其值无法被修改（如字符串的方法均返回新值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/3.-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/3.-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h3 id=&#34;一内部属性-class&#34;&gt;一、内部属性 [[Class]]&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：
内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。&lt;/li&gt;
&lt;li&gt;属性特征：
&lt;ul&gt;
&lt;li&gt;所有&lt;code&gt;typeof&lt;/code&gt;返回值为&lt;code&gt;object&lt;/code&gt;的对象都包含内部属性&lt;code&gt;[[Class]]&lt;/code&gt;，该属性无法直接访问。&lt;/li&gt;
&lt;li&gt;通常通过&lt;code&gt;Object.prototype.toString()&lt;/code&gt;方法查看&lt;code&gt;[[Class]]&lt;/code&gt;的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对应关系：
&lt;ul&gt;
&lt;li&gt;多数情况下，对象的&lt;code&gt;[[Class]]&lt;/code&gt;属性值与创建该对象的内建原生构造函数相对应。&lt;/li&gt;
&lt;li&gt;特殊情况：虽然不存在&lt;code&gt;Null()&lt;/code&gt;和&lt;code&gt;undefined()&lt;/code&gt;原生构造函数，但&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt;的&lt;code&gt;[[Class]]&lt;/code&gt;属性值分别为&lt;code&gt;&#39;Null&#39;&lt;/code&gt;和&lt;code&gt;&#39;Undefined&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二封装对象包装&#34;&gt;二、封装对象包装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动包装机制&lt;/strong&gt;：
基本类型值（如&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。&lt;/li&gt;
&lt;li&gt;手动封装与拆封：
&lt;ul&gt;
&lt;li&gt;手动封装：使用&lt;code&gt;Object()&lt;/code&gt;函数（不带&lt;code&gt;new&lt;/code&gt;关键字）可将基本类型值封装为对象。&lt;/li&gt;
&lt;li&gt;拆封：通过&lt;code&gt;valueOf()&lt;/code&gt;方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用建议&lt;/strong&gt;：除非必要，应避免使用构造函数创建封装对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三原生函数作为构造函数&#34;&gt;三、原生函数作为构造函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array()&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带&lt;code&gt;new&lt;/code&gt;关键字时会被自动补全（等效于&lt;code&gt;new Array()&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代方案&lt;/strong&gt;：ES6 的&lt;code&gt;Array.of()&lt;/code&gt;（无歧义，始终将参数作为元素）&lt;/li&gt;
&lt;li&gt;稀疏数组：包含至少一个空单元的数组，可通过以下方式创建：
&lt;ul&gt;
&lt;li&gt;设置&lt;code&gt;length&lt;/code&gt;属性值超过实际单元数；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;delete&lt;/code&gt;删除数组单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可通过&lt;code&gt;Array.apply(null, {length: 3})&lt;/code&gt;创建包含&lt;code&gt;undefined&lt;/code&gt;单元（非空单元）的数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不建议使用的构造函数&lt;/strong&gt;：
除非特殊需求，尽量避免使用&lt;code&gt;Object()&lt;/code&gt;、&lt;code&gt;Function()&lt;/code&gt;、&lt;code&gt;RegExp()&lt;/code&gt;作为构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Date()&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;必须使用&lt;code&gt;new Date()&lt;/code&gt;创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。&lt;/li&gt;
&lt;li&gt;时间戳获取：&lt;code&gt;getTime()&lt;/code&gt;方法或&lt;code&gt;Date.now()&lt;/code&gt;（ES5+）可获取 Unix 时间戳。&lt;/li&gt;
&lt;li&gt;特殊情况：不带&lt;code&gt;new&lt;/code&gt;关键字调用&lt;code&gt;Date()&lt;/code&gt;时，返回当前日期的字符串值（格式无统一规范）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Error()&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;带或不带&lt;code&gt;new&lt;/code&gt;关键字均可使用。&lt;/li&gt;
&lt;li&gt;作用：创建错误对象以获取当前运行栈上下文（含函数调用栈、错误行号等，便于调试），通常与&lt;code&gt;throw&lt;/code&gt;配合使用。&lt;/li&gt;
&lt;li&gt;特性：错误对象至少包含&lt;code&gt;message&lt;/code&gt;属性；除&lt;code&gt;Error&lt;/code&gt;外，还有针对特定错误类型的原生构造函数（如&lt;code&gt;TypeError&lt;/code&gt;、&lt;code&gt;RangeError&lt;/code&gt;），这些构造函数在程序异常时自动调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;Symbol（符号）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;特性：特殊的基本类型值，具有唯一性，用作对象属性名时不易重名。&lt;/li&gt;
&lt;li&gt;访问性：可作为属性名，但在代码或控制台中难以直接查看和访问其值。&lt;/li&gt;
&lt;li&gt;预定义符号：ES6 中以&lt;code&gt;Symbol&lt;/code&gt;静态属性形式存在（如&lt;code&gt;Symbol.iterator&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;使用规则：&lt;code&gt;Symbol()&lt;/code&gt;不能带&lt;code&gt;new&lt;/code&gt;关键字（否则报错）；符号是基本类型，非对象，不可枚举（不被&lt;code&gt;for...in&lt;/code&gt;遍历），主要用于私有或特殊属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;四原生原型&#34;&gt;四、原生原型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原型特征&lt;/strong&gt;：
原生构造函数（如&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;、&lt;code&gt;RegExp&lt;/code&gt;等）都有自己的&lt;code&gt;prototype&lt;/code&gt;对象，这些对象包含对应子类型的特有行为特征。&lt;/li&gt;
&lt;li&gt;实用场景：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Function.prototype&lt;/code&gt;是空函数，&lt;code&gt;RegExp.prototype&lt;/code&gt;是空正则表达式，&lt;code&gt;Array.prototype&lt;/code&gt;是空数组，适合作为未赋值变量的默认值。&lt;/li&gt;
&lt;li&gt;优势：&lt;code&gt;prototype&lt;/code&gt;对象已预先创建且仅创建一次，性能更优。&lt;/li&gt;
&lt;li&gt;注意：若默认值后续会被修改，则不建议使用原生原型作为默认值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/4.-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/4.-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;h3 id=&#34;一值类型转换的基本概念&#34;&gt;一、值类型转换的基本概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定义与区分：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显式类型转换&lt;/strong&gt;：主动将值从一种类型转换为另一种（如&lt;code&gt;String(123)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式强制类型转换&lt;/strong&gt;：操作中自动发生的类型转换（如&lt;code&gt;1 + &amp;quot;2&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;特性：JS 强制类型转换始终返回&lt;strong&gt;标量基本类型值&lt;/strong&gt;，对象封装（如&lt;code&gt;new Number(1)&lt;/code&gt;）不算严格意义上的强制转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与其他语言的差异：
&lt;ul&gt;
&lt;li&gt;静态类型语言的 “类型转换” 发生在编译阶段；&lt;/li&gt;
&lt;li&gt;动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;二抽象值操作内部使用的转换规则&#34;&gt;二、抽象值操作（内部使用的转换规则）&lt;/h2&gt;
&lt;p&gt;抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括&lt;code&gt;ToString&lt;/code&gt;、&lt;code&gt;ToNumber&lt;/code&gt;、&lt;code&gt;ToBoolean&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;21-tostring非字符串字符串&#34;&gt;2.1 ToString（非字符串→字符串）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本类型转换规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; → &lt;code&gt;&amp;quot;null&amp;quot;&lt;/code&gt;；&lt;code&gt;undefined&lt;/code&gt; → &lt;code&gt;&amp;quot;undefined&amp;quot;&lt;/code&gt;；&lt;code&gt;true&lt;/code&gt; → &lt;code&gt;&amp;quot;true&amp;quot;&lt;/code&gt;；&lt;code&gt;false&lt;/code&gt; → &lt;code&gt;&amp;quot;false&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;数字：常规数字直接转换（如&lt;code&gt;123→&amp;quot;123&amp;quot;&lt;/code&gt;），极小 / 极大数字用指数形式（如&lt;code&gt;1e-20&lt;/code&gt;、&lt;code&gt;1e+20&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象 / 数组转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通对象：默认返回内部属性&lt;code&gt;[[Class]]&lt;/code&gt;值（如&lt;code&gt;&amp;quot;[object Object]&amp;quot;&lt;/code&gt;）；若自定义&lt;code&gt;toString()&lt;/code&gt;方法，则调用该方法并使用其返回值。&lt;/li&gt;
&lt;li&gt;数组：&lt;code&gt;toString()&lt;/code&gt;将所有元素字符串化后用&lt;code&gt;,&lt;/code&gt;连接（如&lt;code&gt;[1, 2, 3].toString() → &amp;quot;1,2,3&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON.stringify () 的特殊处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用：将 JSON 对象序列化为字符串，遵循&lt;code&gt;ToString&lt;/code&gt;规则但结果必为字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ &lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt; 、&lt;code&gt;symbol&lt;/code&gt;、循环引用对象）的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象中遇到非安全值：自动忽略。&lt;/li&gt;
&lt;li&gt;数组中遇到非安全值：返回&lt;code&gt;null&lt;/code&gt;（保持数组长度）。&lt;/li&gt;
&lt;li&gt;循环引用对象：直接报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;toJSON()&lt;/code&gt;方法：若对象定义了&lt;code&gt;toJSON()&lt;/code&gt;，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：&lt;code&gt;toJSON()&lt;/code&gt;应返回安全值，而非字符串）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;replacer&lt;/code&gt;（数组 / 函数）：数组时仅序列化数组中指定的属性；函数时对每个属性调用（返回&lt;code&gt;undefined&lt;/code&gt;则忽略该属性，否则返回处理后的值）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space&lt;/code&gt;（数字 / 字符串）：指定缩进格式，数字时为每级缩进字符数，字符串时取前 10 个字符作为缩进。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-tonumber非数字数字&#34;&gt;2.2 ToNumber（非数字→数字）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基本类型转换规则：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt; → &lt;code&gt;1&lt;/code&gt;；&lt;code&gt;false&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;；&lt;code&gt;undefined&lt;/code&gt; → &lt;code&gt;NaN&lt;/code&gt;；&lt;code&gt;null&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;字符串：遵循数字常量语法，转换失败返回&lt;code&gt;NaN&lt;/code&gt;（注意：不处理八进制前缀&lt;code&gt;0&lt;/code&gt;，如&lt;code&gt;&amp;quot;012&amp;quot;&lt;/code&gt;→&lt;code&gt;12&lt;/code&gt;而非&lt;code&gt;10&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象 / 数组转换：
&lt;ul&gt;
&lt;li&gt;先通过&lt;code&gt;ToPrimitive&lt;/code&gt;转换为基本类型：优先调用&lt;code&gt;valueOf()&lt;/code&gt;（若返回基本类型则使用）；否则调用&lt;code&gt;toString()&lt;/code&gt;（若返回基本类型则使用）。&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;valueOf()&lt;/code&gt;和&lt;code&gt;toString()&lt;/code&gt;均不返回基本类型，抛出&lt;code&gt;TypeError&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊对象&lt;/strong&gt;：&lt;code&gt;Object.create(null)&lt;/code&gt;创建的对象无&lt;code&gt;valueOf()&lt;/code&gt;和&lt;code&gt;toString()&lt;/code&gt;，无法强制转换为数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-toboolean非布尔值布尔值&#34;&gt;2.3 ToBoolean（非布尔值→布尔值）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;假值（转换为 false 的值）&lt;/strong&gt;：&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;、&lt;code&gt;+0&lt;/code&gt;、&lt;code&gt;-0&lt;/code&gt;、&lt;code&gt;NaN&lt;/code&gt;、&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;（空字符串）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真值&lt;/strong&gt;：假值列表以外的所有值（如非空字符串、非 0 数字、对象、数组等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假值对象&lt;/strong&gt;：浏览器环境中特殊的 “外来值”，外观类似普通对象，但强制转换为布尔值时为&lt;code&gt;false&lt;/code&gt;（如&lt;code&gt;document.all&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三显式强制类型转换主动触发的转换&#34;&gt;三、显式强制类型转换（主动触发的转换）&lt;/h2&gt;
&lt;h3 id=&#34;31-字符串和数字之间的显式转换&#34;&gt;3.1 字符串和数字之间的显式转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过内建函数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String(value)&lt;/code&gt;：遵循&lt;code&gt;ToString&lt;/code&gt;规则，返回字符串基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number(value)&lt;/code&gt;：遵循&lt;code&gt;ToNumber&lt;/code&gt;规则，返回数字基本类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;toString()&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;基本类型调用&lt;code&gt;toString()&lt;/code&gt;时，JS 引擎会自动创建封装对象，再调用其&lt;code&gt;toString()&lt;/code&gt;（如&lt;code&gt;123.toString() → &amp;quot;123&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过一元运算符：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+value&lt;/code&gt;：显式将&lt;code&gt;value&lt;/code&gt;转换为数字（如&lt;code&gt;+&amp;quot;123&amp;quot; → 123&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-value&lt;/code&gt;：转换为数字并反转符号位（如&lt;code&gt;-&amp;quot;123&amp;quot; → -123&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;注意：避免与其他运算符混用（如&lt;code&gt;a + + b&lt;/code&gt;易读性差）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日期转时间戳：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+new Date()&lt;/code&gt;：返回 Unix 时间戳（毫秒），但更推荐&lt;code&gt;Date.now()&lt;/code&gt;（当前时间戳）或&lt;code&gt;new Date().getTime()&lt;/code&gt;（指定时间戳）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字位运算符与数字处理：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~x&lt;/code&gt;：等同于&lt;code&gt;-(x + 1)&lt;/code&gt;，可配合&lt;code&gt;indexOf()&lt;/code&gt;判断是否存在（&lt;code&gt;indexOf(-1)&lt;/code&gt;时&lt;code&gt;~-1 → 0&lt;/code&gt;为假值，其他情况为真值）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~~x&lt;/code&gt;或&lt;code&gt;x | 0&lt;/code&gt;：通过&lt;code&gt;ToInt32&lt;/code&gt;将数字截为 32 位整数（如&lt;code&gt;~~3.14 → 3&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-显式解析数字字符串&#34;&gt;3.2 显式解析数字字符串&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;解析与转换的区别：
&lt;ul&gt;
&lt;li&gt;解析（如&lt;code&gt;parseInt()&lt;/code&gt;、&lt;code&gt;parseFloat()&lt;/code&gt;）：从左到右处理，遇到非数字字符停止（如&lt;code&gt;parseInt(&amp;quot;12a3&amp;quot;) → 12&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;转换（如&lt;code&gt;Number()&lt;/code&gt;）：字符串必须完全为数字格式，否则返回&lt;code&gt;NaN&lt;/code&gt;（如&lt;code&gt;Number(&amp;quot;12a3&amp;quot;) → NaN&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parseFloat()&lt;/strong&gt;：解析字符串中的浮点数（如&lt;code&gt;parseFloat(&amp;quot;3.14abc&amp;quot;) → 3.14&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;parseInt()：
&lt;ul&gt;
&lt;li&gt;仅处理字符串，非字符串会先转为字符串（如&lt;code&gt;parseInt(12.3) → 12&lt;/code&gt;，因&lt;code&gt;12.3 → &amp;quot;12.3&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;第二个参数（基数）：指定转换的进制（10 进制最常用）。ES5 及之前默认基数可能因前缀变化（如&lt;code&gt;0&lt;/code&gt;开头视为八进制），ES6 后默认 10 进制，但仍建议显式指定（如&lt;code&gt;parseInt(&amp;quot;12&amp;quot;, 10)&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-显式转换为布尔值&#34;&gt;3.3 显式转换为布尔值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Boolean(value)&lt;/code&gt;：遵循&lt;code&gt;ToBoolean&lt;/code&gt;规则（如&lt;code&gt;Boolean(&amp;quot;&amp;quot;) → false&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!!value&lt;/code&gt;：通过两次逻辑非显式转换为布尔值（第一次&lt;code&gt;!&lt;/code&gt;反转布尔值，第二次&lt;code&gt;!&lt;/code&gt;恢复原值，如&lt;code&gt;!!&amp;quot;abc&amp;quot; → true&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四隐式强制类型转换自动触发的转换&#34;&gt;四、隐式强制类型转换（自动触发的转换）&lt;/h2&gt;
&lt;h3 id=&#34;41-字符串和数字之间的隐式转换&#34;&gt;4.1 字符串和数字之间的隐式转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;运算符的重载：
&lt;ul&gt;
&lt;li&gt;若有一个操作数为字符串（或可转为字符串），则执行拼接（如&lt;code&gt;&amp;quot;1&amp;quot; + 2 → &amp;quot;12&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;否则执行数字加法（如&lt;code&gt;1 + true → 2&lt;/code&gt;，因&lt;code&gt;true → 1&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字转字符串&lt;/strong&gt;：&lt;code&gt;value + &amp;quot;&amp;quot;&lt;/code&gt;（如&lt;code&gt;123 + &amp;quot;&amp;quot; → &amp;quot;123&amp;quot;&lt;/code&gt;），优先调用&lt;code&gt;valueOf()&lt;/code&gt;再转字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串转数字&lt;/strong&gt;：通过&lt;code&gt;-0&lt;/code&gt;、&lt;code&gt;*1&lt;/code&gt;、&lt;code&gt;/1&lt;/code&gt;（如&lt;code&gt;&amp;quot;123&amp;quot; - 0 → 123&lt;/code&gt;），因这些运算符仅适用于数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-隐式转换为布尔值布尔上下文&#34;&gt;4.2 隐式转换为布尔值（布尔上下文）&lt;/h3&gt;
&lt;p&gt;以下场景中，非布尔值会自动通过&lt;code&gt;ToBoolean&lt;/code&gt;转换为布尔值：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/5.-%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/5.-%E8%AF%AD%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;一语句与表达式的基本概念&#34;&gt;一、语句与表达式的基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表达式&lt;/strong&gt;：能返回一个结果值的代码片段（如&lt;code&gt;1 + 2&lt;/code&gt;返回&lt;code&gt;3&lt;/code&gt;，&lt;code&gt;obj.prop&lt;/code&gt;返回属性值）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语句&lt;/strong&gt;：执行某种操作的代码（如&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;），&lt;strong&gt;所有语句都有结果值&lt;/strong&gt;，但语法默认不允许直接获取。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语句的结果值&#34;&gt;语句的结果值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常见语句的结果值：
&lt;ul&gt;
&lt;li&gt;赋值语句&lt;code&gt;a = b&lt;/code&gt;：结果值为被赋予的值（即&lt;code&gt;b&lt;/code&gt;的值）。&lt;/li&gt;
&lt;li&gt;变量声明&lt;code&gt;var a&lt;/code&gt;：结果值为&lt;code&gt;undefined&lt;/code&gt;（&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt;同理）。&lt;/li&gt;
&lt;li&gt;代码块&lt;code&gt;{...}&lt;/code&gt;：结果值为块内最后一个语句 / 表达式的结果（如&lt;code&gt;{1; 2; 3}&lt;/code&gt;结果为&lt;code&gt;3&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取语句结果值的方式&lt;/strong&gt;：语法不直接支持，但可通过&lt;code&gt;eval()&lt;/code&gt;获取（如&lt;code&gt;eval(&#39;{a=1; b=2}&#39;)&lt;/code&gt;返回&lt;code&gt;2&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二表达式的副作用&#34;&gt;二、表达式的副作用&lt;/h2&gt;
&lt;p&gt;副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。&lt;/p&gt;
&lt;h3 id=&#34;常见有副作用的表达式&#34;&gt;常见有副作用的表达式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数调用&lt;/strong&gt;：最常见（如&lt;code&gt;console.log(1)&lt;/code&gt;会输出内容，改变控制台状态）。&lt;/li&gt;
&lt;li&gt;自增 / 自减运算符：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a++&lt;/code&gt;：先返回&lt;code&gt;a&lt;/code&gt;的当前值，再将&lt;code&gt;a&lt;/code&gt;加 1（副作用在后）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;++a&lt;/code&gt;：先将&lt;code&gt;a&lt;/code&gt;加 1，再返回新值（副作用在前）。&lt;/li&gt;
&lt;li&gt;注意：&lt;code&gt;++a++&lt;/code&gt;会报错（&lt;code&gt;ReferenceError&lt;/code&gt;），因运算符需要可赋值的变量作为操作数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逗号运算符&lt;/strong&gt;：将多个表达式串联为一个语句，返回最后一个表达式的结果（如&lt;code&gt;a=1, b=2, a+b&lt;/code&gt;结果为&lt;code&gt;3&lt;/code&gt;），副作用是执行所有表达式。&lt;/li&gt;
&lt;li&gt;delete 操作符：
&lt;ul&gt;
&lt;li&gt;作用：删除对象属性或数组单元。&lt;/li&gt;
&lt;li&gt;结果值：成功删除（属性不存在或可配置）返回&lt;code&gt;true&lt;/code&gt;；失败（不可配置属性）返回&lt;code&gt;false&lt;/code&gt;或报错。&lt;/li&gt;
&lt;li&gt;副作用：实际移除属性 / 单元（如&lt;code&gt;delete obj.prop&lt;/code&gt;后&lt;code&gt;obj.prop&lt;/code&gt;为&lt;code&gt;undefined&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;赋值语句&lt;/strong&gt;：&lt;code&gt;a = 42&lt;/code&gt;结果为&lt;code&gt;42&lt;/code&gt;，副作用是&lt;code&gt;a&lt;/code&gt;被赋值为&lt;code&gt;42&lt;/code&gt;；链式赋值（如&lt;code&gt;a = b = 42&lt;/code&gt;）利用赋值表达式的结果值实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三上下文规则&#34;&gt;三、上下文规则&lt;/h2&gt;
&lt;h3 id=&#34;31-大括号的用法&#34;&gt;3.1 大括号&lt;code&gt;{}&lt;/code&gt;的用法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对象常量&lt;/strong&gt;：定义对象字面量（如&lt;code&gt;{a: 1, b: 2}&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标签（label）：用于标记代码块，配合&lt;code&gt;break&lt;/code&gt;/ &lt;code&gt;continue&lt;/code&gt;跳转：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break 标签&lt;/code&gt;：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue 标签&lt;/code&gt;：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。&lt;/li&gt;
&lt;li&gt;注意：标签不能用双引号；非循环代码块可使用&lt;code&gt;break 标签&lt;/code&gt;，但不能用&lt;code&gt;continue 标签&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON 与 JSON-P：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/</guid>
      <description>&lt;h3 id=&#34;一annex-bes-规范的兼容性补充&#34;&gt;一、Annex B（ES 规范的兼容性补充）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;：
ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主要兼容性差异&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非严格模式允许&lt;strong&gt;八进制数值常量&lt;/strong&gt;（如&lt;code&gt;012&lt;/code&gt;，严格模式下为语法错误）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器提供&lt;code&gt;window.escape()&lt;/code&gt;和&lt;code&gt;window.unescape()&lt;/code&gt;，用于转义 / 还原带&lt;code&gt;%&lt;/code&gt;分隔符的十六进制字符串（非标准方法，建议避免使用）；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String.prototype.substr&lt;/code&gt;与&lt;code&gt;String.prototype.substring&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;substring(start, end)&lt;/code&gt;：第二个参数为结束位置索引（不包含该位置）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;substr(start, length)&lt;/code&gt;：第二个参数为截取长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Web ES 规范的额外差异&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;!--&lt;/code&gt;和&lt;code&gt;--&amp;gt;&lt;/code&gt;被视为合法单行注释分隔符；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String.prototype&lt;/code&gt;包含返回 HTML 格式字符串的附加方法（如&lt;code&gt;anchor()&lt;/code&gt;、&lt;code&gt;bold()&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;正则表达式（RegExp）扩展及&lt;code&gt;Function.prototype&lt;/code&gt;附加方法（非标准，依赖浏览器实现）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二宿主对象&#34;&gt;二、宿主对象&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如&lt;code&gt;window&lt;/code&gt;、&lt;code&gt;document&lt;/code&gt;、&lt;code&gt;console&lt;/code&gt;），包括内建对象和工具函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊行为差异&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;部分宿主对象强制转换为布尔值时可能为&lt;strong&gt;假值&lt;/strong&gt;（如&lt;code&gt;document.all&lt;/code&gt;，不符合 JS 标准假值规则）；&lt;/li&gt;
&lt;li&gt;其他特性：
&lt;ul&gt;
&lt;li&gt;可能无法访问普通&lt;code&gt;Object&lt;/code&gt;的内建方法（如&lt;code&gt;toString()&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;部分属性为只读，无法覆盖；&lt;/li&gt;
&lt;li&gt;方法的&lt;code&gt;this&lt;/code&gt;无法重绑定到其他对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;console 对象&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三全局-dom-对象&#34;&gt;三、全局 DOM 对象&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局变量与 global 对象&lt;/strong&gt;：声明全局变量会同时在全局对象（如浏览器的&lt;code&gt;window&lt;/code&gt;）中创建同名属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DOM 元素 ID 的副作用&lt;/strong&gt;：因浏览器历史遗留问题，带&lt;code&gt;id&lt;/code&gt;属性的 DOM 元素会自动创建同名全局变量（如&lt;code&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&lt;/code&gt;会生成&lt;code&gt;window.app&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四原生原型扩展的注意事项&#34;&gt;四、原生原型扩展的注意事项&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不建议扩展原生原型&lt;/strong&gt;：除非确保无代码冲突（如第三方库可能覆盖扩展方法）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展原则&lt;/strong&gt;：扩展原生方法时需添加判断（如&lt;code&gt;if (!Array.prototype.includes) { ... }&lt;/code&gt;），避免覆盖已有功能。&lt;/li&gt;
&lt;li&gt;polyfill 与 shim：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;shim&lt;/strong&gt;：带兼容性测试的代码，用于填补环境差异（如检查功能是否存在，不存在则提供替代实现）；&lt;/li&gt;
&lt;li&gt;polyfill：只检查功能是否存在，不进行兼容性测试&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pollyfill&lt;/strong&gt;：特殊的 shim，专为实现未被环境支持的标准功能而设计，需与未来标准兼容（如为老浏览器实现&lt;code&gt;Array.prototype.includes&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;五script-标签与代码加载&#34;&gt;五、script 标签与代码加载&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多文件 / 内联代码的运行特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;多个&lt;code&gt;script&lt;/code&gt;标签（外部文件或内联代码）共享全局对象，在同一命名空间交互，但&lt;strong&gt;全局作用域的提升机制不跨文件边界&lt;/strong&gt;（即一个文件的变量不会提升到另一个文件）。&lt;/li&gt;
&lt;li&gt;单个&lt;code&gt;script&lt;/code&gt;出错会停止自身执行，但不影响后续&lt;code&gt;script&lt;/code&gt;运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态创建 script&lt;/strong&gt;：通过 JS 动态创建&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签并插入 DOM，效果与静态标签一致，可用于动态加载外部文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联代码的特殊限制&lt;/strong&gt;：内联代码中不能直接出现&lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;（会被视为代码块结束），变通方法为拆分字符串（如&lt;code&gt;&amp;quot;&amp;lt;sc&amp;quot;+&amp;quot;ript&amp;gt;&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符集差异&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;外部文件通过&lt;code&gt;script&lt;/code&gt;标签的&lt;code&gt;charset&lt;/code&gt;属性指定解析字符集；&lt;/li&gt;
&lt;li&gt;内联代码使用所在页面的字符集，且内联&lt;code&gt;script&lt;/code&gt;无&lt;code&gt;charset&lt;/code&gt;属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;六保留字&#34;&gt;六、保留字&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义：ES5 规范定义的不可用作变量名的标识符，包括四类：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.1-10.5-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.1-10.5-%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文介绍了JavaScript函数的几个重要概念。首先指出函数是Function类型的实例，箭头函数具有独特限制（不能使用arguments、不能作为构造函数等）。其次说明函数名是指向函数的指针，ES6函数具有name属性。接着详细讲解函数参数机制，包括arguments对象的使用、参数传递方式（按值传递），以及如何在严格模式下处理参数。关于函数重载，文章指出JavaScript不支持传统重载，但可以模拟实现。最后介绍了ES6默认参数的用法，包括基本语法、参数初始化顺序和作用域规则，以及箭头函数使用默认参数的方法。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;箭头函数&#34;&gt;箭头函数&lt;/h2&gt;
&lt;p&gt;函数实际上是对象，每个函数都是Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。函数名是指向函数对象的指针，而且不一定与函数本身紧密绑定&lt;/p&gt;
&lt;p&gt;箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数名&#34;&gt;函数名&lt;/h2&gt;
&lt;p&gt;函数名就是指向函数的指针，一个函数可以有多个名称，使用不带括号的函数名会访问函数指针，而不是执行函数&lt;/p&gt;
&lt;p&gt;ES6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串，如果它是使用function构造函数创建的，则会标识成anonymous，如果函数是一个获取函数、设置函数，或者使用bind实例化，那么标识符前面会加上一个前缀&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数参数&#34;&gt;函数参数&lt;/h2&gt;
&lt;p&gt;ES函数既不关心传入的参数个数，也不关心这些参数的数据类型。&lt;/p&gt;
&lt;p&gt;ES函数的参数在内部表现为一个数组，函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。&lt;/p&gt;
&lt;p&gt;在使用function关键字定义函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参数值&lt;/p&gt;
&lt;p&gt;arguments对象是一个类数组对象（不是Array的实例），因此可以使用中括号语法访问其中的元素，而要确定传进来多少个参数，可以访问arguments.length属性&lt;/p&gt;
&lt;p&gt;ES函数的参数只是为了方便才写出来的，并不是必须写出来的，命名参数不会创建让之后的调用必须匹配的函数签名，因为根本不存在验证命名参数的机制&lt;/p&gt;
&lt;p&gt;arguments对象可以跟命名参数一起使用，arguments的值始终会与对应的命名参数同步，但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。&lt;/p&gt;
&lt;p&gt;对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined，这就类似于定义了变量但没有初始化&lt;/p&gt;
&lt;p&gt;严格模式下，arguments对象与命名参数不同步，并且在函数中尝试重写arguments对象会导致语法错误&lt;/p&gt;
&lt;p&gt;如果函数是箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的命名参数访问。虽然箭头函数中没有arguments对象，但可以在包装函数中把它提供给箭头函数&lt;/p&gt;
&lt;p&gt;ES中的所有参数都是按值传递的，不可能按引用传递参数，如果把对象作为参数传递，那么传递的值就是这个对象的引用&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数重载&#34;&gt;函数重载&lt;/h2&gt;
&lt;p&gt;ES函数没有签名，因为参数是由包含零个或多个值的数组表示的，自然也就没有重载。如果在ES中定义了两个同名函数，则后定义的会覆盖先定义的。&lt;/p&gt;
&lt;p&gt;可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;默认参数&#34;&gt;默认参数&lt;/h2&gt;
&lt;p&gt;ES5之前，实现默认参数的一种常用方式就是检测某个参数是否等于undefined，如果是则意味着没有传这个参数，那就给它赋一个值&lt;/p&gt;
&lt;p&gt;ES6支持显示定义默认参数，只要在函数定义中的参数后面用=就可以为参数赋一个默认值&lt;/p&gt;
&lt;p&gt;给参数传undefined相当于没有传值，不过这样可以利用多个独立的默认值&lt;/p&gt;
&lt;p&gt;在使用默认参数时，arguments对应的值不反映参数的默认值，只反映传给函数的参数。&lt;/p&gt;
&lt;p&gt;默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值&lt;/p&gt;
&lt;p&gt;函数默认参数只有在函数被调用时才会求值，不会在函数定义时求值，而且计算默认值的函数只有在调用函数但未传相应参数时才会被调用&lt;/p&gt;
&lt;p&gt;箭头函数同样也可以这样使用默认参数&lt;/p&gt;
&lt;p&gt;给多个参数定义默认值实际上跟使用let关键字顺序声明变量一样，默认参数会按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数。&lt;/p&gt;
&lt;p&gt;参数初始化顺序遵循暂时性死区规则，即前面定义的参数不能引用后面定义的，参数也存在于自己的作用域中，它们不能引用函数体的作用域&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.11-10.16-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.11-10.16-%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文介绍了JavaScript中函数表达式、递归、尾调用优化、闭包、立即调用函数表达式(IIFE)和私有变量等核心概念。重点包括：函数表达式的定义与使用；递归的实现方式；尾调用优化的条件；闭包的作用机制及其内存影响；IIFE的模拟块级作用域应用；通过构造函数和静态变量实现私有变量的方法。文章通过代码示例详细说明了这些特性在JavaScript中的实际应用，帮助理解函数式编程的关键技术点。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;函数表达式&#34;&gt;函数表达式&lt;/h2&gt;
&lt;p&gt;函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义，这意味着函数声明可以出现在调用它的代码之后&lt;/p&gt;
&lt;p&gt;函数表达式看起来像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量，这样创建的函数叫做匿名函数或兰姆达函数，因为function关键字后面没有标识符，未赋值给其他变量的匿名函数的name属性是空字符串&lt;/p&gt;
&lt;p&gt;函数表达式跟JS中的其他表达式一样，需要先赋值后使用&lt;/p&gt;
&lt;p&gt;任何时候，只要函数被当做值来使用，它就是一个函数表达式&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;p&gt;递归函数通常的形式是一个函数通过名称调用自己&lt;/p&gt;
&lt;p&gt;arguments.callee是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，但严格模式下不能访问。&lt;/p&gt;
&lt;p&gt;可以使用命名函数表达式达到目的&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;尾调用优化&#34;&gt;尾调用优化&lt;/h2&gt;
&lt;p&gt;尾调用：外部函数的返回值是内部函数的返回值&lt;/p&gt;
&lt;p&gt;如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做&lt;/p&gt;
&lt;p&gt;尾调用优化的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码在严格模式下执行&lt;/li&gt;
&lt;li&gt;外部函数的返回值是对尾调用函数的调用&lt;/li&gt;
&lt;li&gt;尾调用函数返回后不需要执行额外的逻辑&lt;/li&gt;
&lt;li&gt;尾调用函数不是引用外部函数作用域中自由变量的闭包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是递归尾调用还是非递归尾调用，都可以应用优化，引擎并不区分尾调用中调用的是函数自身还是其他函数&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;p&gt;闭包指的是那些引用了另一个作用域中变量的函数，通常是在嵌套函数中实现的，原理是包含外部函数作用域的作用域链&lt;/p&gt;
&lt;p&gt;在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止&lt;/p&gt;
&lt;p&gt;函数执行时，每个执行上下文中都会有一个包含其中变量的对象，全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。作用域链其实是一个包含指针的列表，每个指针指向一个变量对象，但物理上并不会包含相应的对象&lt;/p&gt;
&lt;p&gt;函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域&lt;/p&gt;
&lt;p&gt;在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中，活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用&lt;/p&gt;
&lt;p&gt;因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用&lt;/p&gt;
&lt;p&gt;在闭包中使用this，如果内部函数没有使用箭头函数定义，则this对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则this在非严格模式下等于window，严格模式下等于undefined。如果作为某个对象的方法调用，则this等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着this会指向window，除非在严格模式下this指向undefined&lt;/p&gt;
&lt;p&gt;每个函数在被调用时都会自动创建两个特殊变量：this和arguments。内部函数永远不可能直接访问外部函数的这两个变量&lt;/p&gt;
&lt;p&gt;赋值表达式的值是函数本身&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;立即调用函数表达式&#34;&gt;立即调用函数表达式&lt;/h2&gt;
&lt;p&gt;立即调用的匿名函数又被称作立即调用的函数表达式(IIFE)，它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式&lt;/p&gt;
&lt;p&gt;使用IIFE可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数，这样位于函数体作用域的变量就像是在块级作用域中一样&lt;/p&gt;
&lt;p&gt;IIFE不会导致闭包相关问题，因为不存在对这个匿名函数的引用，只要函数执行完毕，其作用域链就可以被销毁&lt;/p&gt;
&lt;p&gt;IIFE可以用于锁定参数值&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;私有变量&#34;&gt;私有变量&lt;/h2&gt;
&lt;p&gt;任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数&lt;/p&gt;
&lt;p&gt;如果函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的变量。基于这一点，就可以创建出能够访问私有变量的公有方法&lt;/p&gt;
&lt;p&gt;特权方法是能够访问函数私有变量的公有方法。在对象上有两种方法创建特权方法：构造函数实现，静态私有变量实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyObject&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateVariable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateFunction&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;publicMethod&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;privateVariable&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateFunction&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;构造函数实现&lt;/strong&gt;是把所有私有变量和私有函数都定义在构造函数中，然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。缺点是每个实例都会重新创建一遍新方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateVariable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateFunction&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;MyObject&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;MyObject&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;publicMethod&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;privateVariable&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateFunction&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;静态私有变量&lt;/strong&gt;通过使用私有作用域定义私有变量和函数来实现，在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后有定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。&lt;/p&gt;
&lt;p&gt;这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里不是必须的。&lt;/p&gt;
&lt;p&gt;构造函数标识符未使用任何关键字，因为不使用关键字声明的变量会创建在全局作用域中，可以在私有作用域外部被访问&lt;/p&gt;
&lt;p&gt;该模式，私有变量和私有函数是由实例共享的，因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;singleton&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateVariable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateFunction&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;publicProperty&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;publicMethod&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;privateVariable&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateFunction&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;模块模式&lt;/strong&gt;在一个单例对象上实现了相同的隔离和封装。模块模式使用了匿名函数返回一个对象，在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的公有方法都可以访问同一个作用域的私有变量和私有函数。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.6-10.10-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.6-10.10-%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;ES6扩展操作符简化了函数参数处理，可拆分可迭代对象为单独参数或收集剩余参数为数组。函数声明会提升，表达式则不会。函数可作为值传递或返回。函数内部有arguments、this、caller等特性，方法包括apply/call改变this和bind创建绑定函数。严格模式影响this行为，箭头函数保持定义时上下文。函数属性如length、prototype，继承方法返回函数代码或自身。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;参数扩展与收集&#34;&gt;参数扩展与收集&lt;/h2&gt;
&lt;p&gt;在给函数传参时，有时候可能不需要传入一个数组，而是要分别传入数组的元素。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于apply方法&lt;/p&gt;
&lt;p&gt;在ES6中，可以通过扩展操作符极为简洁地实现这种操作，对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入&lt;/p&gt;
&lt;p&gt;因为数组长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前后再传其他的值，包括使用扩展操作符传其他参数&lt;/p&gt;
&lt;p&gt;在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合成一个数组，这有点类似arguments对象的构造机制，只不过收集参数的结果会得到一个Array实例&lt;/p&gt;
&lt;p&gt;收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数&lt;/p&gt;
&lt;p&gt;箭头函数虽然不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments一样的逻辑&lt;/p&gt;
&lt;p&gt;使用收集参数不影响arguments对象，它仍然反映调用时传给函数的参数&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数声明与函数表达式&#34;&gt;函数声明与函数表达式&lt;/h2&gt;
&lt;p&gt;JS引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义&lt;/p&gt;
&lt;p&gt;函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫做函数声明提升。在执行代码时，JS引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部，因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部，如果把函数声明改为等价表达式，那么执行时会报错&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数作为值&#34;&gt;函数作为值&lt;/h2&gt;
&lt;p&gt;不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数&lt;/p&gt;
&lt;p&gt;如果是访问函数而不是调用函数，那就必须不带括号&lt;/p&gt;
&lt;p&gt;从一个函数中返回另一个函数也是可以的，而且非常有用&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数内部&#34;&gt;函数内部&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;arguments&lt;/strong&gt;：是一个类数组对象，包含调用函数时传入的所有参数，这个对象只有以function关键字定义函数时才会有，该对象其中还有一个callee属性，指向arguments对象所在函数的指针，用作递归中可以让函数逻辑与函数名解耦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候通常称其为this值&lt;/p&gt;
&lt;p&gt;箭头函数中this引用的是定义箭头函数的上下文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;caller&lt;/strong&gt;：这个属性引用的是调用当前函数的函数，如果是在全局作用域中调用的则为null&lt;/p&gt;
&lt;p&gt;严格模式下访问arguments.callee会报错，arguments.caller也是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;new.target&lt;/strong&gt;：ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。如果是普通调用，则new.target的值是undefined，如果是new关键字调用的，则new.target将引用被调用的构造函数&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;函数属性与方法&#34;&gt;函数属性与方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;length属性&lt;/strong&gt;保存函数定义的命名参数的个数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prototype&lt;/strong&gt;是保存引用类型所有实例方法的地方，由所有实例共享&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;apply()和call()方法&lt;/strong&gt;都会以指定的this值来调用函数，即会设置调用函数时函数体内this对象的值。&lt;/p&gt;
&lt;p&gt;apply()方法接收两个参数：函数内this的值和一个参数数组。第二个参数可以是Array实例，也可以是arguments对象&lt;/p&gt;
&lt;p&gt;在严格模式下，调用函数时，如果没有指定上下文对象，则this值不会指向window。除非使用apply或call把函数指定给一个对象，否则this的值会变成undefined&lt;/p&gt;
&lt;p&gt;call()方法与apply()方法一样，只是传参的形式不同，第一个参数也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。&lt;/p&gt;
&lt;p&gt;使用call()和apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bind()方法&lt;/strong&gt;会创建一个新的函数实例，其this值会被绑定到传给bind()的对象&lt;/p&gt;
&lt;p&gt;继承的toLocaleString()和toString()方法时钟返回函数的代码，返回代码的格式因浏览器而异。valueOf()返回函数本身&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.3-%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.3-%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：JavaScript变量声明方式包括var、let和const。var存在变量提升和函数作用域特性，let提供块级作用域且禁止重复声明，const用于声明不可变常量。建议优先使用const，其次是let，避免使用var以提升代码质量。let和const解决了var带来的变量泄露等问题，使变量作用域更可控。对于对象类型的const变量，仅限制引用不可变，内部属性仍可修改。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;要定义变量，可以使用var操作符，后跟变量名&lt;/p&gt;
&lt;p&gt;ES实现变量初始化，因此可以同时定义变量并设置它的值&lt;/p&gt;
&lt;p&gt;使用var操作符定义的变量会成为包含它的函数的局部变量。&lt;/p&gt;
&lt;p&gt;在函数内定义变量时省略var操作符，可以创建一个全局变量&lt;/p&gt;
&lt;p&gt;如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量&lt;/p&gt;
&lt;p&gt;使用var声明的变量会自动提升到函数作用域顶部，这叫做提升&lt;/p&gt;
&lt;p&gt;反复多次使用var声明同一个变量也没有问题&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;let声明的范围是块作用域，而var声明的范围是函数作用域，块作用域是函数作用域的子集&lt;/p&gt;
&lt;p&gt;let也不允许同一个块作用域中出现冗余声明，这样会报错，嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明&lt;/p&gt;
&lt;p&gt;对声明冗余报错不会因混用let和var而受影响，这两个关键字声明的并不是不同类型的变量，他们只是指出变量在相关作用域如何存在&lt;/p&gt;
&lt;p&gt;let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。在解析代码时，JS引擎也会注意出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let声明之前的任何瞬间被称为暂时性死区，在此阶段引用任何后面才声明的变量都会报错&lt;/p&gt;
&lt;p&gt;与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性，var声明的变量则会。不过let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续&lt;/p&gt;
&lt;p&gt;在使用var声明变量时，由于生命会被提升，JS引擎会自动将多余的声明在作用域顶部合并成一个声明。因为let作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它，为此，对于let关键字，不能依赖条件声明模式&lt;/p&gt;
&lt;p&gt;在let出现之前，for循环定义的迭代变量会渗透到循环体外部，改成let后，迭代变量的作用域仅限于for循环快内部&lt;/p&gt;
&lt;p&gt;在使用let声明迭代变量时，JS引擎在后台会为每个迭代循环声明一个新的迭代变量&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误&lt;/p&gt;
&lt;p&gt;const声明的限制只适用于它指向的变量的引用，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制&lt;/p&gt;
&lt;p&gt;不能用const生命迭代变量，因为迭代变量会自增，for-of和for-in可以&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;有助于提升代码质量的最佳实践：不使用var，const优先，let次之&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文深入解析了JavaScript的执行上下文和作用域机制。执行上下文分为全局和函数上下文，每个函数调用会创建新上下文并压入栈中。作用域链决定了变量访问顺序，内部可访问外部变量但反之不行。文章对比了var、let和const的特性：var存在变量提升，let提供块级作用域，const声明不可更改的常量。详细解释了标识符搜索规则，从当前作用域开始逐级向外查找，直至全局上下文。还介绍了with和try/catch语句对作用域链的临时影响。通过剖析上下文创建、销毁过程和变量查找机制，揭示了JavaScript的核心作用域工作原理。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在与这个对象上&lt;/p&gt;
&lt;p&gt;全局上下文是最外层的上下文。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。全局上下文在应用程序退出前才会被销毁&lt;/p&gt;
&lt;p&gt;每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ES程序的执行流就是通过上下文栈控制的&lt;/p&gt;
&lt;p&gt;上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象用作变量对象。活动对象最初之后一个定义变量：arguments。作用域中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象&lt;/p&gt;
&lt;p&gt;代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符，此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量&lt;/p&gt;
&lt;p&gt;内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索&lt;/p&gt;
&lt;p&gt;函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。&lt;/p&gt;
&lt;p&gt;通常会在两种情况下出现这个现象，即代码执行到下面任意一种情况时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try/catch语句的catch块&lt;/li&gt;
&lt;li&gt;with语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种情况下，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在使用&lt;strong&gt;var&lt;/strong&gt;声明变量时，变量会被自动添加到最接近的上下文，在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文&lt;/p&gt;
&lt;p&gt;var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象叫做提升，提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;let&lt;/strong&gt;的作用域是块级的，块级作用域由最近的一对包含花括号决定&lt;/p&gt;
&lt;p&gt;let与var的另一个不同之处是在同一作用域内不能声明两次，重复的var声明会被忽略，而重复的let声明会报错&lt;/p&gt;
&lt;p&gt;let的行为非常适合在循环中声明迭代变量，使用var声明的迭代变量会泄露到循环外部&lt;/p&gt;
&lt;p&gt;let在JS运行时也会被提升，但由于暂时性死区缘故，实际上不能在声明之前使用let变量&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;声明的变量必须同时初始化为某个值，一经声明，在其生命周期的任何时候都不能再重新赋予新值。除此之外与let声明是一样的&lt;/p&gt;
&lt;p&gt;const声明只应用到顶级原语或者对象，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不受影响&lt;/p&gt;
&lt;p&gt;如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败&lt;/p&gt;
&lt;p&gt;由于const声明按时变量的值是单一类型且不可修改，JS运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么，搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定，如果没有找到变量名，则继续沿作用域链搜索。（作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明&lt;/p&gt;
&lt;p&gt;对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符&lt;/p&gt;
&lt;p&gt;使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：本文介绍了JavaScript对象的属性特征和管理方法。对象属性分为数据属性和访问器属性，可通过Object.defineProperty()方法定义特性。数据属性包含[[Value]]等4个特性，访问器属性包含[[Get]]/[[Set]]函数。还讲解了Object.assign()合并对象、Object.is()比较对象、对象解构赋值等ES6新特性，以及简写属性名和可计算属性等语法糖。最后说明了如何在函数参数中使用对象解构。这些特性增强了对象操作的灵活性和代码简洁性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;对象就是一组没有特定顺序的值，对象的每个属性或者方法都可由一个名称来标识，这个名称映射到一个值。可以把对象想象成一张散列表，其中的内容就是一组名值对，值可以是数据或者函数&lt;/p&gt;
&lt;p&gt;创建自定义对象的通常方式是创建Object的一个新实例，然后再给它添加属性和方法。早期开发者频繁使用这种方式创建新对象，几年后，对象字面量变成了更流行的方式&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ES使用了一些内部特性来描述属性的特征，这些特征是由为JS实现引擎的规范定义的，因此，开发者不能在JS中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来&lt;/p&gt;
&lt;p&gt;属性分两种：数据属性和访问器属性&lt;/p&gt;
&lt;h3 id=&#34;数据属性&#34;&gt;数据属性&lt;/h3&gt;
&lt;p&gt;数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。&lt;/p&gt;
&lt;p&gt;数据属性有4个特性描述它们的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true&lt;/li&gt;
&lt;li&gt;[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认情况下，所有直接定义在对象上的属性的这个特性都是true&lt;/li&gt;
&lt;li&gt;[[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是true&lt;/li&gt;
&lt;li&gt;[[Value]]：包含属性实际的值，这个特性默认值为undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将属性添加到对象之后[[Configurable]]、[[Enumerable]]、[[Writable]]都会被设置为true，而[[Value]]特性会被设置为指定的值&lt;/p&gt;
&lt;p&gt;要修改属性的默认特性，就必须使用Object.defineProperty()方法，这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值&lt;/p&gt;
&lt;p&gt;在调用Object.defineProperty()时，如果描述符对象上的属性的值都不指定，则都默认为false&lt;/p&gt;
&lt;h3 id=&#34;访问器属性&#34;&gt;访问器属性&lt;/h3&gt;
&lt;p&gt;访问器属性不包含数据值，相反，他们包含一个获取函数和一个设置函数，不过这两个函数不是必须的，在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值，在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。&lt;/p&gt;
&lt;p&gt;访问器属性有4个特性描述它们的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true&lt;/li&gt;
&lt;li&gt;[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认情况下，所有直接定义在对象上的属性的这个特性都是true&lt;/li&gt;
&lt;li&gt;[[Get]]：获取函数，在读取属性时调用，默认值为undefined&lt;/li&gt;
&lt;li&gt;[[Set]]：设置函数，在写入属性时调用，默认值为undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问器属性是不能直接定义的，必须使用Object.defineProperty()&lt;/p&gt;
&lt;p&gt;获取函数和设置函数不一定都要定义，只定义获取函数意味着属性是只读的，尝试修改属性会被忽略，严格模式下会报错，类似的，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回undefined，严格模式下会报错&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Object.defineProperties()方法可以通过多个描述符一次性定义多个属性，它接受两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符，这个方法接收两个参数：属性所在的对象和要取其描述符的属性名。返回值是一个对象&lt;/p&gt;
&lt;p&gt;ES8新增了Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;合并两个对象：把源对象所有的本地属性一起复制到目标对象上，这种操作也被称为混入，因为目标对象通过混入源对象的属性得到了增强&lt;/p&gt;
&lt;p&gt;ES6专门为合并对象提供了Object.assign()方法，这个方法接受一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象，以字符串和符号为键的属性会被复制，对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值&lt;/p&gt;
&lt;p&gt;Object.assign()实际上对每个源对象执行的是浅复制，如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数&lt;/p&gt;
&lt;p&gt;如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有回滚之前赋值的概念，因此它是一个尽力而为，可能只会完成部分复制的方法&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ES6规范新增了Object.is()方法，这个方法和===很像，但同时也考虑到了一些边界情形&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的，简写属性名只要使用变量名就会自动被解释为同名的属性键，如果没有找到同名变量就会报错&lt;/p&gt;
&lt;p&gt;在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性&lt;/p&gt;
&lt;p&gt;有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值&lt;/p&gt;
&lt;p&gt;可计算属性表达式中抛出任何错误都会中断对象创建，不能回滚&lt;/p&gt;
&lt;p&gt;在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名，这样可以明显缩短方法声明。简写方法名对获取和设置函数也是适用的。简写方法名与可计算属性键相互兼容&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对象解构语法可以在一条语句中使用嵌套数据实现一个或多个赋值操作，简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值&lt;/p&gt;
&lt;p&gt;使用解构可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可使用简写语法。&lt;/p&gt;
&lt;p&gt;解构赋值不一定与对象的属性匹配，赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是undefined。也可以在解构赋值的同时定义默认值。&lt;/p&gt;
&lt;p&gt;解构在内部使用函数toObject()把源数据结构转换为对象，这意味着对象解构的上下文中，原始值会被当成对象，这也意味着，null和undefined不能被解构，否则会报错&lt;/p&gt;
&lt;p&gt;解构并不要求变量必须在解构表达式中声明，不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中&lt;/p&gt;
&lt;p&gt;解构对于引用嵌套的属性或目标没有限制，为此，可以通过解构来复制对象属性，解构赋值可以使用嵌套解构，以匹配嵌套的属性，在外层属性没有定义的情况下不能使用嵌套解构，无论源对象还是目标对象都一样&lt;/p&gt;
&lt;p&gt;涉及多个属性的解构赋值是一个输出无关的顺序化操作，如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分&lt;/p&gt;
&lt;p&gt;在函数参数列表中也可以进行解构赋值，对参数的解构赋值不会影响arguments对象，但可以在函数签名中声明在函数体内使用局部变量&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：本文探讨了JavaScript对象创建的几种模式。工厂模式虽能批量创建对象但无法标识类型，构造函数模式通过new操作符解决类型识别问题，但实例方法会被重复创建。原型模式通过在prototype上定义共享属性和方法优化了性能，并详细介绍了原型链、属性查找机制、原型修改及其对实例的影响，以及相关操作符和方法的使用。最后指出原型模式的局限性在于共享特性导致实例属性初始值相同。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式有明显不足：创建具有同样接口的多个对象需要重复编写很多代码&lt;/p&gt;
&lt;p&gt;工厂模式可以用不同的参数多次调用函数，每次都会返回一个新对象，这种模式虽然可以解决创建多个类似对象的问题，但没有解决对象表示问题，即新创建的对象是什么类型&lt;/p&gt;
&lt;p&gt;构造函数和工厂函数的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有显式的创建对象&lt;/li&gt;
&lt;li&gt;属性和方法字节赋值给了this&lt;/li&gt;
&lt;li&gt;没有return&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用new操作符调用构造函数会执行如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内存中创建一个新对象&lt;/li&gt;
&lt;li&gt;这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性&lt;/li&gt;
&lt;li&gt;构造函数内部的this被赋值为这个新对象，即this指向新对象&lt;/li&gt;
&lt;li&gt;执行构造函数内部的代码，给新对象添加属性&lt;/li&gt;
&lt;li&gt;如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;constructor本来是用于标识对象类型的，不过，一般认为instanceof操作符是确定对象类型更可靠的方式&lt;/p&gt;
&lt;p&gt;相比于工厂模式，定义自定义构造函数可以确保实例被标识为特定类型。&lt;/p&gt;
&lt;p&gt;构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式也可以表示构造函数，在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有new操作符，就可以调用相应的构造函数&lt;/p&gt;
&lt;p&gt;构造函数与普通函数唯一的区别就是调用方式不同，除此之外，构造函数也是函数，并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new操作符调用就是构造函数，而不是用new操作符调用的函数就是普通函数。&lt;/p&gt;
&lt;p&gt;构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍，因为都是做一样的事，所以没必要定义两个不同的Function实例，况且，this对象可以把函数与对象的绑定推迟到运行时&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实例上，这个对象就是通过调用构造函数创建的对象的原型，使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型&lt;/p&gt;
&lt;p&gt;无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性指向原型对象，默认情况下，所有原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。&lt;/p&gt;
&lt;p&gt;在自定义构造函数时，原型对象默认只会获得constructor属性，其他的所有方法都继承自Object，每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]的标准方式，一些浏览器会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。&lt;/p&gt;
&lt;p&gt;实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有&lt;/p&gt;
&lt;p&gt;虽然不是所有实现都对外暴露了[[Prototype]]，但可以使用isPrototypeOf()方法确定两个对象之间的关系，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true&lt;/p&gt;
&lt;p&gt;Object有一个方法叫Object.getPrototype()，返回参数的内部特性[[Prototype]]的值&lt;/p&gt;
&lt;p&gt;Object.setPrototypeOf()可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系，但是会影响代码性能&lt;/p&gt;
&lt;p&gt;Object.create()可以创建一个新对象，同时为其指定原型&lt;/p&gt;
&lt;h3 id=&#34;原型层级&#34;&gt;原型层级&lt;/h3&gt;
&lt;p&gt;在通过对象访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身，如果在这个实例上发现了给定的名称，则返回该名称对应的值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值，这就是原型用于在多个对象实例间共享属性和方法的原理&lt;/p&gt;
&lt;p&gt;虽然可以通过实例读取原型对象上的值，但不能通过实例重写这些值，如果在实例上添加了一个原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。&lt;/p&gt;
&lt;p&gt;使用delete操作符可以删除实例上的属性&lt;/p&gt;
&lt;p&gt;hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上，这个方法是继承自Object的，会在属性存在于调用它的对象实例上时返回true&lt;/p&gt;
&lt;h3 id=&#34;原型和in操作符&#34;&gt;原型和in操作符&lt;/h3&gt;
&lt;p&gt;有两种方式使用in操作符：单独使用和在for-in循环中使用&lt;/p&gt;
&lt;p&gt;在单独使用时，in操作符会在可以通过对象访问指定属性时返回true，无论该属性在实例上还是原型上。&lt;/p&gt;
&lt;p&gt;如果要确定某个属性是否在原型上，可以同时使用hasOwnProperty()和in操作符&lt;/p&gt;
&lt;p&gt;在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例和原型属性&lt;/p&gt;
&lt;p&gt;要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法，这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组&lt;/p&gt;
&lt;p&gt;如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()&lt;/p&gt;
&lt;p&gt;Object.getOwnPropertySymbols()方法针对符号&lt;/p&gt;
&lt;h3 id=&#34;属性枚举顺序&#34;&gt;属性枚举顺序&lt;/h3&gt;
&lt;p&gt;for-in循环和Object.keys()的枚举顺序是不确定的&lt;/p&gt;
&lt;p&gt;Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()的枚举顺序是确定的，先以升序枚举数值键，然后以插入顺序枚举字符串和符号键，在对象字面量中定义的键以它们逗号分隔的顺序插入&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Object.values()和Object.entries()将对象内容转换为序列化的，可迭代的格式，它们接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键值对的数组，非字符串属性会被转换为字符串输出，这两个方法执行对象的浅复制，符号属性会被忽略&lt;/p&gt;
&lt;p&gt;原型上搜索值是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象的修改也会在实例上反映出来&lt;/p&gt;
&lt;p&gt;实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变，重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型&lt;/p&gt;
&lt;p&gt;重写构造函数上的原型之后再创建的实例才会引用新的原型&lt;/p&gt;
&lt;p&gt;通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法&lt;/p&gt;
&lt;p&gt;原型模式弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值，原型的最主要问题是它的共享特性&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.3-%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.3-%E7%BB%A7%E6%89%BF/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文介绍了JS中的5种主要继承方式：原型链、盗用构造函数、组合继承、原型式继承和寄生式继承。原型链通过原型对象实现继承，但存在引用值共享和传参问题；盗用构造函数通过调用父类构造函数解决了传参问题，但方法无法重用；组合继承结合了两者优点；原型式继承基于对象浅复制，适合共享信息；寄生式继承通过增强对象实现继承。最后提到寄生式组合继承解决了组合继承的效率问题，是引用类型继承的最佳模式。各种方式各有适用场景，开发者需根据需求选择。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;原型链&#34;&gt;原型链&lt;/h3&gt;
&lt;p&gt;原型链是ES的主要继承方式，其基本思想就是通过原型继承多个引用类型的属性和方法&lt;/p&gt;
&lt;p&gt;每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，那就意味着这个原型本身有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数，这样就在实例和原型之间构造了一条原型链&lt;/p&gt;
&lt;p&gt;原型链扩展了原型搜索机制，在读取实例上的属性时，首先会在实例上搜索这个属性，如果没找到，则会继承搜索实例的原型，在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型，对属性和方法的搜索会一直持续到原型链的末端&lt;/p&gt;
&lt;p&gt;默认情况下，所有引用类型都继承自Object，这也是通过原型链来实现的，任何函数的默认原型都是一个Object的实例，这意味着这个实例有一个内部指针指向Object.prototype&lt;/p&gt;
&lt;p&gt;原型与实例的关系可以通过两种方式来确定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种方式是使用instanceof操作符，如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种方式是使用isPrototypeOf()方法，原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回true&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;子类有时候需要覆盖父类的方法，或者增加父类没有的方法，为此，这些方法必须在原型复制之后再添加到原型上&lt;/p&gt;
&lt;p&gt;以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链&lt;/p&gt;
&lt;p&gt;原型链的主要问题出现在原型中包含的引用值会在所有实例间共享，在使用原型实现继承时，原型实际上变成了另一个类型的实例，这意味着原先的实例属性变成了原型属性&lt;/p&gt;
&lt;p&gt;原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;盗用构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本原理：在子类构造函数中调用父类的构造函数，可以使用apply()和call()方法以新创建的对象为上下文执行构造函数&lt;/p&gt;
&lt;p&gt;相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参&lt;/p&gt;
&lt;p&gt;盗用构造函数的缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用，此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;组合继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;综合了原型链和盗用构造函数，将两者的优点集中了起来，基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;原型式继承&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;object&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;F&lt;/span&gt;(){}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;F&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;F&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例，本质是，object()是对传入的对象执行了一次浅复制&lt;/p&gt;
&lt;p&gt;适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要吧这个对象先传给object()，然后再对返回的对象进行适当修改&lt;/p&gt;
&lt;p&gt;ES5通过Object.create()方法将原型式继承的概念规范化了，这个方法接受两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（可选），第二个参数与Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性&lt;/p&gt;
&lt;p&gt;原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合，但属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;寄生式继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象&lt;/p&gt;
&lt;p&gt;寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景，通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;寄生式组合继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组合式继承存在效率问题，父类构造函数始终会被调用两次：一次实在创建子类原型时调用，另一次是在子类构造函数中调用。本质是，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了&lt;/p&gt;
&lt;p&gt;寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本，说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号&lt;/p&gt;
&lt;p&gt;与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制&lt;/p&gt;
&lt;p&gt;类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行&lt;/p&gt;
&lt;p&gt;类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;constructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数&lt;/p&gt;
&lt;p&gt;使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。&lt;/p&gt;
&lt;p&gt;使用new调用类的构造函数会执行如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内存中创建一个新对象&lt;/li&gt;
&lt;li&gt;这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性&lt;/li&gt;
&lt;li&gt;构造函数内部的this被赋值为这个新对象&lt;/li&gt;
&lt;li&gt;执行构造函数内部的代码&lt;/li&gt;
&lt;li&gt;如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的&lt;/p&gt;
&lt;p&gt;默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改&lt;/p&gt;
&lt;p&gt;类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误&lt;/p&gt;
&lt;p&gt;类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用&lt;/p&gt;
&lt;p&gt;ES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身&lt;/p&gt;
&lt;p&gt;与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中&lt;/p&gt;
&lt;p&gt;类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转&lt;/p&gt;
&lt;p&gt;类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递&lt;/p&gt;
&lt;p&gt;与立即调用函数表达式类似，类也可以立即实例化&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员&lt;/p&gt;
&lt;p&gt;每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享&lt;/p&gt;
&lt;p&gt;为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据&lt;/p&gt;
&lt;p&gt;类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样&lt;/p&gt;
&lt;p&gt;可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂&lt;/p&gt;
&lt;p&gt;静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样&lt;/p&gt;
&lt;p&gt;虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加&lt;/p&gt;
&lt;p&gt;类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类&lt;/p&gt;
&lt;p&gt;派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数&lt;/p&gt;
&lt;p&gt;在静态方法中可以通过super调用继承的类上定义的静态方法&lt;/p&gt;
&lt;p&gt;ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型&lt;/p&gt;
&lt;p&gt;在使用super时要注意几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;super只能在派生类构造函数和静态方法中使用&lt;/li&gt;
&lt;li&gt;不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法&lt;/li&gt;
&lt;li&gt;调用super会调用父类构造函数，并将返回的实例赋值给this&lt;/li&gt;
&lt;li&gt;super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入&lt;/li&gt;
&lt;li&gt;如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数&lt;/li&gt;
&lt;li&gt;在类构造函数中，不能在调用super之前引用this&lt;/li&gt;
&lt;li&gt;如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化&lt;/p&gt;
&lt;p&gt;通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法&lt;/p&gt;
&lt;p&gt;ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型&lt;/p&gt;
&lt;p&gt;有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类&lt;/p&gt;
&lt;p&gt;把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
