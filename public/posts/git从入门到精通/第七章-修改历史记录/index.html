<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="修改历史信息


命令：git rebase -i &lt;基准commit&gt;


-i：进入互动模式，可编辑历史提交。


&lt;基准commit&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。


操作过程：


执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与git log的 “从新到旧” 相反）。


每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。


影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。


取消 rebase：git reset ORIG_HEAD &ndash;hard


把多个 commit 合并成一个 commit


执行git rebase -i &lt;最早要合并的commit的前一个哈希&gt;（如合并最近 3 个 commit，基准为HEAD~4）。


在编辑器中，将目标 commit 的pick改为squash（或fixup）


保存退出后，若用squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。


完成后，多个 commit 被合并为一个，历史更简洁。


把一个 commit 拆解成多个 commit


在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="修改历史信息 命令：git rebase -i &lt;基准commit&gt;
-i：进入互动模式，可编辑历史提交。
&lt;基准commit&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。
操作过程：
执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与git log的 “从新到旧” 相反）。
每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。
影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。
取消 rebase：git reset ORIG_HEAD –hard
把多个 commit 合并成一个 commit 执行git rebase -i &lt;最早要合并的commit的前一个哈希&gt;（如合并最近 3 个 commit，基准为HEAD~4）。
在编辑器中，将目标 commit 的pick改为squash（或fixup）
保存退出后，若用squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。
完成后，多个 commit 被合并为一个，历史更简洁。
把一个 commit 拆解成多个 commit 在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="修改历史信息


命令：git rebase -i &lt;基准commit&gt;


-i：进入互动模式，可编辑历史提交。


&lt;基准commit&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。


操作过程：


执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与git log的 “从新到旧” 相反）。


每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。


影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。


取消 rebase：git reset ORIG_HEAD &ndash;hard


把多个 commit 合并成一个 commit


执行git rebase -i &lt;最早要合并的commit的前一个哈希&gt;（如合并最近 3 个 commit，基准为HEAD~4）。


在编辑器中，将目标 commit 的pick改为squash（或fixup）


保存退出后，若用squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。


完成后，多个 commit 被合并为一个，历史更简洁。


把一个 commit 拆解成多个 commit


在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "修改历史信息 命令：git rebase -i \u0026lt;基准commit\u0026gt;\n-i：进入互动模式，可编辑历史提交。\n\u0026lt;基准commit\u0026gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。\n操作过程：\n执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与git log的 “从新到旧” 相反）。\n每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。\n影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。\n取消 rebase：git reset ORIG_HEAD \u0026ndash;hard\n把多个 commit 合并成一个 commit 执行git rebase -i \u0026lt;最早要合并的commit的前一个哈希\u0026gt;（如合并最近 3 个 commit，基准为HEAD~4）。\n在编辑器中，将目标 commit 的pick改为squash（或fixup）\n保存退出后，若用squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。\n完成后，多个 commit 被合并为一个，历史更简洁。\n把一个 commit 拆解成多个 commit 在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。\n",
  "keywords": [
    
  ],
  "articleBody": "修改历史信息 命令：git rebase -i \u003c基准commit\u003e\n-i：进入互动模式，可编辑历史提交。\n\u003c基准commit\u003e：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。\n操作过程：\n执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与git log的 “从新到旧” 相反）。\n每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。\n影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。\n取消 rebase：git reset ORIG_HEAD –hard\n把多个 commit 合并成一个 commit 执行git rebase -i \u003c最早要合并的commit的前一个哈希\u003e（如合并最近 3 个 commit，基准为HEAD~4）。\n在编辑器中，将目标 commit 的pick改为squash（或fixup）\n保存退出后，若用squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。\n完成后，多个 commit 被合并为一个，历史更简洁。\n把一个 commit 拆解成多个 commit 在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。\n执行git reset HEAD^指令。\n重新 commit 拆出来的文件，再执行git rebase –continue让 rebase 继续即可。\n在某些 commit 之间加新的 commit 在 rebase 互动模式下，将目标 commit 改成edit，继续执行 rebase，让 rebase 停在该 commit 上。\n注意：处于 rebase 状态的 commit 列表与平常记录相反，需确认停下来的点正确。\n增加新的 commit，完成后执行git rebase –continue，即可在指定位置中间增加新 commit。\n删除某几个 commit 或调整 commit 顺序 调整顺序：在 rebase 交互模式下调整 commit 的位置，存档离开即可。\n删除 commit：在 rebase 交互模式下，把对应 commit 的pick改成drop，或直接删掉该记录即可。\nreset、revert 和 rebase 指令的区别 指令 特点 适用场景 reset 将 HEAD 指针移动到指定 commit，可重置工作区 / 暂存区（--hard/--mixed/--soft） 通常适用于尚未推出去的 commit revert 生成新 commit 抵消目标 commit 的修改，原 commit 保留 适用于已经推出去的 commit，或不允许使用 reset 和 rebase 修改历史记录的情景。例如取消最后的 commit：git revert HEAD –no-edit（–no-edit表示不编辑 commit 信息） rebase 重建 commit 历史（修改、合并、拆分、插入 commit） 通常只适用于尚未推出去的 commit ",
  "wordCount" : "169",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h2 id="修改历史信息">修改历史信息<a hidden class="anchor" aria-hidden="true" href="#修改历史信息">#</a></h2>
<ul>
<li>
<p><strong>命令</strong>：git rebase -i &lt;基准commit&gt;</p>
</li>
<li>
<p><code>-i</code>：进入互动模式，可编辑历史提交。</p>
</li>
<li>
<p><code>&lt;基准commit&gt;</code>：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。</p>
</li>
<li>
<p><strong>操作过程</strong>：</p>
</li>
<li>
<p>执行命令后，弹出 vim 编辑器，列表中<strong>从上到下为 “从旧到新” 的 commit</strong>（与<code>git log</code>的 “从新到旧” 相反）。</p>
</li>
<li>
<p>每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。</p>
</li>
<li>
<p><strong>影响</strong>：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。</p>
</li>
<li>
<p><strong>取消 rebase</strong>：git reset ORIG_HEAD &ndash;hard</p>
</li>
</ul>
<h2 id="把多个-commit-合并成一个-commit">把多个 commit 合并成一个 commit<a hidden class="anchor" aria-hidden="true" href="#把多个-commit-合并成一个-commit">#</a></h2>
<ol>
<li>
<p>执行<code>git rebase -i &lt;最早要合并的commit的前一个哈希&gt;</code>（如合并最近 3 个 commit，基准为<code>HEAD~4</code>）。</p>
</li>
<li>
<p>在编辑器中，将目标 commit 的<code>pick</code>改为<code>squash</code>（或<code>fixup</code>）</p>
</li>
<li>
<p>保存退出后，若用<code>squash</code>：弹出编辑器，合并所有 commit 信息为一个（<code>fixup</code>则直接使用上一个 commit 的信息）。</p>
</li>
<li>
<p>完成后，多个 commit 被合并为一个，历史更简洁。</p>
</li>
</ol>
<h2 id="把一个-commit-拆解成多个-commit">把一个 commit 拆解成多个 commit<a hidden class="anchor" aria-hidden="true" href="#把一个-commit-拆解成多个-commit">#</a></h2>
<ol>
<li>
<p>在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。</p>
</li>
<li>
<p>执行git reset HEAD^指令。</p>
</li>
<li>
<p>重新 commit 拆出来的文件，再执行git rebase &ndash;continue让 rebase 继续即可。</p>
</li>
</ol>
<h2 id="在某些-commit-之间加新的-commit">在某些 commit 之间加新的 commit<a hidden class="anchor" aria-hidden="true" href="#在某些-commit-之间加新的-commit">#</a></h2>
<ol>
<li>
<p>在 rebase 互动模式下，将目标 commit 改成edit，继续执行 rebase，让 rebase 停在该 commit 上。</p>
</li>
<li>
<p>注意：处于 rebase 状态的 commit 列表与平常记录相反，需确认停下来的点正确。</p>
</li>
<li>
<p>增加新的 commit，完成后执行git rebase &ndash;continue，即可在指定位置中间增加新 commit。</p>
</li>
</ol>
<h2 id="删除某几个-commit-或调整-commit-顺序">删除某几个 commit 或调整 commit 顺序<a hidden class="anchor" aria-hidden="true" href="#删除某几个-commit-或调整-commit-顺序">#</a></h2>
<ul>
<li>
<p><strong>调整顺序</strong>：在 rebase 交互模式下调整 commit 的位置，存档离开即可。</p>
</li>
<li>
<p><strong>删除 commit</strong>：在 rebase 交互模式下，把对应 commit 的pick改成drop，或直接删掉该记录即可。</p>
</li>
</ul>
<h2 id="resetrevert-和-rebase-指令的区别">reset、revert 和 rebase 指令的区别<a hidden class="anchor" aria-hidden="true" href="#resetrevert-和-rebase-指令的区别">#</a></h2>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>特点</th>
          <th>适用场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>reset</td>
          <td>将 HEAD 指针移动到指定 commit，可重置工作区 / 暂存区（<code>--hard</code>/<code>--mixed</code>/<code>--soft</code>）</td>
          <td>通常适用于尚未推出去的 commit</td>
      </tr>
      <tr>
          <td>revert</td>
          <td>生成新 commit 抵消目标 commit 的修改，原 commit 保留</td>
          <td>适用于已经推出去的 commit，或不允许使用 reset 和 rebase 修改历史记录的情景。例如取消最后的 commit：git revert HEAD &ndash;no-edit（&ndash;no-edit表示不编辑 commit 信息）</td>
      </tr>
      <tr>
          <td>rebase</td>
          <td>重建 commit 历史（修改、合并、拆分、插入 commit）</td>
          <td>通常只适用于尚未推出去的 commit</td>
      </tr>
  </tbody>
</table>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
