<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>拾光博客 - 永浩</title>
<meta name="keywords" content="">
<meta name="description" content="一、将内容推送到 GitHub


前置准备

在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。
仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。



关联远端仓库
git remote add origin &lt;GitHub仓库地址&gt;


remote add：添加远端节点。


origin：远端 节点的默认名称（可自定义或修改）。


远端仓库管理（补充操作）

查看远端配置：git remote -v（显示远端名称、地址及操作类型，确认是否关联正确）。
修改远端地址：git remote set-url origin &lt;新地址&gt;（如仓库迁移后更新地址）。
删除远端关联：git remote remove origin（解除与远端的绑定）。





推送内容到远端
git push -u origin master

作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。
后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。
upstream 作用

本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。





推送时重命名分支
git push origin master:cat  # 将本地master推送到远端并命名为cat


二、从 GitHub 拉取更新（pull/fetch）

  
      
          命令
          本质
          适用场景
      
  
  
      
          git fetch
          仅获取远端更新（更新origin/xxx分支），不合并
          需先查看远端修改再决定是否合并（安全）
      
      
          git pull
          git fetch &#43; git merge
          快速同步远端修改（可能产生合并 commit）
      
      
          git pull --rebase
          git fetch &#43; git rebase
          保持历史线性（无合并 commit，推荐协作场景）
      
  


fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。
pull --rebase优于pull：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时）

三、推送失败的原因及解决

原因：本地版本落后于远端（远端 有更新未同步到本地）。
解决：

先拉取更新：git pull（合并入远端修改后再推送）。
强制推送（谨慎使用）：git push -f（会覆盖远端内容，仅用于协作分支使用）。



四、从服务器克隆仓库（git clone）


基本用法">
<meta name="author" content="">
<link rel="canonical" href="https://growyears.netlify.app/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://growyears.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://growyears.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://growyears.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://growyears.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://growyears.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://growyears.netlify.app/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://growyears.netlify.app/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/">
  <meta property="og:site_name" content="拾光博客 - 永浩">
  <meta property="og:title" content="拾光博客 - 永浩">
  <meta property="og:description" content="一、将内容推送到 GitHub 前置准备
在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。 关联远端仓库
git remote add origin &lt;GitHub仓库地址&gt; remote add：添加远端节点。
origin：远端 节点的默认名称（可自定义或修改）。
远端仓库管理（补充操作） 查看远端配置：git remote -v（显示远端名称、地址及操作类型，确认是否关联正确）。 修改远端地址：git remote set-url origin &lt;新地址&gt;（如仓库迁移后更新地址）。 删除远端关联：git remote remove origin（解除与远端的绑定）。 推送内容到远端
git push -u origin master 作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。 后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。 upstream 作用 本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。 推送时重命名分支
git push origin master:cat # 将本地master推送到远端并命名为cat 二、从 GitHub 拉取更新（pull/fetch） 命令 本质 适用场景 git fetch 仅获取远端更新（更新origin/xxx分支），不合并 需先查看远端修改再决定是否合并（安全） git pull git fetch &#43; git merge 快速同步远端修改（可能产生合并 commit） git pull --rebase git fetch &#43; git rebase 保持历史线性（无合并 commit，推荐协作场景） fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。 pull --rebase优于pull：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时） 三、推送失败的原因及解决 原因：本地版本落后于远端（远端 有更新未同步到本地）。 解决： 先拉取更新：git pull（合并入远端修改后再推送）。 强制推送（谨慎使用）：git push -f（会覆盖远端内容，仅用于协作分支使用）。 四、从服务器克隆仓库（git clone） 基本用法">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="一、将内容推送到 GitHub


前置准备

在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。
仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。



关联远端仓库
git remote add origin &lt;GitHub仓库地址&gt;


remote add：添加远端节点。


origin：远端 节点的默认名称（可自定义或修改）。


远端仓库管理（补充操作）

查看远端配置：git remote -v（显示远端名称、地址及操作类型，确认是否关联正确）。
修改远端地址：git remote set-url origin &lt;新地址&gt;（如仓库迁移后更新地址）。
删除远端关联：git remote remove origin（解除与远端的绑定）。





推送内容到远端
git push -u origin master

作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。
后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。
upstream 作用

本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。





推送时重命名分支
git push origin master:cat  # 将本地master推送到远端并命名为cat


二、从 GitHub 拉取更新（pull/fetch）

  
      
          命令
          本质
          适用场景
      
  
  
      
          git fetch
          仅获取远端更新（更新origin/xxx分支），不合并
          需先查看远端修改再决定是否合并（安全）
      
      
          git pull
          git fetch &#43; git merge
          快速同步远端修改（可能产生合并 commit）
      
      
          git pull --rebase
          git fetch &#43; git rebase
          保持历史线性（无合并 commit，推荐协作场景）
      
  


fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。
pull --rebase优于pull：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时）

三、推送失败的原因及解决

原因：本地版本落后于远端（远端 有更新未同步到本地）。
解决：

先拉取更新：git pull（合并入远端修改后再推送）。
强制推送（谨慎使用）：git push -f（会覆盖远端内容，仅用于协作分支使用）。



四、从服务器克隆仓库（git clone）


基本用法">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://growyears.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://growyears.netlify.app/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "一、将内容推送到 GitHub 前置准备\n在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。 关联远端仓库\ngit remote add origin \u0026lt;GitHub仓库地址\u0026gt; remote add：添加远端节点。\norigin：远端 节点的默认名称（可自定义或修改）。\n远端仓库管理（补充操作） 查看远端配置：git remote -v（显示远端名称、地址及操作类型，确认是否关联正确）。 修改远端地址：git remote set-url origin \u0026lt;新地址\u0026gt;（如仓库迁移后更新地址）。 删除远端关联：git remote remove origin（解除与远端的绑定）。 推送内容到远端\ngit push -u origin master 作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。 后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。 upstream 作用 本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。 推送时重命名分支\ngit push origin master:cat # 将本地master推送到远端并命名为cat 二、从 GitHub 拉取更新（pull/fetch） 命令 本质 适用场景 git fetch 仅获取远端更新（更新origin/xxx分支），不合并 需先查看远端修改再决定是否合并（安全） git pull git fetch + git merge 快速同步远端修改（可能产生合并 commit） git pull --rebase git fetch + git rebase 保持历史线性（无合并 commit，推荐协作场景） fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。 pull --rebase优于pull：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时） 三、推送失败的原因及解决 原因：本地版本落后于远端（远端 有更新未同步到本地）。 解决： 先拉取更新：git pull（合并入远端修改后再推送）。 强制推送（谨慎使用）：git push -f（会覆盖远端内容，仅用于协作分支使用）。 四、从服务器克隆仓库（git clone） 基本用法\n",
  "keywords": [
    
  ],
  "articleBody": "一、将内容推送到 GitHub 前置准备\n在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。 关联远端仓库\ngit remote add origin remote add：添加远端节点。\norigin：远端 节点的默认名称（可自定义或修改）。\n远端仓库管理（补充操作） 查看远端配置：git remote -v（显示远端名称、地址及操作类型，确认是否关联正确）。 修改远端地址：git remote set-url origin \u003c新地址\u003e（如仓库迁移后更新地址）。 删除远端关联：git remote remove origin（解除与远端的绑定）。 推送内容到远端\ngit push -u origin master 作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。 后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。 upstream 作用 本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。 推送时重命名分支\ngit push origin master:cat # 将本地master推送到远端并命名为cat 二、从 GitHub 拉取更新（pull/fetch） 命令 本质 适用场景 git fetch 仅获取远端更新（更新origin/xxx分支），不合并 需先查看远端修改再决定是否合并（安全） git pull git fetch + git merge 快速同步远端修改（可能产生合并 commit） git pull --rebase git fetch + git rebase 保持历史线性（无合并 commit，推荐协作场景） fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。 pull --rebase优于pull：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时） 三、推送失败的原因及解决 原因：本地版本落后于远端（远端 有更新未同步到本地）。 解决： 先拉取更新：git pull（合并入远端修改后再推送）。 强制推送（谨慎使用）：git push -f（会覆盖远端内容，仅用于协作分支使用）。 四、从服务器克隆仓库（git clone） 基本用法\ngit clone \u003c仓库地址\u003e # 克隆到同名目录 git clone \u003c仓库地址\u003e \u003c自定义目录名\u003e # 克隆到指定目录 克隆内容：包含完整文件、历史记录、分支、标签等。\n浅克隆（适合大型仓库）\ngit clone --depth 1 \u003c仓库地址\u003e # 仅克隆最近1个提交，节省时间和空间（但丢失完整历史） 克隆指定分支\ngit clone -b \u003c分支名\u003e --single-branch \u003c仓库地址\u003e # 仅克隆指定分支，减少冗余 与 pull 的区别\nclone：首次下载完整仓库时使用。 pull：已克隆仓库后，拉取后续更新时使用。 五、协作与 Pull Request（PR） PR 流程 Fork：复制原作者仓库到自己的 GitHub 账号（获得完整修改权限）。 修改并推送：在自己的仓库中修改，推送至自己的远端。 创建 PR：向原作者发送合并请求，原作者审核后可合并到其主仓库。 同步原仓库更新\n方法 1：删除自己的 Fork 仓库，重新 Fork（简单但丢失本地修改）。\n方法 2：关联原仓库为上游，手动同步：\n# 1. 添加原仓库为远端节点（命名为upstream） git remote add upstream \u003c原仓库地址\u003e # 2. 查看远端节点（确认配置） git remote -v # 3. 拉取原仓库更新 git fetch upstream # 4. 合并到本地分支（如master） git merge upstream/master # 5. 推送到自己的仓库 git push origin master 六、删除远端分支 git push origin :\u003c分支名\u003e # 如 git push origin :cat 删除远端cat分支 原理：向远端分支推送 “空内容”，变相删除该分支。 更直观的现代命令：\ngit push origin --delete \u003c分支名\u003e # 如 git push origin --delete feature/old（推荐，可读性更高） 七、git push -f（强制推送）的使用场景 适用情况： 整理历史记录后（如用 rebase 修改本地历史，需强制覆盖远端）。 仅用于个人分支（避免影响协作分支）。 风险：覆盖远端历史，导致他人修改丢失，协作场景慎用。 更安全的替代：git push --force-with-lease（先检查远端是否有未同步的修改，有则拒绝推送，避免误覆盖）。 恢复：若误操作，可重新强制推送正确历史：git push -f。 八、使用 GitHub 搭建静态网站（GitHub Pages） 基本用法 推送内容到 gh-pages 分支，GitHub 会自动部署为静态网站。 仓库命名为 username.github.io 时，可通过 https://username.github.io 访问。 限制 仅支持静态内容（HTML/CSS/JS），不支持 PHP/ASP 等动态语言。 不支持 .htaccess 配置，内容公开可见。 自定义域名步骤： 仓库根目录添加CNAME文件，内容为域名（如blog.example.com）。 域名解析平台添加CNAME记录，指向username.github.io。 GitHub 仓库→Settings → Pages → Custom domain填写域名，启用 HTTPS。 九、离线共享更新（git format-patch \u0026 git am） 生成更新补丁\ngit format-patch A...B # 生成从A（不含）到B的所有commit补丁 git format-patch -2 -o /temp/patches # 生成最近2个commit的补丁，保存到/temp/patches 应用补丁\ngit am /tmp/patches/* # 批量应用补丁 冲突处理：\n冲突时执行git am --abort放弃，或解决冲突后git add . \u0026\u0026 git am --continue。\n",
  "wordCount" : "315",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://growyears.netlify.app/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "拾光博客 - 永浩",
    "logo": {
      "@type": "ImageObject",
      "url": "https://growyears.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://growyears.netlify.app/" accesskey="h" title="拾光博客 - 永浩 (Alt + H)">拾光博客 - 永浩</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h4 id="一将内容推送到-github">一、将内容推送到 GitHub<a hidden class="anchor" aria-hidden="true" href="#一将内容推送到-github">#</a></h4>
<ul>
<li>
<p><strong>前置准备</strong></p>
<ul>
<li>在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。</li>
<li>仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。</li>
</ul>
</li>
<li>
<p><strong>关联远端仓库</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git remote add origin &lt;GitHub仓库地址&gt;
</span></span></code></pre></div><ul>
<li>
<p><code>remote add</code>：添加远端节点。</p>
</li>
<li>
<p><code>origin</code>：远端 节点的默认名称（可自定义或修改）。</p>
</li>
<li>
<h4 id="远端仓库管理补充操作">远端仓库管理（补充操作）<a hidden class="anchor" aria-hidden="true" href="#远端仓库管理补充操作">#</a></h4>
<ul>
<li><strong>查看远端配置</strong>：<code>git remote -v</code>（显示远端名称、地址及操作类型，确认是否关联正确）。</li>
<li><strong>修改远端地址</strong>：<code>git remote set-url origin &lt;新地址&gt;</code>（如仓库迁移后更新地址）。</li>
<li><strong>删除远端关联</strong>：<code>git remote remove origin</code>（解除与远端的绑定）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>推送内容到远端</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git push -u origin master
</span></span></code></pre></div><ul>
<li>作用：将本地 <code>master</code> 分支推送到 <code>origin</code> 远端，若远端无 <code>master</code> 则创建，同时通过 <code>-u</code> 设置 upstream（上游跟踪关系）。</li>
<li>后续推送：设置 upstream 后，直接执行 <code>git push</code> 即可（无需重复指定远端和分支）。</li>
<li><strong>upstream 作用</strong>
<ul>
<li>本地分支通过 <code>-u</code> 关联远端分支（如 <code>origin/master</code>）后，<code>pull/push</code> 会默认操作关联的远端分支。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>推送时重命名分支</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git push origin master:cat  <span style="color:#75715e"># 将本地master推送到远端并命名为cat</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="二从-github-拉取更新pullfetch">二、从 GitHub 拉取更新（pull/fetch）<a hidden class="anchor" aria-hidden="true" href="#二从-github-拉取更新pullfetch">#</a></h4>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>本质</th>
          <th>适用场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git fetch</code></td>
          <td>仅获取远端更新（更新<code>origin/xxx</code>分支），不合并</td>
          <td>需先查看远端修改再决定是否合并（安全）</td>
      </tr>
      <tr>
          <td><code>git pull</code></td>
          <td><code>git fetch + git merge</code></td>
          <td>快速同步远端修改（可能产生合并 commit）</td>
      </tr>
      <tr>
          <td><code>git pull --rebase</code></td>
          <td><code>git fetch + git rebase</code></td>
          <td>保持历史线性（无合并 commit，推荐协作场景）</td>
      </tr>
  </tbody>
</table>
<ul>
<li><code>fetch</code>是 “安全查看”：获取后可通过<code>git diff origin/main</code>对比本地与远端差异，再手动<code>merge</code>或<code>rebase</code>。</li>
<li><code>pull --rebase</code>优于<code>pull</code>：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时）</li>
</ul>
<h4 id="三推送失败的原因及解决">三、推送失败的原因及解决<a hidden class="anchor" aria-hidden="true" href="#三推送失败的原因及解决">#</a></h4>
<ul>
<li><strong>原因</strong>：本地版本落后于远端（远端 有更新未同步到本地）。</li>
<li>解决：
<ol>
<li>先拉取更新：<code>git pull</code>（合并入远端修改后再推送）。</li>
<li>强制推送（谨慎使用）：<code>git push -f</code>（会覆盖远端内容，仅用于协作分支使用）。</li>
</ol>
</li>
</ul>
<h4 id="四从服务器克隆仓库git-clone">四、从服务器克隆仓库（git clone）<a hidden class="anchor" aria-hidden="true" href="#四从服务器克隆仓库git-clone">#</a></h4>
<ol>
<li>
<p><strong>基本用法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone &lt;仓库地址&gt;  <span style="color:#75715e"># 克隆到同名目录</span>
</span></span><span style="display:flex;"><span>git clone &lt;仓库地址&gt; &lt;自定义目录名&gt;  <span style="color:#75715e"># 克隆到指定目录</span>
</span></span></code></pre></div><ul>
<li>
<p>克隆内容：包含完整文件、历史记录、分支、标签等。</p>
</li>
<li>
<p>浅克隆（适合大型仓库）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone --depth <span style="color:#ae81ff">1</span> &lt;仓库地址&gt;  <span style="color:#75715e"># 仅克隆最近1个提交，节省时间和空间（但丢失完整历史）</span>
</span></span></code></pre></div></li>
<li>
<p>克隆指定分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone -b &lt;分支名&gt; --single-branch &lt;仓库地址&gt;  <span style="color:#75715e"># 仅克隆指定分支，减少冗余</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>与 pull 的区别</strong></p>
<ul>
<li><code>clone</code>：首次下载完整仓库时使用。</li>
<li><code>pull</code>：已克隆仓库后，拉取后续更新时使用。</li>
</ul>
</li>
</ol>
<h4 id="五协作与-pull-requestpr">五、协作与 Pull Request（PR）<a hidden class="anchor" aria-hidden="true" href="#五协作与-pull-requestpr">#</a></h4>
<ul>
<li><strong>PR 流程</strong>
<ul>
<li><strong>Fork</strong>：复制原作者仓库到自己的 GitHub 账号（获得完整修改权限）。</li>
<li><strong>修改并推送</strong>：在自己的仓库中修改，推送至自己的远端。</li>
<li><strong>创建 PR</strong>：向原作者发送合并请求，原作者审核后可合并到其主仓库。</li>
</ul>
</li>
</ul>
<p><strong>同步原仓库更新</strong></p>
<ul>
<li>
<p>方法 1：删除自己的 Fork 仓库，重新 Fork（简单但丢失本地修改）。</p>
</li>
<li>
<p>方法 2：关联原仓库为上游，手动同步：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. 添加原仓库为远端节点（命名为upstream）</span>
</span></span><span style="display:flex;"><span>git remote add upstream &lt;原仓库地址&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 查看远端节点（确认配置）</span>
</span></span><span style="display:flex;"><span>git remote -v
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. 拉取原仓库更新</span>
</span></span><span style="display:flex;"><span>git fetch upstream
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. 合并到本地分支（如master）</span>
</span></span><span style="display:flex;"><span>git merge upstream/master
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. 推送到自己的仓库</span>
</span></span><span style="display:flex;"><span>git push origin master
</span></span></code></pre></div></li>
</ul>
<h4 id="六删除远端分支">六、删除远端分支<a hidden class="anchor" aria-hidden="true" href="#六删除远端分支">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git push origin :&lt;分支名&gt;  <span style="color:#75715e"># 如 git push origin :cat 删除远端cat分支</span>
</span></span></code></pre></div><ul>
<li>原理：向远端分支推送 “空内容”，变相删除该分支。</li>
</ul>
<p>更直观的现代命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git push origin --delete &lt;分支名&gt;  <span style="color:#75715e"># 如 git push origin --delete feature/old（推荐，可读性更高）</span>
</span></span></code></pre></div><h4 id="七git-push--f强制推送的使用场景">七、git push -f（强制推送）的使用场景<a hidden class="anchor" aria-hidden="true" href="#七git-push--f强制推送的使用场景">#</a></h4>
<ul>
<li>适用情况：
<ol>
<li>整理历史记录后（如用 rebase 修改本地历史，需强制覆盖远端）。</li>
<li>仅用于个人分支（避免影响协作分支）。</li>
</ol>
</li>
<li><strong>风险</strong>：覆盖远端历史，导致他人修改丢失，协作场景慎用。</li>
<li><strong>更安全的替代</strong>：<code>git push --force-with-lease</code>（先检查远端是否有未同步的修改，有则拒绝推送，避免误覆盖）。</li>
<li><strong>恢复</strong>：若误操作，可重新强制推送正确历史：<code>git push -f</code>。</li>
</ul>
<h4 id="八使用-github-搭建静态网站github-pages">八、使用 GitHub 搭建静态网站（GitHub Pages）<a hidden class="anchor" aria-hidden="true" href="#八使用-github-搭建静态网站github-pages">#</a></h4>
<ol>
<li><strong>基本用法</strong>
<ul>
<li>推送内容到 <code>gh-pages</code> 分支，GitHub 会自动部署为静态网站。</li>
<li>仓库命名为 <code>username.github.io</code> 时，可通过 <code>https://username.github.io</code> 访问。</li>
</ul>
</li>
<li><strong>限制</strong>
<ul>
<li>仅支持静态内容（HTML/CSS/JS），不支持 PHP/ASP 等动态语言。</li>
<li>不支持 <code>.htaccess</code> 配置，内容公开可见。</li>
</ul>
</li>
<li>自定义域名步骤：
<ol>
<li>仓库根目录添加<code>CNAME</code>文件，内容为域名（如<code>blog.example.com</code>）。</li>
<li>域名解析平台添加<code>CNAME</code>记录，指向<code>username.github.io</code>。</li>
<li>GitHub 仓库→<code>Settings → Pages → Custom domain</code>填写域名，启用 HTTPS。</li>
</ol>
</li>
</ol>
<h4 id="九离线共享更新git-format-patch--git-am">九、离线共享更新（git format-patch &amp; git am）<a hidden class="anchor" aria-hidden="true" href="#九离线共享更新git-format-patch--git-am">#</a></h4>
<ol>
<li>
<p><strong>生成更新补丁</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git format-patch A...B  <span style="color:#75715e"># 生成从A（不含）到B的所有commit补丁</span>
</span></span><span style="display:flex;"><span>git format-patch -2 -o /temp/patches  <span style="color:#75715e"># 生成最近2个commit的补丁，保存到/temp/patches</span>
</span></span></code></pre></div></li>
<li>
<p><strong>应用补丁</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git am /tmp/patches/*  <span style="color:#75715e"># 批量应用补丁</span>
</span></span></code></pre></div></li>
</ol>
<ul>
<li>
<p>冲突处理：</p>
<p>冲突时执行<code>git am --abort</code>放弃，或解决冲突后<code>git add . &amp;&amp; git am --continue</code>。</p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://growyears.netlify.app/">拾光博客 - 永浩</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
