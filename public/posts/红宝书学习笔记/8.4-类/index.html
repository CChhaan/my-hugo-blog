<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>拾光博客 - 永浩</title>
<meta name="keywords" content="">
<meta name="description" content="
本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。
与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号
与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制
类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行
类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符

constructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数
使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。
使用new调用类的构造函数会执行如下操作：

在内存中创建一个新对象
这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性
构造函数内部的this被赋值为这个新对象
执行构造函数内部的代码
如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的
默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改
类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误
类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用
ES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身
与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中
类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转
类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递
与立即调用函数表达式类似，类也可以立即实例化

通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员
每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享
为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据
类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样
可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂
静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样
虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加
类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象

ES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类
派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数
在静态方法中可以通过super调用继承的类上定义的静态方法
ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型
在使用super时要注意几个问题：

super只能在派生类构造函数和静态方法中使用
不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法
调用super会调用父类构造函数，并将返回的实例赋值给this
super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入
如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数
在类构造函数中，不能在调用super之前引用this
如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象

有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化
通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法
ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型
有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类
把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式">
<meta name="author" content="">
<link rel="canonical" href="https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://growyears.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://growyears.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://growyears.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://growyears.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://growyears.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/">
  <meta property="og:site_name" content="拾光博客 - 永浩">
  <meta property="og:title" content="拾光博客 - 永浩">
  <meta property="og:description" content=" 本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。
与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号
与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制
类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行
类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符
constructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数
使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。
使用new调用类的构造函数会执行如下操作：
在内存中创建一个新对象 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象 执行构造函数内部的代码 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的
默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改
类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误
类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用
ES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身
与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中
类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转
类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递
与立即调用函数表达式类似，类也可以立即实例化
通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员
每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享
为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据
类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样
可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂
静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样
虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加
类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象
ES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类
派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数
在静态方法中可以通过super调用继承的类上定义的静态方法
ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型
在使用super时要注意几个问题：
super只能在派生类构造函数和静态方法中使用 不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法 调用super会调用父类构造函数，并将返回的实例赋值给this super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入 如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数 在类构造函数中，不能在调用super之前引用this 如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象 有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化
通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法
ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型
有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类
把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="
本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。
与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号
与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制
类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行
类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符

constructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数
使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。
使用new调用类的构造函数会执行如下操作：

在内存中创建一个新对象
这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性
构造函数内部的this被赋值为这个新对象
执行构造函数内部的代码
如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的
默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改
类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误
类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用
ES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身
与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中
类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转
类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递
与立即调用函数表达式类似，类也可以立即实例化

通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员
每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享
为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据
类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样
可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂
静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样
虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加
类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象

ES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类
派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数
在静态方法中可以通过super调用继承的类上定义的静态方法
ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型
在使用super时要注意几个问题：

super只能在派生类构造函数和静态方法中使用
不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法
调用super会调用父类构造函数，并将返回的实例赋值给this
super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入
如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数
在类构造函数中，不能在调用super之前引用this
如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象

有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化
通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法
ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型
有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类
把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://growyears.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": " 本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。\n与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号\n与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制\n类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行\n类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符\nconstructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数\n使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。\n使用new调用类的构造函数会执行如下操作：\n在内存中创建一个新对象 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象 执行构造函数内部的代码 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的\n默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改\n类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误\n类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用\nES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身\n与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中\n类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转\n类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递\n与立即调用函数表达式类似，类也可以立即实例化\n通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员\n每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享\n为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据\n类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样\n可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂\n静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样\n虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加\n类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象\nES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类\n派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数\n在静态方法中可以通过super调用继承的类上定义的静态方法\nES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型\n在使用super时要注意几个问题：\nsuper只能在派生类构造函数和静态方法中使用 不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法 调用super会调用父类构造函数，并将返回的实例赋值给this super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入 如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数 在类构造函数中，不能在调用super之前引用this 如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象 有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化\n通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法\nES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型\n有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类\n把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式\n",
  "keywords": [
    
  ],
  "articleBody": " 本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。\n与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号\n与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制\n类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行\n类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符\nconstructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数\n使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。\n使用new调用类的构造函数会执行如下操作：\n在内存中创建一个新对象 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象 执行构造函数内部的代码 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的\n默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改\n类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误\n类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用\nES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身\n与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中\n类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转\n类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递\n与立即调用函数表达式类似，类也可以立即实例化\n通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员\n每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享\n为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据\n类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样\n可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂\n静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样\n虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加\n类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象\nES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类\n派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数\n在静态方法中可以通过super调用继承的类上定义的静态方法\nES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型\n在使用super时要注意几个问题：\nsuper只能在派生类构造函数和静态方法中使用 不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法 调用super会调用父类构造函数，并将返回的实例赋值给this super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入 如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数 在类构造函数中，不能在调用super之前引用this 如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象 有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化\n通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法\nES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型\n有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类\n把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式\n",
  "wordCount" : "48",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.4-%E7%B1%BB/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "拾光博客 - 永浩",
    "logo": {
      "@type": "ImageObject",
      "url": "https://growyears.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://growyears.netlify.app/" accesskey="h" title="拾光博客 - 永浩 (Alt + H)">拾光博客 - 永浩</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><blockquote>
<p>本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。</p></blockquote>
<p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号</p>
<p>与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制</p>
<p>类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行</p>
<p>类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符</p>
<hr>
<p>constructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数</p>
<p>使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。</p>
<p>使用new调用类的构造函数会执行如下操作：</p>
<ul>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性</li>
<li>构造函数内部的this被赋值为这个新对象</li>
<li>执行构造函数内部的代码</li>
<li>如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象</li>
</ul>
<p>类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的</p>
<p>默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改</p>
<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误</p>
<p>类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用</p>
<p>ES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身</p>
<p>与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中</p>
<p>类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转</p>
<p>类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递</p>
<p>与立即调用函数表达式类似，类也可以立即实例化</p>
<hr>
<p>通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员</p>
<p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享</p>
<p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据</p>
<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样</p>
<p>可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂</p>
<p>静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样</p>
<p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加</p>
<p>类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象</p>
<hr>
<p>ES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类</p>
<p>派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数</p>
<p>在静态方法中可以通过super调用继承的类上定义的静态方法</p>
<p>ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型</p>
<p>在使用super时要注意几个问题：</p>
<ul>
<li>super只能在派生类构造函数和静态方法中使用</li>
<li>不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法</li>
<li>调用super会调用父类构造函数，并将返回的实例赋值给this</li>
<li>super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</li>
<li>如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数</li>
<li>在类构造函数中，不能在调用super之前引用this</li>
<li>如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象</li>
</ul>
<p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化</p>
<p>通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法</p>
<p>ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型</p>
<p>有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类</p>
<p>把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://growyears.netlify.app/">拾光博客 - 永浩</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
