<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。
属性的类型
ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]
属性分两种：数据属性和访问器属性
数据属性
数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。
数据属性有四个特性描述它们的行为：

[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true
[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true
[[Writable]]：表示属性的值是否可以被修改，默认是true
[[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined

要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值
let person = {}
Object.defineProperty(person,&#39;name&#39;,{
    writable: false,
    value: &#39;Nicholas&#39;
})
在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false
访问器属性
访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：

[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true
[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true
[[Get]]：获取函数，在读取属性时调用。默认是undefined
[[Set]]：设置函数，在写入属性时调用，默认是undefined

访问器属性是不能直接定义的，必须使用Object.defineProperty()
let book = {
    year_: 2017,
    edition: 1
}
Object.defineProperty(book, &#39;year&#39;, {
    get(){
        return this.year_
    }
    set(){
        if(newValue&gt;2017){
            this.year_ = newValue
            this.edition &#43;= newValue - 2017
        }
	}
})
获取和设置函数不一定都要定义。
定义多个属性
Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。
let book = {}
Object.defineProperties(book, {
	year_: {
		value: 2017
	},
	
	edition: {
		value: 1
	}
	
	year:{
        get(){
            return this.year_
        }
        set(){
            if(newValue&gt;2017){
                this.year_ = newValue
                this.edition &#43;= newValue - 2017
            }
        }
	}
})
读取属性的特性
使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性
Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。
属性的类型 ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]
属性分两种：数据属性和访问器属性
数据属性 数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。
数据属性有四个特性描述它们的行为：
[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Writable]]：表示属性的值是否可以被修改，默认是true [[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined 要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值
let person = {} Object.defineProperty(person,&#39;name&#39;,{ writable: false, value: &#39;Nicholas&#39; }) 在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false
访问器属性 访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：
[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Get]]：获取函数，在读取属性时调用。默认是undefined [[Set]]：设置函数，在写入属性时调用，默认是undefined 访问器属性是不能直接定义的，必须使用Object.defineProperty()
let book = { year_: 2017, edition: 1 } Object.defineProperty(book, &#39;year&#39;, { get(){ return this.year_ } set(){ if(newValue&gt;2017){ this.year_ = newValue this.edition &#43;= newValue - 2017 } } }) 获取和设置函数不一定都要定义。
定义多个属性 Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。
let book = {} Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 } year:{ get(){ return this.year_ } set(){ if(newValue&gt;2017){ this.year_ = newValue this.edition &#43;= newValue - 2017 } } } }) 读取属性的特性 使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性 Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。
属性的类型
ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]
属性分两种：数据属性和访问器属性
数据属性
数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。
数据属性有四个特性描述它们的行为：

[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true
[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true
[[Writable]]：表示属性的值是否可以被修改，默认是true
[[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined

要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值
let person = {}
Object.defineProperty(person,&#39;name&#39;,{
    writable: false,
    value: &#39;Nicholas&#39;
})
在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false
访问器属性
访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：

[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true
[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true
[[Get]]：获取函数，在读取属性时调用。默认是undefined
[[Set]]：设置函数，在写入属性时调用，默认是undefined

访问器属性是不能直接定义的，必须使用Object.defineProperty()
let book = {
    year_: 2017,
    edition: 1
}
Object.defineProperty(book, &#39;year&#39;, {
    get(){
        return this.year_
    }
    set(){
        if(newValue&gt;2017){
            this.year_ = newValue
            this.edition &#43;= newValue - 2017
        }
	}
})
获取和设置函数不一定都要定义。
定义多个属性
Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。
let book = {}
Object.defineProperties(book, {
	year_: {
		value: 2017
	},
	
	edition: {
		value: 1
	}
	
	year:{
        get(){
            return this.year_
        }
        set(){
            if(newValue&gt;2017){
                this.year_ = newValue
                this.edition &#43;= newValue - 2017
            }
        }
	}
})
读取属性的特性
使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性
Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。\n属性的类型 ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]\n属性分两种：数据属性和访问器属性\n数据属性 数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。\n数据属性有四个特性描述它们的行为：\n[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Writable]]：表示属性的值是否可以被修改，默认是true [[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined 要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值\nlet person = {} Object.defineProperty(person,\u0026#39;name\u0026#39;,{ writable: false, value: \u0026#39;Nicholas\u0026#39; }) 在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false\n访问器属性 访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：\n[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Get]]：获取函数，在读取属性时调用。默认是undefined [[Set]]：设置函数，在写入属性时调用，默认是undefined 访问器属性是不能直接定义的，必须使用Object.defineProperty()\nlet book = { year_: 2017, edition: 1 } Object.defineProperty(book, \u0026#39;year\u0026#39;, { get(){ return this.year_ } set(){ if(newValue\u0026gt;2017){ this.year_ = newValue this.edition += newValue - 2017 } } }) 获取和设置函数不一定都要定义。\n定义多个属性 Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。\nlet book = {} Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 } year:{ get(){ return this.year_ } set(){ if(newValue\u0026gt;2017){ this.year_ = newValue this.edition += newValue - 2017 } } } }) 读取属性的特性 使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性 Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。\n",
  "keywords": [
    
  ],
  "articleBody": "对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。\n属性的类型 ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]\n属性分两种：数据属性和访问器属性\n数据属性 数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。\n数据属性有四个特性描述它们的行为：\n[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Writable]]：表示属性的值是否可以被修改，默认是true [[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined 要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值\nlet person = {} Object.defineProperty(person,'name',{ writable: false, value: 'Nicholas' }) 在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false\n访问器属性 访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：\n[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Get]]：获取函数，在读取属性时调用。默认是undefined [[Set]]：设置函数，在写入属性时调用，默认是undefined 访问器属性是不能直接定义的，必须使用Object.defineProperty()\nlet book = { year_: 2017, edition: 1 } Object.defineProperty(book, 'year', { get(){ return this.year_ } set(){ if(newValue\u003e2017){ this.year_ = newValue this.edition += newValue - 2017 } } }) 获取和设置函数不一定都要定义。\n定义多个属性 Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。\nlet book = {} Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 } year:{ get(){ return this.year_ } set(){ if(newValue\u003e2017){ this.year_ = newValue this.edition += newValue - 2017 } } } }) 读取属性的特性 使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性 Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。\n合并对象 Object.assign()方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[GET]]取得属性的值，然后使用目标对象上的[[SET]]设置属性的值\nObject.assign()实际上对每个源对象执行的是浅复制，如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数\n如果赋值期间出错,则操作会终止并退出,同时抛出错误。Object.assign()没有回滚之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法\n对象标识及相等判定 Object.is()方法和===很像，同时考虑到边界情况，这个方法接收两个参数。\n增强的对象的语法 属性值简写 在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。简写属性名只需要使用变量名就会自动被解释为同名的属性键。如果没有找到同名的变量，会抛错\nlet person = { name\t//相当于name: name } 可计算属性 可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值。\n简写方法名 原先：\nlet person = { sayName: function(name){} } 现在：\nlet person = { sayName(name){} } 简写方法名与可计算属性键相互兼容\n对象解构 可以在一条语句中使用嵌套数据实现一个或多个赋值操作。就是使用与对象匹配的结构来实现对象属性赋值。 使用解构可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。 解构赋值不一定与对象的属性匹配，赋值的时候可以忽略某些属性，如果引用的属性不存在，则该变量的值就是undefined 也可以在解构赋值的同时定义默认值\n解构在内部使用函数toObject()把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象，null和undefined不能被解构，否则会抛出错误。 解构不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中。\nlet personName,personAge let person = { name: 'Matt', age: 27 } ({name:personName, age:personAge} = person) 嵌套解构 解构对于引用嵌套的属性或赋值目标没有限制，可以通过解构来复制对象属性\nlet person ={ name: 'Matt', age: 27, job: { title: 'Egineer' } } let personCopy = {} ({ name: personCopy.name, age: personCopy.age, job: personCopy.job } = person) person.job.title='Hacker'\t//会影响person和personCopy 解构赋值也可以使用嵌套解构，来匹配嵌套的属性。 无论源对象还是目标对象，在外层属性没有定义的情况下不能使用嵌套解构。（未声明）\n部分解构 涉及多个属性的解构赋值是一个输出无关的顺序化操作，如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。 在函数参数列表中也可以进行解构赋值。\n参数上下文匹配 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响arguments对象，但可以在函数签名中声明在函数体内使用局部变量。\n",
  "wordCount" : "196",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><p>对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。</p>
<h1 id="属性的类型">属性的类型<a hidden class="anchor" aria-hidden="true" href="#属性的类型">#</a></h1>
<p>ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]</p>
<p>属性分两种：数据属性和访问器属性</p>
<h2 id="数据属性">数据属性<a hidden class="anchor" aria-hidden="true" href="#数据属性">#</a></h2>
<p>数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。</p>
<p>数据属性有四个特性描述它们的行为：</p>
<ul>
<li>[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true</li>
<li>[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true</li>
<li>[[Writable]]：表示属性的值是否可以被修改，默认是true</li>
<li>[[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined</li>
</ul>
<p>要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">person</span>,<span style="color:#e6db74">&#39;name&#39;</span>,{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">writable</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Nicholas&#39;</span>
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false</p>
<h2 id="访问器属性">访问器属性<a hidden class="anchor" aria-hidden="true" href="#访问器属性">#</a></h2>
<p>访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：</p>
<ul>
<li>[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true</li>
<li>[[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true</li>
<li>[[Get]]：获取函数，在读取属性时调用。默认是undefined</li>
<li>[[Set]]：设置函数，在写入属性时调用，默认是undefined</li>
</ul>
<p>访问器属性是不能直接定义的，必须使用Object.defineProperty()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">year_</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2017</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">edition</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">book</span>, <span style="color:#e6db74">&#39;year&#39;</span>, {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">get</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">year_</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">newValue</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">2017</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">year_</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newValue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">edition</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">newValue</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2017</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>获取和设置函数不一定都要定义。</p>
<h1 id="定义多个属性">定义多个属性<a hidden class="anchor" aria-hidden="true" href="#定义多个属性">#</a></h1>
<p>Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">book</span> <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>Object.<span style="color:#a6e22e">defineProperties</span>(<span style="color:#a6e22e">book</span>, {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">year_</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2017</span>
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">edition</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">year</span><span style="color:#f92672">:</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">get</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">year_</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">set</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">newValue</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">2017</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">year_</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newValue</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">edition</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">newValue</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2017</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h1 id="读取属性的特性">读取属性的特性<a hidden class="anchor" aria-hidden="true" href="#读取属性的特性">#</a></h1>
<p>使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性
Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。</p>
<h1 id="合并对象">合并对象<a hidden class="anchor" aria-hidden="true" href="#合并对象">#</a></h1>
<p>Object.assign()方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[GET]]取得属性的值，然后使用目标对象上的[[SET]]设置属性的值</p>
<p>Object.assign()实际上对每个源对象执行的是浅复制，如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数</p>
<p>如果赋值期间出错,则操作会终止并退出,同时抛出错误。Object.assign()没有回滚之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法</p>
<h1 id="对象标识及相等判定">对象标识及相等判定<a hidden class="anchor" aria-hidden="true" href="#对象标识及相等判定">#</a></h1>
<p>Object.is()方法和===很像，同时考虑到边界情况，这个方法接收两个参数。</p>
<h1 id="增强的对象的语法">增强的对象的语法<a hidden class="anchor" aria-hidden="true" href="#增强的对象的语法">#</a></h1>
<h2 id="属性值简写">属性值简写<a hidden class="anchor" aria-hidden="true" href="#属性值简写">#</a></h2>
<p>在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。简写属性名只需要使用变量名就会自动被解释为同名的属性键。如果没有找到同名的变量，会抛错</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">name</span>	<span style="color:#75715e">//相当于name: name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="可计算属性">可计算属性<a hidden class="anchor" aria-hidden="true" href="#可计算属性">#</a></h2>
<p>可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值。</p>
<h2 id="简写方法名">简写方法名<a hidden class="anchor" aria-hidden="true" href="#简写方法名">#</a></h2>
<p>原先：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sayName</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">name</span>){}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sayName</span>(<span style="color:#a6e22e">name</span>){}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>简写方法名与可计算属性键相互兼容</p>
<h1 id="对象解构">对象解构<a hidden class="anchor" aria-hidden="true" href="#对象解构">#</a></h1>
<p>可以在一条语句中使用嵌套数据实现一个或多个赋值操作。就是使用与对象匹配的结构来实现对象属性赋值。
使用解构可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。
解构赋值不一定与对象的属性匹配，赋值的时候可以忽略某些属性，如果引用的属性不存在，则该变量的值就是undefined
也可以在解构赋值的同时定义默认值</p>
<p>解构在内部使用函数toObject()把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象，null和undefined不能被解构，否则会抛出错误。
解构不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">personName</span>,<span style="color:#a6e22e">personAge</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Matt&#39;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">27</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>({<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span><span style="color:#a6e22e">personName</span>, <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span><span style="color:#a6e22e">personAge</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span>)
</span></span></code></pre></div><h2 id="嵌套解构">嵌套解构<a hidden class="anchor" aria-hidden="true" href="#嵌套解构">#</a></h2>
<p>解构对于引用嵌套的属性或赋值目标没有限制，可以通过解构来复制对象属性</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Matt&#39;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">27</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">job</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Egineer&#39;</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">personCopy</span> <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>({
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">personCopy</span>.<span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">personCopy</span>.<span style="color:#a6e22e">age</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">job</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">personCopy</span>.<span style="color:#a6e22e">job</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">job</span>.<span style="color:#a6e22e">title</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Hacker&#39;</span>	<span style="color:#75715e">//会影响person和personCopy
</span></span></span></code></pre></div><p>解构赋值也可以使用嵌套解构，来匹配嵌套的属性。
无论源对象还是目标对象，在外层属性没有定义的情况下不能使用嵌套解构。（未声明）</p>
<h2 id="部分解构">部分解构<a hidden class="anchor" aria-hidden="true" href="#部分解构">#</a></h2>
<p>涉及多个属性的解构赋值是一个输出无关的顺序化操作，如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。
在函数参数列表中也可以进行解构赋值。</p>
<h2 id="参数上下文匹配">参数上下文匹配<a hidden class="anchor" aria-hidden="true" href="#参数上下文匹配">#</a></h2>
<p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响arguments对象，但可以在函数签名中声明在函数体内使用局部变量。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
