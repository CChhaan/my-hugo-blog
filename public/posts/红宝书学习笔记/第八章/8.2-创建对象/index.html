<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="工厂模式
function createPerson(name, age, job){
	let o = new	Object()
	o.name = name
	o.age = age
	o.job = job
	o.sayName = function(){
		console.log(this.name)
	}
	return o
}

let person1 = createPerson(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;)
let person2 = createPerson(&#34;Greg&#34;, 27, &#34;Doctor&#34;)
这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。
构造函数模式
构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
function Person(name, age, job){
	this.name = name
	this.age = age
	this.job = job
	this.sayName = function(){
		console.log(this.name)
	}
}

let person1 = new Person(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;)
let person2 = new Person(&#34;Greg&#34;, 27, &#34;Doctor&#34;)
构造函数和工厂函数的区别：

没有显式的创建对象
属性和方法直接赋值给了this
没有return

创建Person实例用new操作符，会执行如下操作：

在内存中创建一个新对象
这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。
构造函数内部的this被赋值为这个新对象(即this指向新对象)
执行构造函数内部的代码(给新对象添加属性)
如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

新创建的对象都有一个constructor属性指向构造函数
person1.constructor == Person
constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式
定义自定义构造函数可以确保实例被标识为特定类型。
构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数
构造函数也是函数
构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数
在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。
构造函数的问题
构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象
解决这个问题，可以把函数定义转移到构造函数外部
虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。
原型模式
每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。
与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。
理解原型
无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。
在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。
可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。
Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。
Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。
但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：
let person = Object.create(bipe)	//Object.getPrototypeOf(person) === bipe
原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。
虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。
只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。
hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="工厂模式 function createPerson(name, age, job){ let o = new	Object() o.name = name o.age = age o.job = job o.sayName = function(){ console.log(this.name) } return o } let person1 = createPerson(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;) let person2 = createPerson(&#34;Greg&#34;, 27, &#34;Doctor&#34;) 这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。
构造函数模式 构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
function Person(name, age, job){ this.name = name this.age = age this.job = job this.sayName = function(){ console.log(this.name) } } let person1 = new Person(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;) let person2 = new Person(&#34;Greg&#34;, 27, &#34;Doctor&#34;) 构造函数和工厂函数的区别：
没有显式的创建对象 属性和方法直接赋值给了this 没有return 创建Person实例用new操作符，会执行如下操作：
在内存中创建一个新对象 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 构造函数内部的this被赋值为这个新对象(即this指向新对象) 执行构造函数内部的代码(给新对象添加属性) 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 新创建的对象都有一个constructor属性指向构造函数
person1.constructor == Person constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式
定义自定义构造函数可以确保实例被标识为特定类型。 构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数
构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数
在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。
构造函数的问题 构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象 解决这个问题，可以把函数定义转移到构造函数外部 虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。
原型模式 每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。 与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。
理解原型 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。 在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。 可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。 Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。 Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。 但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：
let person = Object.create(bipe)	//Object.getPrototypeOf(person) === bipe 原型层级 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。 只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。 hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="工厂模式
function createPerson(name, age, job){
	let o = new	Object()
	o.name = name
	o.age = age
	o.job = job
	o.sayName = function(){
		console.log(this.name)
	}
	return o
}

let person1 = createPerson(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;)
let person2 = createPerson(&#34;Greg&#34;, 27, &#34;Doctor&#34;)
这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。
构造函数模式
构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
function Person(name, age, job){
	this.name = name
	this.age = age
	this.job = job
	this.sayName = function(){
		console.log(this.name)
	}
}

let person1 = new Person(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;)
let person2 = new Person(&#34;Greg&#34;, 27, &#34;Doctor&#34;)
构造函数和工厂函数的区别：

没有显式的创建对象
属性和方法直接赋值给了this
没有return

创建Person实例用new操作符，会执行如下操作：

在内存中创建一个新对象
这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。
构造函数内部的this被赋值为这个新对象(即this指向新对象)
执行构造函数内部的代码(给新对象添加属性)
如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

新创建的对象都有一个constructor属性指向构造函数
person1.constructor == Person
constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式
定义自定义构造函数可以确保实例被标识为特定类型。
构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数
构造函数也是函数
构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数
在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。
构造函数的问题
构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象
解决这个问题，可以把函数定义转移到构造函数外部
虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。
原型模式
每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。
与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。
理解原型
无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。
在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。
可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。
Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。
Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。
但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：
let person = Object.create(bipe)	//Object.getPrototypeOf(person) === bipe
原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。
虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。
只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。
hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "工厂模式 function createPerson(name, age, job){ let o = new\tObject() o.name = name o.age = age o.job = job o.sayName = function(){ console.log(this.name) } return o } let person1 = createPerson(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Egineer\u0026#34;) let person2 = createPerson(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;) 这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。\n构造函数模式 构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。\nfunction Person(name, age, job){ this.name = name this.age = age this.job = job this.sayName = function(){ console.log(this.name) } } let person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Egineer\u0026#34;) let person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;) 构造函数和工厂函数的区别：\n没有显式的创建对象 属性和方法直接赋值给了this 没有return 创建Person实例用new操作符，会执行如下操作：\n在内存中创建一个新对象 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 构造函数内部的this被赋值为这个新对象(即this指向新对象) 执行构造函数内部的代码(给新对象添加属性) 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 新创建的对象都有一个constructor属性指向构造函数\nperson1.constructor == Person constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式\n定义自定义构造函数可以确保实例被标识为特定类型。 构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数\n在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数\n构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数\n在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。\n构造函数的问题 构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象 解决这个问题，可以把函数定义转移到构造函数外部 虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。\n原型模式 每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。 与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。\n理解原型 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。 在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。 可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。 Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。 Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。 但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：\nlet person = Object.create(bipe)\t//Object.getPrototypeOf(person) === bipe 原型层级 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。 只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。 hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true\n",
  "keywords": [
    
  ],
  "articleBody": "工厂模式 function createPerson(name, age, job){ let o = new\tObject() o.name = name o.age = age o.job = job o.sayName = function(){ console.log(this.name) } return o } let person1 = createPerson(\"Nicholas\", 29, \"Software Egineer\") let person2 = createPerson(\"Greg\", 27, \"Doctor\") 这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。\n构造函数模式 构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。\nfunction Person(name, age, job){ this.name = name this.age = age this.job = job this.sayName = function(){ console.log(this.name) } } let person1 = new Person(\"Nicholas\", 29, \"Software Egineer\") let person2 = new Person(\"Greg\", 27, \"Doctor\") 构造函数和工厂函数的区别：\n没有显式的创建对象 属性和方法直接赋值给了this 没有return 创建Person实例用new操作符，会执行如下操作：\n在内存中创建一个新对象 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 构造函数内部的this被赋值为这个新对象(即this指向新对象) 执行构造函数内部的代码(给新对象添加属性) 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 新创建的对象都有一个constructor属性指向构造函数\nperson1.constructor == Person constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式\n定义自定义构造函数可以确保实例被标识为特定类型。 构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数\n在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数\n构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数\n在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。\n构造函数的问题 构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象 解决这个问题，可以把函数定义转移到构造函数外部 虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。\n原型模式 每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。 与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。\n理解原型 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。 在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。 可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。 Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。 Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。 但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：\nlet person = Object.create(bipe)\t//Object.getPrototypeOf(person) === bipe 原型层级 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。 只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。 hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true\n原型和in操作符 有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上。 在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举属性的实例属性也会返回。 要获得对象上的所有可枚举的实例属性可以使用Object.keys()方法，这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。 如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyName()\n对象迭代 Object.value()和Object.entries()接收一个对象，返回它们内容的数组。前者返回对象值的数组，后者返回键值对的数组。非字符串属性会被转换为字符串输出，执行对象的浅复制。符号属性会被忽略\n其他原型语法 可以直接通过一个包含所有属性和方法的对象字面量来重写原型，但这样重写之后constructor属性就不指向原构造函数了，指向了Object，虽然可以专门设置以下它的值，但又会造成constructor属性的Enumerable为true。可以用Object.defineProperty来解决。\nfunction Person(){} Person.prototype = { name:'Nicholas', age: 29 } Object.defineProperty(Person.prototype,\"constructor\",{ enumerable:false, value:Person }) 原型的动态性 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。 重写构造函数上的原型之后再创建的实例才会引用新的原型，而在此之前创建的实例仍然会引用最初的原型。\n原生对象原型 所有原生引用类型的构造函数都在原型上定义了实例方法。 通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。\n原型的问题 弱化了向构造函数传递初始化参数的能力 共享特性 ",
  "wordCount" : "156",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="工厂模式">工厂模式<a hidden class="anchor" aria-hidden="true" href="#工厂模式">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createPerson</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span>, <span style="color:#a6e22e">job</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span>	Object()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">age</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">job</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">job</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">o</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createPerson</span>(<span style="color:#e6db74">&#34;Nicholas&#34;</span>, <span style="color:#ae81ff">29</span>, <span style="color:#e6db74">&#34;Software Egineer&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createPerson</span>(<span style="color:#e6db74">&#34;Greg&#34;</span>, <span style="color:#ae81ff">27</span>, <span style="color:#e6db74">&#34;Doctor&#34;</span>)
</span></span></code></pre></div><p>这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。</p>
<h1 id="构造函数模式">构造函数模式<a hidden class="anchor" aria-hidden="true" href="#构造函数模式">#</a></h1>
<p>构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Person</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span>, <span style="color:#a6e22e">job</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">age</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">job</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">job</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#34;Nicholas&#34;</span>, <span style="color:#ae81ff">29</span>, <span style="color:#e6db74">&#34;Software Egineer&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#34;Greg&#34;</span>, <span style="color:#ae81ff">27</span>, <span style="color:#e6db74">&#34;Doctor&#34;</span>)
</span></span></code></pre></div><p>构造函数和工厂函数的区别：</p>
<ul>
<li>没有显式的创建对象</li>
<li>属性和方法直接赋值给了this</li>
<li>没有return</li>
</ul>
<p>创建Person实例用new操作符，会执行如下操作：</p>
<ul>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。</li>
<li>构造函数内部的this被赋值为这个新对象(即this指向新对象)</li>
<li>执行构造函数内部的代码(给新对象添加属性)</li>
<li>如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象</li>
</ul>
<p>新创建的对象都有一个constructor属性指向构造函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">constructor</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">Person</span>
</span></span></code></pre></div><p>constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式</p>
<p>定义自定义构造函数可以确保实例被标识为特定类型。
构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数</p>
<p>在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数</p>
<h2 id="构造函数也是函数">构造函数也是函数<a hidden class="anchor" aria-hidden="true" href="#构造函数也是函数">#</a></h2>
<p>构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数</p>
<p>在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。</p>
<h2 id="构造函数的问题">构造函数的问题<a hidden class="anchor" aria-hidden="true" href="#构造函数的问题">#</a></h2>
<p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象
解决这个问题，可以把函数定义转移到构造函数外部
虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。</p>
<h1 id="原型模式">原型模式<a hidden class="anchor" aria-hidden="true" href="#原型模式">#</a></h1>
<p>每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。
与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。</p>
<h2 id="理解原型">理解原型<a hidden class="anchor" aria-hidden="true" href="#理解原型">#</a></h2>
<p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。
在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。
可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。
Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。
Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。
但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">bipe</span>)	<span style="color:#75715e">//Object.getPrototypeOf(person) === bipe
</span></span></span></code></pre></div><h2 id="原型层级">原型层级<a hidden class="anchor" aria-hidden="true" href="#原型层级">#</a></h2>
<p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。
虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。
只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。
hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true</p>
<h2 id="原型和in操作符">原型和in操作符<a hidden class="anchor" aria-hidden="true" href="#原型和in操作符">#</a></h2>
<p>有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上。
在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举属性的实例属性也会返回。
要获得对象上的所有可枚举的实例属性可以使用Object.keys()方法，这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。
如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyName()</p>
<h1 id="对象迭代">对象迭代<a hidden class="anchor" aria-hidden="true" href="#对象迭代">#</a></h1>
<p>Object.value()和Object.entries()接收一个对象，返回它们内容的数组。前者返回对象值的数组，后者返回键值对的数组。非字符串属性会被转换为字符串输出，执行对象的浅复制。符号属性会被忽略</p>
<h2 id="其他原型语法">其他原型语法<a hidden class="anchor" aria-hidden="true" href="#其他原型语法">#</a></h2>
<p>可以直接通过一个包含所有属性和方法的对象字面量来重写原型，但这样重写之后constructor属性就不指向原构造函数了，指向了Object，虽然可以专门设置以下它的值，但又会造成constructor属性的Enumerable为true。可以用Object.defineProperty来解决。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Person</span>(){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#39;Nicholas&#39;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">29</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>,<span style="color:#e6db74">&#34;constructor&#34;</span>,{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">enumerable</span><span style="color:#f92672">:</span><span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span><span style="color:#a6e22e">Person</span>
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="原型的动态性">原型的动态性<a hidden class="anchor" aria-hidden="true" href="#原型的动态性">#</a></h2>
<p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。
重写构造函数上的原型之后再创建的实例才会引用新的原型，而在此之前创建的实例仍然会引用最初的原型。</p>
<h2 id="原生对象原型">原生对象原型<a hidden class="anchor" aria-hidden="true" href="#原生对象原型">#</a></h2>
<p>所有原生引用类型的构造函数都在原型上定义了实例方法。
通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。</p>
<h2 id="原型的问题">原型的问题<a hidden class="anchor" aria-hidden="true" href="#原型的问题">#</a></h2>
<ul>
<li>弱化了向构造函数传递初始化参数的能力</li>
<li>共享特性</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
