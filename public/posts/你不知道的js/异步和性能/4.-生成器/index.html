<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="一、生成器的基本概念与特性

定义与控制方式：

生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。
通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。


next()与yield的交互：

next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。
yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。


生成器实例与并发：

每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。



二、生成器产生值：生产者与迭代器
1. 迭代器接口

作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。
next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。

2. for..of循环

自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。
支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。

3. Iterable（可迭代对象）

定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。
for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。

4. 生成器迭代器的特性

生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。
异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。

三、异步迭代生成器
生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) {
  ajax(&#34;http://...&#34;, (err, data) =&gt; {
    if (err) it.throw(err); // 向生成器抛错
    else it.next(data); // 向生成器传递异步结果
  });
}

function* main() {
  try {
    const text = yield foo(11, 31); // 暂停等待异步结果
    console.log(text);
  } catch (err) {
    console.error(err); // 捕获异步错误
  }
}

const it = main();
it.next(); // 启动生成器

上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 &#43; 异步执行”。

四、生成器与 Promise 的结合

优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。
实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器：

Promise 完成时，调用it.next(结果值)恢复生成器；
Promise 拒绝时，调用it.throw(错误)向生成器抛错。



五、生成器委托（yield*）

语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。
作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。
特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。

六、形实转换程序（Thunk）

定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。
用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。

补充说明

生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。
生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。
for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。
">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="一、生成器的基本概念与特性 定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 二、生成器产生值：生产者与迭代器 1. 迭代器接口 作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 2. for..of循环 自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 3. Iterable（可迭代对象） 定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 4. 生成器迭代器的特性 生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 三、异步迭代生成器 生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&#34;http://...&#34;, (err, data) =&gt; { if (err) it.throw(err); // 向生成器抛错 else it.next(data); // 向生成器传递异步结果 }); } function* main() { try { const text = yield foo(11, 31); // 暂停等待异步结果 console.log(text); } catch (err) { console.error(err); // 捕获异步错误 } } const it = main(); it.next(); // 启动生成器 上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 &#43; 异步执行”。 四、生成器与 Promise 的结合 优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。 实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器： Promise 完成时，调用it.next(结果值)恢复生成器； Promise 拒绝时，调用it.throw(错误)向生成器抛错。 五、生成器委托（yield*） 语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。 作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。 特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。 六、形实转换程序（Thunk） 定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。 用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。 补充说明 生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。 生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。 for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。 ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="一、生成器的基本概念与特性

定义与控制方式：

生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。
通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。


next()与yield的交互：

next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。
yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。


生成器实例与并发：

每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。



二、生成器产生值：生产者与迭代器
1. 迭代器接口

作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。
next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。

2. for..of循环

自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。
支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。

3. Iterable（可迭代对象）

定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。
for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。

4. 生成器迭代器的特性

生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。
异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。

三、异步迭代生成器
生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) {
  ajax(&#34;http://...&#34;, (err, data) =&gt; {
    if (err) it.throw(err); // 向生成器抛错
    else it.next(data); // 向生成器传递异步结果
  });
}

function* main() {
  try {
    const text = yield foo(11, 31); // 暂停等待异步结果
    console.log(text);
  } catch (err) {
    console.error(err); // 捕获异步错误
  }
}

const it = main();
it.next(); // 启动生成器

上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 &#43; 异步执行”。

四、生成器与 Promise 的结合

优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。
实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器：

Promise 完成时，调用it.next(结果值)恢复生成器；
Promise 拒绝时，调用it.throw(错误)向生成器抛错。



五、生成器委托（yield*）

语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。
作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。
特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。

六、形实转换程序（Thunk）

定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。
用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。

补充说明

生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。
生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。
for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。
">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "一、生成器的基本概念与特性 定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 二、生成器产生值：生产者与迭代器 1. 迭代器接口 作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 2. for..of循环 自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 3. Iterable（可迭代对象） 定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 4. 生成器迭代器的特性 生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 三、异步迭代生成器 生成器可简化异步流程，将异步操作抽象为同步形式的代码：\nfunction foo(x, y) { ajax(\u0026#34;http://...\u0026#34;, (err, data) =\u0026gt; { if (err) it.throw(err); // 向生成器抛错 else it.next(data); // 向生成器传递异步结果 }); } function* main() { try { const text = yield foo(11, 31); // 暂停等待异步结果 console.log(text); } catch (err) { console.error(err); // 捕获异步错误 } } const it = main(); it.next(); // 启动生成器 上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 + 异步执行”。 四、生成器与 Promise 的结合 优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。 实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器： Promise 完成时，调用it.next(结果值)恢复生成器； Promise 拒绝时，调用it.throw(错误)向生成器抛错。 五、生成器委托（yield*） 语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。 作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。 特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。 六、形实转换程序（Thunk） 定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。 用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。 补充说明 生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。 生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。 for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。 ",
  "keywords": [
    
  ],
  "articleBody": "一、生成器的基本概念与特性 定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 二、生成器产生值：生产者与迭代器 1. 迭代器接口 作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 2. for..of循环 自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 3. Iterable（可迭代对象） 定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 4. 生成器迭代器的特性 生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 三、异步迭代生成器 生成器可简化异步流程，将异步操作抽象为同步形式的代码：\nfunction foo(x, y) { ajax(\"http://...\", (err, data) =\u003e { if (err) it.throw(err); // 向生成器抛错 else it.next(data); // 向生成器传递异步结果 }); } function* main() { try { const text = yield foo(11, 31); // 暂停等待异步结果 console.log(text); } catch (err) { console.error(err); // 捕获异步错误 } } const it = main(); it.next(); // 启动生成器 上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 + 异步执行”。 四、生成器与 Promise 的结合 优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。 实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器： Promise 完成时，调用it.next(结果值)恢复生成器； Promise 拒绝时，调用it.throw(错误)向生成器抛错。 五、生成器委托（yield*） 语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。 作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。 特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。 六、形实转换程序（Thunk） 定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。 用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。 补充说明 生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。 生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。 for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。 ",
  "wordCount" : "138",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h3 id="一生成器的基本概念与特性">一、生成器的基本概念与特性<a hidden class="anchor" aria-hidden="true" href="#一生成器的基本概念与特性">#</a></h3>
<ol>
<li><strong>定义与控制方式</strong>：
<ul>
<li>生成器是一类特殊函数，声明方式为<code>function*</code>（函数名前加<code>*</code>），可暂停、恢复执行，不一定需要完成。</li>
<li>通过迭代器控制生成器：调用生成器函数（如<code>*foo()</code>）会返回一个迭代器对象（如<code>it</code>），通过<code>it.next()</code>启动或恢复生成器执行，直至下一个<code>yield</code>或结束。</li>
</ul>
</li>
<li><strong><code>next()</code>与<code>yield</code>的交互</strong>：
<ul>
<li><code>next()</code>返回一个对象<code>{ value, done }</code>：<code>value</code>是<code>yield</code>产出的值，<code>done</code>为布尔值（<code>true</code>表示生成器执行完毕）。</li>
<li><code>yield</code>作为表达式可双向传递消息：<code>yield</code>向外发送值，<code>next()</code>可向暂停的<code>yield</code>传入值（第一个<code>next()</code>的参数会被忽略，因此时无暂停的<code>yield</code>）。</li>
</ul>
</li>
<li><strong>生成器实例与并发</strong>：
<ul>
<li>每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。</li>
</ul>
</li>
</ol>
<h3 id="二生成器产生值生产者与迭代器">二、生成器产生值：生产者与迭代器<a hidden class="anchor" aria-hidden="true" href="#二生成器产生值生产者与迭代器">#</a></h3>
<h4 id="1-迭代器接口">1. 迭代器接口<a hidden class="anchor" aria-hidden="true" href="#1-迭代器接口">#</a></h4>
<ul>
<li><strong>作用</strong>：定义从生产者逐步获取一系列值的标准接口，核心是<code>next()</code>方法。</li>
<li><strong><code>next()</code>返回值</strong>：<code>{ done: boolean, value: any }</code>，<code>done</code>标识迭代是否结束，<code>value</code>为当前迭代值。</li>
</ul>
<h4 id="2-forof循环">2. <code>for..of</code>循环<a hidden class="anchor" aria-hidden="true" href="#2-forof循环">#</a></h4>
<ul>
<li>自动迭代标准迭代器：每次循环调用<code>next()</code>，不传入参数，遇<code>done: true</code>自动停止。</li>
<li>支持内建可迭代对象：如数组（<code>array</code>）等内建数据结构默认实现迭代器，可直接用于<code>for..of</code>。</li>
</ul>
<h4 id="3-iterable可迭代对象">3. Iterable（可迭代对象）<a hidden class="anchor" aria-hidden="true" href="#3-iterable可迭代对象">#</a></h4>
<ul>
<li><strong>定义</strong>：包含迭代器的对象，需实现<code>Symbol.iterator</code>方法（调用时返回一个新迭代器）。</li>
<li><strong><code>for..of</code>的依赖</strong>：<code>for..of</code>循环期望操作可迭代对象，通过调用其<code>Symbol.iterator</code>获取迭代器。</li>
</ul>
<h4 id="4-生成器迭代器的特性">4. 生成器迭代器的特性<a hidden class="anchor" aria-hidden="true" href="#4-生成器迭代器的特性">#</a></h4>
<ul>
<li>生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。</li>
<li><strong>异常终止</strong>：<code>for..of</code>因<code>break</code>、<code>return</code>或未捕获异常终止时，会向迭代器发送停止信号；可手动调用<code>it.return(value)</code>终止生成器，返回<code>{ value: 传入值, done: true }</code>。</li>
</ul>
<h3 id="三异步迭代生成器">三、异步迭代生成器<a hidden class="anchor" aria-hidden="true" href="#三异步迭代生成器">#</a></h3>
<p>生成器可简化异步流程，将异步操作抽象为同步形式的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ajax</span>(<span style="color:#e6db74">&#34;http://...&#34;</span>, (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">data</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">err</span>) <span style="color:#a6e22e">it</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#a6e22e">err</span>); <span style="color:#75715e">// 向生成器抛错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">data</span>); <span style="color:#75715e">// 向生成器传递异步结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">foo</span>(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">31</span>); <span style="color:#75715e">// 暂停等待异步结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#a6e22e">err</span>); <span style="color:#75715e">// 捕获异步错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">main</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// 启动生成器
</span></span></span></code></pre></div><ul>
<li>上述代码中，<code>yield</code>等待异步操作<code>foo</code>完成，通过<code>it.next(data)</code>或<code>it.throw(err)</code>恢复执行，实现 “同步写法 + 异步执行”。</li>
</ul>
<h3 id="四生成器与-promise-的结合">四、生成器与 Promise 的结合<a hidden class="anchor" aria-hidden="true" href="#四生成器与-promise-的结合">#</a></h3>
<ul>
<li><strong>优势</strong>：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。</li>
<li>实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器：
<ul>
<li>Promise 完成时，调用<code>it.next(结果值)</code>恢复生成器；</li>
<li>Promise 拒绝时，调用<code>it.throw(错误)</code>向生成器抛错。</li>
</ul>
</li>
</ul>
<h3 id="五生成器委托yield">五、生成器委托（<code>yield*</code>）<a hidden class="anchor" aria-hidden="true" href="#五生成器委托yield">#</a></h3>
<ul>
<li><strong>语法</strong>：<code>yield* 迭代对象</code>（如<code>yield* foo()</code>，<code>foo</code>为生成器或其他可迭代对象）。</li>
<li><strong>作用</strong>：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。</li>
<li><strong>特性</strong>：支持双向消息与错误传递（目标迭代器的<code>yield</code>与当前生成器的<code>next</code>/<code>throw</code>可交互）。</li>
</ul>
<h3 id="六形实转换程序thunk">六、形实转换程序（Thunk）<a hidden class="anchor" aria-hidden="true" href="#六形实转换程序thunk">#</a></h3>
<ul>
<li><strong>定义</strong>：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。</li>
<li><strong>用途</strong>：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。</li>
</ul>
<h3 id="补充说明">补充说明<a hidden class="anchor" aria-hidden="true" href="#补充说明">#</a></h3>
<ul>
<li>生成器的<code>yield</code>数量与<code>next()</code>调用次数关系：<code>next()</code>调用次数比<code>yield</code>语句多 1（最后一次<code>next()</code>用于获取<code>done: true</code>）。</li>
<li>生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。</li>
<li><code>for..of</code>与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现<code>Symbol.iterator</code>）。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
