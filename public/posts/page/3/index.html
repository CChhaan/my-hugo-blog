<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 拾光博客 - 永浩</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 拾光博客 - 永浩">
<meta name="author" content="">
<link rel="canonical" href="https://growyears.netlify.app/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://growyears.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://growyears.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://growyears.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://growyears.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://growyears.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://growyears.netlify.app/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://growyears.netlify.app/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://growyears.netlify.app/posts/">
  <meta property="og:site_name" content="拾光博客 - 永浩">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://growyears.netlify.app/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://growyears.netlify.app/" accesskey="h" title="拾光博客 - 永浩 (Alt + H)">拾光博客 - 永浩</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、对象类型的基本定义 对象类型是 TS 中描述数据结构的核心方式，主要有三种定义形式：
匿名对象类型 直接在参数或变量声明中定义，无需命名：
function greet(person: { name: string; age: number }) { return &#34;Hello &#34; &#43; person.name; } 接口（interface） 通过interface关键字命名对象类型，支持声明合并（多次定义同一接口会自动合并），可复用：
interface Person { name: string; age: number; } function greet(person: Person) { /* ... */ } 类型别名（type alias） 通过type关键字为对象类型命名：
type Person = { name: string; age: number; }; function greet(person: Person) { /* ... */ } 面试高频对比：
场景 interface type 声明合并 支持 不支持（重复声明报错） 扩展方式 extends继承 交叉类型（&amp;）合并 适用类型 仅对象 / 类形状 任意类型（对象、联合、基础类型等） 二、对象属性的特性 对象类型的属性可通过修饰符指定特性：
可选属性
标记为?的属性可省略，类型为T | undefined（在strictNullChecks开启时需显式处理undefined）。
示例：
interface User { name: string; age?: number; // 可选属性 } const user: User = { name: &#34;Alice&#34; }; // 合法，age可省略 只读属性（readonly）
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/05--%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、类型变量 类型变量是泛型的 “灵魂”，用于在类型层面建立关联（而非值层面），解决 “同一份逻辑适配多种类型” 的问题。
基本用法 // 定义泛型函数：类型变量&lt;Type&gt;关联输入与输出类型 function identity&lt;Type&gt;(arg: Type): Type { return arg; } // 两种调用方式 let output1 = identity&lt;string&gt;(&#34;myString&#34;); // 显式指定类型参数 let output2 = identity(42); // 类型推断（推荐）：编译器自动推断Type为number 核心价值：避免重复编写不同类型的同名函数（如identityString、identityNumber），同时保持类型安全（对比any：any会丢失类型关联，泛型则保留输入与输出的类型一致性）。 类型推断：编译器可通过传入的值自动推断类型参数，简化代码。复杂场景下若推断失败，需显式指定类型。 类型约束：函数体内必须正确使用泛型参数（视为 “任意类型” 处理）。 二、泛型函数的类型定义 泛型函数的类型与非泛型函数类似，需先声明类型参数，有多种表达方式：
直接作为函数类型
let myIdentity: &lt;Type&gt;(arg: Type) =&gt; Type = identity; 使用不同名称的类型变量（只要数量和使用方式一致）
let myIdentity: &lt;Input&gt;(arg: Input) =&gt; Input = identity; // 合法：Input与Type作用相同 对象字面量的调用签名
let myIdentity: { &lt;Type&gt;(arg: Type): Type } = identity; 泛型接口
// 接口内声明泛型调用签名 interface GenericIdentityFn { &lt;Type&gt;(arg: Type): Type; } let myIdentity: GenericIdentityFn = identity; // 接口本身泛型化（更常用） interface GenericIdentityFn&lt;Type&gt; { (arg: Type): Type; } let myIdentity: GenericIdentityFn&lt;number&gt; = identity; // 绑定类型参数为number 三、泛型类 泛型类在类名后通过&lt;&gt;声明类型参数，确保类的所有实例属性使用相同类型。
基本用法 class GenericNumber&lt;NumType&gt; { zeroValue: NumType; // 实例属性使用泛型类型 add: (x: NumType, y: NumType) =&gt; NumType; // 方法参数与返回值使用泛型类型 } // 实例化时指定类型参数为number let myGenericNumber = new GenericNumber&lt;number&gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = (x, y) =&gt; x &#43; y; 注意点 静态成员限制：泛型类的类型参数仅作用于实例端，静态成员不能使用类的类型参数，静态成员属于类本身，而非实例，无法关联实例的类型变量。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/06--%E6%B3%9B%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、keyof 运算符 keyof 用于将对象类型的所有键名转换为字面量联合类型，是实现 “类型安全的键访问” 的基础。
1. 基础用法 type Point = { x: number; y: number }; type P = keyof Point; // 等价于 type P = &#34;x&#34; | &#34;y&#34; 作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。 2. 与索引签名结合 当对象类型包含 string 或 number 索引签名时，keyof 会返回对应的索引类型：
// number 索引签名 type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; // type A = number（仅允许 number 类型索引） // string 索引签名 type Mapish = { [k: string]: boolean }; type M = keyof Mapish; // type M = string | number 因为 JavaScript 会将数字索引自动转换为字符串（如 obj[0] 等价于 obj[&#34;0&#34;]），因此 string 索引签名隐含支持 number 索引。 keyof与Object.keys的区别： keyof：在类型层面工作，返回键的字面量联合类型（编译时）。 Object.keys：在值层面工作，返回键的字符串数组（运行时）。 二、typeof 运算符（类型上下文） typeof 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、条件类型 条件类型通过判断类型关系返回不同类型，基本形式为 SomeType extends OtherType ? TrueType : FalseType，核心价值在于与泛型结合实现灵活的类型逻辑。
1. 基本用法 当SomeType可赋值给OtherType时，返回TrueType；否则返回FalseType
type Example1 = Dog extends Animal ? number : string; // 若Dog是Animal的子类型，返回number 2. 与泛型结合 条件类型与泛型结合可简化重载，实现类型与值的动态关联：
// 需求：输入number返回IdLabel，输入string返回NameLabel type IdLabel = { id: number }; type NameLabel = { name: string }; // 条件类型关联输入与输出类型 type Label&lt;T extends number | string&gt; = T extends number ? IdLabel : NameLabel; // 单个函数替代重载 function createLabel&lt;T extends number | string&gt;(value: T): Label&lt;T&gt; { return typeof value === &#39;number&#39; ? { id: value } : { name: value } as Label&lt;T&gt;; } const label1 = createLabel(10); // 类型：IdLabel（{ id: number }） const label2 = createLabel(&#34;Alice&#34;); // 类型：NameLabel（{ name: string }） 3. 类型推断与 infer 通过 infer 关键字在条件类型中声明性推断类型，无需显式指定提取逻辑：
示例 1：提取数组元素类型
type Flatten&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type; type Str = Flatten&lt;string[]&gt;; // type Str = string（推断Item为string） type Num = Flatten&lt;number&gt;; // type Num = number（不满足数组，返回原类型） 示例 2：提取函数返回类型
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、类的字段 字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。
基本特性 字段声明默认创建公共可写属性，类型可显式声明（如x: number）或通过初始化值推断（如x = 0 → 推断为number）。 未指定类型且无初始化值时，隐式为any（可通过noImplicitAny禁用，强制显式声明）。 初始化相关 初始化器：字段可直接赋值（如x = 0），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。 strictPropertyInitialization 配置： 开启时，字段必须在构造函数内或初始化器中初始化，否则报错（防止访问未初始化的属性）。 例外：用!（明确赋值断言）标记 “后续会初始化” 的字段（如name!: string，常用于依赖注入场景）。 注意：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。 readonly 修饰符 标记字段为只读，仅可在初始化器或构造函数中赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。 二、构造函数 类的初始化函数，用于实例化时设置初始状态。
与函数的异同 相似性：支持类型注释、默认值、重载（如多构造函数签名）。 区别： 不能有类型参数（类型参数属于外部类声明）； 不能有返回类型注释（默认返回类实例类型）。 super () 调用要求 派生类构造函数中，使用this前必须调用super()（调用基类构造函数），否则 TypeScript 报错。 三、方法与访问器 类的函数属性，用于定义行为和属性访问逻辑。
方法 本质是类的函数属性，支持类型注释（参数和返回值）。 方法体内访问字段 / 其他方法必须通过this.，否则引用外部变量。 访问器 包括get（读取）和set（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。 TypeScript 推断规则： 仅有get时，属性自动为readonly； 未指定set参数类型时，从get返回类型推断； 4.3&#43; 版本支持get和set使用不同类型。 注意：无额外逻辑的get/set对意义不大，建议直接用公共字段。 四、索引签名 类可声明索引签名，与对象类型索引签名规则一致。
示例：class MyClass { [s: string]: boolean | ((s: string) =&gt; boolean); } 注意：需覆盖方法类型，使用复杂，建议将索引数据存储在类实例外。 五、类继承 类可通过implements和extends实现接口约束或基类继承。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/09--%E7%B1%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> JavaScript中this的绑定规则取决于函数的调用方式而非声明位置。核心规则包括：默认绑定（非严格模式绑定全局对象，严格模式为undefined）、隐式绑定（通过对象调用）、显式绑定（call/apply/bind）和new绑定（构造函数调用）。箭头函数例外，它继承外层作用域的this且不可更改。优先级顺序为：new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。特殊情况下，传入null/undefined会触发默认绑定，而硬绑定函数被new调用时会替换this。理解这些规则对掌握JavaScript的执行上下文至关重要。
this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件
this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
当一个函数被调用时，会创建一个活动记录（也称为执行上下文），这个记录会包含函数在哪里被调用，函数的调用方式，传入的参数等信息，this就是这个记录的一个属性，会在函数执行的过程中用到
调用位置就是函数在代码中被调用的位置，在当前正在执行的函数的前一个调用中
默认绑定：函数直接使用不带任何修饰的函数引用进行调用（独立函数调用），只能使用默认绑定，无法应用其他规则，非严格模式下，默认绑定绑定到全局对象，在严格模式下绑定到undefined
隐式绑定：当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象
对象属性引用链中只有上一层或者说最后一层在调用位置中起作用
显示绑定：所有函数都可以使用call()和apply()方法，它们的第一个参数是一个对象，接着在调用函数时将其绑定到this
如果传入一个原始值来当做this的绑定对象，这个原始值会被转换成它的对象形式，这通常被称为装箱
硬绑定：一种显式的强制绑定
function foo(){ console.log(this.a) } var obj = { a:2 } var bar = function(){ foo.call(obj) } 可以创建一个包裹函数，负责接收参数并返回值
var bar = function(){ return foo.apply(obj,arguments) } 另一种是创建一个可以重复使用的辅助函数
function bind(fn,obj){ return function(){ return fn.apply(obj,arguments) } } var bar = bind(foo,obj) bar(3) ES5提供了内置的方法Function.prototype.bind，返回一个硬编码的新函数，把指定的参数设置为this的上下文并调用原始函数
JS许多内置函数或第三方库函数都提供了一个可选的参数，通常被称为上下文，其作用和bind一样，确保回调函数使用指定的this，实际上都是通过call或apply实现了显示绑定
new绑定：在JS中，构造函数只是一些使用new操作符时被调用的函数，它们并不会属于某个类，也不会实例化一个类，只是被new操作符调用的普通函数而已
所有函数都可以用new调用，这种函数调用被称为构造函数调用
使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
创建一个全新的对象 这个新对象会被执行[[Prototype]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 bind()方法会判断硬绑定函数是否被new调用，如果是的话就会使用新创建的this替换硬绑定的this。
在new中使用硬绑定函数主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数
根据优先级判断this：
函数是否在new中调用？如果是的话this绑定的是新创建的对象 函数是否通过call，apply或者硬绑定调用？如果是的话，this绑定的是指定的对象 函数是否在某个上下文对象中调用？如果是的话，this绑定的是那个上下文对象 如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到undefined，否则绑定到全局对象 如果null或undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则
apply可以用来展开数组，并当做参数传入一个函数；bind可以对参数进行柯里化，预先设置一些参数
Object.create(null)可以创建一个空对象，并且不会创建Object.prototype这个委托，比{}更空
忽略this绑定时传入空对象可以避免对全局对象产生影响
有可能会创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认绑定规则
箭头函数不使用this的四种标准规则，而是根据外层作用域来决定this
箭头函数的绑定无法被修改，箭头函数可以像bind一样确保函数的this绑定到指定的对象，用常见的词法作用域取代了传统的this机制
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/1.this/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文摘要：JavaScript对象可以通过文字声明或构造形式定义，两种方式结果相同但写法不同。JS有6种基本类型和多种对象子类型，包括内置对象如Array、Date等。对象属性存储的是名称而非值本身，可通过点语法或块访问访问。属性描述符可控制属性的可写性、可配置性等特性。通过Object.preventExtensions()、Object.seal()和Object.freeze()可实现不同级别的对象不可变性。in、hasOwnProperty()等方法可用于检查属性存在性，forEach、every等辅助迭代器可用于数组遍历。for..of循环通过内置@@iterator实现迭代访问。
对象可以通过两种形式定义：声明文字形式和构造形式
构造形式和文字形式生成的对象是一样的，唯一的区别是，在文字声明中可以添加多个键值对，但是在构造形式中必须逐个添加属性
在JS中一共有六种主要类型：string、number、boolean、null、undefined和object
简单基本类型本身并不是对象，JS中有许多特殊的对象子类型，我们称之为复杂基本类型
函数就是对象的一个子类型（可调用的对象），JS中的函数是一等公民，因为他本质上和普通的对象一样（只是可调用），所以可以像操作其他对象一样操作函数
数组也是对象的一种类型，具备一些额外的行为，数组中内容的组织方式比一般的对象要稍微复杂一些
JS还有一些对象子类型，被称为内置对象，String、Number、Boolean、Object、Function、Array、Date、RegExp、Error
这些内置函数可以当做构造函数来使用，从而可以构造一个对应子类型的新对象
有必要时，语言会自动把字面量转换成对应的内置对象，也就是说并不需要显式创建一个对象
null和undefined没有对应的构造形式，它们只有文字形式，Date只有构造，没有文字形式
对于Object、Array、Function和RegExp来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，构造形式可以提供一些额外选项，建议只在需要那些额外选项时使用构造形式
Error对象很少在代码中显式创建，一般是在抛出异常时被自动创建，也可以使用new Error()这种构造形式来创建
对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性
在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部，存储在对象容器内部的是这些属性的名称，它们就像指针一样，指向这些值真正的存储位置
.语法通常被称为属性访问，[&#34;&#34;]语法通常被称为块访问，这两种语法的主要区别是.操作符要求属性名满足标识符的命名规范，[&#34;&#34;]语法可以接受任意UTF-8/Unicode字符串作为属性名。此外，由于[&#34;&#34;]语法使用字符串来访问属性，所以可以在程序中构造这个字符串
在对象中，属性名永远都是字符串，如果使用string字面量以外的其他值作为属性名，那它首先会被转换为一个字符串
可以在文字形式中使用[]包裹一个表达式来当做属性名（可计算属性名）
函数永远不会属于一个对象，无论返回值是什么类型，每次访问对象的属性就是属性访问，属性访问返回的函数和其他函数没有任何区别
数组也支持[]访问形式，数组有一套更加结构化的值存储机制，数组期望的是数值下标，也就是说值存储的位置是非负整数
数组也是对象，虽然每个下标都是整数，但仍然可以给数组添加命名属性，数组的length值不会发生变化
完全可以把数组当成一个普通的键值对象来使用，并且不添加任何数值索引，但最好只用对象来存储键值对，只用数组来存储下标值对
如果试图向数组添加一个属性，但是属性名看起来像一个数字，那他会变成一个数值下标
对于JSON安全的对象来说，进行深拷贝可以通过：
var newObj = JSON.parse(JSON.stringify(someObj)) ES6定义了Object.assign()方法实现浅拷贝，第一个参数是目标对象，之后可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象。
因为Object.assign()使用=操作符来赋值，所以源对象属性的一些特性不会被复制到目标对象
在创建普通属性时属性描述符会使用默认值，我们也可以使用Object.defineProperty()来添加一个新属性或者修改一个已有属性并对特性进行设置
writable：决定是否可以修改属性的值 configurable：只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符，将其改成false是单项操作，不能撤销 ​	除了无法修改，configurable:false还会禁止删除这个属性
​	delete只用来删除对象的属性
enumerable：这个描述符控制的是属性是否会出现在对象的属性枚举中。如果把enumerable设置成false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。
get：对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到名称相同的属性，GET算法会执行原型链查找，如果无论如何都没有找到名称相同的属性，会返回undefined
put：如果已经存在这个属性，put算法大致会检查下面这些内容：
属性是否是访问操作符？如果是并且存在setter就调用setter 属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出类型异常 如果都不是，将该值设置为属性值 如果对象中不存在这个属性，put操作会更加复杂
getter是一个隐藏函数，会在获取属性值时调用。setter也是一个隐藏函数，会在设置属性值时调用。当给一个属性定义getter、setter或者两者都有时，这个属性会被定义为访问描述符（和数据描述符相对）。对于访问描述符来说，JS会忽略它们的value和writable特性，取而代之的是关心set和get特性
​	不管是对象文字语法中的get a(){}，还是defineProperty()中的显示定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值
​	setter会覆盖单个属性默认的put操作，通常来说getter和setter是成对出现的
让属性或对象是不可变的：
对象常量：结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改、重定义或者删除）
禁止扩展：使用Object.preventExtensions()可以禁止一个对象添加新属性并且保留已有属性
密封：Object.seal()会创建一个密封的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions()并把所有现有属性标记为configurable:false。所以密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）
Object.freeze()会创建一个冻结对象。这个方法实际上会在一个现有对象上调用Object.seal()并把所有数据访问属性标记为writable:false，这样就无法修改它们的值
这个方法是可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改
以上所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。
存在性：
in操作符会检查属性是否在对象及其原型链中。hasOwnProperty()只会检查属性是否在对象中，不会检查原型链
propertyIsEnumerable()方法会检查给定的属性名是否直接存在于对象中，而不是原型链上，并且满足enumerable:true
Object.keys()会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames()会返回一个数组，包含所有属性，无论它们是否可枚举
in和hasOwnProperty()的区别在于是否查找原型链，然而，Object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性
for…in循环可以用来遍历对象的可枚举属性列表（包括原型链），遍历顺序是不确定的，在不同的JS引擎中可能不一样
对于数值索引的数组来说，可以使用标准的for循环来遍历值
ES5中增加了一些数组的辅助迭代器，每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它对于回调函数返回值的处理方式不同：
forEach()会遍历数组中的所有值并忽略回调函数的返回值 every()会一直运行直到回调函数返回false some()会一直运行直到回调函数返回true every()和some()中特殊的返回值和普通for循环中的break语句类似，它们会提前终止遍历
for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值
数组有内置的@@iterator（返回迭代器对象的函数），因此for…of可以直接应用在数组上
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/2.-%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：面向对象编程中，类作为蓝图定义了数据结构与行为的封装，通过继承实现父类与子类的特殊化关系，核心概念包括多态（方法重写与相对引用）和实例化（构造函数创建对象副本）。然而JavaScript的对象机制与传统类继承不同，采用原型关联而非复制，并不存在真正的类实例化概念。(148字)
类继承描述了一种代码的组织结构形式，一种在软件中对真实世界中问题领域的建模方法
面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包起来。这在正式的计算机科学中有时被称为数据结构
我们可以实用类对数据结构进行分类，把任意数据结构看作范围更广的定义的一种特例
类的另一个核心概念是多态，这个概念就是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行为
类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类
一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有共有数据属性。这个对象就是类中描述的所有特性的一份副本
通常不会使用一个实例对象来直接访问并操作它的类，不过至少可以判断出这个实例对象来自哪个类
类通过复制操作被实例化为对象形式
类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息。
类构造函数属于类，而且通常和类同名，此外，构造函数大多需要用new来调，这样语言引擎才知道你想用构造一个新的类实例
在面向类的语言中，可以先定义一个类，然后定义一个继承前者的类，后者通常被称为子类，前者通常被称为父类。
定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本。但是也可以重写所有继承的行为甚至定义新行为
多态是一个很广泛的话题，相对是多态的一个方面：任何方法都可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说相对，是因为我们并不会定义想要访问的绝对继承层次，而是使用相对引用查找上一层
许多语言中可以用super，它的含义是超类，表示当前类的父类/祖先类，从子类的构造函数中通过super可以直接调用父类的构造函数。
多态的另一方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义
方法定义的多态性取决于是在哪个类的实例中引用它
在继承和实例化时，JS的对象机制并不会自动执行复制行为，JS中只有对象，并不存在可以被实例化的类，一个对象并不会被复制到其他对象，它们会被关联起来
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/3.-%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：JavaScript对象通过[[Prototype]]链实现原型继承机制，属性访问会沿着原型链查找。对象创建时[[Prototype]]会被赋予非空值，最终指向Object.prototype。属性赋值可能产生屏蔽效果，不同情况处理方式不同。构造函数.prototype属性用于关联新对象，但JS本质是对象互相关联而非类继承。Object.create()和__proto__等方法可操作原型链，空[[Prototype]]对象适合数据存储。JS通过原型链实现对象间的委托而非传统类继承。（150字）
JS中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值
当试图引用对象的属性时就会触发[[Get]]操作，对于默认的[[Get]]操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。但是如果不在，就需要使用对象的[[Prototype]]链了。对于默认的[[Get]]操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的[[Prototype]]链。这个过程会持续到找到匹配的属性名或者查找完整条[[Prototype]]链，如果是后者的话，[[Get]]操作的返回值就是undefined
使用for…in遍历对象时，原理和查找[[Prototype]]链类似，任何可以通过原型链访问到并且是enumerable的属性都会被枚举
使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链，无论属性是否可枚举
所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。由于所有普通对象都源于这个Object.prototype对象，所以它包含JS中许多通用的功能
myObject.foo = &#39;bar&#39; 如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值
如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作，如果原型链上找不到foo，foo就会被直接添加到myObject上
如果属性名既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽，myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性
如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = ‘bar’会出现三种情况：
如果在[[Prototype]]链上层存在名为foo的普通数据访问属性并且没有被标记为只读，那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性 如果在[[Prototype]]链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在myObject上创建屏蔽属性，如果运行在严格模式下，代码会报错，否则，这天赋值语句会被忽略 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter。foo不会被添加到myObject，也不会重新定义foo这个setter 如果希望在第二或三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty()来向myObject添加foo
在JS中，类无法描述对象的行为，因为根本不存在类，对象直接定义自己的行为，JS中只有对象
所有函数默认都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象，这个对象通常被称为该函数的原型，因为我们通过名为Xxx.prototype的属性引用来访问它
通过调用new Xxx()创建的每个对象最终被[[Prototype]]链接到这个Xxx.prototype对象
在面向类的语言中，类可以被实例化多次，但是JS没有类似的复制机制，不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行赋值，因此这些对象之间并不会完全失去联系，它们是互相关联的
new函数调用实际上并没有直接创建关联，这关联只是一个意外的副作用，它只是间接完成了我们的目标：一个关联到其他对象的新对象
在JS中，我们并不会讲一个对象复制到另一个对象，只是将它们关联起来，这个机制通常被称为原型继承，也可以叫做委托
函数本身并不是构造函数，但当你在普通函数调用前面加上new关键字之后，就会把这个函数调用变成一个构造函数调用。
new会劫持所有普通函数并用构造对象的形式来调用它
Xxx.prototype默认有一个公有且不可枚举的属性.constructor，这个属性引用的是对象关联的函数。Xxx.prototype的.constructor属性只是Xxx函数在声明时的默认属性，如果创建了一个新对象并替换了函数默认的.prototype对象引用，那么新对象并不会自动获得.constructor属性。
实际上，对象的.constructor属性默认指向一个函数，而这个函数也有一个叫做.prototype的引用指向这个对象。
constructor并不是一个不可变的属性，它是不可枚举的，但是它的值是可写的，可以给任意[[Prototype]]链中的任意对象添加一个名为constructor的属性或者对其进行修改，可以任意对其赋值
调用Object.create()会凭空创建一个新对象并把新对象内部的[[Prototype]]关联到指定的对象
Object.setPrototypeOf()可以用标准且可靠的方法来修改对象的[[Prototype]]关联
检查一个实例的继承祖先通常被称为内省或者反射
a instanceof Foo instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数，instanceof回答的问题是：在a的整条[[Prototype]]链中是否有Foo.prototype指向的对象
Foo.prototype.isPrototypeOf(a) 在a的整条[[Prototype]]链中是否出现过Foo.prototype
也可以直接获取一个对象的[[Prototype]]链
Object.getPrototypeOf(a) === Foo.prototype 绝大多数浏览器也支持一种非标准方法来访问内部的[[Prototype]]属性：
a.__proto__ === Foo.prototype 这个__proto__属性引用了内部的[[Prototype]]对象，这个属性并不存在于正在使用的对象中，而是存在于内置的Object.prototype中，并且是不可枚举的，它更像一个getter/setter，是可设置属性，但通常不需要修改已有对象的[[Prototype]]
[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找，同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推，这一系列对象的链接被称为原型链
Object.create()会创建一个新对象，并把它关联到我们指定的对象，这样可以充分发挥[[Prototype]]机制的威力并且避免不必要的麻烦
Object.create(null)会创建一个拥有空[[Prototype]]链接的对象，这个对象无法进行委托。这些空[[Prototype]]对象通常被称作字典，他们完全不会受到原型链的干扰，非常适合用来存储数据
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/4.-%E5%8E%9F%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文对比了对象关联和类继承两种编程模式的区别。对象关联采用[[Prototype]]委托机制，强调状态存储在委托者而非目标上，避免同名方法重写，提倡使用描述性方法名以提高代码可读性。同时指出委托行为存在循环委托的限制。另一方面，class语法支持super多态和extends继承，但本质上仍是语法糖，存在静态绑定super、无法声明属性和动态修改等局限性。两种模式各有特点，开发者需要根据实际需求选择合适的实现方式。
相比于面向类，对象关联风格的代码有一些不同之处：
在[[Prototype]]委托中最好把状态保存在委托者而不是委托目标上
在类设计中，我们故意让父类和子类中都有同名方法，这样就可以利用重写的优势，在委托行为中我们会尽量避免在[[Prototype]]链的不同级别中使用相同的命名
这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型，这样做实际上可以创建出更容易理解和维护的代码，因为方法名更清晰
委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象
无法在两个或两个以上互相委托的对象之间创建循环委托，如果把B关联到A然后试着把A关联到B，就会出错
class语法特点：
可以通过super()来实现相对多态，这样任何方法都可以引用原型链上层的同名方法 class字面语法不能声明属性，只能声明方法 可以通过extends很自然的扩展对象类型，甚至是内置对象类型 但是本质是语法糖，没法真正实现类，并且super声明时是静态绑定而不是动态绑定的，所以定义了class后不容易对其动态修改 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/5.-%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://growyears.netlify.app/posts/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://growyears.netlify.app/posts/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://growyears.netlify.app/">拾光博客 - 永浩</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
