<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - My New Hugo Site">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：JavaScript对象通过[[Prototype]]链实现原型继承机制，属性访问会沿着原型链查找。对象创建时[[Prototype]]会被赋予非空值，最终指向Object.prototype。属性赋值可能产生屏蔽效果，不同情况处理方式不同。构造函数.prototype属性用于关联新对象，但JS本质是对象互相关联而非类继承。Object.create()和__proto__等方法可操作原型链，空[[Prototype]]对象适合数据存储。JS通过原型链实现对象间的委托而非传统类继承。（150字）
JS中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值
当试图引用对象的属性时就会触发[[Get]]操作，对于默认的[[Get]]操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。但是如果不在，就需要使用对象的[[Prototype]]链了。对于默认的[[Get]]操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的[[Prototype]]链。这个过程会持续到找到匹配的属性名或者查找完整条[[Prototype]]链，如果是后者的话，[[Get]]操作的返回值就是undefined
使用for…in遍历对象时，原理和查找[[Prototype]]链类似，任何可以通过原型链访问到并且是enumerable的属性都会被枚举
使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链，无论属性是否可枚举
所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。由于所有普通对象都源于这个Object.prototype对象，所以它包含JS中许多通用的功能
myObject.foo = &#39;bar&#39; 如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值
如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作，如果原型链上找不到foo，foo就会被直接添加到myObject上
如果属性名既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽，myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性
如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = ‘bar’会出现三种情况：
如果在[[Prototype]]链上层存在名为foo的普通数据访问属性并且没有被标记为只读，那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性 如果在[[Prototype]]链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在myObject上创建屏蔽属性，如果运行在严格模式下，代码会报错，否则，这天赋值语句会被忽略 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter。foo不会被添加到myObject，也不会重新定义foo这个setter 如果希望在第二或三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty()来向myObject添加foo
在JS中，类无法描述对象的行为，因为根本不存在类，对象直接定义自己的行为，JS中只有对象
所有函数默认都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象，这个对象通常被称为该函数的原型，因为我们通过名为Xxx.prototype的属性引用来访问它
通过调用new Xxx()创建的每个对象最终被[[Prototype]]链接到这个Xxx.prototype对象
在面向类的语言中，类可以被实例化多次，但是JS没有类似的复制机制，不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行赋值，因此这些对象之间并不会完全失去联系，它们是互相关联的
new函数调用实际上并没有直接创建关联，这关联只是一个意外的副作用，它只是间接完成了我们的目标：一个关联到其他对象的新对象
在JS中，我们并不会讲一个对象复制到另一个对象，只是将它们关联起来，这个机制通常被称为原型继承，也可以叫做委托
函数本身并不是构造函数，但当你在普通函数调用前面加上new关键字之后，就会把这个函数调用变成一个构造函数调用。
new会劫持所有普通函数并用构造对象的形式来调用它
Xxx.prototype默认有一个公有且不可枚举的属性.constructor，这个属性引用的是对象关联的函数。Xxx.prototype的.constructor属性只是Xxx函数在声明时的默认属性，如果创建了一个新对象并替换了函数默认的.prototype对象引用，那么新对象并不会自动获得.constructor属性。
实际上，对象的.constructor属性默认指向一个函数，而这个函数也有一个叫做.prototype的引用指向这个对象。
constructor并不是一个不可变的属性，它是不可枚举的，但是它的值是可写的，可以给任意[[Prototype]]链中的任意对象添加一个名为constructor的属性或者对其进行修改，可以任意对其赋值
调用Object.create()会凭空创建一个新对象并把新对象内部的[[Prototype]]关联到指定的对象
Object.setPrototypeOf()可以用标准且可靠的方法来修改对象的[[Prototype]]关联
检查一个实例的继承祖先通常被称为内省或者反射
a instanceof Foo instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数，instanceof回答的问题是：在a的整条[[Prototype]]链中是否有Foo.prototype指向的对象
Foo.prototype.isPrototypeOf(a) 在a的整条[[Prototype]]链中是否出现过Foo.prototype
也可以直接获取一个对象的[[Prototype]]链
Object.getPrototypeOf(a) === Foo.prototype 绝大多数浏览器也支持一种非标准方法来访问内部的[[Prototype]]属性：
a.__proto__ === Foo.prototype 这个__proto__属性引用了内部的[[Prototype]]对象，这个属性并不存在于正在使用的对象中，而是存在于内置的Object.prototype中，并且是不可枚举的，它更像一个getter/setter，是可设置属性，但通常不需要修改已有对象的[[Prototype]]
[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找，同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推，这一系列对象的链接被称为原型链
Object.create()会创建一个新对象，并把它关联到我们指定的对象，这样可以充分发挥[[Prototype]]机制的威力并且避免不必要的麻烦
Object.create(null)会创建一个拥有空[[Prototype]]链接的对象，这个对象无法进行委托。这些空[[Prototype]]对象通常被称作字典，他们完全不会受到原型链的干扰，非常适合用来存储数据
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/4.-%E5%8E%9F%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文对比了对象关联和类继承两种编程模式的区别。对象关联采用[[Prototype]]委托机制，强调状态存储在委托者而非目标上，避免同名方法重写，提倡使用描述性方法名以提高代码可读性。同时指出委托行为存在循环委托的限制。另一方面，class语法支持super多态和extends继承，但本质上仍是语法糖，存在静态绑定super、无法声明属性和动态修改等局限性。两种模式各有特点，开发者需要根据实际需求选择合适的实现方式。
相比于面向类，对象关联风格的代码有一些不同之处：
在[[Prototype]]委托中最好把状态保存在委托者而不是委托目标上
在类设计中，我们故意让父类和子类中都有同名方法，这样就可以利用重写的优势，在委托行为中我们会尽量避免在[[Prototype]]链的不同级别中使用相同的命名
这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型，这样做实际上可以创建出更容易理解和维护的代码，因为方法名更清晰
委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象
无法在两个或两个以上互相委托的对象之间创建循环委托，如果把B关联到A然后试着把A关联到B，就会出错
class语法特点：
可以通过super()来实现相对多态，这样任何方法都可以引用原型链上层的同名方法 class字面语法不能声明属性，只能声明方法 可以通过extends很自然的扩展对象类型，甚至是内置对象类型 但是本质是语法糖，没法真正实现类，并且super声明时是静态绑定而不是动态绑定的，所以定义了class后不容易对其动态修改 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/5.-%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文总结《你不了解的JS》第一部分第一章的核心概念，重点介绍了JavaScript的编译原理和作用域机制。笔记指出程序状态通过变量存储和访问实现，作用域是一套管理变量的规则体系。编译过程包括分词、语法分析和代码生成三个阶段。在变量赋值时，编译器处理声明，引擎执行查询（LHS/RHS）。作用域嵌套时，引擎会逐级向上查找变量。文章还区分了RHS和LHS查询的区别，以及在不同情况下可能出现的ReferenceError和TypeError异常。严格模式会改变LHS查询失败时的默认行为。
一、核心概念 程序状态与变量：存储和访问变量值的能力为程序赋予了状态。 作用域定义：一套规则体系，用于管理变量的存储方式和查找逻辑，确保代码能按规则访问变量。 二、编译原理 传统编译三阶段： 分词 / 词法分析：将源代码字符串分解为有意义的词法单元（如关键字、变量名、运算符等）。 解析 / 语法分析：将词法单元流转换为抽象语法树（AST），AST 是体现程序语法结构的嵌套树状结构。 代码生成：将 AST 转换为可执行代码。 JavaScript 编译特点：多数情况下，编译在代码片段执行前的几微秒内完成（即时编译）。 三、作用域的核心角色 引擎：负责整个 JavaScript 程序的编译及执行全过程。 编译器：负责语法分析、代码生成等编译相关工作。 作用域：负责收集并维护所有声明的标识符（变量、函数名等），并制定规则确定当前执行的代码对这些标识符的访问权限。 四、变量声明与赋值过程（以var a = 2为例） 变量声明（编译器处理）： 编译器询问当前作用域：是否已存在名为a的变量。 若存在，忽略该声明；若不存在，要求作用域在当前集合中声明一个新变量a。 变量赋值（引擎处理）： 引擎询问当前作用域：是否存在名为a的变量。存在则直接使用，不存在则继续向上查找。 找到a后，将 2 赋值给它；未找到则抛出异常。 LHS 与 RHS 查询： RHS 查询：查找变量的值（如console.log(a)中对a的查询）。 LHS 查询：查找变量的容器本身，用于赋值（如a = 2中对a的查询）。 函数声明处理：编译器在代码生成阶段同步处理函数的声明和值定义。 五、作用域嵌套 嵌套场景：当块或函数嵌套在另一个块或函数中时，形成作用域嵌套。 查找规则： 引擎从当前执行作用域开始查找变量，找不到则向上一级嵌套作用域继续查找。 直至找到变量或抵达全局作用域，查找过程终止。 六、异常类型及触发场景 ReferenceError（引用错误）： RHS 查询：在所有嵌套作用域中未找到目标变量时抛出。 LHS 查询：严格模式下，在所有作用域中未找到目标变量时抛出（非严格模式下会自动在全局作用域创建该变量，let/const本身在非严格模式下也不会隐式创建全局变量）。 TypeError（类型错误）：RHS 查询找到变量，但对其值进行不合理操作（如对非函数变量调用方法）时抛出。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/1.%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 《你不了解的JS》笔记：词法作用域与欺骗词法
词法作用域由代码书写位置决定，查找从内向外进行，存在遮蔽效应。全局变量可通过window对象间接访问。欺骗词法的方式包括eval和with：eval动态修改作用域（严格模式除外），with将对象处理为临时作用域。两者都会影响性能，eval在严格模式下有独立作用域，with会将var声明泄漏到函数作用域。这些特性都可能导致代码运行效率下降。
一、词法作用域的核心特性 定义与本质： 词法作用域是在代码书写阶段就确定的作用域，由变量、块作用域及函数的声明位置决定，与函数的调用位置无关。 查找规则： 作用域查找从最内部作用域开始，逐级向外（向上）进行，直到找到第一个匹配的标识符后停止（即 “就近匹配”）。 仅查找一级标识符（如a，不会自动查找对象属性链如obj.a）。 遮蔽效应： 在多层嵌套作用域中，内层作用域的标识符可遮蔽外层同名标识符（如内层var a = 1会遮蔽外层的var a = 2）。 全局变量的特殊访问： 全局变量会成为全局对象（如浏览器中的window）的属性，可通过window.a访问被内层同名变量遮蔽的全局变量。 函数的词法作用域： 函数的词法作用域仅由其声明时所处的位置决定，与调用位置、调用方式无关。 二、欺骗词法作用域的方式 1. eval 函数 功能：接收字符串参数，将其视为代码片段插入到当前位置执行，仿佛该代码在书写时就存在于此。 对作用域的影响： 默认情况下，若eval中的代码包含变量 / 函数声明，会修改其所处的词法作用域（新增或覆盖标识符）。 严格模式下，eval有独立的词法作用域，内部声明不会影响外部作用域。 常见用途：执行动态生成的代码（如拼接字符串形成的逻辑）。 2. with 语句 功能：作为访问对象多个属性的快捷方式，避免重复书写对象名（如with(obj) { a = 1; b = 2 }等效于obj.a = 1; obj.b = 2）。 对作用域的影响： 将传入的对象视为一个临时的词法作用域，对象的属性被当作该作用域中的标识符。 块内的var声明不会被限制在with块中，而是泄漏到外层函数作用域。 本质：根据传入对象 “凭空创建” 全新的词法作用域，与eval修改现有作用域的行为不同。 三、副作用与风险 性能问题： eval和with会破坏 JS 引擎的词法作用域静态分析（无法提前确定变量查找规则），导致无法优化代码执行，显著降低运行效率。 代码可读性与维护性： 动态修改作用域会使变量的查找逻辑变得模糊，增加调试难度，不符合词法作用域的设计初衷。 严格模式限制： 严格模式下eval的作用域被隔离，with被完全禁止（直接抛出错误），进一步体现了对 “欺骗词法” 行为的不推荐。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/2.%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 《你不了解的JS》第一部分第三章探讨了函数和块作用域的概念。函数作用域允许变量在函数内部复用，并可通过隐藏内部实现遵循最小特权原则，避免命名冲突。函数声明与表达式的主要区别在于标识符绑定位置，建议为函数表达式命名以便调试。IIFE（立即执行函数表达式）是常见模式，可用于传递参数和解决变量覆盖问题。块作用域通过let和const实现变量本地化，let在循环中每次迭代重新绑定变量，const则创建不可变绑定。这些机制有助于优化变量生命周期和避免提升问题。
一、函数作用域的核心特性 定义与复用：函数内部声明的变量，可在整个函数范围内（包括嵌套作用域）使用和复用。 隐藏内部实现： 通过函数作用域封装变量和函数，遵循最小特权原则（仅暴露必要内容，隐藏细节），减少命名冲突。 第三方库通常通过命名空间对象（将功能作为对象属性暴露）或模块管理器（避免全局作用域污染）防止冲突。 二、函数声明与表达式的区别 区分方法： 若function是声明的第一个词，则为函数声明；否则为函数表达式。 关键差异： 函数声明的名称标识符绑定在所在作用域中； 函数表达式的名称标识符绑定在自身函数内部（外部不可直接访问）。 匿名函数表达式的缺点： 栈追踪无有意义名称，调试困难； 无法通过名称自引用（依赖arguments.callee，已过时）； 降低代码可读性。 最佳实践：始终为函数表达式命名（如const fn = function namedFn() {}）。 三、立即执行函数表达式（IIFE） 定义：函数表达式被声明后立即执行（如(function() { ... })()）。
常见用途
：
传递参数，隔离作用域（避免污染外部）； 确保undefined标识符的准确性（通过参数占位，如(function(undef) { ... })()）； 倒置代码执行顺序（将主逻辑作为参数传递给 IIFE）。 四、块作用域的特性与实现 核心作用：将变量本地化，扩展最小授权原则，从函数级隐藏扩展到块级隐藏。 块作用域的优势：变量声明靠近使用位置，减少作用域污染，优化变量生命周期，避免提升带来的意外行为。 实现方式： with 语句：为对象创建临时块作用域（仅在with内部有效）； try/catch：catch分句创建块作用域，内部变量仅在catch中有效； let 关键字： 将变量绑定到所在块作用域（如if、for块）； 无提升特性（声明前访问会报错）； for循环中，let会将变量重新绑定到每个迭代（确保迭代值独立）。 const 关键字： 同let的块作用域特性，但值为常量（修改会报错）。 原书中P34最上方 “点击事件因闭包导致变量问题” 的描述有误：实际是var声明的变量属于函数 / 全局作用域，生命周期长，导致循环中共享同一变量；而let通过块作用域解决此问题。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/3.%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> JS中的变量和函数声明会在代码执行前被&#34;提升&#34;。引擎在编译阶段会将所有声明提前处理，但赋值操作保留原位。函数声明优先于变量声明，且会被提升到作用域顶部。需要注意的是，函数表达式不会被提升，块级函数声明也存在提升问题。开发者应避免在块内部声明函数，且重复声明时后面的函数会覆盖前面的。这些机制体现了JS编译阶段和执行阶段的差异性。
一、变量和函数声明的提升机制 提升的本质： 引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。 作用域范围：每个作用域（全局、函数、块作用域）都会独立进行提升操作。 二、函数声明与变量声明的提升优先级 函数声明优先： 函数声明的提升优先级高于变量声明，会被提升到作用域更顶部。 示例：若同时存在function a() {}和var a，函数声明会先被提升，变量声明因重复被忽略（但变量赋值会覆盖函数）。 函数表达式不提升： 函数表达式（如var fn = function() {}）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到undefined。 具名函数表达式（如var fn = function named() {}）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。 三、特殊情况与注意事项 重复声明的覆盖： 变量重复声明（如var a = 1; var a = 2）会被忽略前序，保留最后一次赋值； 函数重复声明（如function a() {}; function a() {}）后序声明会覆盖前序。 块级函数声明的问题： 普通块内部的函数声明（如if (true) { function a() {} }）可能被提升到所在作用域顶部（不同 JS 环境处理有差异），易导致逻辑混乱，应避免在块内声明函数。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/4.%E6%8F%90%E5%8D%87/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：闭包是指函数能够记住并访问其词法作用域，即使在其作用域外执行。通过回调函数或将内部函数传递到外部都可形成闭包。示例展示了用IIFE解决循环变量共享问题，以及let在循环中的特殊行为。模块模式需满足：1)外部封闭函数被调用创建实例；2)返回内部函数形成闭包访问私有状态。ES6模块与函数模块不同，具有静态API检查机制，需定义在单独文件中，其内容如同在闭包中处理。
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包
只要使用了回调函数，实际上就是在使用闭包
一个需要调用的函数引用了其他作用域的变量，导致该作用域不会消失，并且函数可以随时引用这个作用域
for (var i = 1; i &lt; 5; i&#43;&#43;) { (function (j) { setTimeout(function () { console.log(j); }, j * 1000); }(i)) } 在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会包含有一个具有正确值的变量供我们访问！！！！！
for循环头部的let声明有一个特殊行为：变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量
最常见的实现模块模式的方法通常被称为模块暴露
模块模式需要具备两个必要条件：
必须有外部的封闭函数，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态 模块模式一个简单但强大的用法是命名将要作为公共API返回的对象
模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的API
基于函数的模块并不是一个能被静态识别的模式，可以在运行时修改一个模块的API，ES6模块API是静态的，编辑器可以在编译器检查对导入模块的API成员的引用是否真实存在，而不会等到运行期再动态解析
ES6模块没有行内格式，必须被定义在独立的文件中，模块中的内容会被当做好像包含在作用域闭包中一样来处理
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/5.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：词法作用域在代码定义时确定，关注函数声明位置；动态作用域在运行时确定，关注函数调用位置。ES6前可用try/catch模拟let的块作用域。箭头函数通过词法作用域绑定this，替代普通函数的this绑定规则，其效果类似于使用self变量或bind方法，解决了this指向问题。三种方式都能确保this正确指向外层对象（示例中的obj），但箭头函数提供了更简洁的语法实现。
词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用
ES6之前可以用catch实现let的效果
{ try { throw undefined; }catch(a){ a=2 console.log(a) } } console.log(a) 箭头函数放弃了普通this绑定的规则，取而代之的是用当前的词法作用域覆盖了this本来的值
var obj = { count:0, cool: function coolFn(){ if(this.count&lt;1){ setTimeout(()=&gt;{ this.count&#43;&#43;; }) } } } 相当于：
var obj = { count:0, cool: function coolFn(){ var self = this if(self.count&lt;1){ setTimeout(function timer()=&gt;{ self.count&#43;&#43;; }) } } } 相当于：
var obj = { count:0, cool: function coolFn(){ if(this.count&lt;1){ setTimeout(function timer()=&gt;{ this.count&#43;&#43;; }.bind(this),100) } } } </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/6.%E9%99%84%E5%BD%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、分块的程序与异步机制 分块程序的本质： 将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。 console.log 的异步特性： 部分浏览器的console.log并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。 二、事件循环 核心机制： 事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个tick： 若队列中有等待事件（即回调函数），则从队列中取出一个执行； 无事件时，循环等待新事件加入。 setTimeout 的作用： 并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。 三、并行执行 异步与并行的区别： 异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）； 并行：关注 “同时发生”（多个操作在物理上同时进行）。 进程与线程： 进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存； JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。 JS 的单线程特性： 函数代码具有原子性（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）； 若函数执行顺序不确定，可能导致竞态条件（因共享状态的修改顺序不可控引发的逻辑错误）。 四、并发 定义： 两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。
JS 的并发形式： 单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。
并发交互的协调方式：
门（Gate）：等待多个条件都满足后再执行下一步。例如：
function foo(x) { a = x * 2; if (a &amp;&amp; b) baz(); // 需a和b都准备好才调用baz() } 门闩（Latch）：“只有第一名取胜”，仅首次满足条件时执行。例如：
function foo(x) { if (!a) { // 仅a未被赋值时执行 a = x * 2; baz(); } } 并发协作：将长期运行的进程拆分为多步 / 多批任务，允许其他并发进程插入事件循环交替运行。例如：处理长列表时，用setTimeout(..., 0)
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/1.-%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、回调函数的本质 回调函数的核心作用是包裹或封装程序的延续逻辑—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。
二、回调地狱（Callback Hell）的成因 回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：
思维与代码的不匹配：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。
控制反转导致的信任问题： 回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：
无法确保回调被调用的次数（可能被多次调用或不调用）； 无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）； 无法确保回调的参数符合预期。 三、回调模式的优化设计 为缓解回调地狱和信任问题，常见的回调模式设计：
分离回调（Split Callbacks）： 为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。 错误优先回调（Error-First Callbacks，Node 风格）： 回调函数的第一个参数固定为错误对象，后续参数为成功结果：
若操作成功，错误参数为null或undefined； 若操作失败，错误参数为非空值（通常是Error对象）。 四、回调调用的最佳实践：永远异步执行 即使回调逻辑可以同步完成，也应强制异步调用（如通过setTimeout或队列机制），确保回调行为的一致性：
避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）； 保证所有回调都遵循相同的异步逻辑，减少不可预测性。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/2.-%E5%9B%9E%E8%B0%83/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/posts/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/posts/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
