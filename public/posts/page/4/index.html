<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - My New Hugo Site">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、什么是 Promise 1. 未来值 核心特性：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。 状态与不可变性： 封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。 一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。 then 方法的双回调：调用then(onFulfilled, onRejected)时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。 2. 完成事件（流程控制） 本质：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。 反控制反转： 传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过then注册回调，等待 Promise 决议后触发，将控制返还给调用代码。 信号特性：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。 二、具有 then 方法的鸭子类型 thenable 定义：任何具有then方法的对象或函数，被视为与 Promise 一致的 “thenable”。 鸭子类型：通过值的形态（是否有then方法）假定其类型，这是识别 Promise 的核心逻辑。 三、Promise 信任问题（可靠性保障） 异步回调：对 Promise 调用then时，即使 Promise 已决议，回调也始终异步执行（下一个事件循环 tick），确保行为一致。 决议的唯一性： Promise 只能被决议一次（首次调用resolve或reject生效，后续调用被忽略），因此then注册的回调仅执行一次。 若同一回调多次注册，会按注册次数执行。 决议值的单一性： 至多有一个决议值（未显式决议时为undefined），传给所有注册的回调。 调用resolve/reject时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。 异常处理：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。 Promise.resolve 的作用： 传入非 Promise / 非 thenable 值：返回以该值完成的 Promise。 传入真正的 Promise：直接返回该 Promise。 传入 thenable：递归展开至非 thenable 的最终值，返回一个可信任的真正 Promise。 作用：确保任何值通过Promise.resolve过滤后都是可信任的 Promise。 四、链式流（Promise 链式调用） 链式基础： 每次调用then都会创建并返回新的 Promise，支持链式连接。 完成回调的返回值会自动作为新 Promise 的完成值（若返回 Promise/thenable，会展开其决议值）。 错误传播： 若then仅传入完成回调，默认拒绝处理函数会 “重新抛出错误”，使错误沿链传播，直至被显式拒绝处理函数捕获。 若then未传入有效完成回调，默认完成处理函数会将值传递给下一个步骤。 catch 的本质：catch(onRejected)是then(null, onRejected)的缩写，仅处理拒绝，自动传递完成值。 五、Promise 模式 1. Promise.all（“门” 模式） 作用：等待多个并行 / 并发任务全部完成后再继续，顺序无关。 参数：接受一个由 Promise、thenable 或立即值组成的数组（元素会被Promise.resolve规范化）。 决议规则： 完成：所有成员 Promise 完成后，主 Promise 以 “成员完成值组成的数组” 完成（顺序与传入数组一致，与完成顺序无关）。 拒绝：任一成员 Promise 拒绝时，主 Promise 立即以该拒绝理由拒绝（忽略其他结果）。 特殊情况：传入空数组时，主 Promise立即完成（值为 []）。 2. Promise.race（“门闩” 模式） 作用：仅响应第一个决议的 Promise（完成或拒绝），忽略其他。 参数：接受一个由 Promise、thenable 或立即值组成的数组（元素会被Promise.resolve规范化）。 决议规则： 完成：第一个完成的成员 Promise 的完成值作为主 Promise 的完成值。 拒绝：第一个拒绝的成员 Promise 的拒绝理由作为主 Promise 的拒绝理由。 特殊情况：传入空数组时，主 Promise永远不会决议。 六、Promise API 概述 1. new Promise 构造器 必须与new配合使用，参数为一个同步执行的回调函数，该回调接受两个参数（resolve和reject）： reject(reason)：直接拒绝 Promise，理由为reason。 resolve(value)： 若value为非 Promise / 非 thenable：以value完成 Promise。 若value为 Promise/thenable：递归展开，采用其最终决议状态 / 值。 2. Promise.resolve 和 Promise.reject（静态方法） Promise.reject(reason)：快捷创建已拒绝的 Promise，理由为reason（不展开reason，即使其为 thenable）。 Promise.resolve(value)： 若value为 Promise：直接返回该 Promise。 若value为 thenable：展开至最终值，返回以该值决议的 Promise（完成或拒绝）。 其他情况：返回以value完成的 Promise。 3. then 和 catch（实例方法） then(onFulfilled?, onRejected?)： 注册完成 / 拒绝回调，返回新 Promise。 若回调为非函数：替换为默认回调（完成回调传递值，拒绝回调重新抛错）。 回调返回值处理： 抛出异常：新 Promise 以该异常拒绝。 返回非 Promise / 非 thenable：新 Promise 以该值完成。 返回 Promise/thenable：新 Promise 采用其最终决议状态 / 值。 catch(onRejected)：等价于then(null, onRejected)，仅注册拒绝回调。 4. Promise.all 和 Promise.race（静态方法） 同 “Promise 模式” 中描述，核心为 “门” 和 “门闩” 模式，控制多 Promise 的并发协作。 七、Promise 局限性 错误易被忽略： 若 Promise 链未设置错误处理函数，链中任何错误会一直传播，直至被捕获（可能导致隐性 bug）。 链中无统一实体标识，无法从外部观察未处理的错误。 单一决议值： 只能有一个完成值或拒绝理由，复杂场景需拆分多个 Promise。 无法中途取消： 一旦创建 Promise 并注册回调，若任务悬而未决，无法从外部终止其进程。 轻微性能开销： 相比非 Promise 回调，因内建可靠性（如异步保证、状态管理），性能略低，但可忽略不计。 补充说明（修正与强调） “决议” 包含 “完成（fulfilled）” 和 “拒绝（rejected）” 两种状态，避免混淆为单一概念。 Promise.race 传入空数组 “永远不决议” 是标准行为（因无竞争对象），需注意与 Promise.all 空数组的区别。 所有回调的 “异步执行” 基于事件循环，确保宏观任务队列的顺序性，避免同步执行导致的时序混乱。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/3.-promise/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、生成器的基本概念与特性 定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 二、生成器产生值：生产者与迭代器 1. 迭代器接口 作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 2. for..of循环 自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 3. Iterable（可迭代对象） 定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 4. 生成器迭代器的特性 生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 三、异步迭代生成器 生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&#34;http://...&#34;, (err, data) =&gt; { if (err) it.throw(err); // 向生成器抛错 else it.next(data); // 向生成器传递异步结果 }); } function* main() { try { const text = yield foo(11, 31); // 暂停等待异步结果 console.log(text); } catch (err) { console.error(err); // 捕获异步错误 } } const it = main(); it.next(); // 启动生成器 上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 &#43; 异步执行”。 四、生成器与 Promise 的结合 优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。 实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器： Promise 完成时，调用it.next(结果值)恢复生成器； Promise 拒绝时，调用it.throw(错误)向生成器抛错。 五、生成器委托（yield*） 语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。 作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。 特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。 六、形实转换程序（Thunk） 定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。 用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。 补充说明 生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。 生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。 for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、Web Worker 基础 定义与作用：
Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。 创建与类型：
专用 Worker（Dedicated Worker）：通过 new Worker(&#39;script.js&#39;) 创建，与主程序是一对一关系，仅能与创建它的程序通信。
示例：
// 主程序中创建专用 Worker const w1 = new Worker(&#39;worker.js&#39;); 二、Worker 通信机制 消息传递：
不共享作用域 / 资源，通过 message 事件双向通信，数据传递基于结构化克隆或所有权转移。
主程序与 Worker 内部均通过postMessage(data)发送消息，通过onmessage监听消息：
// 主程序 w1.postMessage(&#39;hello&#39;); // 发送消息到 Worker w1.onmessage = (e) =&gt; console.log(&#39;收到 Worker 消息：&#39;, e.data); // worker.js 内部 self.onmessage = (e) =&gt; { console.log(&#39;收到主程序消息：&#39;, e.data); self.postMessage(&#39;hi&#39;); // 发送消息到主程序 }; 终止 Worker：
主程序中调用 w1.terminate() 可立即终止 Worker（无清理机会）； Worker 内部可调用 self.close() 主动终止自身。 三、Worker 运行环境 限制与可用资源： 不可访问 DOM、主程序全局变量，但可使用 navigator、location、JSON、setTimeout 等，支持网络请求（如 fetch）。 可通过 importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;) 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。 典型应用场景： 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。 四、数据传递方式 结构化克隆：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/5.-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、内置类型概述 定义：类型是值的内部特征，决定值的行为，以区分于其他值。 分类： 基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。 对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。 二、typeof 运算符 作用：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。 特殊情况： null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理） 检测 null 值类型的复合条件：!a &amp;&amp; typeof a === &#39;object&#39;（因 null 是假值，且是唯一用 typeof 检测返回 ‘object’ 的基本类型值）。 三、对象子类型 函数（function）： 是 object 的子类型，属于可调用对象。 具有内部属性 [[Call]]，使其可被调用。 可拥有属性，如 length 属性表示其声明的参数个数。 typeof function返回&#34;function&#34;，是历史遗留的特殊处理 数组： 是 object 的子类型。 元素按数字顺序索引，length 属性表示元素个数。 四、值和类型的特性 变量与类型的关系： JS 中变量无类型，只有值有类型。 变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。 对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。 undefined 与 undeclared 的区别： undefined：变量已在作用域中声明但未赋值。 undeclared：变量未在作用域中声明过。 typeof 的安全防范机制： 对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。 应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。 其他安全检查方法： 检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。 依赖注入设计模式：将依赖通过参数显式传递到函数中。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/1.-%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、数组 特性： 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。 使用delete运算符删除单元后，位置变为空白单元，数组length属性不变。 稀疏数组： 指含有空白 / 空缺单元的数组，空白单元值为undefined，但与显式赋值为undefined的单元有区别（如[,,]与[undefined, undefined]行为不同）。 索引与属性： 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在length内，length只计算数字索引的最大整数 &#43; 1）。 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。 类数组转换： 类数组特征：有length和数字索引，但无数组方法（如arguments、DOM 集合NodeList） 可转换为真正的数组，常用方法： Array.prototype.slice.call(类数组) ES6 的Array.from(类数组) 扩展运算符（需类数组为可迭代对象） 二、字符串 与数组的区别： 是类数组（有length、indexOf()、concat()等），但并非字符数组。 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。 数组方法的借用： 可借用数组的非变更方法（如Array.prototype.indexOf.call(str, &#39;a&#39;)）处理字符串。 不可借用数组的变更方法（因字符串不可变），需先通过split(&#39;&#39;)转为数组，处理后再用join(&#39;&#39;)转回字符串。 三、数字 类型与格式： JS 只有一种数值类型number（双精度浮点数），包含整数（如42.0）和带小数的十进制数。 字面量表示： 十进制：可省略小数点前的 0（.42）或后多余的 0（42.）。 特殊格式：指数形式（1e3）、二进制（0b1010）、八进制（0o12）、十六进制（0xa）。 显示规则： 大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同toExponential()）。 Number 对象方法： toFixed(n)：指定小数部分显示位数，不足用 0 补齐（返回字符串）。 toPrecision(n)：指定有效数位的显示位数。 注意：数字字面量调用方法时，需避免.被误判为数字一部分（如42..toFixed(2)或42 .toFixed(2)）。 精度与范围： 精度问题：0.1 &#43; 0.2 !== 0.3（浮点数二进制存储导致精度丢失），可通过Math.abs(n1 - n2) &lt; Number.EPSILON（机器精度）判断近似相等。
范围：
最大浮点数：Number.MAX_VALUE；最小浮点数（接近 0 的正数）：Number.MIN_VALUE。 安全整数范围：Number.MIN_SAFE_INTEGER（-2^53 &#43; 1）到Number.MAX_SAFE_INTEGER（2^53 - 1），超出需用字符串处理。 BigInt解决大整数：用n后缀声明，支持超出安全范围的整数运算 const big = 9007199254740993n; big &#43; 1n; // 9007199254740994n（精确计算） 检测方法： Number.isInteger(num)：检测是否为整数（ES6&#43;）。 Number.isSafeInteger(num)：检测是否为安全整数（ES6&#43;）。 四、特殊数值 null 与 undefined： 均为唯一值，名称即类型也即值。 区别： null：表示 “空值”（曾赋值，当前无值），不是标识符，不能作为变量赋值。 undefined：表示 “未赋值”，是内置标识符（不建议手动赋值，严格模式下可能报错）。 void运算符：表达式void XXX返回undefined，不改变表达式副作用（惯例用void 0获取undefined）。 NaN（Not a Number）： 属于number类型，代表数学运算失败的警戒值。 特性：与自身不相等（NaN !== NaN）。 检测：isNaN()不可靠（误判非数字类型），Number.isNaN()更准确（仅检测NaN）。 无穷数（Infinity）： 产生：正数除以 0 得Infinity，负数除以 0 得-Infinity；运算溢出时也会返回。 特性： Infinity / Infinity结果为NaN。 有穷正数 /Infinity为 0，有穷负数 /Infinity为-0。 溢出为无穷数后，无法再得到有穷数。 负零（-0）： 产生：某些数学运算（如-1 / Infinity）的结果，加减法不会得到-0。 特性： 字符串化返回&#34;0&#34;，但从字符串转回数字时保留符号。 -0 === 0为true，ES6 的Object.is(-0, 0)为false（可准确区分）。 五、值和引用 引用本质： JS 中引用指向值，而非变量；多个引用可指向同一值，但引用间无相互指向关系。 赋值 / 传递规则： 由值的类型决定，与语法无关： 基本类型（null、undefined、string、number、boolean、symbol）：通过值复制（赋值 / 传递的是值的副本）。 复合值（对象、函数、数组等）：通过引用复制（赋值 / 传递的是指向值的引用）。 操作特性： 引用无法修改另一个引用的指向（如a = b后修改a不影响b）。 复合值的复制：需创建复本（如a.slice()返回数组浅复本），避免引用共享。 基本类型的修改：若需在函数内修改基本类型，需封装到复合值中（通过引用传递）。 基本类型不可变：其值无法被修改（如字符串的方法均返回新值）。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/2.-%E5%80%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、内部属性 [[Class]] 基本概念： 内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。 属性特征： 所有typeof返回值为object的对象都包含内部属性[[Class]]，该属性无法直接访问。 通常通过Object.prototype.toString()方法查看[[Class]]的值。 对应关系： 多数情况下，对象的[[Class]]属性值与创建该对象的内建原生构造函数相对应。 特殊情况：虽然不存在Null()和undefined()原生构造函数，但null和undefined的[[Class]]属性值分别为&#39;Null&#39;和&#39;Undefined&#39;。 二、封装对象包装 自动包装机制： 基本类型值（如string、number等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。 手动封装与拆封： 手动封装：使用Object()函数（不带new关键字）可将基本类型值封装为对象。 拆封：通过valueOf()方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。 使用建议：除非必要，应避免使用构造函数创建封装对象。 三、原生函数作为构造函数 Array()：
不带new关键字时会被自动补全（等效于new Array()）。 仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。 替代方案：ES6 的Array.of()（无歧义，始终将参数作为元素） 稀疏数组：包含至少一个空单元的数组，可通过以下方式创建： 设置length属性值超过实际单元数； 使用delete删除数组单元。 可通过Array.apply(null, {length: 3})创建包含undefined单元（非空单元）的数组。 不建议使用的构造函数： 除非特殊需求，尽量避免使用Object()、Function()、RegExp()作为构造函数。
Date()：
必须使用new Date()创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。 时间戳获取：getTime()方法或Date.now()（ES5&#43;）可获取 Unix 时间戳。 特殊情况：不带new关键字调用Date()时，返回当前日期的字符串值（格式无统一规范）。 Error()： 带或不带new关键字均可使用。 作用：创建错误对象以获取当前运行栈上下文（含函数调用栈、错误行号等，便于调试），通常与throw配合使用。 特性：错误对象至少包含message属性；除Error外，还有针对特定错误类型的原生构造函数（如TypeError、RangeError），这些构造函数在程序异常时自动调用。 Symbol（符号）： 特性：特殊的基本类型值，具有唯一性，用作对象属性名时不易重名。 访问性：可作为属性名，但在代码或控制台中难以直接查看和访问其值。 预定义符号：ES6 中以Symbol静态属性形式存在（如Symbol.iterator）。 使用规则：Symbol()不能带new关键字（否则报错）；符号是基本类型，非对象，不可枚举（不被for...in遍历），主要用于私有或特殊属性。 四、原生原型 原型特征： 原生构造函数（如Array、Function、RegExp等）都有自己的prototype对象，这些对象包含对应子类型的特有行为特征。 实用场景： Function.prototype是空函数，RegExp.prototype是空正则表达式，Array.prototype是空数组，适合作为未赋值变量的默认值。 优势：prototype对象已预先创建且仅创建一次，性能更优。 注意：若默认值后续会被修改，则不建议使用原生原型作为默认值。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/3.-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、值类型转换的基本概念 定义与区分： 显式类型转换：主动将值从一种类型转换为另一种（如String(123)）。 隐式强制类型转换：操作中自动发生的类型转换（如1 &#43; &#34;2&#34;）。 特性：JS 强制类型转换始终返回标量基本类型值，对象封装（如new Number(1)）不算严格意义上的强制转换。 与其他语言的差异： 静态类型语言的 “类型转换” 发生在编译阶段； 动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。 二、抽象值操作（内部使用的转换规则） 抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括ToString、ToNumber、ToBoolean。
2.1 ToString（非字符串→字符串） 基本类型转换规则：
null → &#34;null&#34;；undefined → &#34;undefined&#34;；true → &#34;true&#34;；false → &#34;false&#34;。 数字：常规数字直接转换（如123→&#34;123&#34;），极小 / 极大数字用指数形式（如1e-20、1e&#43;20）。 对象 / 数组转换：
普通对象：默认返回内部属性[[Class]]值（如&#34;[object Object]&#34;）；若自定义toString()方法，则调用该方法并使用其返回值。 数组：toString()将所有元素字符串化后用,连接（如[1, 2, 3].toString() → &#34;1,2,3&#34;）。 JSON.stringify () 的特殊处理：
作用：将 JSON 对象序列化为字符串，遵循ToString规则但结果必为字符串。
安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ undefined、function 、symbol、循环引用对象）的处理：
对象中遇到非安全值：自动忽略。 数组中遇到非安全值：返回null（保持数组长度）。 循环引用对象：直接报错。 toJSON()方法：若对象定义了toJSON()，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：toJSON()应返回安全值，而非字符串）。
可选参数：
replacer（数组 / 函数）：数组时仅序列化数组中指定的属性；函数时对每个属性调用（返回undefined则忽略该属性，否则返回处理后的值）。 space（数字 / 字符串）：指定缩进格式，数字时为每级缩进字符数，字符串时取前 10 个字符作为缩进。 2.2 ToNumber（非数字→数字） 基本类型转换规则： true → 1；false → 0；undefined → NaN；null → 0。 字符串：遵循数字常量语法，转换失败返回NaN（注意：不处理八进制前缀0，如&#34;012&#34;→12而非10）。 对象 / 数组转换： 先通过ToPrimitive转换为基本类型：优先调用valueOf()（若返回基本类型则使用）；否则调用toString()（若返回基本类型则使用）。 若valueOf()和toString()均不返回基本类型，抛出TypeError。 特殊对象：Object.create(null)创建的对象无valueOf()和toString()，无法强制转换为数字。 2.3 ToBoolean（非布尔值→布尔值） 假值（转换为 false 的值）：undefined、null、false、&#43;0、-0、NaN、&#34;&#34;（空字符串）。 真值：假值列表以外的所有值（如非空字符串、非 0 数字、对象、数组等）。 假值对象：浏览器环境中特殊的 “外来值”，外观类似普通对象，但强制转换为布尔值时为false（如document.all）。 三、显式强制类型转换（主动触发的转换） 3.1 字符串和数字之间的显式转换 通过内建函数： String(value)：遵循ToString规则，返回字符串基本类型。 Number(value)：遵循ToNumber规则，返回数字基本类型。 通过toString()： 基本类型调用toString()时，JS 引擎会自动创建封装对象，再调用其toString()（如123.toString() → &#34;123&#34;）。 通过一元运算符： &#43;value：显式将value转换为数字（如&#43;&#34;123&#34; → 123）。 -value：转换为数字并反转符号位（如-&#34;123&#34; → -123）。 注意：避免与其他运算符混用（如a &#43; &#43; b易读性差）。 日期转时间戳： &#43;new Date()：返回 Unix 时间戳（毫秒），但更推荐Date.now()（当前时间戳）或new Date().getTime()（指定时间戳）。 字位运算符与数字处理： ~x：等同于-(x &#43; 1)，可配合indexOf()判断是否存在（indexOf(-1)时~-1 → 0为假值，其他情况为真值）。 ~~x或x | 0：通过ToInt32将数字截为 32 位整数（如~~3.14 → 3）。 3.2 显式解析数字字符串 解析与转换的区别： 解析（如parseInt()、parseFloat()）：从左到右处理，遇到非数字字符停止（如parseInt(&#34;12a3&#34;) → 12）。 转换（如Number()）：字符串必须完全为数字格式，否则返回NaN（如Number(&#34;12a3&#34;) → NaN）。 parseFloat()：解析字符串中的浮点数（如parseFloat(&#34;3.14abc&#34;) → 3.14）。 parseInt()： 仅处理字符串，非字符串会先转为字符串（如parseInt(12.3) → 12，因12.3 → &#34;12.3&#34;）。 第二个参数（基数）：指定转换的进制（10 进制最常用）。ES5 及之前默认基数可能因前缀变化（如0开头视为八进制），ES6 后默认 10 进制，但仍建议显式指定（如parseInt(&#34;12&#34;, 10)）。 3.3 显式转换为布尔值 Boolean(value)：遵循ToBoolean规则（如Boolean(&#34;&#34;) → false）。 !!value：通过两次逻辑非显式转换为布尔值（第一次!反转布尔值，第二次!恢复原值，如!!&#34;abc&#34; → true）。 四、隐式强制类型转换（自动触发的转换） 4.1 字符串和数字之间的隐式转换 &#43;运算符的重载： 若有一个操作数为字符串（或可转为字符串），则执行拼接（如&#34;1&#34; &#43; 2 → &#34;12&#34;）。 否则执行数字加法（如1 &#43; true → 2，因true → 1）。 数字转字符串：value &#43; &#34;&#34;（如123 &#43; &#34;&#34; → &#34;123&#34;），优先调用valueOf()再转字符串。 字符串转数字：通过-0、*1、/1（如&#34;123&#34; - 0 → 123），因这些运算符仅适用于数字。 4.2 隐式转换为布尔值（布尔上下文） 以下场景中，非布尔值会自动通过ToBoolean转换为布尔值：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/4.-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、语句与表达式的基本概念 表达式：能返回一个结果值的代码片段（如1 &#43; 2返回3，obj.prop返回属性值）。 语句：执行某种操作的代码（如if、for、return），所有语句都有结果值，但语法默认不允许直接获取。 语句的结果值 常见语句的结果值： 赋值语句a = b：结果值为被赋予的值（即b的值）。 变量声明var a：结果值为undefined（let/const同理）。 代码块{...}：结果值为块内最后一个语句 / 表达式的结果（如{1; 2; 3}结果为3）。 获取语句结果值的方式：语法不直接支持，但可通过eval()获取（如eval(&#39;{a=1; b=2}&#39;)返回2）。 二、表达式的副作用 副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。
常见有副作用的表达式 函数调用：最常见（如console.log(1)会输出内容，改变控制台状态）。 自增 / 自减运算符： a&#43;&#43;：先返回a的当前值，再将a加 1（副作用在后）。 &#43;&#43;a：先将a加 1，再返回新值（副作用在前）。 注意：&#43;&#43;a&#43;&#43;会报错（ReferenceError），因运算符需要可赋值的变量作为操作数。 逗号运算符：将多个表达式串联为一个语句，返回最后一个表达式的结果（如a=1, b=2, a&#43;b结果为3），副作用是执行所有表达式。 delete 操作符： 作用：删除对象属性或数组单元。 结果值：成功删除（属性不存在或可配置）返回true；失败（不可配置属性）返回false或报错。 副作用：实际移除属性 / 单元（如delete obj.prop后obj.prop为undefined）。 赋值语句：a = 42结果为42，副作用是a被赋值为42；链式赋值（如a = b = 42）利用赋值表达式的结果值实现。 三、上下文规则 3.1 大括号{}的用法 对象常量：定义对象字面量（如{a: 1, b: 2}）。
标签（label）：用于标记代码块，配合break/ continue跳转：
break 标签：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。 continue 标签：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。 注意：标签不能用双引号；非循环代码块可使用break 标签，但不能用continue 标签。 JSON 与 JSON-P：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/5.-%E8%AF%AD%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、Annex B（ES 规范的兼容性补充） 背景： ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。
主要兼容性差异：
非严格模式允许八进制数值常量（如012，严格模式下为语法错误）；
浏览器提供window.escape()和window.unescape()，用于转义 / 还原带%分隔符的十六进制字符串（非标准方法，建议避免使用）；
String.prototype.substr与String.prototype.substring
的区别：
substring(start, end)：第二个参数为结束位置索引（不包含该位置）； substr(start, length)：第二个参数为截取长度。 Web ES 规范的额外差异：
&lt;!--和--&gt;被视为合法单行注释分隔符； String.prototype包含返回 HTML 格式字符串的附加方法（如anchor()、bold()）； 正则表达式（RegExp）扩展及Function.prototype附加方法（非标准，依赖浏览器实现）。 二、宿主对象 定义：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如window、document、console），包括内建对象和工具函数。 特殊行为差异： 部分宿主对象强制转换为布尔值时可能为假值（如document.all，不符合 JS 标准假值规则）； 其他特性： 可能无法访问普通Object的内建方法（如toString()）； 部分属性为只读，无法覆盖； 方法的this无法重绑定到其他对象。 console 对象： 宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。 三、全局 DOM 对象 全局变量与 global 对象：声明全局变量会同时在全局对象（如浏览器的window）中创建同名属性。 DOM 元素 ID 的副作用：因浏览器历史遗留问题，带id属性的 DOM 元素会自动创建同名全局变量（如&lt;div id=&#34;app&#34;&gt;会生成window.app）。 四、原生原型扩展的注意事项 不建议扩展原生原型：除非确保无代码冲突（如第三方库可能覆盖扩展方法）。 扩展原则：扩展原生方法时需添加判断（如if (!Array.prototype.includes) { ... }），避免覆盖已有功能。 polyfill 与 shim： shim：带兼容性测试的代码，用于填补环境差异（如检查功能是否存在，不存在则提供替代实现）； polyfill：只检查功能是否存在，不进行兼容性测试 pollyfill：特殊的 shim，专为实现未被环境支持的标准功能而设计，需与未来标准兼容（如为老浏览器实现Array.prototype.includes）。 五、script 标签与代码加载 多文件 / 内联代码的运行特性： 多个script标签（外部文件或内联代码）共享全局对象，在同一命名空间交互，但全局作用域的提升机制不跨文件边界（即一个文件的变量不会提升到另一个文件）。 单个script出错会停止自身执行，但不影响后续script运行。 动态创建 script：通过 JS 动态创建&lt;script&gt;标签并插入 DOM，效果与静态标签一致，可用于动态加载外部文件。 内联代码的特殊限制：内联代码中不能直接出现&lt;/script&gt;（会被视为代码块结束），变通方法为拆分字符串（如&#34;&lt;sc&#34;&#43;&#34;ript&gt;&#34;）。 字符集差异： 外部文件通过script标签的charset属性指定解析字符集； 内联代码使用所在页面的字符集，且内联script无charset属性。 六、保留字 定义：ES5 规范定义的不可用作变量名的标识符，包括四类：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>React Native 是一个使用React和应用平台的原生功能来构建 Android 和 iOS 应用的开源框架。
通过 React Native，您可以使用 JavaScript 来访问移动平台的 API，以及使用 React 组件来描述 UI 的外观和行为：一系列可重用、可嵌套的代码。
视图（Views）与移动开发 在 Android 和 iOS 开发中，一个视图是 UI 的基本组成部分：屏幕上的一个小矩形元素、可用于显示文本、图像或响应用户输入。甚至应用程序最小的视觉元素（例如一行文本或一个按钮）也都是各种视图。某些类型的视图可以包含其他视图。全部都是视图。
原生组件 在 React Native 中，使用 React 组件通过 JavaScript 来调用这些视图。
在运行时，React Native 为这些组件创建相应的 Android 和 iOS 视图。
由于 React Native 组件就是对原生视图的封装，因此使用 React Native 编写的应用外观、感觉和性能与其他任何原生应用一样。我们将这些平台支持的组件称为原生组件。
React Native 还包括一组基本的，随时可用的原生组件，您可以使用它们来构建您的应用程序。这些是 React Native 的核心组件。
核心组件 React Native 具有许多核心组件，从表单控件到活动指示器，应有尽有。主要使用以下核心组件：
React Native UI 组件 Android 原生视图 iOS 原生视图 Web 标签 说明 &lt;View&gt; &lt;ViewGroup&gt; &lt;UIView&gt; A non-scrolling &lt;div&gt; 一个支持使用flexbox布局、样式、一些触摸处理和无障碍性控件的容器 &lt;Text&gt; &lt;TextView&gt; &lt;UITextView&gt; &lt;p&gt; 显示、样式和嵌套文本字符串，甚至处理触摸事件 &lt;Image&gt; &lt;ImageView&gt; &lt;UIImageView&gt; &lt;img&gt; 显示不同类型的图片 &lt;ScrollView&gt; &lt;ScrollView&gt; &lt;UIScrollView&gt; &lt;div&gt; 一个通用的滚动容器，可以包含多个组件和视图 &lt;TextInput&gt; &lt;EditText&gt; &lt;UITextField&gt; &lt;input type=&#34;text&#34;&gt; 使用户可以输入文本 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/react/react-native/%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/posts/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/posts/page/5/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
