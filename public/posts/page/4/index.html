<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - My New Hugo Site">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文总结《你不了解的JS》第一部分第一章的核心概念，重点介绍了JavaScript的编译原理和作用域机制。笔记指出程序状态通过变量存储和访问实现，作用域是一套管理变量的规则体系。编译过程包括分词、语法分析和代码生成三个阶段。在变量赋值时，编译器处理声明，引擎执行查询（LHS/RHS）。作用域嵌套时，引擎会逐级向上查找变量。文章还区分了RHS和LHS查询的区别，以及在不同情况下可能出现的ReferenceError和TypeError异常。严格模式会改变LHS查询失败时的默认行为。
一、核心概念 程序状态与变量：存储和访问变量值的能力为程序赋予了状态。 作用域定义：一套规则体系，用于管理变量的存储方式和查找逻辑，确保代码能按规则访问变量。 二、编译原理 传统编译三阶段： 分词 / 词法分析：将源代码字符串分解为有意义的词法单元（如关键字、变量名、运算符等）。 解析 / 语法分析：将词法单元流转换为抽象语法树（AST），AST 是体现程序语法结构的嵌套树状结构。 代码生成：将 AST 转换为可执行代码。 JavaScript 编译特点：多数情况下，编译在代码片段执行前的几微秒内完成（即时编译）。 三、作用域的核心角色 引擎：负责整个 JavaScript 程序的编译及执行全过程。 编译器：负责语法分析、代码生成等编译相关工作。 作用域：负责收集并维护所有声明的标识符（变量、函数名等），并制定规则确定当前执行的代码对这些标识符的访问权限。 四、变量声明与赋值过程（以var a = 2为例） 变量声明（编译器处理）： 编译器询问当前作用域：是否已存在名为a的变量。 若存在，忽略该声明；若不存在，要求作用域在当前集合中声明一个新变量a。 变量赋值（引擎处理）： 引擎询问当前作用域：是否存在名为a的变量。存在则直接使用，不存在则继续向上查找。 找到a后，将 2 赋值给它；未找到则抛出异常。 LHS 与 RHS 查询： RHS 查询：查找变量的值（如console.log(a)中对a的查询）。 LHS 查询：查找变量的容器本身，用于赋值（如a = 2中对a的查询）。 函数声明处理：编译器在代码生成阶段同步处理函数的声明和值定义。 五、作用域嵌套 嵌套场景：当块或函数嵌套在另一个块或函数中时，形成作用域嵌套。 查找规则： 引擎从当前执行作用域开始查找变量，找不到则向上一级嵌套作用域继续查找。 直至找到变量或抵达全局作用域，查找过程终止。 六、异常类型及触发场景 ReferenceError（引用错误）： RHS 查询：在所有嵌套作用域中未找到目标变量时抛出。 LHS 查询：严格模式下，在所有作用域中未找到目标变量时抛出（非严格模式下会自动在全局作用域创建该变量，let/const本身在非严格模式下也不会隐式创建全局变量）。 TypeError（类型错误）：RHS 查询找到变量，但对其值进行不合理操作（如对非函数变量调用方法）时抛出。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/1.%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 《你不了解的JS》笔记：词法作用域与欺骗词法
词法作用域由代码书写位置决定，查找从内向外进行，存在遮蔽效应。全局变量可通过window对象间接访问。欺骗词法的方式包括eval和with：eval动态修改作用域（严格模式除外），with将对象处理为临时作用域。两者都会影响性能，eval在严格模式下有独立作用域，with会将var声明泄漏到函数作用域。这些特性都可能导致代码运行效率下降。
一、词法作用域的核心特性 定义与本质： 词法作用域是在代码书写阶段就确定的作用域，由变量、块作用域及函数的声明位置决定，与函数的调用位置无关。 查找规则： 作用域查找从最内部作用域开始，逐级向外（向上）进行，直到找到第一个匹配的标识符后停止（即 “就近匹配”）。 仅查找一级标识符（如a，不会自动查找对象属性链如obj.a）。 遮蔽效应： 在多层嵌套作用域中，内层作用域的标识符可遮蔽外层同名标识符（如内层var a = 1会遮蔽外层的var a = 2）。 全局变量的特殊访问： 全局变量会成为全局对象（如浏览器中的window）的属性，可通过window.a访问被内层同名变量遮蔽的全局变量。 函数的词法作用域： 函数的词法作用域仅由其声明时所处的位置决定，与调用位置、调用方式无关。 二、欺骗词法作用域的方式 1. eval 函数 功能：接收字符串参数，将其视为代码片段插入到当前位置执行，仿佛该代码在书写时就存在于此。 对作用域的影响： 默认情况下，若eval中的代码包含变量 / 函数声明，会修改其所处的词法作用域（新增或覆盖标识符）。 严格模式下，eval有独立的词法作用域，内部声明不会影响外部作用域。 常见用途：执行动态生成的代码（如拼接字符串形成的逻辑）。 2. with 语句 功能：作为访问对象多个属性的快捷方式，避免重复书写对象名（如with(obj) { a = 1; b = 2 }等效于obj.a = 1; obj.b = 2）。 对作用域的影响： 将传入的对象视为一个临时的词法作用域，对象的属性被当作该作用域中的标识符。 块内的var声明不会被限制在with块中，而是泄漏到外层函数作用域。 本质：根据传入对象 “凭空创建” 全新的词法作用域，与eval修改现有作用域的行为不同。 三、副作用与风险 性能问题： eval和with会破坏 JS 引擎的词法作用域静态分析（无法提前确定变量查找规则），导致无法优化代码执行，显著降低运行效率。 代码可读性与维护性： 动态修改作用域会使变量的查找逻辑变得模糊，增加调试难度，不符合词法作用域的设计初衷。 严格模式限制： 严格模式下eval的作用域被隔离，with被完全禁止（直接抛出错误），进一步体现了对 “欺骗词法” 行为的不推荐。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/2.%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 《你不了解的JS》第一部分第三章探讨了函数和块作用域的概念。函数作用域允许变量在函数内部复用，并可通过隐藏内部实现遵循最小特权原则，避免命名冲突。函数声明与表达式的主要区别在于标识符绑定位置，建议为函数表达式命名以便调试。IIFE（立即执行函数表达式）是常见模式，可用于传递参数和解决变量覆盖问题。块作用域通过let和const实现变量本地化，let在循环中每次迭代重新绑定变量，const则创建不可变绑定。这些机制有助于优化变量生命周期和避免提升问题。
一、函数作用域的核心特性 定义与复用：函数内部声明的变量，可在整个函数范围内（包括嵌套作用域）使用和复用。 隐藏内部实现： 通过函数作用域封装变量和函数，遵循最小特权原则（仅暴露必要内容，隐藏细节），减少命名冲突。 第三方库通常通过命名空间对象（将功能作为对象属性暴露）或模块管理器（避免全局作用域污染）防止冲突。 二、函数声明与表达式的区别 区分方法： 若function是声明的第一个词，则为函数声明；否则为函数表达式。 关键差异： 函数声明的名称标识符绑定在所在作用域中； 函数表达式的名称标识符绑定在自身函数内部（外部不可直接访问）。 匿名函数表达式的缺点： 栈追踪无有意义名称，调试困难； 无法通过名称自引用（依赖arguments.callee，已过时）； 降低代码可读性。 最佳实践：始终为函数表达式命名（如const fn = function namedFn() {}）。 三、立即执行函数表达式（IIFE） 定义：函数表达式被声明后立即执行（如(function() { ... })()）。
常见用途
：
传递参数，隔离作用域（避免污染外部）； 确保undefined标识符的准确性（通过参数占位，如(function(undef) { ... })()）； 倒置代码执行顺序（将主逻辑作为参数传递给 IIFE）。 四、块作用域的特性与实现 核心作用：将变量本地化，扩展最小授权原则，从函数级隐藏扩展到块级隐藏。 块作用域的优势：变量声明靠近使用位置，减少作用域污染，优化变量生命周期，避免提升带来的意外行为。 实现方式： with 语句：为对象创建临时块作用域（仅在with内部有效）； try/catch：catch分句创建块作用域，内部变量仅在catch中有效； let 关键字： 将变量绑定到所在块作用域（如if、for块）； 无提升特性（声明前访问会报错）； for循环中，let会将变量重新绑定到每个迭代（确保迭代值独立）。 const 关键字： 同let的块作用域特性，但值为常量（修改会报错）。 原书中P34最上方 “点击事件因闭包导致变量问题” 的描述有误：实际是var声明的变量属于函数 / 全局作用域，生命周期长，导致循环中共享同一变量；而let通过块作用域解决此问题。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/3.%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> JS中的变量和函数声明会在代码执行前被&#34;提升&#34;。引擎在编译阶段会将所有声明提前处理，但赋值操作保留原位。函数声明优先于变量声明，且会被提升到作用域顶部。需要注意的是，函数表达式不会被提升，块级函数声明也存在提升问题。开发者应避免在块内部声明函数，且重复声明时后面的函数会覆盖前面的。这些机制体现了JS编译阶段和执行阶段的差异性。
一、变量和函数声明的提升机制 提升的本质： 引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。 作用域范围：每个作用域（全局、函数、块作用域）都会独立进行提升操作。 二、函数声明与变量声明的提升优先级 函数声明优先： 函数声明的提升优先级高于变量声明，会被提升到作用域更顶部。 示例：若同时存在function a() {}和var a，函数声明会先被提升，变量声明因重复被忽略（但变量赋值会覆盖函数）。 函数表达式不提升： 函数表达式（如var fn = function() {}）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到undefined。 具名函数表达式（如var fn = function named() {}）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。 三、特殊情况与注意事项 重复声明的覆盖： 变量重复声明（如var a = 1; var a = 2）会被忽略前序，保留最后一次赋值； 函数重复声明（如function a() {}; function a() {}）后序声明会覆盖前序。 块级函数声明的问题： 普通块内部的函数声明（如if (true) { function a() {} }）可能被提升到所在作用域顶部（不同 JS 环境处理有差异），易导致逻辑混乱，应避免在块内声明函数。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/4.%E6%8F%90%E5%8D%87/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：闭包是指函数能够记住并访问其词法作用域，即使在其作用域外执行。通过回调函数或将内部函数传递到外部都可形成闭包。示例展示了用IIFE解决循环变量共享问题，以及let在循环中的特殊行为。模块模式需满足：1)外部封闭函数被调用创建实例；2)返回内部函数形成闭包访问私有状态。ES6模块与函数模块不同，具有静态API检查机制，需定义在单独文件中，其内容如同在闭包中处理。
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包
只要使用了回调函数，实际上就是在使用闭包
一个需要调用的函数引用了其他作用域的变量，导致该作用域不会消失，并且函数可以随时引用这个作用域
for (var i = 1; i &lt; 5; i&#43;&#43;) { (function (j) { setTimeout(function () { console.log(j); }, j * 1000); }(i)) } 在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会包含有一个具有正确值的变量供我们访问！！！！！
for循环头部的let声明有一个特殊行为：变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量
最常见的实现模块模式的方法通常被称为模块暴露
模块模式需要具备两个必要条件：
必须有外部的封闭函数，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态 模块模式一个简单但强大的用法是命名将要作为公共API返回的对象
模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的API
基于函数的模块并不是一个能被静态识别的模式，可以在运行时修改一个模块的API，ES6模块API是静态的，编辑器可以在编译器检查对导入模块的API成员的引用是否真实存在，而不会等到运行期再动态解析
ES6模块没有行内格式，必须被定义在独立的文件中，模块中的内容会被当做好像包含在作用域闭包中一样来处理
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/5.%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：词法作用域在代码定义时确定，关注函数声明位置；动态作用域在运行时确定，关注函数调用位置。ES6前可用try/catch模拟let的块作用域。箭头函数通过词法作用域绑定this，替代普通函数的this绑定规则，其效果类似于使用self变量或bind方法，解决了this指向问题。三种方式都能确保this正确指向外层对象（示例中的obj），但箭头函数提供了更简洁的语法实现。
词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用
ES6之前可以用catch实现let的效果
{ try { throw undefined; }catch(a){ a=2 console.log(a) } } console.log(a) 箭头函数放弃了普通this绑定的规则，取而代之的是用当前的词法作用域覆盖了this本来的值
var obj = { count:0, cool: function coolFn(){ if(this.count&lt;1){ setTimeout(()=&gt;{ this.count&#43;&#43;; }) } } } 相当于：
var obj = { count:0, cool: function coolFn(){ var self = this if(self.count&lt;1){ setTimeout(function timer()=&gt;{ self.count&#43;&#43;; }) } } } 相当于：
var obj = { count:0, cool: function coolFn(){ if(this.count&lt;1){ setTimeout(function timer()=&gt;{ this.count&#43;&#43;; }.bind(this),100) } } } </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/6.%E9%99%84%E5%BD%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、分块的程序与异步机制 分块程序的本质： 将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。 console.log 的异步特性： 部分浏览器的console.log并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。 二、事件循环 核心机制： 事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个tick： 若队列中有等待事件（即回调函数），则从队列中取出一个执行； 无事件时，循环等待新事件加入。 setTimeout 的作用： 并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。 三、并行执行 异步与并行的区别： 异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）； 并行：关注 “同时发生”（多个操作在物理上同时进行）。 进程与线程： 进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存； JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。 JS 的单线程特性： 函数代码具有原子性（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）； 若函数执行顺序不确定，可能导致竞态条件（因共享状态的修改顺序不可控引发的逻辑错误）。 四、并发 定义： 两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。
JS 的并发形式： 单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。
并发交互的协调方式：
门（Gate）：等待多个条件都满足后再执行下一步。例如：
function foo(x) { a = x * 2; if (a &amp;&amp; b) baz(); // 需a和b都准备好才调用baz() } 门闩（Latch）：“只有第一名取胜”，仅首次满足条件时执行。例如：
function foo(x) { if (!a) { // 仅a未被赋值时执行 a = x * 2; baz(); } } 并发协作：将长期运行的进程拆分为多步 / 多批任务，允许其他并发进程插入事件循环交替运行。例如：处理长列表时，用setTimeout(..., 0)
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/1.-%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、回调函数的本质 回调函数的核心作用是包裹或封装程序的延续逻辑—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。
二、回调地狱（Callback Hell）的成因 回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：
思维与代码的不匹配：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。
控制反转导致的信任问题： 回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：
无法确保回调被调用的次数（可能被多次调用或不调用）； 无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）； 无法确保回调的参数符合预期。 三、回调模式的优化设计 为缓解回调地狱和信任问题，常见的回调模式设计：
分离回调（Split Callbacks）： 为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。 错误优先回调（Error-First Callbacks，Node 风格）： 回调函数的第一个参数固定为错误对象，后续参数为成功结果：
若操作成功，错误参数为null或undefined； 若操作失败，错误参数为非空值（通常是Error对象）。 四、回调调用的最佳实践：永远异步执行 即使回调逻辑可以同步完成，也应强制异步调用（如通过setTimeout或队列机制），确保回调行为的一致性：
避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）； 保证所有回调都遵循相同的异步逻辑，减少不可预测性。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/2.-%E5%9B%9E%E8%B0%83/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、什么是 Promise 1. 未来值 核心特性：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。 状态与不可变性： 封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。 一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。 then 方法的双回调：调用then(onFulfilled, onRejected)时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。 2. 完成事件（流程控制） 本质：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。 反控制反转： 传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过then注册回调，等待 Promise 决议后触发，将控制返还给调用代码。 信号特性：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。 二、具有 then 方法的鸭子类型 thenable 定义：任何具有then方法的对象或函数，被视为与 Promise 一致的 “thenable”。 鸭子类型：通过值的形态（是否有then方法）假定其类型，这是识别 Promise 的核心逻辑。 三、Promise 信任问题（可靠性保障） 异步回调：对 Promise 调用then时，即使 Promise 已决议，回调也始终异步执行（下一个事件循环 tick），确保行为一致。 决议的唯一性： Promise 只能被决议一次（首次调用resolve或reject生效，后续调用被忽略），因此then注册的回调仅执行一次。 若同一回调多次注册，会按注册次数执行。 决议值的单一性： 至多有一个决议值（未显式决议时为undefined），传给所有注册的回调。 调用resolve/reject时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。 异常处理：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。 Promise.resolve 的作用： 传入非 Promise / 非 thenable 值：返回以该值完成的 Promise。 传入真正的 Promise：直接返回该 Promise。 传入 thenable：递归展开至非 thenable 的最终值，返回一个可信任的真正 Promise。 作用：确保任何值通过Promise.resolve过滤后都是可信任的 Promise。 四、链式流（Promise 链式调用） 链式基础： 每次调用then都会创建并返回新的 Promise，支持链式连接。 完成回调的返回值会自动作为新 Promise 的完成值（若返回 Promise/thenable，会展开其决议值）。 错误传播： 若then仅传入完成回调，默认拒绝处理函数会 “重新抛出错误”，使错误沿链传播，直至被显式拒绝处理函数捕获。 若then未传入有效完成回调，默认完成处理函数会将值传递给下一个步骤。 catch 的本质：catch(onRejected)是then(null, onRejected)的缩写，仅处理拒绝，自动传递完成值。 五、Promise 模式 1. Promise.all（“门” 模式） 作用：等待多个并行 / 并发任务全部完成后再继续，顺序无关。 参数：接受一个由 Promise、thenable 或立即值组成的数组（元素会被Promise.resolve规范化）。 决议规则： 完成：所有成员 Promise 完成后，主 Promise 以 “成员完成值组成的数组” 完成（顺序与传入数组一致，与完成顺序无关）。 拒绝：任一成员 Promise 拒绝时，主 Promise 立即以该拒绝理由拒绝（忽略其他结果）。 特殊情况：传入空数组时，主 Promise立即完成（值为 []）。 2. Promise.race（“门闩” 模式） 作用：仅响应第一个决议的 Promise（完成或拒绝），忽略其他。 参数：接受一个由 Promise、thenable 或立即值组成的数组（元素会被Promise.resolve规范化）。 决议规则： 完成：第一个完成的成员 Promise 的完成值作为主 Promise 的完成值。 拒绝：第一个拒绝的成员 Promise 的拒绝理由作为主 Promise 的拒绝理由。 特殊情况：传入空数组时，主 Promise永远不会决议。 六、Promise API 概述 1. new Promise 构造器 必须与new配合使用，参数为一个同步执行的回调函数，该回调接受两个参数（resolve和reject）： reject(reason)：直接拒绝 Promise，理由为reason。 resolve(value)： 若value为非 Promise / 非 thenable：以value完成 Promise。 若value为 Promise/thenable：递归展开，采用其最终决议状态 / 值。 2. Promise.resolve 和 Promise.reject（静态方法） Promise.reject(reason)：快捷创建已拒绝的 Promise，理由为reason（不展开reason，即使其为 thenable）。 Promise.resolve(value)： 若value为 Promise：直接返回该 Promise。 若value为 thenable：展开至最终值，返回以该值决议的 Promise（完成或拒绝）。 其他情况：返回以value完成的 Promise。 3. then 和 catch（实例方法） then(onFulfilled?, onRejected?)： 注册完成 / 拒绝回调，返回新 Promise。 若回调为非函数：替换为默认回调（完成回调传递值，拒绝回调重新抛错）。 回调返回值处理： 抛出异常：新 Promise 以该异常拒绝。 返回非 Promise / 非 thenable：新 Promise 以该值完成。 返回 Promise/thenable：新 Promise 采用其最终决议状态 / 值。 catch(onRejected)：等价于then(null, onRejected)，仅注册拒绝回调。 4. Promise.all 和 Promise.race（静态方法） 同 “Promise 模式” 中描述，核心为 “门” 和 “门闩” 模式，控制多 Promise 的并发协作。 七、Promise 局限性 错误易被忽略： 若 Promise 链未设置错误处理函数，链中任何错误会一直传播，直至被捕获（可能导致隐性 bug）。 链中无统一实体标识，无法从外部观察未处理的错误。 单一决议值： 只能有一个完成值或拒绝理由，复杂场景需拆分多个 Promise。 无法中途取消： 一旦创建 Promise 并注册回调，若任务悬而未决，无法从外部终止其进程。 轻微性能开销： 相比非 Promise 回调，因内建可靠性（如异步保证、状态管理），性能略低，但可忽略不计。 补充说明（修正与强调） “决议” 包含 “完成（fulfilled）” 和 “拒绝（rejected）” 两种状态，避免混淆为单一概念。 Promise.race 传入空数组 “永远不决议” 是标准行为（因无竞争对象），需注意与 Promise.all 空数组的区别。 所有回调的 “异步执行” 基于事件循环，确保宏观任务队列的顺序性，避免同步执行导致的时序混乱。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/3.-promise/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、生成器的基本概念与特性 定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 二、生成器产生值：生产者与迭代器 1. 迭代器接口 作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 2. for..of循环 自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 3. Iterable（可迭代对象） 定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 4. 生成器迭代器的特性 生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 三、异步迭代生成器 生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&#34;http://...&#34;, (err, data) =&gt; { if (err) it.throw(err); // 向生成器抛错 else it.next(data); // 向生成器传递异步结果 }); } function* main() { try { const text = yield foo(11, 31); // 暂停等待异步结果 console.log(text); } catch (err) { console.error(err); // 捕获异步错误 } } const it = main(); it.next(); // 启动生成器 上述代码中，yield等待异步操作foo完成，通过it.next(data)或it.throw(err)恢复执行，实现 “同步写法 &#43; 异步执行”。 四、生成器与 Promise 的结合 优势：生成器的 “同步化异步代码” 与 Promise 的 “可信任异步结果” 结合，是 ES6 中处理异步的理想模式。 实现方式：yield产出一个 Promise，通过 Promise 的状态（完成 / 拒绝）控制生成器迭代器： Promise 完成时，调用it.next(结果值)恢复生成器； Promise 拒绝时，调用it.throw(错误)向生成器抛错。 五、生成器委托（yield*） 语法：yield* 迭代对象（如yield* foo()，foo为生成器或其他可迭代对象）。 作用：将迭代控制委托给另一个迭代器，暂停当前生成器的迭代控制，转由目标迭代器接管。 特性：支持双向消息与错误传递（目标迭代器的yield与当前生成器的next/throw可交互）。 六、形实转换程序（Thunk） 定义：JS 中的 thunk 指一个无参数函数，其作用是调用另一个函数（封装参数或逻辑）。 用途：常用于简化函数调用，尤其是在异步流程中封装回调或参数，配合生成器使用可进一步简化异步代码。 补充说明 生成器的yield数量与next()调用次数关系：next()调用次数比yield语句多 1（最后一次next()用于获取done: true）。 生成器迭代器的独立性：同一生成器的多个实例（迭代器）互不干扰，可并发运行。 for..of与迭代器的兼容性：仅支持符合 ES6 迭代器标准的对象（实现Symbol.iterator）。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/4.-%E7%94%9F%E6%88%90%E5%99%A8/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/posts/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/posts/page/5/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
