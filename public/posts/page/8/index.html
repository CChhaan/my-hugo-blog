<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - My New Hugo Site">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/posts/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一元操作符 只操作一个值的操作符叫一元操作符
递增递减操作符 前缀递增操作符会给数值加1，把两个加号(&#43;&#43;)放到变量前头即可 前缀递减操作符类似，只不过是从一个数值减1。使用前缀递减操作符，只要把两个减号(–)放到变量前头即可 无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。
递增和递减的后缀版语法一样（分别是&#43;&#43;和–），只不过要放在变量后面。后缀版和前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。
这四个操作符可以用于任何值，不限于整数——字符串、布尔值、浮点值，甚至对象都可以
递增和递减操作符遵循如下规则：
对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型由字符串变成数值 对于字符串，如果不是有效的数值形式，则将变量的值设置为NaN。变量类型由字符串变成数值。 对于布尔值，如果是false，则转换为0再应用改变。变量类型由布尔值变成数值 对于布尔值，如果是true，则转换为1再应用改变。变量类型由布尔值变成数值 对于浮点值，加1或减1 如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是NaN，则调用toString()并再次应用其他规则。变量类型由对象变成数值 一元加和减 一元加由一个加号(&#43;)表示，放在变量前头，对数值没有任何影响 如果将一元加应用到非数值，则会执行与使用Number()转型函数一样的类型转换
一元减由一个减号(-)表示，放在变量前头，主要用于把数值变成负值 如果将一元减应用到非数值，则会执行与使用Number()转型函数一样的类型转换，然后再去负值
位操作符 暂时跳过
布尔操作符 逻辑非 逻辑非操作符由一个叹号(!)表示，可应用给ES中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。 逻辑非操作符会遵循如下规则：
如果操作数是对象，则返回false 如果操作数是空字符串，则返回true 如果操作数是非空字符串，则返回false 如果操作数是数值0，则返回true 如果操作数是非0数值，则返回false 如果操作数是null，则返回true 如果操作数是NaN，则返回true 如果操作数是undefined，则返回true 逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号(!!)，相当于调用了转型函数Boolean()。
逻辑与 逻辑与操作符由两个和号(&amp;&amp;)表示，应用到两个值 逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果操作数不是布尔值，逻辑与并不一定会返回布尔值，而是遵循如下规则：
如果第一个操作数是对象，则返回第二个操作数。 如果第二个操作数是对象，则返回第一个操作数求值为true才会返回该对象 如果两个操作数都是对象，则返回第二个操作数 如果有一个操作数是null。则返回null 如果有一个操作数是NaN。则返回NaN 如果有一个操作数是undefined。则返回undefined 逻辑与操作符是一种短路操作符，如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第二个操作数是false，那么无论第二个操作数是什么值，结果也不可能等于true
逻辑或 逻辑或操作符由两个管道符(||)表示 与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：
如果第一个操作数是对象，则返回第一个操作数。 如果第一个操作数求值为false，则返回第二个操作数 如果两个操作数都是对象，则返回第一个操作数 如果两个操作数都是null。则返回null 如果两个个操作数都是NaN。则返回NaN 如果两个个操作数都是undefined。则返回undefined 同样与逻辑与类似，逻辑或操作符也具有短路特性，只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了
利用这个行为，可以避免给变量赋值null或undefined
let myObject = preferredObject || backupObject 乘性操作符 乘法操作符 乘法操作符由一个星号(*)表示，用于计算两个数值的乘积
乘法操作符在处理特殊值时有一些特殊行为：
如果操作数都是数值，则执行常规的乘法运算 如果有任一操作数是NaN，则返回NaN Infinity * 0 = NaN Infinity乘以非零的有限值，则根据第二个操作数的符号返回Infinity或-Infinity Infinity * Infinity = Infinity 如果有不是数值的操作数，则现在后台用Number()将其转换为数值，在应用上述规则 除法操作符 除法操作符由一个斜杠(/)表示，用于计算第一个操作数除以第二个操作数的商
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.4%E6%93%8D%E4%BD%9C%E7%AC%A6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>if语句 if(condition) statement1 else statement2 这里的条件condition可以是任何表达式，并且求值结果不一定是布尔值，ES会自动调用Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为true，则执行语句statement1；如果条件求值为false，则执行语句statement2。 这里的语句可能是一行代码，也可能是一个代码块，最佳实践是使用代码块，即使只有一行代码也是如此。
if(condition1) statement1 else if(condition2) statement2 else statement3 do-while语句 do { statement } while(expression) do-while是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次
while语句 while(expression)statement while语句是一种先测试循环语句，即先检测退出条件，在执行循环体内的代码。因此，while循环体内的代码有可能不会执行
for语句 for(initialization;expression;post-loop-expression)statement 也是先测试循环语句，只不过增加了进入循环之前的初始化代码和循环执行后要执行的表达式
无法通过while循环实现的逻辑，同样也无法使用for循环实现。
初始化、条件表达式、循环后表达式都不是必须的。
for-in语句 for(property in expression) statement 是一种严格的迭代语句，用于枚举对象中的非符号键属性
ES中对象的属性是无序的，因此for-in语句不能保证返回对象属性的顺序
如果for-in循环要迭代的变量是null或undefined，则不执行循环体
for-of语句 for(property of expression)statement 是一种严格的迭代语句，用于遍历可迭代对象的元素
for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素。
如果尝试迭代的变量不支持迭代，则for-of语句会抛出错误
标签语句 label:statement 用于给语句加标签
可以在后面通过break或continue语句引用。标签语句的典型应用场景是嵌套循环
break和continue语句 break用于立即退出循环，强制执行循环后的下一条语句，continue语句也用于立即退出循环，但会再次从循环顶部开始执行
break和continue都可以与标签语句一起使用，返回代码中特定的位置。
with语句 with的用途是将代码作用于设置为特定的对象
with(expression)statement 使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利
let qs = location.search.subString(1) let hostname = location.hostname let url = location.href with(location){ let qs = search.subString(1) let hostname = hostname let url = href } with语句内部，每个变量首先会被认为是一个局部变量，如果没有找到该局部变量，则会搜索location对象，看它是否有一个同名属性。如果有，则该变量会被求值为location对象的属性
严格模式不允许使用with语句，否则会抛出错误
with语句影响性能且难以调试
switch语句 switch(expression){ case value1: statement break; case value2: statement break; default: statement } 这里的每个case相当于如果表达式等于后面的值，则执行下面的语句。break关键字会导致代码执行跳出switch语句。如果没有break，则代码会继续匹配下一个条件。default关键字用于在任何条件都没有满足时默认执行的语句
为避免不必要的条件判断，最好给每个条件后面都加上break语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了break
switch语句可以用于所有数据类型，因此可以使用字符串甚至对象。 条件的值不需要是常量，也可以是变量或表达式
switch语句在比较每个条件的值时使用全等操作符，因此不会强制转换数据类型
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.5%E8%AF%AD%E5%8F%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>函数声明：
function functionName(arg0, arg1,..., argN){ statements } 函数调用：
functionName(arg0,arg1,...argN) ES函数无需指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后要跟返回的值 除了return语句之外没有任何特殊声明表明该函数有返回值。 只要碰到return语句，函数就会立即停止执行并退出。因此return语句后面的代码不会被执行 一个函数里也可以有多个return语句 return语句也可以不带返回值。这时候函数会立即停止执行并返回undefined。这种用法最常用于提前终止函数执行，并不是为了返回值
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>script元素：将JS插入HTML地主要方法
嵌入行内JavaScript代码：
直接把代码放在script元素中，包含在scrip内的代码会被从上到下解释。在script元素中的代码被计算完成之前，页面的其余内容不会加载，也不会显示。 JavaScript代码中不能出现字符串&lt;/script&gt;，可以用转义字符\解决
&lt;script&gt; console.log(hi!) &lt;/script&gt; 包含外部文件的JavaScript代码：
使用src属性，这个属性的值是一个url，指向包含JavaScript代码的文件 文件只需包含要放在&lt;script&gt;的起始及结束标签中间的js代码。 在解释外部JS文件时，页面也会阻塞，阻塞时间包含下载文件的时
&lt;script src=&#34;example.js&#34;&gt;&lt;/script&gt; 使用了src属性的&lt;script&gt;元素不应该再在&lt;script&gt;和&lt;/script&gt;中再包含其他JS代码。如果两者都提供的话，浏览器只会下载并执行脚本文件，忽略行内代码 &lt;script&gt;元素可以包含来自外部域的JS文件 浏览器会按照&lt;script&gt;在页面中出现的顺序依次解释它们
现代Web应用程序通常将所有JS引用放在&lt;body&gt;元素中的页面内容后面，这样，页面会在处理JS代码之前完全渲染页面
defer属性：脚本会被延迟到整个页面都解析完毕后再运行，只对外部脚本文件有效
async属性：不必等脚本下载和执行完后在加载页面，也不必等到异步脚本下载和执行后再加载其他脚本
动态加载脚本：
let script = document.createElement(&#39;script&#39;) //默认情况下，以这种方式创建的script元素是以异步方式加载的，相当于添加了async属性。 script.src=&#39;gibberish.js&#39; script.async=false document.head.appendChild(script) 让浏览器预加载器知道动态请求文件的存在，可以在文档头部显示声明它们：
&lt;link rel=&#34;preload&#34; href=&#34;gibberish.js&#34;&gt; &lt;noscript&gt;元素可以包含任何可以出现在&lt;body&gt;中的HTML元素，&lt;script&gt;除外。 “浏览器不支持脚本&#34;或&#34;浏览器对脚本的支持被关闭&#34;任何一个条件被满足，包含在&lt;noscript&gt;中的内容就会被渲染，否则，浏览器不会渲染&lt;noscript&gt;中的内容
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>在ES中，引用类型是把数据和功能组织到一起的结构，引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。
引用值或对象是某个特定引用类型的实例。新对象通过new操作符后跟一个构造函数来创建。构造函数就是用来创建新对象的函数
let now = new Date() Date类型将日期保存为子协调世界时(UTC)时间1970年1月1日零时至今所经过的毫秒数。
要创建日期对象，就要使用new操作符来调用Date构造函数
在不给Date函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX纪元之后的毫秒数）。辅助办法是Date.parse()和Date.UTC()
Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。所有的实现都必须支持下列的日期格式：
“月/日/年” “月名/日/年” “周几 月名 日 年 时:分:秒 时区” “YYYY-MM-DDTHH:mm:ss.sssZ” 如果传给Date.parse()的字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()。
let someDate = new Date(Date.parse(&#39;May 23 2019&#39;)) let someDate = new Date(&#39;May 23 2019&#39;) Date.UTC()方法也返回日期的毫秒表示，传给它的参数是年、零起点月数(1是0，2是1)、日(1-31)、时(0-23)、分、秒和毫秒。这些参数中，只有前两个(年和月)是必须的。如果不提供日，那么默认为1日。其他参数的默认值都是0 Date.UTC()会被Date构造函数隐式调用，创建的是本地日期。
Date.now()方法，返回表示方法执行时日期和时间的毫秒数。
Date重写了toLocaleString()、toString()和valueOf()方法
Date类型的toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。 toString()方法返回带时区信息的日期和时间 valueOf()返回的是日期的毫秒表示。
专门用于格式化时间日期的方法
日期/时间组件方法(直接涉及取得或设置日期值的特定部分)
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1-date/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>（之后再研究）
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.2-regexp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>每当用到某个原始值的方法或属性时,后台都会创建一个相应原始包装类型的对象,从而暴露出操作原始值的各种方法
let s1 = &#39;some text&#39; let s2 = s1.substring(2) 当第二行访问s1时，是以读模式访问的，也就是要从内存中读取变量保存的值。 在以读模式访问字符串值的时候，后台都会执行以下3步：
创建一个String类型的实例 调用实例上的方法 销毁实例 这种行为可以让原始值拥有对象的行为。
引用类型与原始值包装类型的主要区别在于对象的声明周期。在通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。
可以显示的使用Boolean、Number和String构造函数创建原始值包装对象。不过应该在确实必要时再这么做。 所有原始值包装对象都会转换为布尔值true 另外，Object构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。
Boolean Boolean的实例会重写valueOf()方法，返回一个原始值true或false。toString()方法被调用时也会被覆盖，返回字符串&#34;true&#34;或&#34;false&#34;
Number Number的实例重写了valueOf()方法，返回Number对象表示的原始数值，toString()方法可选的接收一个表示基数的参数，并返回相应基数形式的字符串
toFixed()方法返回包含指定小数点位数的数值字符串，如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位 toExponential()方法返回以科学计数法表示的数值字符串。接收参数表示结果中小数的位数 toPrecision()方法会根据情况返回最合理的结果，可能是固定长度，也可能是科学计数法形式，接收参数表示结果中数字的总位数，会向上或向下舍入 isInteger()方法用于辨别一个数值是否保存为整数 isSafeInteger()方法判断整数是否超出可表示范围
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.3-%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/boolean%E5%92%8Cnumber/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>String的三个继承方法valueOf()、toLocaleString()、toString()都返回对象的原始字符串值
每个String对象都有一个length属性，表示字符串中字符的数量 即使字符串中包含双字节字符，也仍然会按单字节计数
JS字符串 每16位码元对应一个字符，字符串的length属性表示字符串包含多少16位码元
charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。 charCodeAt()方法查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定 fromCharCode()方法根据给定的UTF-16码元创建字符串中的字符，这个方法接收任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
对于大多数语言字符集16位足够了，在Unicode中称为基本多语言平面，为了表示更多的字符，每个字符串使用另外16位去选择一个增补平面。每个字符使用两个16位码元的策略称为代理对 为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用codePointAt()来代替charCodeAt()，可以从指定码元位置识别完整的码点(Unicode的一个字符的完整标识) fromCharCode()也有一个对应的fromCodePoint()，接收任意数量的码点，返回对应字符拼接起来的字符串
字符串操作方法 concat()方法用于将一个或多个字符串拼接成一个新的字符串。 concat可以接收任意多个参数，因此可以一次性拼接多个字符串 更常用的还是使用加号操作符
提取字符串的方法：
slice() substr() substring() 这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一个或两个参数。而第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。
对slice()和substring()而言，第二个参数是提取结束的位置，对substr()方法而言，第二个参数表示返回的字符串数量。在任何情况下，返回第二个参数都意味着提取到字符串末尾。
当某个参数是负值时，slice()方法将所有负值参数都当成字符串长度加上负参数值，substr()方法将第一个负参数值当成字符串长度加上该值，第二个负参数值转换为0，substring()方法将所有负参数值都转换为0
字符串位置方法 indexOf()和lastIndexOf()方法从字符串中搜索传入的字符串，并返回位置，如果没有找到，返回-1
indexOf()方法从字符串开头开始查找子字符串，而lastIndexOf()从字符串末尾开始查找子字符串。
这两个方法都可以接受可选的第二个参数，表示开始搜索的位置。indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符，lastIndexOf()会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。
使用第二个参数并循环调用这两个方法其一，可以在字符串中找到所有的目标子字符串
字符串包含方法 startsWidth()、endsWith()和includes()方法判断字符串中是否包含另一个字符串，从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。 startsWith()检查开始于索引0的匹配项(是否以指定字符串开头)，endsWidth()检查开始于索引(string.length-substring.length)的匹配项(是否以指定字符串结尾)，而includes()检查整个字符串
startsWidth()和includes()方法接收可选的第二个参数，表示开始搜索的位置，如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。
endsWidth()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样。
trim()方法 这个方法创建字符串的一个副本，删除前、后所有空格符，再返回结果。 trimLeft()和trimRight()方法分别用于从字符串开始和末尾清楚空格符
repeat()方法 这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果
padStart()和padEnd()方法 这两个方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法第一个参数是长度，第二个参数是可选的填充字符串，默认为空格
可选的第二个参数不限于一个字符，如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。 如果长度小于或等于字符串长度，会返回原始字符串
字符串迭代与解构 （Symbol学完再说）
字符串大小写转换 toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()
字符串模式匹配方法 (学完正则表达式再说)
localeCompare()方法 这个方法比较两个字符串，返回如下三个值中的一个
如果按字母表顺序，字符串应该排在字符串参数前头，则返回负值。(通常是-1，具体看与实际值相关的实现) 如果字符串与字符串参数相等，则返回0 如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正直(通常是1，具体看与实际值相关的实现) </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.3-%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/string/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>内置对象：任何由ES实现提供、与宿主环境无关，并在ES程序开始执行时就存在的对象
Global Global对象是一种兜底对象，它所针对的是不属于任何对象的属性和方法，在全局作用域中定义的变量和函数都会变成Global对象的属性
Global对象有很多属性，包括undefined、NaN、Infinity等特殊值，Object、Array、Function等原生引用类型构造函数，以及Error构造函数
url编码方法 （以后有时间再研究）
eval()方法 这个方法就是一个完整的ES解释器，它接收一个参数，即一个要执行的ES字符串，当解释器发现eval()调用时，会将参数解释为实际的ES语句，然后将其插入到该位置。
通过eval()调用的代码属于该调用的所在上下文，被执行的代码与该上下文用于相同的作用域链。这意味着定义在包含上下文中的变量可以在eval()调用内部被引用
类似的，可以在eval()内部定义一个函数或变量，然后在外部代码中引用
eval()定义的任何变量和函数都不会提升。
注意提防XSS攻击
window对象 浏览器将window对象实现为Global对象的代理，因此，所有全局作用域声明的变量和函数都变成了window的属性。
当一个函数在没有明确指定this值的情况下，this值等于Global对象
Math Math对象属性 主要用于保存数学中的一些特殊值（用到在查）
min()和max()方法 这两个方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数。数组可以使用扩展操作符
舍入方法 把小数舍入为整数的方法：
Math.ceil()方法始终向上舍入为最接近的整数。 Math.floor()方法始终向下舍入为最接近的整数 Math.round()方法执行四舍五入 Math.fround()方法返回数值最接近的单精度浮点值表示 random()方法 Math.random()方法返回一个0-1范围内的随机数，其中包含0但不包含1。
基于如下公式，从一组整数中随机选择一个数：
number = Math.floor(Math.random() * total_number_of_choices &#43; first_possible_value) 对其函数封装：
function selectFrom(lowerValue,upperValue){ let choice = upperValue - lowerValue &#43; 1 return Math.floor(Math.random() * choice &#43; lowerValue) } 如果需要更高不确定性，使用window.crypto.getRandomValues()
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.4-%E5%8D%95%E4%BE%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>对象是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。
属性的类型 ES使用一些内部特性来描述属性的特征。开发者不能直接访问这些特性，内部特性在规范中会用两个中括号把特性的名称括起来，比如[[Enumerable]]
属性分两种：数据属性和访问器属性
数据属性 数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。
数据属性有四个特性描述它们的行为：
[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Writable]]：表示属性的值是否可以被修改，默认是true [[Value]]：包含属性实际的值，也就是读取和写入属性值的位置，默认值是undefined 要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应，根据要修改的特性，可以设置其中一个或多个值
let person = {} Object.defineProperty(person,&#39;name&#39;,{ writable: false, value: &#39;Nicholas&#39; }) 在调用Object.definePorperty()时，configurable、enumerable、writable的值如果不指定，默认为false
访问器属性 访问器属性不包含数据值，相反，它们包含一个获取函数和一个设置函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为：
[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性，默认都是true [[Enumerable]]：表示属性是否可以通过for-in循环返回，默认是true [[Get]]：获取函数，在读取属性时调用。默认是undefined [[Set]]：设置函数，在写入属性时调用，默认是undefined 访问器属性是不能直接定义的，必须使用Object.defineProperty()
let book = { year_: 2017, edition: 1 } Object.defineProperty(book, &#39;year&#39;, { get(){ return this.year_ } set(){ if(newValue&gt;2017){ this.year_ = newValue this.edition &#43;= newValue - 2017 } } }) 获取和设置函数不一定都要定义。
定义多个属性 Object.defineProperties()方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。
let book = {} Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 } year:{ get(){ return this.year_ } set(){ if(newValue&gt;2017){ this.year_ = newValue this.edition &#43;= newValue - 2017 } } } }) 读取属性的特性 使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性 Object.getOwnPropertyDescriptors()静态方法会在每个自有属性上调用Object.getOwnPropertyDescriptor()方法并在一个新对象中返回它们。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.1-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/posts/page/7/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/posts/page/9/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
