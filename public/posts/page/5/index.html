<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 拾光博客 - 永浩</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 拾光博客 - 永浩">
<meta name="author" content="">
<link rel="canonical" href="https://growyears.netlify.app/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://growyears.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://growyears.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://growyears.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://growyears.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://growyears.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://growyears.netlify.app/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://growyears.netlify.app/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://growyears.netlify.app/posts/">
  <meta property="og:site_name" content="拾光博客 - 永浩">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://growyears.netlify.app/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://growyears.netlify.app/" accesskey="h" title="拾光博客 - 永浩 (Alt + H)">拾光博客 - 永浩</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、Web Worker 基础 定义与作用：
Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。 创建与类型：
专用 Worker（Dedicated Worker）：通过 new Worker(&#39;script.js&#39;) 创建，与主程序是一对一关系，仅能与创建它的程序通信。
示例：
// 主程序中创建专用 Worker const w1 = new Worker(&#39;worker.js&#39;); 二、Worker 通信机制 消息传递：
不共享作用域 / 资源，通过 message 事件双向通信，数据传递基于结构化克隆或所有权转移。
主程序与 Worker 内部均通过postMessage(data)发送消息，通过onmessage监听消息：
// 主程序 w1.postMessage(&#39;hello&#39;); // 发送消息到 Worker w1.onmessage = (e) =&gt; console.log(&#39;收到 Worker 消息：&#39;, e.data); // worker.js 内部 self.onmessage = (e) =&gt; { console.log(&#39;收到主程序消息：&#39;, e.data); self.postMessage(&#39;hi&#39;); // 发送消息到主程序 }; 终止 Worker：
主程序中调用 w1.terminate() 可立即终止 Worker（无清理机会）； Worker 内部可调用 self.close() 主动终止自身。 三、Worker 运行环境 限制与可用资源： 不可访问 DOM、主程序全局变量，但可使用 navigator、location、JSON、setTimeout 等，支持网络请求（如 fetch）。 可通过 importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;) 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。 典型应用场景： 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。 四、数据传递方式 结构化克隆：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E5%BC%82%E6%AD%A5%E5%92%8C%E6%80%A7%E8%83%BD/5.-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、内置类型概述 定义：类型是值的内部特征，决定值的行为，以区分于其他值。 分类： 基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。 对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。 二、typeof 运算符 作用：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。 特殊情况： null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理） 检测 null 值类型的复合条件：!a &amp;&amp; typeof a === &#39;object&#39;（因 null 是假值，且是唯一用 typeof 检测返回 ‘object’ 的基本类型值）。 三、对象子类型 函数（function）： 是 object 的子类型，属于可调用对象。 具有内部属性 [[Call]]，使其可被调用。 可拥有属性，如 length 属性表示其声明的参数个数。 typeof function返回&#34;function&#34;，是历史遗留的特殊处理 数组： 是 object 的子类型。 元素按数字顺序索引，length 属性表示元素个数。 四、值和类型的特性 变量与类型的关系： JS 中变量无类型，只有值有类型。 变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。 对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。 undefined 与 undeclared 的区别： undefined：变量已在作用域中声明但未赋值。 undeclared：变量未在作用域中声明过。 typeof 的安全防范机制： 对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。 应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。 其他安全检查方法： 检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。 依赖注入设计模式：将依赖通过参数显式传递到函数中。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/1.-%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、数组 特性： 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。 使用delete运算符删除单元后，位置变为空白单元，数组length属性不变。 稀疏数组： 指含有空白 / 空缺单元的数组，空白单元值为undefined，但与显式赋值为undefined的单元有区别（如[,,]与[undefined, undefined]行为不同）。 索引与属性： 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在length内，length只计算数字索引的最大整数 &#43; 1）。 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。 类数组转换： 类数组特征：有length和数字索引，但无数组方法（如arguments、DOM 集合NodeList） 可转换为真正的数组，常用方法： Array.prototype.slice.call(类数组) ES6 的Array.from(类数组) 扩展运算符（需类数组为可迭代对象） 二、字符串 与数组的区别： 是类数组（有length、indexOf()、concat()等），但并非字符数组。 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。 数组方法的借用： 可借用数组的非变更方法（如Array.prototype.indexOf.call(str, &#39;a&#39;)）处理字符串。 不可借用数组的变更方法（因字符串不可变），需先通过split(&#39;&#39;)转为数组，处理后再用join(&#39;&#39;)转回字符串。 三、数字 类型与格式： JS 只有一种数值类型number（双精度浮点数），包含整数（如42.0）和带小数的十进制数。 字面量表示： 十进制：可省略小数点前的 0（.42）或后多余的 0（42.）。 特殊格式：指数形式（1e3）、二进制（0b1010）、八进制（0o12）、十六进制（0xa）。 显示规则： 大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同toExponential()）。 Number 对象方法： toFixed(n)：指定小数部分显示位数，不足用 0 补齐（返回字符串）。 toPrecision(n)：指定有效数位的显示位数。 注意：数字字面量调用方法时，需避免.被误判为数字一部分（如42..toFixed(2)或42 .toFixed(2)）。 精度与范围： 精度问题：0.1 &#43; 0.2 !== 0.3（浮点数二进制存储导致精度丢失），可通过Math.abs(n1 - n2) &lt; Number.EPSILON（机器精度）判断近似相等。
范围：
最大浮点数：Number.MAX_VALUE；最小浮点数（接近 0 的正数）：Number.MIN_VALUE。 安全整数范围：Number.MIN_SAFE_INTEGER（-2^53 &#43; 1）到Number.MAX_SAFE_INTEGER（2^53 - 1），超出需用字符串处理。 BigInt解决大整数：用n后缀声明，支持超出安全范围的整数运算 const big = 9007199254740993n; big &#43; 1n; // 9007199254740994n（精确计算） 检测方法： Number.isInteger(num)：检测是否为整数（ES6&#43;）。 Number.isSafeInteger(num)：检测是否为安全整数（ES6&#43;）。 四、特殊数值 null 与 undefined： 均为唯一值，名称即类型也即值。 区别： null：表示 “空值”（曾赋值，当前无值），不是标识符，不能作为变量赋值。 undefined：表示 “未赋值”，是内置标识符（不建议手动赋值，严格模式下可能报错）。 void运算符：表达式void XXX返回undefined，不改变表达式副作用（惯例用void 0获取undefined）。 NaN（Not a Number）： 属于number类型，代表数学运算失败的警戒值。 特性：与自身不相等（NaN !== NaN）。 检测：isNaN()不可靠（误判非数字类型），Number.isNaN()更准确（仅检测NaN）。 无穷数（Infinity）： 产生：正数除以 0 得Infinity，负数除以 0 得-Infinity；运算溢出时也会返回。 特性： Infinity / Infinity结果为NaN。 有穷正数 /Infinity为 0，有穷负数 /Infinity为-0。 溢出为无穷数后，无法再得到有穷数。 负零（-0）： 产生：某些数学运算（如-1 / Infinity）的结果，加减法不会得到-0。 特性： 字符串化返回&#34;0&#34;，但从字符串转回数字时保留符号。 -0 === 0为true，ES6 的Object.is(-0, 0)为false（可准确区分）。 五、值和引用 引用本质： JS 中引用指向值，而非变量；多个引用可指向同一值，但引用间无相互指向关系。 赋值 / 传递规则： 由值的类型决定，与语法无关： 基本类型（null、undefined、string、number、boolean、symbol）：通过值复制（赋值 / 传递的是值的副本）。 复合值（对象、函数、数组等）：通过引用复制（赋值 / 传递的是指向值的引用）。 操作特性： 引用无法修改另一个引用的指向（如a = b后修改a不影响b）。 复合值的复制：需创建复本（如a.slice()返回数组浅复本），避免引用共享。 基本类型的修改：若需在函数内修改基本类型，需封装到复合值中（通过引用传递）。 基本类型不可变：其值无法被修改（如字符串的方法均返回新值）。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/2.-%E5%80%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、内部属性 [[Class]] 基本概念： 内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。 属性特征： 所有typeof返回值为object的对象都包含内部属性[[Class]]，该属性无法直接访问。 通常通过Object.prototype.toString()方法查看[[Class]]的值。 对应关系： 多数情况下，对象的[[Class]]属性值与创建该对象的内建原生构造函数相对应。 特殊情况：虽然不存在Null()和undefined()原生构造函数，但null和undefined的[[Class]]属性值分别为&#39;Null&#39;和&#39;Undefined&#39;。 二、封装对象包装 自动包装机制： 基本类型值（如string、number等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。 手动封装与拆封： 手动封装：使用Object()函数（不带new关键字）可将基本类型值封装为对象。 拆封：通过valueOf()方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。 使用建议：除非必要，应避免使用构造函数创建封装对象。 三、原生函数作为构造函数 Array()：
不带new关键字时会被自动补全（等效于new Array()）。 仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。 替代方案：ES6 的Array.of()（无歧义，始终将参数作为元素） 稀疏数组：包含至少一个空单元的数组，可通过以下方式创建： 设置length属性值超过实际单元数； 使用delete删除数组单元。 可通过Array.apply(null, {length: 3})创建包含undefined单元（非空单元）的数组。 不建议使用的构造函数： 除非特殊需求，尽量避免使用Object()、Function()、RegExp()作为构造函数。
Date()：
必须使用new Date()创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。 时间戳获取：getTime()方法或Date.now()（ES5&#43;）可获取 Unix 时间戳。 特殊情况：不带new关键字调用Date()时，返回当前日期的字符串值（格式无统一规范）。 Error()： 带或不带new关键字均可使用。 作用：创建错误对象以获取当前运行栈上下文（含函数调用栈、错误行号等，便于调试），通常与throw配合使用。 特性：错误对象至少包含message属性；除Error外，还有针对特定错误类型的原生构造函数（如TypeError、RangeError），这些构造函数在程序异常时自动调用。 Symbol（符号）： 特性：特殊的基本类型值，具有唯一性，用作对象属性名时不易重名。 访问性：可作为属性名，但在代码或控制台中难以直接查看和访问其值。 预定义符号：ES6 中以Symbol静态属性形式存在（如Symbol.iterator）。 使用规则：Symbol()不能带new关键字（否则报错）；符号是基本类型，非对象，不可枚举（不被for...in遍历），主要用于私有或特殊属性。 四、原生原型 原型特征： 原生构造函数（如Array、Function、RegExp等）都有自己的prototype对象，这些对象包含对应子类型的特有行为特征。 实用场景： Function.prototype是空函数，RegExp.prototype是空正则表达式，Array.prototype是空数组，适合作为未赋值变量的默认值。 优势：prototype对象已预先创建且仅创建一次，性能更优。 注意：若默认值后续会被修改，则不建议使用原生原型作为默认值。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/3.-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、值类型转换的基本概念 定义与区分： 显式类型转换：主动将值从一种类型转换为另一种（如String(123)）。 隐式强制类型转换：操作中自动发生的类型转换（如1 &#43; &#34;2&#34;）。 特性：JS 强制类型转换始终返回标量基本类型值，对象封装（如new Number(1)）不算严格意义上的强制转换。 与其他语言的差异： 静态类型语言的 “类型转换” 发生在编译阶段； 动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。 二、抽象值操作（内部使用的转换规则） 抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括ToString、ToNumber、ToBoolean。
2.1 ToString（非字符串→字符串） 基本类型转换规则：
null → &#34;null&#34;；undefined → &#34;undefined&#34;；true → &#34;true&#34;；false → &#34;false&#34;。 数字：常规数字直接转换（如123→&#34;123&#34;），极小 / 极大数字用指数形式（如1e-20、1e&#43;20）。 对象 / 数组转换：
普通对象：默认返回内部属性[[Class]]值（如&#34;[object Object]&#34;）；若自定义toString()方法，则调用该方法并使用其返回值。 数组：toString()将所有元素字符串化后用,连接（如[1, 2, 3].toString() → &#34;1,2,3&#34;）。 JSON.stringify () 的特殊处理：
作用：将 JSON 对象序列化为字符串，遵循ToString规则但结果必为字符串。
安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ undefined、function 、symbol、循环引用对象）的处理：
对象中遇到非安全值：自动忽略。 数组中遇到非安全值：返回null（保持数组长度）。 循环引用对象：直接报错。 toJSON()方法：若对象定义了toJSON()，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：toJSON()应返回安全值，而非字符串）。
可选参数：
replacer（数组 / 函数）：数组时仅序列化数组中指定的属性；函数时对每个属性调用（返回undefined则忽略该属性，否则返回处理后的值）。 space（数字 / 字符串）：指定缩进格式，数字时为每级缩进字符数，字符串时取前 10 个字符作为缩进。 2.2 ToNumber（非数字→数字） 基本类型转换规则： true → 1；false → 0；undefined → NaN；null → 0。 字符串：遵循数字常量语法，转换失败返回NaN（注意：不处理八进制前缀0，如&#34;012&#34;→12而非10）。 对象 / 数组转换： 先通过ToPrimitive转换为基本类型：优先调用valueOf()（若返回基本类型则使用）；否则调用toString()（若返回基本类型则使用）。 若valueOf()和toString()均不返回基本类型，抛出TypeError。 特殊对象：Object.create(null)创建的对象无valueOf()和toString()，无法强制转换为数字。 2.3 ToBoolean（非布尔值→布尔值） 假值（转换为 false 的值）：undefined、null、false、&#43;0、-0、NaN、&#34;&#34;（空字符串）。 真值：假值列表以外的所有值（如非空字符串、非 0 数字、对象、数组等）。 假值对象：浏览器环境中特殊的 “外来值”，外观类似普通对象，但强制转换为布尔值时为false（如document.all）。 三、显式强制类型转换（主动触发的转换） 3.1 字符串和数字之间的显式转换 通过内建函数： String(value)：遵循ToString规则，返回字符串基本类型。 Number(value)：遵循ToNumber规则，返回数字基本类型。 通过toString()： 基本类型调用toString()时，JS 引擎会自动创建封装对象，再调用其toString()（如123.toString() → &#34;123&#34;）。 通过一元运算符： &#43;value：显式将value转换为数字（如&#43;&#34;123&#34; → 123）。 -value：转换为数字并反转符号位（如-&#34;123&#34; → -123）。 注意：避免与其他运算符混用（如a &#43; &#43; b易读性差）。 日期转时间戳： &#43;new Date()：返回 Unix 时间戳（毫秒），但更推荐Date.now()（当前时间戳）或new Date().getTime()（指定时间戳）。 字位运算符与数字处理： ~x：等同于-(x &#43; 1)，可配合indexOf()判断是否存在（indexOf(-1)时~-1 → 0为假值，其他情况为真值）。 ~~x或x | 0：通过ToInt32将数字截为 32 位整数（如~~3.14 → 3）。 3.2 显式解析数字字符串 解析与转换的区别： 解析（如parseInt()、parseFloat()）：从左到右处理，遇到非数字字符停止（如parseInt(&#34;12a3&#34;) → 12）。 转换（如Number()）：字符串必须完全为数字格式，否则返回NaN（如Number(&#34;12a3&#34;) → NaN）。 parseFloat()：解析字符串中的浮点数（如parseFloat(&#34;3.14abc&#34;) → 3.14）。 parseInt()： 仅处理字符串，非字符串会先转为字符串（如parseInt(12.3) → 12，因12.3 → &#34;12.3&#34;）。 第二个参数（基数）：指定转换的进制（10 进制最常用）。ES5 及之前默认基数可能因前缀变化（如0开头视为八进制），ES6 后默认 10 进制，但仍建议显式指定（如parseInt(&#34;12&#34;, 10)）。 3.3 显式转换为布尔值 Boolean(value)：遵循ToBoolean规则（如Boolean(&#34;&#34;) → false）。 !!value：通过两次逻辑非显式转换为布尔值（第一次!反转布尔值，第二次!恢复原值，如!!&#34;abc&#34; → true）。 四、隐式强制类型转换（自动触发的转换） 4.1 字符串和数字之间的隐式转换 &#43;运算符的重载： 若有一个操作数为字符串（或可转为字符串），则执行拼接（如&#34;1&#34; &#43; 2 → &#34;12&#34;）。 否则执行数字加法（如1 &#43; true → 2，因true → 1）。 数字转字符串：value &#43; &#34;&#34;（如123 &#43; &#34;&#34; → &#34;123&#34;），优先调用valueOf()再转字符串。 字符串转数字：通过-0、*1、/1（如&#34;123&#34; - 0 → 123），因这些运算符仅适用于数字。 4.2 隐式转换为布尔值（布尔上下文） 以下场景中，非布尔值会自动通过ToBoolean转换为布尔值：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/4.-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、语句与表达式的基本概念 表达式：能返回一个结果值的代码片段（如1 &#43; 2返回3，obj.prop返回属性值）。 语句：执行某种操作的代码（如if、for、return），所有语句都有结果值，但语法默认不允许直接获取。 语句的结果值 常见语句的结果值： 赋值语句a = b：结果值为被赋予的值（即b的值）。 变量声明var a：结果值为undefined（let/const同理）。 代码块{...}：结果值为块内最后一个语句 / 表达式的结果（如{1; 2; 3}结果为3）。 获取语句结果值的方式：语法不直接支持，但可通过eval()获取（如eval(&#39;{a=1; b=2}&#39;)返回2）。 二、表达式的副作用 副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。
常见有副作用的表达式 函数调用：最常见（如console.log(1)会输出内容，改变控制台状态）。 自增 / 自减运算符： a&#43;&#43;：先返回a的当前值，再将a加 1（副作用在后）。 &#43;&#43;a：先将a加 1，再返回新值（副作用在前）。 注意：&#43;&#43;a&#43;&#43;会报错（ReferenceError），因运算符需要可赋值的变量作为操作数。 逗号运算符：将多个表达式串联为一个语句，返回最后一个表达式的结果（如a=1, b=2, a&#43;b结果为3），副作用是执行所有表达式。 delete 操作符： 作用：删除对象属性或数组单元。 结果值：成功删除（属性不存在或可配置）返回true；失败（不可配置属性）返回false或报错。 副作用：实际移除属性 / 单元（如delete obj.prop后obj.prop为undefined）。 赋值语句：a = 42结果为42，副作用是a被赋值为42；链式赋值（如a = b = 42）利用赋值表达式的结果值实现。 三、上下文规则 3.1 大括号{}的用法 对象常量：定义对象字面量（如{a: 1, b: 2}）。
标签（label）：用于标记代码块，配合break/ continue跳转：
break 标签：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。 continue 标签：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。 注意：标签不能用双引号；非循环代码块可使用break 标签，但不能用continue 标签。 JSON 与 JSON-P：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/5.-%E8%AF%AD%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、Annex B（ES 规范的兼容性补充） 背景： ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。
主要兼容性差异：
非严格模式允许八进制数值常量（如012，严格模式下为语法错误）；
浏览器提供window.escape()和window.unescape()，用于转义 / 还原带%分隔符的十六进制字符串（非标准方法，建议避免使用）；
String.prototype.substr与String.prototype.substring
的区别：
substring(start, end)：第二个参数为结束位置索引（不包含该位置）； substr(start, length)：第二个参数为截取长度。 Web ES 规范的额外差异：
&lt;!--和--&gt;被视为合法单行注释分隔符； String.prototype包含返回 HTML 格式字符串的附加方法（如anchor()、bold()）； 正则表达式（RegExp）扩展及Function.prototype附加方法（非标准，依赖浏览器实现）。 二、宿主对象 定义：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如window、document、console），包括内建对象和工具函数。 特殊行为差异： 部分宿主对象强制转换为布尔值时可能为假值（如document.all，不符合 JS 标准假值规则）； 其他特性： 可能无法访问普通Object的内建方法（如toString()）； 部分属性为只读，无法覆盖； 方法的this无法重绑定到其他对象。 console 对象： 宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。 三、全局 DOM 对象 全局变量与 global 对象：声明全局变量会同时在全局对象（如浏览器的window）中创建同名属性。 DOM 元素 ID 的副作用：因浏览器历史遗留问题，带id属性的 DOM 元素会自动创建同名全局变量（如&lt;div id=&#34;app&#34;&gt;会生成window.app）。 四、原生原型扩展的注意事项 不建议扩展原生原型：除非确保无代码冲突（如第三方库可能覆盖扩展方法）。 扩展原则：扩展原生方法时需添加判断（如if (!Array.prototype.includes) { ... }），避免覆盖已有功能。 polyfill 与 shim： shim：带兼容性测试的代码，用于填补环境差异（如检查功能是否存在，不存在则提供替代实现）； polyfill：只检查功能是否存在，不进行兼容性测试 pollyfill：特殊的 shim，专为实现未被环境支持的标准功能而设计，需与未来标准兼容（如为老浏览器实现Array.prototype.includes）。 五、script 标签与代码加载 多文件 / 内联代码的运行特性： 多个script标签（外部文件或内联代码）共享全局对象，在同一命名空间交互，但全局作用域的提升机制不跨文件边界（即一个文件的变量不会提升到另一个文件）。 单个script出错会停止自身执行，但不影响后续script运行。 动态创建 script：通过 JS 动态创建&lt;script&gt;标签并插入 DOM，效果与静态标签一致，可用于动态加载外部文件。 内联代码的特殊限制：内联代码中不能直接出现&lt;/script&gt;（会被视为代码块结束），变通方法为拆分字符串（如&#34;&lt;sc&#34;&#43;&#34;ript&gt;&#34;）。 字符集差异： 外部文件通过script标签的charset属性指定解析字符集； 内联代码使用所在页面的字符集，且内联script无charset属性。 六、保留字 定义：ES5 规范定义的不可用作变量名的标识符，包括四类：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文介绍了JavaScript函数的几个重要概念。首先指出函数是Function类型的实例，箭头函数具有独特限制（不能使用arguments、不能作为构造函数等）。其次说明函数名是指向函数的指针，ES6函数具有name属性。接着详细讲解函数参数机制，包括arguments对象的使用、参数传递方式（按值传递），以及如何在严格模式下处理参数。关于函数重载，文章指出JavaScript不支持传统重载，但可以模拟实现。最后介绍了ES6默认参数的用法，包括基本语法、参数初始化顺序和作用域规则，以及箭头函数使用默认参数的方法。
箭头函数 函数实际上是对象，每个函数都是Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。函数名是指向函数对象的指针，而且不一定与函数本身紧密绑定
箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性
函数名 函数名就是指向函数的指针，一个函数可以有多个名称，使用不带括号的函数名会访问函数指针，而不是执行函数
ES6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串，如果它是使用function构造函数创建的，则会标识成anonymous，如果函数是一个获取函数、设置函数，或者使用bind实例化，那么标识符前面会加上一个前缀
函数参数 ES函数既不关心传入的参数个数，也不关心这些参数的数据类型。
ES函数的参数在内部表现为一个数组，函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。
在使用function关键字定义函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参数值
arguments对象是一个类数组对象（不是Array的实例），因此可以使用中括号语法访问其中的元素，而要确定传进来多少个参数，可以访问arguments.length属性
ES函数的参数只是为了方便才写出来的，并不是必须写出来的，命名参数不会创建让之后的调用必须匹配的函数签名，因为根本不存在验证命名参数的机制
arguments对象可以跟命名参数一起使用，arguments的值始终会与对应的命名参数同步，但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。
对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined，这就类似于定义了变量但没有初始化
严格模式下，arguments对象与命名参数不同步，并且在函数中尝试重写arguments对象会导致语法错误
如果函数是箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的命名参数访问。虽然箭头函数中没有arguments对象，但可以在包装函数中把它提供给箭头函数
ES中的所有参数都是按值传递的，不可能按引用传递参数，如果把对象作为参数传递，那么传递的值就是这个对象的引用
函数重载 ES函数没有签名，因为参数是由包含零个或多个值的数组表示的，自然也就没有重载。如果在ES中定义了两个同名函数，则后定义的会覆盖先定义的。
可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载
默认参数 ES5之前，实现默认参数的一种常用方式就是检测某个参数是否等于undefined，如果是则意味着没有传这个参数，那就给它赋一个值
ES6支持显示定义默认参数，只要在函数定义中的参数后面用=就可以为参数赋一个默认值
给参数传undefined相当于没有传值，不过这样可以利用多个独立的默认值
在使用默认参数时，arguments对应的值不反映参数的默认值，只反映传给函数的参数。
默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值
函数默认参数只有在函数被调用时才会求值，不会在函数定义时求值，而且计算默认值的函数只有在调用函数但未传相应参数时才会被调用
箭头函数同样也可以这样使用默认参数
给多个参数定义默认值实际上跟使用let关键字顺序声明变量一样，默认参数会按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数。
参数初始化顺序遵循暂时性死区规则，即前面定义的参数不能引用后面定义的，参数也存在于自己的作用域中，它们不能引用函数体的作用域
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.1-10.5-%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文介绍了JavaScript中函数表达式、递归、尾调用优化、闭包、立即调用函数表达式(IIFE)和私有变量等核心概念。重点包括：函数表达式的定义与使用；递归的实现方式；尾调用优化的条件；闭包的作用机制及其内存影响；IIFE的模拟块级作用域应用；通过构造函数和静态变量实现私有变量的方法。文章通过代码示例详细说明了这些特性在JavaScript中的实际应用，帮助理解函数式编程的关键技术点。
函数表达式 函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义，这意味着函数声明可以出现在调用它的代码之后
函数表达式看起来像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量，这样创建的函数叫做匿名函数或兰姆达函数，因为function关键字后面没有标识符，未赋值给其他变量的匿名函数的name属性是空字符串
函数表达式跟JS中的其他表达式一样，需要先赋值后使用
任何时候，只要函数被当做值来使用，它就是一个函数表达式
递归 递归函数通常的形式是一个函数通过名称调用自己
arguments.callee是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，但严格模式下不能访问。
可以使用命名函数表达式达到目的
尾调用优化 尾调用：外部函数的返回值是内部函数的返回值
如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做
尾调用优化的条件：
代码在严格模式下执行 外部函数的返回值是对尾调用函数的调用 尾调用函数返回后不需要执行额外的逻辑 尾调用函数不是引用外部函数作用域中自由变量的闭包 无论是递归尾调用还是非递归尾调用，都可以应用优化，引擎并不区分尾调用中调用的是函数自身还是其他函数
闭包 闭包指的是那些引用了另一个作用域中变量的函数，通常是在嵌套函数中实现的，原理是包含外部函数作用域的作用域链
在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止
函数执行时，每个执行上下文中都会有一个包含其中变量的对象，全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。作用域链其实是一个包含指针的列表，每个指针指向一个变量对象，但物理上并不会包含相应的对象
函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域
在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中，活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用
因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用
在闭包中使用this，如果内部函数没有使用箭头函数定义，则this对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则this在非严格模式下等于window，严格模式下等于undefined。如果作为某个对象的方法调用，则this等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着this会指向window，除非在严格模式下this指向undefined
每个函数在被调用时都会自动创建两个特殊变量：this和arguments。内部函数永远不可能直接访问外部函数的这两个变量
赋值表达式的值是函数本身
立即调用函数表达式 立即调用的匿名函数又被称作立即调用的函数表达式(IIFE)，它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式
使用IIFE可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数，这样位于函数体作用域的变量就像是在块级作用域中一样
IIFE不会导致闭包相关问题，因为不存在对这个匿名函数的引用，只要函数执行完毕，其作用域链就可以被销毁
IIFE可以用于锁定参数值
私有变量 任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数
如果函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的变量。基于这一点，就可以创建出能够访问私有变量的公有方法
特权方法是能够访问函数私有变量的公有方法。在对象上有两种方法创建特权方法：构造函数实现，静态私有变量实现
function MyObject(){ let privateVariable = 10 function privateFunction(){ return false } this.publicMethod = function(){ privateVariable&#43;&#43; return privateFunction } } 构造函数实现是把所有私有变量和私有函数都定义在构造函数中，然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。缺点是每个实例都会重新创建一遍新方法
(function(){ let privateVariable = 10 function privateFunction(){ return false } MyObject = function(){} MyObject.prototype.publicMethod = function(){ privateVariable&#43;&#43; return privateFunction() } }) 静态私有变量通过使用私有作用域定义私有变量和函数来实现，在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后有定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。
这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里不是必须的。
构造函数标识符未使用任何关键字，因为不使用关键字声明的变量会创建在全局作用域中，可以在私有作用域外部被访问
该模式，私有变量和私有函数是由实例共享的，因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域
let singleton = function(){ let privateVariable = 10 function privateFunction(){ return false } return { publicProperty:true publicMethod(){ privateVariable&#43;&#43; return privateFunction() } } } 模块模式在一个单例对象上实现了相同的隔离和封装。模块模式使用了匿名函数返回一个对象，在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的公有方法都可以访问同一个作用域的私有变量和私有函数。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.11-10.16-%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> ES6扩展操作符简化了函数参数处理，可拆分可迭代对象为单独参数或收集剩余参数为数组。函数声明会提升，表达式则不会。函数可作为值传递或返回。函数内部有arguments、this、caller等特性，方法包括apply/call改变this和bind创建绑定函数。严格模式影响this行为，箭头函数保持定义时上下文。函数属性如length、prototype，继承方法返回函数代码或自身。
参数扩展与收集 在给函数传参时，有时候可能不需要传入一个数组，而是要分别传入数组的元素。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于apply方法
在ES6中，可以通过扩展操作符极为简洁地实现这种操作，对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入
因为数组长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前后再传其他的值，包括使用扩展操作符传其他参数
在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合成一个数组，这有点类似arguments对象的构造机制，只不过收集参数的结果会得到一个Array实例
收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数
箭头函数虽然不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments一样的逻辑
使用收集参数不影响arguments对象，它仍然反映调用时传给函数的参数
函数声明与函数表达式 JS引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义
函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫做函数声明提升。在执行代码时，JS引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部，因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部，如果把函数声明改为等价表达式，那么执行时会报错
函数作为值 不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数
如果是访问函数而不是调用函数，那就必须不带括号
从一个函数中返回另一个函数也是可以的，而且非常有用
函数内部 arguments：是一个类数组对象，包含调用函数时传入的所有参数，这个对象只有以function关键字定义函数时才会有，该对象其中还有一个callee属性，指向arguments对象所在函数的指针，用作递归中可以让函数逻辑与函数名解耦
this
在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候通常称其为this值
箭头函数中this引用的是定义箭头函数的上下文
caller：这个属性引用的是调用当前函数的函数，如果是在全局作用域中调用的则为null
严格模式下访问arguments.callee会报错，arguments.caller也是
new.target：ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。如果是普通调用，则new.target的值是undefined，如果是new关键字调用的，则new.target将引用被调用的构造函数
函数属性与方法 length属性保存函数定义的命名参数的个数
prototype是保存引用类型所有实例方法的地方，由所有实例共享
apply()和call()方法都会以指定的this值来调用函数，即会设置调用函数时函数体内this对象的值。
apply()方法接收两个参数：函数内this的值和一个参数数组。第二个参数可以是Array实例，也可以是arguments对象
在严格模式下，调用函数时，如果没有指定上下文对象，则this值不会指向window。除非使用apply或call把函数指定给一个对象，否则this的值会变成undefined
call()方法与apply()方法一样，只是传参的形式不同，第一个参数也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。
使用call()和apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法
bind()方法会创建一个新的函数实例，其this值会被绑定到传给bind()的对象
继承的toLocaleString()和toString()方法时钟返回函数的代码，返回代码的格式因浏览器而异。valueOf()返回函数本身
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.6-10.10-%E5%87%BD%E6%95%B0/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://growyears.netlify.app/posts/page/4/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://growyears.netlify.app/posts/page/6/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://growyears.netlify.app/">拾光博客 - 永浩</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
