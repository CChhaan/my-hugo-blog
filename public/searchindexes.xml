<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>3.3 ping 的工作原理</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0303-ping-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>IP</tag></tags><content type="html">  ICMP（互联网控制报文协议）功能ping 是基于 ICMP 协议工作的，ICMP 的主要功能包括：确认 IP 包是否成功送达目标地址；报告 IP 包在传输中被废弃的原因；改善网络设置。
当 IP 包未能到达目标地址时，ICMP 负责通知具体原因。
类型ICMP 报文分为两类：
查询报文类型：用于诊断（查询消息） 差错报文类型：用于通知出错原因（错误消息） 查询报文类型回送消息用于主机或路由器之间判断数据包是否成功到达对端。 ping 命令 即利用该消息实现。
可以向对端主机发送 回送请求消息（类型 8），也可以接收对端主机发回的 回送应答消息（类型 0）。
报文结构新增字段
标识符：用于区分发出 ICMP 包的应用程序，例如使用进程 PID 作为标识符。 序号：从 0 开始，每次发送新的请求加 1，用于确认网络包是否丢失。 选项数据：ping 命令会在其中存放发送请求的时间值，用以计算往返时间，反映通信路程长短 差错报文类型目标不可达消息类型：3
作用：当路由器无法将 IP 数据包发送给目标地址时，返回该消息，说明 不可达的具体原因。
错误类型 代码 含义 网络不可达 0 路由表匹配不到接收方 IP 的网络号；因不再有网络分类，该错误较少使用。 主机不可达 1 路由表中无主机信息或主机未连接网络。 协议不可达 2 对端主机存在，但防火墙禁止该协议访问。 端口不可达 3 对端主机存在且防火墙允许，但端口无进程监听。 需分片但设置不分片位 4 路由器遇到超过 MTU 的包且分片位为 1，丢弃并返回该错误。 原点抑制消息类型：4
作用：在低速广域线路（WAN）出现拥堵时，用于缓和网络流量。
机制：当路由器的发送队列缓存为零、无法继续发送时，向 IP 包源地址发送 原点抑制消息。主机接收后得知线路某处发生拥堵，从而 增大发送间隔，减少网络流量。
由于可能导致通信不公平，该类型消息一般 不被使用。
重定向消息类型：5
作用：当路由器发现主机未使用最优路径发送数据时，返回 重定向消息，内容包含最合适的路由信息和源数据，告知发送端下次应将数据发给更合适的路由器。
超时消息类型：11
触发条件：IP 包的 TTL（Time To Live，生存周期） 减为 0 时。
作用：通知发送端主机该 IP 包已被丢弃。
TTL 机制：每经过一个路由器，TTL 值减 1。 …  </content></entry><entry><title>3.4 断网了，还能 ping 通 127.0.0.1 吗？</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0304-%E6%96%AD%E7%BD%91%E4%BA%86%E8%BF%98%E8%83%BD-ping-%E9%80%9A-127.0.0.1-%E5%90%97/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>IP</tag></tags><content type="html">  什么是 127.0.0.1127.0.0.1 是 IPv4 地址中的一个特殊地址，属于回环地址。
IPv4 地址：总共有 32 位，分成 4 个字节（每字节 8 位），以 . 隔开。
回环地址：以 127 开头的地址都属于回环地址，用于指向本机。
IPv6 地址：回环地址为 ::1，连续的 0 会被省略，且只能有一个 ::。
ping 命令：
在 IPv4 下，使用 ping 127.0.0.1 来测试本机的回环地址。 在 IPv6 下，使用 ping6 ::1 来测试回环地址。 什么是 pingping 是一个应用层命令，用于测试目标主机是否可达， 通过 ICMP 协议进行通信。
工作原理：通过 ICMP 协议发送一个小的消息包，判断目标机器的网络是否通畅。
ICMP：网络层协议，用于传递控制消息。
TCP 发数据和 ping 的区别ping 和其他应用层软件一样，都是应用层的程序。
ping 与 TCP 的主要区别：
Socket 创建： TCP：socket(AF_INET, SOCK_STREAM, 0)，面向字节流的 TCP 协议，工作在传输层。 ping：socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)，原始套接字，工作在网络层。 数据流动： TCP 数据通过用户态和内核态之间的 sendto 调用传递，进入传输层、网络层，最终加上 MAC 头通过网卡发送。 ping 使用原始套接字构建 ICMP 数据包，并通过类似路径发出，最终加上 ICMP 和 IP 头，发送数据包。 总结：ping 通过模拟正常数据流的方式，自己构建数据包，由系统按照 TCP 数据传输的路径发送。
为什么断网了还能 ping 通 127.0.0.1回环地址：127.0.0.1 属于回环地址，不需要通过网络接口发送数据到外部网络。
工作流程：
目标 IP 是回环地址时，系统选择 本地网卡（&amp;ldquo;假网卡&amp;rdquo;）来发送数据。 假网卡 处理消息并将其推送到 input_pkt_queue 链表中，触发软中断。 ksoftirqd 内核线程处理软中断，将数据包通过网络协议栈返回应用程序。 结论：即使断网，回环地址仍能正常 ping 通，因为数据完全在本机内处理。
ping 回环地址与 ping 本机地址的区别ping 本机 IP 和 ping 回环地址：都使用本地回环接口（lo0），也叫 假网卡。
相同点：数据不会发送到网络，都会在本机网络协议栈内转发并回传。
没有实际区别，都是走本机的本地回环接口。
127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗localhost：
不是一个 IP 地址，而是一个域名。 默认解析为 127.0.0.1，可以通过修改 /etc/hosts 文件来更改。 127.0.0.1：
与 localhost 等价，都是本机的回环地址。 0.0.0.0：
0.0.0.0 是无效的目标地址，在 IPv4 中不能用于 ping。 用途：在服务器启动时，通常会将监听地址设置为 0.0.0.0，表示监听本机所有的 IPv4 地址。 客户端连接：不能使用 0.0.0.0 来连接服务器，必须指定具体的服务器 IP 地址。   </content></entry><entry><title>3.1 IP 基本认识</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0301-ip-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>IP</tag></tags><content type="html">  IPIP：位于 TCP/IP 参考模型 的 网络层（第三层）。
网络层的作用：实现 主机与主机 之间的通信，称为 点对点（end to end）通信。
MAC 地址用于实现直接连接的设备之间通信；而 IP 地址 则用于没有直连的两个网络之间的通信。
源 IP 地址 和 目标 IP 地址 不会在传输过程中改变（前提：未使用 NAT）。源 MAC 地址 和 目标 MAC 地址 会发生变化。
IP 地址IPv4 地址：由 32 位 正整数表示，计算机以 二进制 形式处理。
为便于记忆，采用 点分十进制 表示方式，分为四组，每组 8 位转换为十进制（例如：192.168.1.1）。
IP 地址是与网卡绑定的，而不是与主机台数关联。
服务器和路由器通常有 多个网卡，因此它们可能有多个 IP 地址。
IP 地址的分类A、B、C 类 分为网络号和主机号，具体用法见下表：
A 类（网络号为 0）：支持大量主机，适用于大型网络。 B 类（网络号为 1）：适用于中型网络。 C 类（网络号为 2）：适用于小型网络。 D 类：无主机号，常用于多播。
E 类：预留地址，尚未使用。
主机号全为 1：用于广播（广播地址）。
主机号全为 0：用于指定某个网络。
广播地址：用于在同一网络内广播数据包，分为 本地广播 和 直接广播。
本地广播：在同一网络内广播。
直接广播：跨网络广播。
D 类地址范围：224.0.0.0 ~ 239.255.255.255。
三类多播地址：
224.0.0.0 ~ 224.0.0.255：仅局域网内有效，不可通过路由器转发。 224.0.1.0 ~ 238.255.255.255：可用于 Internet。 239.0.0.0 ~ 239.255.255.255：本地管理组播地址，仅在局部网络内有效。 A、B、C 类的缺陷：
C 类：最多只能容纳 254 台主机，通常不能满足大规模网络需求。 B 类：最多容纳 6 万多台主机，过于庞大，对于多数企业而言是一种资源浪费。 无分类地址 CIDRCIDR（无类别域间路由选择）取消了传统的 A/B/C 类地址概念，而是将 IP 地址划分为 网络号 和 主机号 两部分。
表示方式：a.b.c.d/x，其中 /x 表示网络号的位数，范围是 0 ~ 32，剩余是主机号。
子网掩码：用来屏蔽主机号，留下网络号部分。使用 AND …  </content></entry><entry><title>3.2 IP 协议相关技术</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0302-ip%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>IP</tag></tags><content type="html">  DNSDNS：将域名网址自动转换为具体的 IP 地址的系统。
域名的层级关系域名使用句点（.）分隔，越靠右层级越高。
层级结构类似树状：
根 DNS 服务器 顶级域 DNS 服务器（例如 .com） 权威 DNS 服务器（例如 server.com） 根域 DNS 服务器信息保存在所有 DNS 服务器中，因此任何 DNS 服务器都能找到根域服务器，客户端只需找到任意一台 DNS 服务器，即可层层查找目标服务器。
域名解析的工作流程浏览器检查自身缓存 → 操作系统缓存 → 本机 hosts 文件。
若都无结果，则开始向 DNS 服务器查询：
客户端向 本地 DNS 服务器 发送请求，询问 www.server.com的 IP。 若本地 DNS 有缓存结果，直接返回 IP；若无则向 根域名服务器 查询。 根域名服务器根据域名后缀（如 .com），返回对应 顶级域名服务器地址。 本地 DNS 再询问顶级域名服务器。 顶级域名服务器返回该域的 权威 DNS 服务器地址。 本地 DNS 继续询问权威 DNS 服务器。 权威 DNS 服务器 返回 www.server.com对应的 IP 地址。 本地 DNS 将结果返回给客户端，客户端与目标主机建立连接。 ARP当主机确定了源 IP 与目标 IP 后，会通过路由表确定下一跳 IP 地址。为了在数据链路层传输，还需知道下一跳的 MAC 地址。主机通过 ARP 协议向网络请求并获取目标的 MAC 地址。
ARP 用于在已知 IP 地址的情况下，获取对应的 MAC 地址。
ARP 确定 MAC 地址的过程主机通过广播发送 ARP 请求包，包内包含目标主机的 IP 地址。
同一链路上的设备收到请求后检查目标 IP 是否与自己匹配。若匹配，则将自身 MAC 地址 填入 ARP 响应包，返回给请求方。
操作系统会缓存第一次获取的 MAC 地址，以便下次使用。MAC 缓存有有效期，过期后将被清除。
RARP 协议RARP与 ARP 相反，已知 MAC 地址求 IP 地址。
流程：
网络中架设 RARP 服务器，注册设备的 MAC 与 IP 映射。 设备接入网络后，发送请求：“我的 MAC 地址是 XXXX，请告诉我对应的 IP 地址。” RARP 服务器收到请求后，返回应答：“MAC 地址为 XXXX 的设备，其 IP 地址 …  </content></entry><entry><title>2.14 HTTP/2</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0214-http2/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  HTTP/1.1 协议的性能问题延迟难以下降：网络带宽虽然增加，但延迟降到一定幅度后难以再降低，已到达延迟下限。
并发连接有限：谷歌浏览器最大并发连接数：6 个，每个连接都需要经历 TCP 与 TLS 握手，并受 TCP 慢启动影响。
队头阻塞问题：同一连接中只能在完成一个 HTTP 事务（请求与响应）后，才能处理下一个事务。
HTTP 头部巨大且重复：每个请求都需携带完整 HTTP 头部，Cookie 通常较大，造成带宽浪费。
不支持服务器推送消息：客户端需定时拉取通知，浪费带宽和服务器资源。
兼容 HTTP/1.1URI 保持一致：仍使用 http:// 表示明文协议， https:// 表示加密协议。浏览器与服务器可在后台自动升级，实现平滑过渡。
仅修改应用层语法：传输层仍基于 TCP 协议。语义层（方法、状态码、头字段）保持一致。仅语法层进行重新设计，改变了报文传输格式。
头部压缩HTTP 报文结构为 Header + Body。HTTP/1.1 仅可通过 Content-Encoding 压缩 Body，Header 无优化手段。
Header 的问题：
含有大量固定字段（可达数百字节甚至上千字节）。 字段值重复，占用大量带宽。 使用 ASCII 编码，效率低。 HTTP/2 的改进：HPACK 算法
HPACK 由三部分组成：静态字典、动态字典、Huffman 编码
客户端与服务器各自维护字典，用索引号替代重复字符串，再用 Huffman 编码压缩，压缩率可达 50%~90%。
静态表编码预定义高频字段，写入 HTTP/2 框架中，不会变化。
通过 Index（索引号） 表示字段名和值。
若字段值可变，则使用 Huffman 编码后再发送。
按 RFC7541 标准，静态表字段的二进制头部前两位为 01。
二进制编码取代文本格式，不再使用冒号与 \r\n 作为分隔符，而使用 **字符串长度（Value Length）**区分。
动态表编码用于静态表未覆盖的字段，Index 从 62 开始。
首次传输时会 Huffman 编码，之后双方更新动态表。再次传输同字段时，仅需发送 1 字节索引号。
前提：必须在同一连接上重复传输完全相同的头部。
若字段值频繁变化，则动态表无法充分利用。
动态表越大，占用内存越多，影响性能。 …  </content></entry><entry><title>2.15 WebSocket</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0215-websocket/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>WebSocket</tag></tags><content type="html">  使用 HTTP 不断轮询轮询（Polling）：前端代码不断定时向服务器发送 HTTP 请求，服务器收到请求后返回消息。
这种方式是一种“伪服务器推送”，实际上是 客户端主动请求，服务器被动响应。
应用场景：常见于 扫码登录 等需要实时更新页面状态的场景。
问题：
打开 F12 调试工具时，会看到大量 HTTP 请求，请求虽小但消耗带宽，同时增加服务器负担。 用户体验问题：若用户扫码后正好错过下一次请求，需等待 1~2 秒 才触发跳转，造成明显卡顿。 长轮询客户端发起 HTTP 请求，并设置较长超时时间（例如 30 秒）。服务器在这段时间内若收到数据（如扫码请求），立即返回响应，若超时，则客户端立刻发起下一次请求。
减少请求次数，响应及时，大多数情况下能在超时前获取到数据。
此机制也称为“长轮询机制”。常用于 消息队列（如 RocketMQ） 中消费者取数据的方式。
本质上仍是 客户端主动取数据，并非真正的服务器推送。
WebSocket 是什么WebSocket 是一种 全双工通信协议，双方可在同一时间内主动向对方发送数据。
HTTP/1.1 属于 半双工，只能客户端先请求、服务器再响应。WebSocket 基于 TCP，为了解决这一限制而设计。
WebSocket 连接的建立浏览器与服务器完成 TCP 三次握手 后，统一使用 HTTP 协议 进行第一次通信。
若为普通 HTTP 请求，则继续保持 HTTP 通信。
若要建立 WebSocket 连接，则在 HTTP 请求头中添加：
Connection: Upgrade（请求升级协议） Upgrade: WebSocket（升级为 WebSocket） Sec-WebSocket-Key（随机生成的 base64 编码） 若服务器支持 WebSocket，则：
返回状态码 101（Switching Protocols）； 在响应头 Sec-WebSocket-Accept 中，放入基于客户端 Sec-WebSocket-Key 计算得到的字符串。 浏览器用相同算法转换 base64 字符串，若与服务器返回的一致，则握手成功。
至此，WebSocket 连接建立完成，双方可直接使用 WebSocket 数据格式进行通信。
WebSocket 的消息格式WebSocket 的数据单元称为 帧（Frame）。
opcode 字段：标识数据帧类型。
payload 字段：存放数据长度（单位：字节）。最开始的 7 bit 为标志位，根据取值判断是否继续读取 16 bit 或 64 bit 长度字段。
payload data 字段：存放实际要传输的数据，根据 payload 长度截取相应字节。
WebSocket 数据格式为：数据头（含 payload 长度） + payload data。
设计原因：TCP 是全双工协议，但直接传输数据会产生 粘包问题；为解决粘包，上层协议采用 消息头 + 消息体 格式；消息头中记录消息体长度，接收端可据此准确截取完整数据。
  </content></entry><entry><title>2.16 RPC</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0216-rpc/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>RPC</tag></tags><content type="html">  使用纯裸 TCP 会有什么问题TCP 的三个特点：面向连接、可靠、基于字节流
字节流可以理解为一个双向通道中的二进制数据流（01 串）。
在纯裸 TCP 中，这些数据之间没有任何边界，无法确定一条完整消息的开始与结束。这被称为 粘包问题。
在纯 TCP 之上定义自定义规则，用于区分消息边界。将每条数据进行包装：
消息头：包含完整包的长度； 消息体：为实际传输的数据。 根据消息头中的长度信息，可以准确截取消息体。
消息头中还可以放：消息体是否压缩、消息体格式等信息。只要上下游约定一致即可，这种约定即为 协议。
不同项目会自定义不同协议解析标准，但原理相似。
由于这种封装机制，基于 TCP 衍生出了多种协议，如：HTTP、RPC
HTTP 和 RPCTCP：传输层协议。
HTTP / RPC：基于 TCP 定义不同消息格式的应用层协议。
HTTP 协议，中文名：超文本传输协议。用于浏览器访问网页时的数据传输。
RPC，中文名：远程过程调用。不是具体协议，而是一种调用方式。虽多数基于 TCP，但也可以基于 UDP 或 HTTP 实现。
为什么既有 RPC 又要有 HTTPClient/Server (C/S) 架构：各种联网软件作为客户端与服务器通信，可使用自定义的 RPC 协议，仅服务于自己公司的服务器。
Browser/Server (B/S) 架构：浏览器需访问不同公司的服务器，为保证互通，必须有统一标准，HTTP 因此成为 B/S 架构下的统一通信协议。
HTTP 主要用于 B/S 架构，RPC 更多用于 C/S 架构。
随着 B/S 与 C/S 融合，软件往往需要多端兼容：例如云盘类应用需同时支持网页版、手机端、PC 端；使用 HTTP 可实现服务器复用同一套协议。
RPC 逐渐用于内部集群微服务通信。
HTTP 和 RPC 的区别服务发现HTTP：需先知道目标服务器的 IP 地址和端口，才能建立连接，这个查找服务对应 IP 端口的过程称为 服务发现。
RPC：一般使用中间服务保存服务名与 IP 信息，例如：Consul、Etcd、Redis。请求服务时，通过这些中间服务获取 IP 与端口。
DNS 也是一种服务发现机制，也存在基于 DNS 实现的服务发现组件，如 CoreDNS。
底层连接形式以 HTTP/1.1 为例：建立 TCP …  </content></entry><entry><title>2.10 HTTP1.1 如何优化</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0210-http1.1%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag><tag>性能优化</tag></tags><content type="html">  避免发送 HTTP 请求缓存技术：通过在客户端保存「请求-响应」的数据，避免重复的网络请求，从而提升 HTTP/1.1 的性能。
工作机制：
客户端将第一次请求的 URL 作为 key，响应作为 value，形成映射关系并存入本地磁盘。 当再次发起相同请求时：客户端先在本地通过 key 查找缓存，若缓存存在且未过期，直接读取响应数据。 过期判断：服务器在响应头部中加入过期时间，客户端检查缓存的响应是否过期，若过期则重新请求。
Etag 校验机制：客户端在重新请求时，携带上次响应头部的 Etag 摘要。服务器比较本地资源摘要与 Etag：不同，返回最新资源；相同，返回 304 Not Modified，客户端继续使用缓存。
减少 HTTP 请求次数减少重定向请求次数当资源迁移后，服务器通过 302 响应码 和 Location 头部 通知客户端新地址，客户端需重新发送请求获取资源。
多次重定向将导致客户端多次发起 HTTP 请求，增加网络开销。
若由 代理服务器完成重定向，可减少消息传递次数，当代理服务器知晓重定向规则后，还可进一步减少消息传递。
合并请求原理：将多个小文件请求合并为一个大文件请求。减少重复的 HTTP 头部发送，降低 TCP 连接建立和慢启动的开销。
浏览器行为：为防止请求阻塞，通常会并发 5–6 个请求，合并请求能减少 TCP 连接数。
典型方式：
使用 CSS Image Sprites：合并多张小图片为一张大图，再通过 CSS 切割。 使用 webpack 等打包工具：合并 JS、CSS 等资源为大文件。 Base64 嵌入图片：将图片二进制数据编码为 Base64，嵌入 HTML 文件中。 问题：当大资源中的某个小资源更新时，必须重新下载整个大文件。
延迟发送请求按需获取：仅在需要时才发送请求。
应用场景：页面首次加载时仅请求可见部分资源，当用户滚动页面时，再加载后续资源。
效果：减少初始阶段的 HTTP 请求次数。
减少 HTTP 响应的数据大小无损压缩定义：压缩后数据可完全恢复，适用于文本文件、可执行文件、源代码等。
步骤：
去除代码中的换行符和空格。 建立统计模型，用 霍夫曼编码 表示数据。 实现方式：
客户端通过请求头 Accept-Encoding 告知服务器支持的压缩算法。 服务器选择合适算法压缩响应， …  </content></entry><entry><title>2.11 HTTPS RSA 握手解析</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0211-https-rsa-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  TLS 握手过程HTTP 明文传输的风险：：窃听风险、篡改风险、冒充风险
**HTTPS 的解决方案：**在 HTTP 与 TCP 层之间加入 TLS 协议，通过以下方式保障安全：信息加密、校验机制、身份证书
TLS 握手是建立安全通信的前提。通常通过 四个消息（2 个 RTT） 完成握手。不同的密钥交换算法会导致握手过程存在差异。
TLS 记录是数据收发的基本单位，类似 TCP 的 segment。
HTTPS 作为应用层协议，需先建立 TCP 连接，再执行 TLS 握手。
数据加密使用 对称加密密钥，性能较高。对称密钥需通过 非对称加密 保护其协商过程。密钥交换算法 负责保护对称密钥的安全性。
RSA 握手过程传统 TLS 握手多使用 RSA 算法 进行密钥交换。
服务端证书文件即为 公钥。服务端的 私钥 仅保存在服务端，必须防止泄漏。
客户端生成随机密钥，用服务端公钥加密后传给服务端。服务端用私钥解密，双方获得相同密钥以加密应用消息。
第一次握手：Client Hello客户端发送 Client Hello 消息，内容包括：TLS 版本号、支持的密码套件列表、随机数（Client Random），该随机数是生成对称加密密钥的材料之一。
第二次握手：Server Hello服务端收到消息后：确认 TLS 版本号是否支持，从客户端提供的密码套件中选择一个，生成随机数（Server Random）。
随后返回 Server Hello 消息，包含：确认的 TLS 版本号，随机数（Server Random）选定的密码套件。
密码套件格式：「密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法」，其中第一个单词表示 密钥交换算法，第二个单词表示 证书验证算法
客户端与服务端完成：
TLS 版本和密码套件确认 双方各自生成并交换随机数，用于生成 会话密钥 服务端随后发送：
Server Certificate（包含数字证书） Server Hello Done（表示打招呼完毕） 客户端验证证书数字证书和 CA 机构**数字证书内容：**公钥、持有者信息、证书认证机构（CA）信息、CA 的数字签名及算法、证书有效期、其他附加信息
**作用：**认证公钥持有者身份，防止冒充。
CA：负责签发并验证证书，签名可防止中间人篡改证书内容。 …  </content></entry><entry><title>2.12 HTTPS ECDHE 握手解析</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0212-https-ecdhe-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  离散对数ECDHE 密钥协商算法 是 DH 算法 的演进版本。
DH 算法 是一种 非对称加密算法，可用于 密钥交换。该算法的核心数学思想是 离散对数。
对数运算 的取值是连续的，离散对数 的取值是离散的。
离散对数是在对数运算的基础上加入了 模运算（取余数）。
公式结构：底数：a、模数：p（为公共参数，公开）、真数：b、对数：i
若已知对数，可通过公式计算出真数，但反之，若只知道真数，计算对数极其困难。
当 模数 p 是一个很大的质数 时，即使已知底数 a 和真数 b，在现有计算机水平下几乎无法算出离散对数。这正是 DH 算法的数学基础。
DH 算法**确定公开参数：**选择模数 P 和底数 G。
**生成私钥：**双方各自生成随机整数作为私钥（a 与 b），私钥需严格保密。
**计算公钥：**公钥是公开的。
客户端：A = G ^ a ( mod P ) 服务端：B = G ^ b ( mod P ) **计算共享密钥：**因离散对数幂运算具有交换律，双方计算结果相同，即 K 为会话密钥。
客户端计算：K = B ^ a ( mod P ) 服务端计算：K = A ^ b ( mod P ) DHE 算法DH 算法根据私钥生成方式分为两种实现：
Static DH 算法（已废弃） DHE 算法（现常用） Static DH 的问题： 一方（通常为服务端）的私钥是静态的，即固定不变。客户端的私钥每次协商随机生成。 随着时间推移，黑客可截获大量协商数据，并暴力破解出服务器私钥，从而推算出历史会话密钥。 因此，Static DH 不具备前向安全性。
DHE 的改进：“E” 表示 ephemeral（临时性的）。双方在每次通信时，私钥均随机生成、临时使用。每次通信过程的私钥独立无关，从而实现 前向安全。
ECDHE 算法DHE 算法性能较差（计算量大），因此演进出 ECDHE 算法（利用椭圆曲线特性）。ECDHE 能以更少计算量生成公钥和会话密钥。
算法步骤：
**确定公共参数：**椭圆曲线种类、椭圆曲线基点 G（二者均为公开参数） **生成密钥对：**双方各自生成随机数作为私钥 d，计算公钥 Q = dG **交换公钥：**双方交换各自的公钥。 **计算共享密钥：**客户端计算：(x1, y1) = d1Q2服务端计算：(x2, y2) = d2Q1因椭圆曲线 …  </content></entry><entry><title>2.13 HTTPS如何优化</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0213-https%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  分析性能损耗性能消耗的两个环节：
TLS 协议握手过程 握手后的对称加密报文传输 第二环节：对称加密性能：主流对称加密算法：AES、ChaCha20性能不错，一些 CPU 厂商针对这些算法进行了硬件级优化，因此，该环节的性能消耗 非常小。
第一个环节：TLS 握手性能消耗：TLS 握手不仅增加网络延时（最长可达 2 RTT），还会在以下步骤中产生性能损耗：
客户端和服务端临时生成椭圆曲线公私钥（ECDHE 密钥协商算法）。 客户端验证证书时，访问 CA 获取 CRL 或 OCSP，验证证书是否被吊销。 双方计算 Pre-Master（对称加密密钥）。 硬件优化HTTPS 协议是 计算密集型，非 I/O 密集型，因此，应投资于 CPU 而非网卡、硬盘等。
高性能 CPU 可提升计算速度，加速 TLS 握手过程。
优先选择支持 AES-NI 特性 的 CPU，可在指令级别优化 AES 算法，加速加解密。
若 CPU 支持 AES-NI，应选择 AES 算法；若不支持 AES-NI，应选择 ChaCha20 算法，因其对 CPU 更友好。
软件优化软件优化分为两种方式：
软件升级：将使用的软件升级至最新版本，最新版本通常包含性能优化和问题修复。
协议优化：通过优化密钥交换算法与 TLS 版本实现性能提升。
协议优化密钥交换算法优化RSA 密钥交换的缺陷：TLS 1.2 使用 RSA 密钥交换算法需 4 次握手（2 RTT），不具备 前向安全性，因此，RSA 握手过程 慢且安全性不高。
建议使用 ECDHE 密钥交换算法 替换 RSA。
ECDHE 支持 False Start（抢跑机制），客户端可在 第 3 次握手后、第 4 次握手前 发送加密应用数据，将握手往返由 2 RTT 减少至 1 RTT，同时具备 前向安全性。
ECDHE 基于椭圆曲线，不同曲线性能不同。推荐使用 x25519 曲线（目前最快）。
若安全要求不高，可使用 AES_128_GCM，其速度快于 AES_256_GCM。
TLS 升级TLS 1.2 的握手过程：需 4 次握手（2 RTT）：Client Hello、Server Hello、公钥交换（第 3、第 4 次握手），之后双方计算出会话密钥。
TLS 1.3 的改进：将 Hello 与公钥交换 合并为一个消息，仅需 1 RTT 即 …  </content></entry><entry><title>2.6 HTTP 缓存</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0206-http%E7%BC%93%E5%AD%98/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html"><![CDATA[  HTTP 缓存的目的对于一些具有重复性请求的场景（如每次请求得到的数据都相同），可以将这对「请求-响应」的数据缓存在本地。这样下次请求时直接读取本地数据，无需通过网络获取服务器响应，从而显著提升 HTTP/1.1 的性能。
HTTP 协议在设计时已考虑缓存机制，头部中包含多个与缓存相关的字段。
HTTP 缓存的实现方式主要分为两类：强制缓存（强缓存）和协商缓存
强制缓存只要浏览器判断缓存未过期，则直接使用本地缓存，无需与服务器通信。是否使用缓存的主动权在浏览器。
强制缓存通过以下两个 HTTP 响应头字段实现：
Cache-Control：相对时间。 Expires：绝对时间。 当同时存在时，Cache-Control 优先级高于 Expires。Cache-Control 设置更精细，推荐使用该字段。
实现流程：
第一次请求：浏览器请求服务器资源；服务器在响应头中添加 Cache-Control 字段，指定过期时间。 再次请求：浏览器根据上次请求时间与 Cache-Control 设置的过期时长计算资源是否过期；若未过期 → 使用本地缓存；若已过期 → 重新请求服务器。 服务器响应：收到新的请求后，更新响应头中的 Cache-Control。 协商缓存由客户端与服务器协商是否使用缓存。服务器根据客户端提供的缓存标识，判断资源是否变更，并返回相应状态码。
当响应状态码为 304 Not Modified 时，表示可以使用本地缓存。
协商缓存可通过两组请求头与响应头字段实现：
基于时间的实现： 响应头字段：Last-Modified（资源最后修改时间）
请求头字段：If-Modified-Since（上次修改时间）
工作流程:
第一次请求时，服务器返回资源，并在响应头中添加：Last-Modified: &amp;lt;最后修改时间&amp;gt; 资源过期后再次请求时，浏览器在请求头中加入：If-Modified-Since: &amp;lt;上次 Last-Modified 值&amp;gt; 服务器比较时间： 若资源修改时间较新 → 返回最新资源，状态码 200 OK； 若资源未修改 → 返回 304 Not Modified，浏览器使用缓存。 基于唯一标识的实现: 响应头字段：ETag（资源唯一标识）
请求头字段：If-None-Match（上次 ETag 值）
工作流程:
第一次请求 …  ]]></content></entry><entry><title>2.7 HTTP1.1 特性</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0207-http1.1%E7%89%B9%E6%80%A7/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  优点简单HTTP 报文格式：由 header + body 组成。
头部信息形式：key-value 的简单文本，易于理解。
优势：降低学习和使用门槛。
灵活和易于扩展组成部分（请求方法、URI/URL、状态码、头字段等）：没有被固定，允许开发人员自定义与扩充。
层次特性：HTTP 工作在 应用层（OSI 第七层）。下层协议可自由变化，具备灵活性。
应用广泛和跨平台特点：HTTP 协议在不同系统和设备上均被广泛支持。
缺点无状态双刃剑无状态特征：服务器不记忆 HTTP 的状态。
好处：
无需额外资源记录状态信息。 减轻服务器负担。 提升 CPU 与内存 用于对外服务的能力。 缺点：因服务器无记忆能力，执行 有关联性的操作 时会变得 麻烦。
明文传输双刃剑明文传输：信息可直接阅读。
好处：调试方便（如使用 Wireshark 抓包可直接查看内容）。
缺点：所有信息 暴露在明文中，如同“信息裸奔”。隐私风险高，传输过程中的内容容易被窃取。
不安全通信使用明文（未加密） → 内容可能被窃听。
不验证通信方身份 → 有可能遭遇伪装。
无法证明报文完整性 → 报文可能已遭篡改。
性能长连接在 HTTP/1.0 中每次请求都需新建一次 TCP 连接（三次握手），请求串行执行，导致频繁的 TCP 建立与断开，增加通信开销。
HTTP/1.1 引入了 长连接（持久连接）。减少重复 TCP 连接的开销。降低服务器负载。
特点：只要通信双方未明确断开，TCP 连接会保持；若长时间无数据交互，服务端会主动断开连接。
管道网络传输前提：基于 HTTP/1.1 的长连接。
机制：在同一个 TCP 连接中，客户端可连续发起多个请求。无需等待前一个请求响应，即可发送下一个请求。减少整体响应时间。
限制：服务器必须 按接收顺序 响应请求。若前一个请求耗时较长，后续请求会被阻塞，形成 「队头堵塞」。
管道化解决了 请求的队头阻塞，但 未解决响应的队头阻塞。
队头阻塞问题来源：HTTP 的 “请求 - 应答” 模式。
当一个请求被阻塞时，其后的所有请求也被一并阻塞，导致客户端长时间无法收到响应数据。这种现象称为 「队头阻塞」。
  </content></entry><entry><title>2.8 HTTP 与 HTTPS</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0208-http%E4%B8%8Ehttps/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  HTTP 与 HTTPS 的区别HTTP：
超文本传输协议，信息以明文传输，存在安全风险。 TCP 三次握手后即可进行报文传输。 端口号为 80。 HTTPS：
在 TCP 与 HTTP 层之间加入 SSL/TLS 安全协议，使报文能够 加密传输，解决了 HTTP 的安全问题。 TCP 三次握手后，还需进行 SSL/TLS 握手过程，才能进入加密报文传输阶段。 端口号为 443。 需要向 CA（证书权威机构） 申请数字证书，以保证服务器身份可信。 HTTPS 解决的安全问题HTTP 明文传输存在三种风险：窃听风险、篡改风险、冒充风险。
HTTPS 在 HTTP 与 TCP 层之间加入 SSL/TLS 协议，解决上述风险：
信息加密：交互信息无法被窃取； 校验机制：通信内容无法被篡改； 身份证书验证：防止身份冒充。 对应解决方案：
风险类型 HTTPS 解决方式 机制说明 窃听风险 混合加密 实现信息机密性 篡改风险 摘要算法 确保数据完整性 冒充风险 数字证书 验证身份合法性 混合加密通过结合 对称加密 与 非对称加密 的混合方式，保证信息机密性，防止被窃听。
具体过程：
在通信建立前，采用 非对称加密 交换「会话秘钥」； 在通信过程中，使用 对称加密 的「会话秘钥」加密明文数据。 摘要算法 + 数字签名计算内容的唯一「指纹」（哈希值），用于校验数据是否被篡改；
无法通过哈希值推导出原内容。
仅使用哈希算法无法防止中间人替换数据，因此需结合 非对称加密 进行身份验证。
非对称加密的密钥类型：
公钥：可公开； 私钥：仅由持有者保管。 加解密方向与目的：
公钥加密 → 私钥解密。保证内容安全性 私钥加密 → 公钥解密。保证消息来源真实性 私钥用于加密消息的哈希值，公钥用于验证签名的真实性，若能正确解密，说明消息来源可靠。
数字证书CA（证书认证机构） 颁发的证书，将服务器公钥封装其中，证明公钥可信。
客户端通过浏览器或操作系统验证证书真实性。只要证书可信，公钥即可信。
HTTPS 建立连接过程（TLS 握手流程）总体流程：
客户端向服务器索要并验证公钥； 双方协商生成「会话秘钥」； 使用「会话秘钥」进行加密通信。 握手阶段（四次通信）：
ClientHello 客户端发送：支持的 TLS 版本、客户端随机数、支持的密码套件列表。 2. SeverHello
 …  </content></entry><entry><title>2.9 HTTP 版本</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0209-http%E7%89%88%E6%9C%AC/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  HTTP/1.1 相比 HTTP/1.0 的性能改进性能提升：
使用长连接：改善了 HTTP/1.0 短连接造成的性能开销。 支持管道（Pipeline）网络传输：第一个请求发出后，不必等待响应即可发送第二个请求，减少整体响应时间。 性能瓶颈：
请求 / 响应头部未经压缩，首部信息越多延迟越大，只能压缩 Body。 冗长首部重复发送，造成带宽浪费。 按顺序响应请求，响应慢会导致客户端长时间等待，出现队头阻塞。 无请求优先级控制。 请求必须由客户端发起，服务器只能被动响应。 HTTP/2 的优化HTTP/2 协议基于 HTTPS，安全性有保障。
性能改进包括：头部压缩、二进制格式、并发传输、服务器推送。
头部压缩（HPACK）HTTP/2 会压缩 Header，自动消除重复部分。
HPACK 算法：客户端与服务器同时维护头信息表，所有字段存入表中并生成索引号，后续仅发送索引号，提高传输速度。
二进制格式不再使用 HTTP/1.1 的纯文本报文，全面采用二进制格式，头信息与数据体均为二进制，统称为 帧（Frame）：头信息帧和数据帧。
无需再解析明文报文，直接处理二进制，提高数据传输效率。
并发传输（多路复用）HTTP/1.1：请求-响应模型，同一连接需串行执行，易出现队头阻塞。
HTTP/2：引入 Stream 概念，多个 Stream 复用一条 TCP 连接。
结构层级：
TCP 连接 → 包含多个 Stream。 Stream → 包含 1 个或多个 Message。 Message → 对应 HTTP/1 的请求或响应（含头部与包体）。 Frame → HTTP/2 最小单位，以二进制压缩格式存放数据。 每个请求分配唯一 Stream ID，不同 Stream 的帧可乱序发送，再由接收端按 ID 组装，可并行交错地发送请求与响应。
服务器推送改善传统「请求 - 应答」模式，服务器可主动推送资源。
双方都可建立 Stream：客户端 Stream ID 为奇数，服务器 Stream ID 为偶数。
HTTP/2 的缺陷HTTP/2 基于 TCP 协议，TCP 是 字节流协议，要求数据完整、连续。
若「前 1 个字节」未到达，后续字节只能暂存于内核缓冲区，只有前一个字节到达后，HTTP/2 才能从内核中读取数据。
一旦发生丢包，会触发 TCP 重传机 …  </content></entry><entry><title>2.4 HTTP 方法</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0204-http-%E6%96%B9%E6%B3%95/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  GET 方法GET 方法是最常见的 HTTP 方法之一，用于从服务器请求数据，是一种不改变内容的询问信息。
浏览器访问网页时，会向服务器发送 GET 请求，请求网页内容。服务器响应数据（如 HTML、图片或其他文件），浏览器显示结果。
GET 请求不会修改任何数据，仅用于“读取”或检索信息。
请求参数附加在 URL 中，因此可在浏览器地址栏中看到。
常见应用场景：
加载网页：输入 URL 或点击链接时，发起 GET 请求。 从 API 获取数据：开发者常使用 GET 请求从外部服务器获取信息。 搜索查询：搜索引擎查询会通过 GET 请求发送搜索词。 获取文件：用于下载图片、查看 PDF、播放视频等。 使用规范与实践：
仅用于数据检索：避免使用 GET 发送敏感信息（如密码）。 保持 URL 简短清晰：避免数据过长或超出 URL 限制。 启用缓存以提升性能：服务器可设置缓存控制头来优化加载速度。 避免修改数据：GET 是“安全”方法，不应引发数据变更。 谨慎处理敏感数据：GET 请求中的参数可能被记录或保存。 POST 方法POST 方法用于向服务器发送数据，通常用于表单提交、数据存储或处理。与 GET 不同，POST 请求的数据存储在请求体（body）中，而不是 URL。
GET 与 POST 的对比：
比较项 GET POST 数据位置 数据包含在 URL 中 数据包含在请求体中 可见性 数据在地址栏中可见 数据隐藏，不在地址栏中显示 主要用途 仅检索数据 发送、修改或添加数据 缓存 可被缓存 不会被缓存 幂等性 幂等，多次结果相同 非幂等，多次请求结果可能不同 常见应用场景：
提交表单 用户认证（用户名与密码验证） 上传文件 创建新资源 向 API 发送数据 在线购物支付处理 PUT 方法PUT 方法用于更新或替换服务器上的资源。
它发送的数据告诉服务器“资源应该是什么样子”。
应用场景：
更新资源：用新数据替换现有资源。 创建资源：若资源不存在，则使用数据创建新资源。 API 更新操作：常用于更新用户资料、产品详情等。 PUT 与 POST 的对比：
比较项 PUT POST 主要用途 更新或替换现有资源 创建或提交新资源 数据处理 替换整个资源 增量添加或修改 幂等性 幂等（重复执行结果相同） 非幂等（可能创建重复资源） 适用场景 更新或完全替换资源  …  </content></entry><entry><title>2.5 GET 与 POST</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0205-get%E4%B8%8Epost/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  GET 与 POST 的基本区别GET 的语义是从服务器获取指定资源。这个资源可以是文本、页面、图片、视频等。GET 请求的参数一般写在 URL 中。
URL 只支持 ASCII 字符。浏览器对 URL 长度有限制（HTTP 协议本身未规定）。
特点：参数可见于地址栏。适合只读、无副作用的请求。
POST 的语义是根据请求负荷（报文 body）对指定资源进行处理，处理方式取决于资源类型。POST 请求携带的数据一般是写在 报文 body 中，body 中的数据可以是任意格式，客户端与服务端协商确定。
特点：浏览器对 body 无大小限制。数据不可见于地址栏。常用于提交、上传、创建数据等操作。
安全性与幂等性安全：请求不会破坏服务器上的资源。
幂等：多次执行相同请求，结果相同。
RFC 语义定义：
方法 是否安全 是否幂等 是否可缓存 GET ✅ 安全 ✅ 幂等 ✅ 可缓存 POST ❌ 不安全 ❌ 不幂等 ⚠️ 一般不可缓存 GET：
只读操作，不修改服务器数据。 多次执行结果相同。 可缓存（浏览器或代理层，如 nginx）。可保存为书签。 POST：
用于新增或提交数据，会修改服务器资源。 多次执行会产生不同结果（如多条数据）。 浏览器一般不缓存。不能保存为书签。 实际开发中的情况：
可能用 GET 实现新增或删除操作 → 不再安全、幂等。 可能用 POST 实现查询操作 → 安全、幂等。 如果“安全”指信息不泄露：
GET 参数在 URL 可见； POST 数据在 body 中不可见； 但两者的 HTTP 数据都以 明文传输，通过抓包都能看到。 结论：GET 并不比 POST 更不安全；需使用 HTTPS 才能确保数据加密传输。
RFC 规范 未禁止 GET 请求带 body。理论上，任何请求 都可以带 body。只是 GET 的语义是获取资源，因此通常 不会使用 body。
URL 查询参数 并非 GET 独有，POST 请求的 URL 也可以包含参数。
  </content></entry><entry><title>2.3 HTTP 入门</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0203-http-%E5%85%A5%E9%97%A8/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  HTTP（超文本传输协议）：浏览网页时使用的通信协议。
工作原理：
浏览器向服务器发出 HTTP 请求。 服务器响应资源（图片、视频或 HTML 网页）。 浏览器接收并显示内容。 模型特征：HTTP 是一个 基于消息的模型。每个 HTTP 交互包含一个 请求（Request） 和一个 响应（Response）。
无状态性：
每个请求都是 独立的。 每次请求必须包含足够的信息，服务器才能单独处理。 各事务之间相互独立。 URLsURL：用于识别 Web 资源的网址。
网络围绕“资源”构建。资源包括文本、HTML 文件、文档、图像等。网络可以被视为 资源的集合。
协议（Protocol）：通常为 HTTP 或 HTTPS（安全版本）。
其他常见协议：
FTP（文件传输协议）：在客户端与服务器之间传输文件。 SMTP（简单邮件传输协议）：用于电子邮件传输。 域名 — 用于识别资源所在的一个或多个 IP 地址。
路径 — 指定服务器上的资源位置。
参数 —用于识别或过滤服务器上的资源的附加数据。
HTTP 请求每个 HTTP 请求包含：URL 地址、HTTP 方法、标头（Headers）、可选的消息正文（Body）
HTTP 请求的第一部分包含三项：
HTTP 方法：指定所使用的请求方式。最常用的是 GET（从服务器检索资源）。GET 请求没有消息体，标头后无内容。 请求的 URL HTTP 版本：常见版本1.1（主流）与 2.0（逐渐取代 1.1）。 当 URL 中包含 “?” 时，表示它携带查询参数。查询参数用于发送请求资源所需的附加数据。
常见请求标头：
Referer：告知请求的来源 URL。 User-Agent：提供发出请求的浏览器信息。 Host：标识主机名（当多个网站共用同一服务器时必需）。 Cookie：向客户端提交附加参数。 HTTP 响应HTTP 响应包含以下三部分：
HTTP 版本 状态码（数字代码） 状态描述（文字说明） 常见响应标头：
Server：提供所使用的 Web 服务器软件信息。 Set-Cookie：向浏览器发出 Cookie。 Content-Length：以字节为单位告知消息正文大小。 消息正文（Body）：包含实际响应内容。
HTTP 方法方法 说明 GET 请求数据，不修改资源。 POST 向服务器发送数据以创建资源。 …  </content></entry><entry><title>2.2 什么是 HTTP？</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0202-%E4%BB%80%E4%B9%88%E6%98%AF-http/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  HTTP 简介HTTP（超文本传输协议）：一种用于在互联网上交换信息的协议，是万维网的基础。
功能：支持互联网数据传输，允许用户访问网站和其他在线资源。
作用：
确保信息从一个地方传输到另一个地方。 实现 Web 浏览器 与 服务器 之间的通信。 是 网页内容传输与展示的基础机制。 HTTP 请求-响应周期HTTP 的通信过程围绕着一个称为 请求-响应周期（Request-Response Cycle） 的机制展开。
工作流程：
客户端（如浏览器或移动应用）向服务器发送 HTTP 请求消息。请求中包含所需资源及附加参数等信息。 服务器 接收并处理请求。使用服务器资源生成 响应消息。 服务器 将响应消息发送回客户端。响应通常包含所请求的资源（例如网页）及附加元数据。 客户端 接收响应并进行处理。通常通过浏览器渲染网页或在应用中显示内容。 客户端 可根据需要再次发起新的请求。 周期可多次重复。
HTTP 请求创建一个有效的 HTTP 请求需要包含以下内容：
URL HTTP 方法 请求标头（Headers） 请求主体（Body） HTTP 请求 URLURL 是请求服务器上资源的唯一标识符。指向服务器上的特定 资源（Resource）。包括用户、产品、文章、文档、图像等。资源可以被视为一个 名词。
HTTP 请求方法请求方法用于告诉服务器客户端希望执行的操作。
常见方法如下：
HEAD：向服务器询问资源的状态（如大小、可用性） GET：请求服务器检索资源。 POST：要求服务器创建新资源。 PUT：要求服务器编辑/更新现有资源。 DELETE：请求服务器删除资源。 HTTP 请求标头请求标头是客户端在 HTTP 请求中附加的名称/值信息。
这些标头向服务器提供上下文信息。指示如何处理请求或定制响应。
HTTP 请求主体请求主体是客户端在 HTTP 请求中发送给服务器的数据部分。
HTTP 响应HTTP 响应是 服务器返回给客户端 的消息，用于回应客户端的请求。
组成部分：
状态行：包含 HTTP 版本、状态码、状态消息。
响应标头：提供响应的附加信息，如内容类型、时间等。
消息正文：包含实际返回的数据，如 HTML、JSON 或 XML。
常见 HTTP 状态码：100： Continue （继续） 101：Switching Protocols （切换协议） 200：OK（成功） 201：Created（创建成功） 202：Accepted（已接受） 203： Non-Authoritative Information（非权威信息） 301： Moved Permanently（永久移动，资源已移至新的 URL） 404：Not Found（未找到，服务器上无请求的资源） 500：Internal Server Error（服务器内部错误）   </content></entry><entry><title>1.5 基于计网的前端优化思路</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0105-%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%BD%91%E7%9A%84%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>性能优化</tag></tags><content type="html">  一、网页从服务器到用户屏幕的五个关键阶段阶段 层次对应 优化目标 1️ 请求阶段 DNS、TCP、TLS 连接更快（少重试、少延迟） 2️ 传输阶段 TCP/IP 层 数据包更少、更小 3️ 下载阶段 HTTP 层 资源请求并行化、压缩、缓存 4️ 解析与执行阶段 浏览器渲染层 更少的 JS 执行阻塞 5️ 渲染阶段 GPU / DOM 层 减少回流重绘、加速绘制 二、前端优化其实就是“减少负担 + 加快流动”我们来逐层对应一下你刚说的“封装包 → 解包 → 不卡死”思路 👇
1. 减少要“装进包”的内容HTTP 传输的内容越多，包就越多 → 传输越慢。
优化方式：
代码压缩（JS/CSS/HTML minify） 图片压缩、懒加载、合图（sprite） Tree Shaking / 按需加载（减少没必要的模块） 延迟加载（lazy import、code splitting） 类比：打包少带点行李，车子跑得快。
2. 让包传得更快优化“网络传输”这一段流水线。
方式：
CDN 加速（让资源从离你最近的服务器来） HTTP/2 多路复用（多个文件共用一个 TCP 连接） HTTP/3（基于 UDP，减少握手延迟） 缓存策略（304 / ETag / Service Worker） 类比：走最近的路 + 开高速公路 + 不重复寄。
3. 减少“装包拆包”的开销让浏览器少做多余的工作。
方式：
合并请求（减少 TCP 连接） 避免太多小资源（请求越多，TCP/TLS 握手越多） 启用压缩传输（gzip、brotli） 类比：把很多小信封塞进一个包寄，省下装拆时间。
4. 解包后渲染更高效即浏览器的“解析与渲染阶段”。
方式：
减少 JS 阻塞渲染（defer / async） 避免频繁 DOM 操作（虚拟 DOM、批量更新） CSS 放上面、JS 放下面 使用 GPU 加速动画（transform / opacity） 类比：包裹到了仓库后，快速分类、直接上架展示。
5. 缓存结果，避免重复运输方式：
使用本地缓存（LocalStorage、IndexedDB） 使用 HTTP 缓存头（Cache-Control, ETag） PWA / Service Worker 离线缓存 类比：快递到了第一次后，后面直接用本地备份，不再重新寄。
三、前端性能优化的核心思路一句话总结：优化 = 让网页传得少、传得快、解得轻、显示得快。
也就是：
减少请求数（包少） 减少包大小（轻） 让传输通道更高效（快） 让解包和渲染更顺畅（不卡） 让重复访问更聪明（缓存）   </content></entry><entry><title>2.1 HTTP 基本概念</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0201-http%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag><tag>HTTP协议</tag></tags><content type="html">  HTTP 是什么HTTP 是超文本传输协议（HyperText Transfer Protocol）。
HTTP 的名称可以拆解为三个部分：
超文本 传输 协议 协议协议的特点:
“协”表示必须有两个以上的参与者。 “议”表示对参与者的行为约定和规范。 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立交流通信规范。包括各种控制和错误处理方式。
传输“传输”表示在两点之间传递数据，可以是从 A 到 B，也可以从 B 到 A。
HTTP 是一个双向协议：浏览器发送请求 → 服务器响应数据 → 浏览器渲染结果。
允许中间有中转或接力，只要遵从 HTTP 协议即可。
本质上，HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。
超文本“超文本”是超越普通文本的文本，包含文字、图片、视频等内容，且具备超链接特性，能从一个超文本跳转到另一个超文本。
HTML 是最常见的超文本，虽然是纯文本文件，但通过标签定义了图片、视频等链接。浏览器解释 HTML 后，会呈现出文字、图片等混合的网页。
HTTP 是一个在计算机世界里专门在“两点”之间“传输”文字、图片、音频、视频等“超文本”数据的“约定和规范”。
HTTP 常见的状态码1xx：提示信息：
表示协议处理中的中间状态，实际使用较少。 2xx：请求成功：
200 OK：一切正常（非 HEAD 请求有 body 数据）。 204 No Content：与 200 类似，但响应头没有 body 数据。 206 Partial Content：用于分块下载或断点续传，返回的是资源的一部分。 3xx：重定向：
301 Moved Permanently：永久重定向，请求资源需使用新的 URL。 302 Found：临时重定向，请求资源暂时需用另一个 URL。 二者均在响应头中使用 Location 字段指明新的 URL。 304 Not Modified：资源未修改，可继续使用缓存资源（缓存重定向）。 4xx：客户端错误：
400 Bad Request：客户端请求报文有错误（笼统错误）。 403 Forbidden：服务器禁止访问资源。 404 Not Found：资源不存在或未找到。 5xx：服务器错误：
500 Internal Server Error：服务器内部错误（笼统错误）。 …  </content></entry><entry><title>1.3 键入网址到网页显示期间发生了什么</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0103-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag></tags><content type="html">  HTTP浏览器第一步工作是解析 URL，以生成发送给 Web 服务器的 HTTP 请求信息。
URL 指向服务器中的文件资源。如果 URL 中没有路径名，访问默认文件
解析结果：
确定 Web 服务器 地址。 确定请求的 文件名。 浏览器根据这些信息生成 HTTP 请求消息。 DNSDNS 保存 域名与 IP 地址 的对应关系。能够将域名解析为 IP 地址，确保消息能够发送到目标服务器。
域名层级结构DNS 使用句点分隔域名层级，如 www.server.com。
在域名中，越靠右的位置表示其层级越高。
越右层级越高：
根域 DNS 服务器（.） 顶级域 DNS 服务器（如 .com） 权威 DNS 服务器（如 server.com） 客户端可通过任意 DNS 服务器逐层找到目标权威 DNS。
域名解析流程客户端：
发出 DNS 请求：查询 www.server.com 的 IP。 优先查找浏览器缓存。 本地 DNS：
如果缓存有结果，直接返回。 如果没有，查询 根域名服务器。 根 DNS：指向顶级域服务器（如 .com）。
顶级域 DNS：指向权威 DNS 服务器（如 server.com）。
权威 DNS：返回域名对应的 IP 地址。
本地 DNS：
将 IP 地址返回给客户端。 缓存结果以便下次查询。 协议栈负责将应用层（HTTP）数据传输到网络中。
组成：
传输层：TCP / UDP
接受应用层委托，处理收发数据。 网络层：IP
将数据拆分为网络包，控制发送。
包含 ICMP（错误与控制信息）和 ARP（IP → MAC 地址查询）。
网络接口层：
网卡驱动控制网卡硬件。
网卡完成实际收发，将数字信息转为电信号。
TCPHTTP 基于 TCP 传输。
特点：
面向连接 提供可靠传输（顺序、确认、重传、流量控制、拥塞控制） TCP 报文头部的格式源端口 &amp;amp;amp; 目标端口：确定数据发送和接收的应用。
序号 &amp;amp;amp; 确认号：解决乱序与丢包问题。
状态位：
SYN：发起连接 ACK：确认 RST：重置连接 FIN：结束连接 窗口大小：用于流量控制。
TCP 三次握手（建立连接）客户端 SYN → 服务器（SYN-SENT） 服务器 SYN + ACK → 客户端（SYN-RCVD） 客户端 ACK → 服务器（ESTABLISHED） 目的： …  </content></entry><entry><title>1.4 当您在浏览器中单击 URL 时会发生什么</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0104-%E5%BD%93%E6%82%A8%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%8D%95%E5%87%BB-url-%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag></tags><content type="html">  URL（统一资源定位符）URL 包含了要访问的资源的位置，是用户与资源进行交互或获取信息的地址。
网站像房子，URL 就是它的地址。
URL 的构成https://www.example.com/page1第一部分是 https。它告诉浏览器应使用哪种协议（如 http、https、ftp）。
协议是一组浏览器用于通过网络通信的规则。
https 是 http 的安全版本，信息以安全的方式交换。
第二部分 www.example.com 是域名。它是网站的地址，用于连接到提供该网站信息的服务器。
URL 与域名之间的区别URL：完整的地址，说明了信息交换的方法和到达路径。
域名：URL 的一部分，仅表示网站的地址。
域名域名是网站的地址，为网站提供在网络中的独特身份。没有两个域名可以相同。
当点击 URL 或域名时，网站内容由服务器提供。
每台计算机都有一个 IP 地址 用于互联网通信。当点击 URL 时，实际上是访问了提供网站内容的计算机的 IP 地址。
DNS 是存储域名及其对应 IP 地址的系统。
作用：将域名解析为 IP 地址，使浏览器能够找到服务器。
DNS 查询：找到 IP 地址的过程DNS 类似“电话簿”，帮助找到与域名对应的 IP 地址。
解析过程分为多个层级：
浏览器缓存：浏览器保存访问过的网站的 DNS 记录；首先在浏览器缓存中查找域名对应的 IP 地址。 操作系统与路由器缓存：若浏览器缓存无结果，查询操作系统缓存；接着查询路由器缓存。 解析服务器（ISP 缓存）：若前两步未找到结果，请求发送到 ISP（互联网服务提供商） 的解析服务器；查询 ISP 的 DNS 缓存。 DNS 层次结构的顶级或根服务器：若仍未解析成功，请求发送至 根服务器；根服务器不会出现“找不到”的情况；它会告诉解析服务器去 顶级域服务器（如 .com、.net、.gov、.org） 查找。 后续解析流程：
解析器 → 顶级域名服务器：请求获取域名的 IP 地址； 顶级域名服务器：告知解析器去询问 权威域名服务器； 权威域名服务器：保存关于域名的所有信息； 解析器（ISP）：最终获取 IP 地址并返回给浏览器。 缓存机制：获取到 IP 地址后，解析器将结果存入缓存；下次相同查询时，可直接从缓存获取，无需重复整个解析流程。
TCP 连接： …  </content></entry><entry><title>1.1 TCP/IP 网络模型</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0101-tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag></tags><content type="html">  同一台设备上的进程间通信方式：管道、消息队列、共享内存、信号
不同设备上的进程间通信：需要通过网络通信实现。
网络协议的设计目标：兼容多种类型的设备；通过分层结构定义不同层的作用与职责。
应用层最上层，也是用户能够直接接触到的一层。
当两个不同设备的应用需要通信时，应用将应用数据传递给下一层（传输层）
应用层只专注于为用户提供应用功能，无需关心数据如何传输。
应用层运行于操作系统的用户态。传输层及以下运行于操作系统的内核态。
传输层为应用层提供网络支持。负责将应用层的数据打包并传输给目标主机的指定应用。
在传输层会有两个传输协议，分别是 TCP 和 UDP。
主要协议：
TCP（传输控制协议）：提供可靠传输；具有流量控制、超时重传、拥塞控制等特性；多数应用（如 HTTP）使用 TCP。 UDP（用户数据报协议）：不保证可靠性；仅负责发送数据包；实时性高、效率高；可靠性可在应用层自行实现。 当传输层的数据包大小超过 MSS（TCP 最大报文段长度），数据会被拆分成多个分块。每个分块称为一个 TCP 段（TCP Segment）。若其中一个分块丢失，只需重传该分块。
设备上可能有多个应用在传输数据，端口号 用于区分不同应用：
80 端口 → Web 服务器； 22 端口 → 远程登录服务器； 浏览器的每个标签页 → 独立进程，分配临时端口号。 报文携带端口号，使接收方能识别出目标应用。
网络层负责不同网络之间的数据传输与路由选择。
常用协议：IP 协议。
数据封装过程：
传输层报文作为数据部分； 加上 IP 包头组装成 IP 报文； 若 IP 报文大小超过 MTU（以太网中通常为 1500 字节），则进行分片。 IPv4 地址：32 位，分为 4 段（如 192.168.100.1）。
作用：区分不同设备；实现寻址与路由。
IP 地址结构：
网络号：标识该地址所属的子网； 主机号：标识同一子网下的不同主机； 子网掩码：辅助计算网络号与主机号。 地址：10.100.122.0/24， /24 表示子网掩码为 255.255.255.0。
IP 地址与子网掩码按位与 → 网络号；
子网掩码取反后与 IP 地址按位与 → 主机号。
寻址过程：先匹配网络号（确定子网）；再匹配主机号（确定主机）。
寻址：确定目标地址所属的子网；
路由：决定数据包下一跳的路径。
实际通信中， …  </content></entry><entry><title>1.2 OSI 七层网络模型</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0102-osi-%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url><categories><category>计算机网络</category></categories><tags><tag>计算机基础</tag><tag>计算机网络</tag></tags><content type="html">  常见网络术语节点（Node）定义：连接到网络的实际电子设备。如果设置得当，节点能够通过网络发送和/或接收信息。
节点 A 可以直接连接节点 B；也可以通过中间节点（如交换机或路由器）连接。
路由器：连接网络到互联网。交换机：促进网络内部通信。
主机：需要 IP 地址的节点类型。所有主机都是节点，但并非所有节点都是主机。
链路（Link）定义：连接网络上节点的通道。
类型：
有线链路（如以太网） 无线链路（如 WiFi） 连接方式：
点对点（节点 A ↔ 节点 B） 多点（节点 A ↔ 节点 B、C） 传输信息时也可表示为“一对一”或“一对多”关系。
协议（Protocol）定义：双方同意的一组规则，使两个节点能在网络上交换数据。
内容：
语法：可通信的内容 语义：通信方式 同步：通信时间与速度 实现方式：硬件、软件或两者结合。任何人都可创建协议，但最广泛采用的协议是基于标准的。
有线与无线链路均可使用协议。
网络（Network）定义：计算机、打印机或任何其他共享数据的设备集合。
类型：LAN、HAN、CAN、MAN、WAN、BAN、VPN。
拓扑（Topology）定义：描述节点和链路在网络配置中的连接方式。
网络由以下部分组成：
节点 节点之间的链路 控制节点间数据传输的协议 什么是 OSI 模型？OSI 模型由 七层网络结构 组成。
每一层用于对网络功能与行为进行分类与分组。
层级顺序：从最有形（物理）到最抽象（用户层）。
层级特性：
上层抽象下层功能； 用户只接触最高层； 下层的细节对用户隐藏。 物理层（Layer 1）定义：涉及物理网络设备、布线、信号类型及传输方式。关注设备连接与信号传输的物理特性。
内容分类：
节点与硬件组件：集线器、中继器、路由器、计算机、打印机、天线、放大器、网络接口卡 (NIC) 设备接口机制：电缆连接方式、连接器尺寸与形状、引脚功能及活动状态 功能与程序逻辑：定义引脚功能及通信顺序 布线协议与规范：以太网 (CAT)、USB、DSL 等；包括最大电缆长度、调制方式、无线电规格等 电缆类型：屏蔽或非屏蔽双绞线、同轴电缆等 信号类型：基带（单一比特流）、宽带（多比特流） 传输方式：有线：电（以太网）、光（光纤）；无线：无线电（WiFi、蓝牙） 数据单位：
位（bit）：数字信息最小单位。1 字节 = 8 位。
比特传 …  </content></entry><entry><title>3.5 简化真值表</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0305-%E7%AE%80%E5%8C%96%E7%9C%9F%E5%80%BC%E8%A1%A8/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  简化真值表方法：检验论证无效性与语句集相容性在语句逻辑中，完整真值表虽能精准判定论证有效性和语句集相容性，但当支语句数量较多时（如 4 个支语句需 16 行真值组合），会显得繁琐低效。简化真值表方法通过“目标导向”的真值指派，直接定位关键解释（反例或相容解释），大幅简化推理过程，尤其适用于检验论证无效性和语句集相容性。
简化真值表方法：检验论证无效性论证无效的核心标志是“存在反例”——即存在一种支语句真值组合，使得所有前提为真（T）且结论为假（F）。简化真值表方法的本质的是“逆向推导”：先预设“前提皆真、结论假”的目标，再反向推导支语句的真值，若能找到无矛盾的真值组合，则论证无效（反例存在）；若推导过程中出现矛盾，则论证有效（反例不存在）。
核心原理与步骤简化真值表检验论证无效性的核心逻辑是：先定目标（前提 T、结论 F），再推支语句真值，验证是否无矛盾。具体步骤如下：
步骤 1：明确论证结构，列出前提与结论首先提取论证的所有前提和结论，用符号化形式表示（如前提：p⊃q、q∨r；结论：p⊃r），明确所有支语句（如 p、q、r）。
步骤 2：预设目标真值——前提皆为 T，结论为 F直接给每个前提指派“真（T）”，给结论指派“假（F）”，这是寻找反例的起点（反例的定义就是“前提真且结论假”）。
步骤 3：逆向推导支语句的真值根据复合语句（前提、结论）的真值规则，反向推导支语句的真值，需遵循“优先处理真值唯一确定的语句”原则：
优先处理否定句：若否定句为 T，则原句为 F；若否定句为 F，则原句为 T（如 ¬p=T → p=F）。 优先处理真值唯一的复合句：部分复合语句的真值仅对应唯一的支语句组合，需优先推导（如条件句 A⊃B=F 仅当 A=T 且 B=F；合取句 A∧B=T 仅当 A=T 且 B=T）。 步骤 4：验证真值指派是否无矛盾若推导过程中，所有支语句的真值始终一致（无“同一支语句既为 T 又为 F”的矛盾），则找到反例，论证无效；若推导必然出现矛盾（如某支语句被迫同时为 T 和 F），则不存在反例，论证有效。
实例演示：检验论证无效性以论证“前提 1：p⊃q；前提 2：q∨r；结论：p⊃r”为例，演示简化真值表的应用：
步骤 1：明确结构支语句：p、q、r 前提 1：p⊃q（T），前提 2：q∨r（T），结论：p⊃r（F） 步骤 2：预设目标 …  </content></entry><entry><title>3.3 逻辑等价与条件句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0303-%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  核心概念界定与区分在逻辑研究中，“等值”与“蕴含”是两类关键关系，但需严格区分“实质”与“逻辑”两个层面——前者依赖语句的实际真值，后者依赖语句的逻辑结构，二者的核心差异在于“真值是否仅由逻辑形式决定”。
实质等值与逻辑等值实质等值：基于实际真值的等同定义：若两个语句（如 p 和 q）在实际情况中具有相同的真值（即同真或同假），则称二者“实质等值”。
例如：“今天下雨”（p）和“地面潮湿”（q），若今天确实下雨且地面潮湿（同真），或今天没下雨且地面干燥（同假），则 p 与 q 实质等值。 表达式：用双条件句 p ≡ q（读作“p 当且仅当 q”）表示实质等值关系。
当 p 与 q 实质等值时，p ≡ q 为真；若二者真值不同（一真一假），则 p ≡ q 为假。 关键特性：实质等值依赖语句的“实际真值”，而非逻辑结构。即使两个语句的逻辑形式无关，只要实际真值相同，就满足实质等值。 逻辑等值：基于逻辑结构的必然等同定义：若两个语句（如 p 和 q）不可能具有不同的真值（即无论支语句的真值如何变化，二者始终同真同假），则称二者“逻辑等值”。
例如：“并非（p 且 q）”（¬(p ∧ q)）和“非 p 或非 q”（¬p ∨ ¬q），无论 p 和 q 本身是真还是假，这两个语句的真值始终一致（这是逻辑中的“德摩根定律”）。 表达式：仍用双条件句 p ≡ q 表示，但此时 p ≡ q 是逻辑等价句（属于重言句的一种）。
逻辑等价句的核心特征是：其真值独立于支语句的真值，仅由逻辑结构决定——无论支语句取何值，p ≡ q 始终为真。 判定标准：两个语句逻辑等值，当且仅当它们的真值表中没有任何一行出现不同的真值。
以 ¬(p ∧ q) 与 ¬p ∨ ¬q 为例，真值表如下（T 为真，F 为假）： p q p ∧ q ¬(p ∧ q) ¬p ¬q ¬p ∨ ¬q T T T F F F F T F F T F T T F T F T T F T F F F T T T T 可见，¬(p ∧ q) 与 ¬p ∨ ¬q 在所有行的真值完全一致，因此二者逻辑等值。
实质蕴含与逻辑蕴含实质蕴含：基于实际真值的推导定义：若两个语句 p 和 q 满足“不可能 p 真而 q 假”的实际情况，则称 p 实质蕴含 q。
例如：“今天是周一”（p）和“今天是工作日”（q），若实际情况中“今天是 …  </content></entry><entry><title>3.4 有效性、相容性</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0304-%E6%9C%89%E6%95%88%E6%80%A7%E7%9B%B8%E5%AE%B9%E6%80%A7/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  语句逻辑中真值表的应用：有效性与相容性检验在语句逻辑（命题逻辑）中，真值表是分析论证有效性和语句集相容性的核心工具。它通过穷尽所有可能的“解释”（即支语句的真值组合），直观呈现论证或语句集的逻辑特征，帮助我们精准判定其逻辑属性。
用真值表检验论证有效性论证的“有效性”是语句逻辑的核心概念，其本质是前提与结论之间的必然逻辑联系——若前提为真，则结论不可能为假。真值表通过覆盖所有可能的真值组合，直接验证这一必然性。
有效性的核心定义一个论证是有效的，当且仅当：
不存在任何解释（支语句真值组合），使得“所有前提为真”且“结论为假”。 反之，若存在至少一种解释满足“前提皆真而结论假”，则论证是无效的，这种解释被称为论证的“反例”。 真值表检验有效性的步骤以简单论证“如果 p，那么 q（p⊃q）；p；因此 q”为例，演示检验流程：
步骤 1：确定支语句与真值组合论证中涉及的支语句为p和q，每个支语句有“真（T）”“假（F）”两种可能，因此总共有2²=4种真值组合（若有 n 个支语句，组合数为2ⁿ）。
步骤 2：构造真值表，计算前提与结论的真值支语句组合 前提 1：p⊃q 前提 2：p 结论：q 关键判定（前提皆真？结论假？） p=T, q=T T（T⊃T=T） T T 前提皆真，结论真 → 符合有效性 p=T, q=F F（T⊃F=F） T F 前提 1 假，不满足“前提皆真” → 无关 p=F, q=T T（F⊃T=T） F T 前提 2 假，不满足“前提皆真” → 无关 p=F, q=F T（F⊃F=T） F F 前提 2 假，不满足“前提皆真” → 无关 步骤 3：判定有效性观察真值表中是否存在“前提皆真且结论假”的行：上述表格中无此类行，因此该论证（假言推理肯定前件式）是有效的。
论证的对应条件句与有效性论证的“对应条件句”定义为：（前提 1 ∧ 前提 2 ∧ &amp;amp;hellip; ∧ 前提 n）⊃ 结论（即所有前提的合取作为前件，结论作为后件的条件句）。
一个论证是有效的，当且仅当其对应条件句是重言句（恒真句）。
原因：重言句的真值独立于支语句，始终为真，意味着“前提合取为真”时“结论必为真”，完全符合有效性定义。 示例：上述论证的对应条件句为((p⊃q) ∧ p) ⊃ q，其真值表中所有行均为真（重言句），进一步验证论证有效。 …  </content></entry><entry><title>3.1 真值的计算</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0301--%E7%9C%9F%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  核心前提对由真值函数联结词（如否定 ¬、合取 ∧、析取 ∨、蕴含 →、等值 ↔）联结的任意复合语句，若已知所有支语句（原子语句/子复合语句）的真值，可通过真值表相关方法判定整个复合语句的真值。
真值表分析法（含环线方法）核心逻辑从语句的最小单位（原子语句） 开始，按“由小到大、逐步演算”的顺序，结合真值函数联结词的真值表规则，最终通过“环线标注”确定整个语句的真值。
操作步骤拆分语句结构：将复合语句拆解为原子语句、子复合语句，明确各层级的联结词（如“¬(p∧q)∨r”拆分为原子语句 p/q/r、子复合语句 p∧q、外层复合语句 ¬(p∧q)∨r）； 赋值原子语句真值：根据已知条件，为每个原子语句赋予 T（真）或 F（假）； 逐步演算子复合语句真值： 先计算“最小辖域联结词”对应的子语句真值（如先算 p∧q，依据合取词真值表：p、q 均为 T 时 p∧q 为 T，否则为 F）； 再计算“更大辖域联结词”对应的子语句真值（如基于 p∧q 的真值算 ¬(p∧q)，依据否定词真值表：原语句为 T 则否定为 F，原语句为 F 则否定为 T）； 环线标注最终真值：每完成一个层级的演算，用环线标注该层级子语句的真值；重复步骤 3，直到演算至整个语句的“主联结词”，主联结词旁环线标注的真值即为整个复合语句的真值。 优势图解式标注（环线）清晰区分各层级真值，适合初学阶段理解真值演算的“分步逻辑”。 表列方法（无环线的真值表分析）核心逻辑不使用环线，直接将各层级语句的真值写在对应联结词下方，整个复合语句的真值最终体现在“主联结词下方”，通过“箭头符”标示主联结词，明确真值判定的最终依据。
操作步骤（含主联结词标示）符号化语句与原子赋值： 确保复合语句已完成符号化（如“如果 p 那么 q 且 r”符号化为 p→(q∧r)）； 在每个原子语句（p、q、r）下方，根据已知条件标注 T 或 F； 计算否定句真值：对原子语句的否定（如 ¬p），依据否定词真值表，在“否定号（¬）下方”标注真值（p 为 T 则 ¬p 下标 F，p 为 F 则 ¬p 下标 T）； 按辖域从小到大演算联结词真值： 先找“辖域最小的非否定联结词”（如 q∧r 中的 ∧），依据对应联结词真值表，在该联结词下方标注真值（q、r 均为 T 则 ∧ 下标 T，否则为 F）； 重复此步骤，逐步寻找“辖域更大的联结 …  </content></entry><entry><title>3.2 重言句、矛盾句和偶真句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0302--%E9%87%8D%E8%A8%80%E5%8F%A5%E7%9F%9B%E7%9B%BE%E5%8F%A5%E5%92%8C%E5%81%B6%E7%9C%9F%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  真值表的核心概念：解释与语句分类解释与真值表行的关系解释：对复合语句中所有原子语句的真值指派（即给每个原子语句赋 T 或 F）。 真值表行：每一行对应一个唯一的解释，完整真值表覆盖语句的所有可能解释（无遗漏）。 主联结词的作用：语句的最终真值由其主联结词下方的真值决定（某行主联结词为 T，代表该解释下语句为真；为 F 则为假）。 语句的三类分类（基于真值表判定）语句类型 定义（基于解释） 真值表判定标准（主联结词下方） 矛盾句 不存在任何解释使其为真（逻辑上必然假） 所有行均为 F 重言句 不存在任何解释使其为假（逻辑上必然真） 所有行均为 T 偶真句 存在部分解释使其为真，部分解释使其为假（真值依赖“世界偶然状态”，非逻辑必然） 既有 T 也有 F 特殊情况：单原子语句的解释若语句仅含 1 个不同原子语句（无论该原子语句出现多少次），仅存在2 种可能解释（原子语句为 T 或 F）。 真值表的构建步骤（机械流程）步骤 1：确定真值表的行数核心公式：若语句含 n 个不同原子语句，行数 = 2ⁿ（如 2 个原子语句：2²=4 行；3 个原子语句：2³=8 行）。 步骤 2：列出原子语句的所有真值组合规则：从最右侧原子语句开始，按“T、F 交替”赋值；左侧原子语句按“2 行同值、2 行交替”（n=2）、“4 行同值、4 行交替”（n=3）的规律扩展，确保覆盖所有组合。 示例（2 个原子语句 p、q）： p q T T T F F T F F 步骤 3：逐步演算支语句与主联结词的真值原子语句列赋值：直接在每个原子语句下方，按步骤 2 的真值组合填写 T 或 F； 优先演算否定句：对原子语句的否定（如 ¬p），依据否定词真值表（原句为 T 则 ¬ 为 F，原句为 F 则 ¬ 为 T），在否定号下方填写真值； 按辖域从小到大演算联结词： 先算“最小辖域联结词”（如 p∧q 中的 ∧），依据对应联结词真值表（合取 ∧：仅 p、q 均 T 时为 T；析取 ∨：仅 p、q 均 F 时为 F 等），在联结词下方填真值； 逐步扩大辖域，重复演算（如先算 p∧q，再算 ¬(p∧q)，最后算 ¬(p∧q)∨r）； 完成主联结词赋值：当演算至覆盖全句的“主联结词”，并填写其下方所有真值后，真值表构建完成。 真值表的延伸应用：论证有效性与哲学关联论证有效性的判定核心逻辑：有效 …  </content></entry><entry><title>2.13 - 2.14 复杂语句符号化</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0205-%E5%A4%8D%E6%9D%82%E8%AF%AD%E5%8F%A5%E7%AC%A6%E5%8F%B7%E5%8C%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html"><![CDATA[  日常语句符号化的核心原则：语法结构与逻辑结构的对应日常语句的语法结构（如联结词、标点）往往直接反映其逻辑结构，符号化的核心是将语法联结词替换为逻辑符号，同时确保逻辑含义与原语句完全一致。
复杂语句符号化的四步实操方法第一步：定位主联结词——符号化的“突破口”主联结词是决定整个语句逻辑类型的核心联结词（如“并且”“如果&amp;hellip;那么&amp;hellip;”“或”），找到它就能将复杂语句拆分为更小的支语句。
关键技巧： 关注语句开头：很多语句的主联结词直接出现在句首（如“如果明天晴天，我们就去公园”，主联结词是开头的“如果&amp;hellip;就&amp;hellip;”，对应逻辑符号“⊃”）。 区分“转折词的位置”： 转折词（如“但是”“然而”“不过”）出现在句首时，通常无真值函数意义（仅表语气转折），符号化时直接忽略（如“不过，小明今天没迟到”，实际逻辑是“小明今天没迟到”，符号化为“~A”，“不过”可忽略）； 转折词出现在语句中间时，等价于真值函数的“并且（·）”（如“小明很努力，但是没考好”，逻辑是“小明很努力且没考好”，符号化为“A·~B”）。 第二步：利用标点符号——确定支语句的边界逗号（,）、分号（;）是划分支语句的重要标志，通常对应逻辑符号中的“括号”，需将标点分隔的两部分分别置于主联结词两侧。
示例： 语句：“小明喜欢数学，小红喜欢英语”——逗号分隔两个支语句，主联结词是隐含的“并且”，符号化为“A·B”（A：小明喜欢数学，B：小红喜欢英语）； 语句：“如果明天不加班，我们去看电影；否则，我们在家做饭”——分号将语句分为“如果不加班则看电影”和“如果加班则在家做饭”，主联结词是“并且”，整体符号化为“(~A⊃B)·(A⊃C)”（A：明天加班，B：去看电影，C：在家做饭）。 第三步：分而治之——拆解支语句（递归应用符号化技巧）找到主联结词并拆分出支语句后，对每个支语句重复第一步和第二步：定位支语句的主联结词、利用标点划分更小的支语句，直到拆解为不可再分的原子语句。
示例（复杂语句）：“如果小明参加比赛并且小红当裁判，那么小李会来加油或小张会帮忙” 找主联结词：句首的“如果&amp;hellip;那么&amp;hellip;”（⊃），将语句拆为前件“小明参加比赛并且小红当裁判”和后件“小李会来加油或小张会帮忙”； 拆解前件：主联结词是“并且（·）”，拆为原子语句 A（小明参加 …  ]]></content></entry><entry><title>2.10 - 2.12 条件句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0204-%E6%9D%A1%E4%BB%B6%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html"><![CDATA[  实质条件句（“如果&amp;hellip;那么&amp;hellip;”）核心定义与结构定义：用联结词“如果&amp;hellip;那么&amp;hellip;”联结两个原子语句构成的复合语句，逻辑中用符号“⊃”（马蹄符）表示，形式为“前件 ⊃ 后件”（如“如果 A，那么 B”符号化为“A⊃B”）。 结构：“如果”后的语句为前件（如 A），“那么”后的语句为后件（如 B）。 真值规则（实质蕴含的核心）实质条件句“A⊃B”是真值函数联结词，仅当“前件真且后件假”时，整体为假；其余三种情况（前真后真、前假后真、前假后假）均为真。具体可概括为：
若前件真而后件假，则实质条件句为假；否则为真
前件（A） 后件（B） A⊃B（实质条件句） T T T T F F F T T F F T 与日常条件句的差异日常条件句常隐含“前件与后件的关联”（如因果、逻辑推导），而实质条件句仅关注真值组合，不要求前后件有实际关联（如“如果 2+2=5，那么太阳从西边升起”，虽前后无关联，但因前件假，实质条件句仍为真）。 实质条件句是“最弱的条件句”，仅捕捉日常条件句中“并非前真后假”的核心真值属性，其余隐含意义（如关联关系）会被忽略。 实质双条件句（“当且仅当”）核心定义与结构定义：表示“两个语句真值相同”的复合语句，逻辑中用符号“≡”表示，形式为“前件 ≡ 后件”（如“A 当且仅当 B”符号化为“A≡B”），也称为“实质等值句”。 等价形式：实质双条件句等价于“双向的实质条件句”，即“A≡B” = “(A⊃B)·(B⊃A)”（“如果 A 则 B，并且如果 B 则 A”）。 真值规则实质双条件句“A≡B”为真，当且仅当“前件与后件真值完全相同”（同真或同假）；若真值不同（一真一假），则整体为假。可概括为：
若前后件真值相同，则实质双条件句为真；否则为假
前件（A） 后件（B） A≡B（实质双条件句） T T T T F F F T F F F T 与日常等值句的差异日常语言中“等值”常隐含“前后件有内在关联”（如“三角形是等边的，当且仅当它是等角的”），而实质双条件句仅关注真值是否一致，不要求关联（如“2+2=5≡ 太阳从西边升起”，因前后均假，实质双条件句为真）。 五大联结词真值规则总结通过以下 5 句话可完整掌握所有基础联结词的真值条件：
否定（~）：颠倒原语句真值（真变假，假变真）； 合取（·）：仅当 …  ]]></content></entry><entry><title>2.8 - 2.9 析取</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0203-%E6%9E%90%E5%8F%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html">  析取句与“或”的两种含义析取句的定义由联结词“或”联结两个语句构成的复合语句，称为析取句；被联结的两个语句，称为“析取支”（如“小明吃苹果或小红吃香蕉”，“小明吃苹果”“小红吃香蕉”均为析取支）。
“或”的两种核心含义可兼含义（非互斥）：断言“至少一个析取支为真”，允许两个析取支同时为真（如“他学数学或学英语”，可同时为真）。日常中“和/或”是其明确表达（常见于法律文件），逻辑中用符号“∨”（v 字符）表示，是真值函数联结词。 不可兼含义（互斥）：断言“恰好一个析取支为真”，排除两个析取支同时为真的情况（如“比赛赢或输”，不可同时为真）。其含义比可兼或更丰富，除“至少一个真”外，还包含“至少一个假”。 可兼析取（∨）的真值规则“∨”的真值完全由析取支的真值决定，仅当两个析取支均为假时，析取句“p∨q”为假；其余情况（一个真、一个假，或两个均真）均为真。具体真值表如下：
p（析取支 1） q（析取支 2） p∨q（可兼析取句） T T T T F T F T T F F F 不可兼析取的符号化问题不可兼或的完整含义：需同时满足“至少一个真”和“至少一个假”，完整符号化为“(p∨q)·~(p·q)”（可兼或 + 否定合取）。 用“∨”符号化的局限性：若直接用“∨”表示不可兼或，会丢失“至少一个假”的含义（仅保留“至少一个真”），导致符号式与原语句真值可能不一致（如两个析取支均真时，原不可兼或语句为假，但“p∨q”为真）。 论证中的处理原则： 部分论证中，仅需“至少一个真”的核心含义，用“∨”符号化不影响有效性； 若论证依赖“互斥”属性（如“比赛赢或输，赢了，所以没输”），则需完整符号化为“(p∨q)·~(p·q)”。 日常语句的符号化规则：若“或”的含义不明确（无法判断是否互斥），遵循“如有疑义，按可兼含义符号化”（用“∨”），避免过度添加未明确的“互斥”假设。 多算子语句的符号化与辖域核心原则含两个及以上逻辑算子（如~、·、∨）的语句，需通过括号明确算子辖域，避免歧义（辖域即算子管辖的支语句范围）。
常见句式的符号化“并非既&amp;amp;hellip;又&amp;amp;hellip;”：否定“两个语句同时为真”，等价于“至少一个为假”，符号化为“~(Q·G)”或“~Q∨~G”（如“并非既下雨又刮风”，即“不下雨或不刮风”）。 逻辑依据：否定合取等价于析取否定（德摩根定律），两者 …  </content></entry><entry><title>2.4 - 2.7 否定</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0202-%E5%90%A6%E5%AE%9A/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html">  非真值函数联结词与真值函数联结词的区别真值函数联结词（如“并且”）：复合语句的真值由支语句的真值唯一决定（只要支语句真值确定，复合语句真值就固定，如“ A 并且 B ”仅当 A、B 均真时为真）。 非真值函数联结词：复合语句的真值不能仅由支语句真值决定，还需依赖支语句内容、时态、语境等额外信息。 常见示例“在&amp;amp;hellip;之前”（时态联结词）：如“小明吃饭在小红看书之前”，即使“小明吃饭”和“小红看书”均为真，复合语句的真值仍需看两者的时间顺序（若小红先看书，则复合语句为假），无法仅通过支语句真值判断。 “众所周知”：如“众所周知地球是圆的”（真）和“众所周知小明今天吃了饭”（假），两者支语句均为真，但复合语句真值不同，因“众所周知”依赖“语句是否被广泛知晓”的额外信息。 “因为”：如“他感冒了因为他淋了雨”，即使“他感冒了”和“他淋了雨”均为真，复合语句真值还需看两者是否存在因果关系（若感冒是因着凉，而非淋雨，则复合语句为假），不取决于支语句真值。 变项与常项定义与作用语句变项：用小写字母（如 p、q）表示，是“位置所有者”，不指代特定语句，仅用于表示“任意语句的占位符”（如真值表中 p、q 可代表任何原子语句）。 语句常项：用大写字母（如 A、B）表示，是特定语句的缩写（如 A 代表“今天下雨”，B 代表“我带了伞”），有确定的真值（真或假）。 示例：真值表中的变项与常项合取句的真值表用 p、q（变项）表示任意合取支，描述“所有合取句的真值规则”： p q p·q T T T T F F 若用 A（“今天下雨”，真）、B（“我带了伞”，真）（常项）替换变项，得到具体合取句“A·B”（“今天下雨并且我带了伞”），其真值为 T，符合真值表规则。 否定（一元逻辑算子）核心性质一元算子：仅作用于单个语句（无需联结两个语句），就能生成新的复合语句（否定句），是标准语句逻辑中唯一的一元真值函数算子。 符号表示：用波浪符“~”表示（如“并非今天下雨”记为“~A”，A 代表“今天下雨”）。 真值规则否定句的真值与原语句（被否定的语句）真值完全相反：
若原语句为真（T），则否定句为假（F）（如 A 为真，~A 为假）； 若原语句为假（F），则否定句为真（T）（如 A 为假，~A 为真）。 真值表： A ~A T F F T 括号：消除歧义与明确算子辖域核心作 …  </content></entry><entry><title>2.1 - 2.3 合取</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0201%E5%90%88%E5%8F%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html">  核心概念：原子语句与复合语句原子语句（简单语句）：不包含“并且”“或者”等语句联结词的语句，是构成复合语句的基础单位（如“今天下雨”“我吃了饭”）。 复合语句：用“并且”“或者”等联结词联结原子语句构成的语句（如“今天下雨并且我带了伞”“他看书或者他写字”）。 语句逻辑与真值函数语句逻辑：逻辑学中“无需考虑原子语句内部结构”即可分析的部分，属于符号逻辑的分支（另一分支是谓词逻辑）。 真值函数核心： 输入与输出仅含“真（T）”和“假（F）”两个真值； 复合语句的真值由其包含的原子语句的真值唯一决定（复合语句是原子语句的“真值函数”），因此语句逻辑也叫“真值函数逻辑”。 合取句：“并且”联结的复合语句定义：用联结词“并且”（逻辑中常用小圆点“·”作为缩写）联结两个原子语句（称为“合取支”）构成的复合语句（如“A·B”，A、B 为合取支）。 真值表（合取句的真值规则）：
合取句“ A·B ”仅当两个合取支均为真时，整体才为真；只要有一个合取支为假，整体即为假，具体如下： A（合取支 1） B（合取支 2） A·B（合取句） T T T T F F F T F F F F 日常语句与逻辑符号化的注意事项并非所有“并且”都能符号化为“·”：
逻辑中的 “・” 要求联结的是两个独立的原子语句（即 “合取支需能单独判断真假”），但日常语言中部分含 “和” 的语句，“和” 仅用于连接名词（而非独立语句），无法拆分为两个原子语句，因此不能符号化为合取句 “・”。例如 “小明和小红在恋爱”，句中 “和” 连接的是 “小明”“小红” 两个主体，整个语句是一个不可拆分的原子语句（无法拆成 “小明在恋爱”“小红在恋爱” 两个独立真 / 假判断，因为 “恋爱” 是两人之间的关系，单独判断 “小明在恋爱” 不完整），因此不能符号化为 “A・B”。 符号化恰当性的判断标准：
若逻辑符号式的真值与原日常语句的真值一致（符号式真则原句真，符号式假则原句假），则符号化恰当；反之则不恰当。 等效联结词：
日常中“但是”“然而”等词，虽表达转折语气，但从真值函数角度，与“并且”功能一致（均需前后两部分均为真，整体才为真），可符号化为“·”（如“他很努力但是没考好”，符号化为“A·B”）。   </content></entry><entry><title>1.5 - 1.9 论证的本质</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0103-%E8%AE%BA%E8%AF%81%E7%9A%84%E6%80%A7%E8%B4%A8/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  有效论证、可靠论证与坏论证的关系核心概念辨析有效论证：仅保证“若前提全为真，则结论必为真”（逻辑形式有效），不要求前提实际为真。 可靠论证：需同时满足两个条件：
a. 论证有效（逻辑形式无问题）；
b. 所有前提实际为真。 坏论证：有效论证也可能是坏论证——若其存在一个或多个假前提（满足“有效”但不满足“所有前提真”，即不满足“可靠”）。 逻辑学的关注点逻辑学不直接判定论证的“可靠性”，仅关注“有效性”：
除“逻辑上为真/假的前提”（如“2+2=4”“三角形有 4 条边”）外，前提的实际真假需依赖具体领域知识（如数学、物理、事实），无法仅靠逻辑学判定。 陈述集的相容性与不相容性定义相容陈述集：所有陈述同时为真是可能的（不要求实际为真，仅需无逻辑矛盾）； 不相容陈述集：所有陈述同时为真是不可能的（存在逻辑矛盾，如“今天下雨”与“今天不下雨”组成的集合）。 关键特征相容性与陈述的“实际真假”无关： 所有陈述为真时，集合必相容； 所有陈述为假时，集合仍可能相容（如“地球是方的”与“太阳绕地球转”，虽均假，但无逻辑矛盾，可同时为假）； 唯一不可能的情况：集合不相容，但所有陈述均为真（矛盾陈述无法同时为真）。 有效性与相容性的关联核心等价关系一个论证是有效的，当且仅当“前提全为真且结论为假”的断言是不相容的：
有效论证的本质：“前提真而结论假”存在逻辑矛盾（不相容），故不可能发生； 无效论证的本质：“前提真而结论假”无逻辑矛盾（相容），故可能发生。 利用相容性检测有效性的方法通过以下步骤可借助“相容性”判断论证是否有效：
假设原论证的结论为假，得到“结论的否定”； 将“原前提”与“结论的否定”组成一个新的陈述集； 若该新集合相容（可同时为真）→ 原论证无效（“前提真而结论假”可能）； 若该新集合不相容（不可同时为真）→ 原论证有效（“前提真而结论假”不可能）。 发现语境与辩护语境两个核心问题当某人断言“某结论为真”时，存在两个维度的问题：
发现语境：引导其得出该结论的心理因素（如直觉、经验、情绪、灵感）； 辩护语境：支持该结论为真的客观理由（如前提、逻辑推导、证据）。 逻辑学的关注范围逻辑学仅关心“辩护语境”：
不探究结论的“产生过程”（心理因素具有主观性、偶然性），仅评估“结论是否有合理的理由支撑”（即论证的有效性与前提的相关性）。   </content></entry><entry><title>1.2 - 1.4 演绎与归纳</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0102-%E6%BC%94%E7%BB%8E%E4%B8%8E%E5%BD%92%E7%BA%B3/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  演绎上有效的论证核心定义与逻辑性质基本性质：若所有前提为真，则结论必定为真（不可能出现“前提全真而结论假”的情况），前提之真完全保证结论之真。 判定标准：追问是否存在“前提全真、结论假”的可能——不存在则有效，存在则无效（无效论证即“非有效论证”）。 内容与形式的关系：演绎有效性由论证形式决定，而非内容。只要形式有效，无论内容如何，均为有效论证。例如以下两种固定有效形式： 形式 1： AAA，或者 BBB 并非 AAA BBB 形式 2： 如果 AAA，那么 BBB AAA BBB 有效性与“真/假”的关系关键区分：
有效性/无效性是论证的性质，仅判断“结论能否从前提推出”； 真/假是陈述（前提/结论）的性质，仅判断陈述是否符合事实。 （误区：不可说“论证是真的/假的”，也不可说“陈述是有效的/无效的”） 真假组合的可能性： 有效论证可出现 3 种组合（仅排除“前提全真+结论假”）：
前提真 + 结论真； 前提假 + 结论真； 前提假 + 结论假。 无效论证无限制：可出现“前提全真+结论真”“前提全假+结论假”等任意组合（只需构造无逻辑关联的陈述即可）。 核心特征结论信息已暗含在前提中，并非“真正的新信息”（仅可能是心理层面的新信念）； 演绎有效性是“绝对的”：论证要么有效，要么无效，不存在“更有效”或“较无效”的程度差异。 归纳论证核心定义与逻辑性质基本性质：结论内容超出前提包含的信息（并非从前提中暗含推导）；“好的归纳论证”称为“归纳上强的论证”。 与演绎有效性的核心区别： 强归纳论证的前提全真，仅能使结论或然/盖然（仍有可能前提真而结论假）； 有效演绎论证的前提全真，能保证结论真。 归纳强度的特征逻辑基础：基于“经验学习”——从经验中观察模式、规律性，再投射到其他场合。 强度的程度差异： 归纳强度是“相对的”：可描述“一个论证比另一个论证归纳更强”（如更多证据支持的论证强度更高）； 演绎有效性无程度差异（要么有效，要么无效）。 优缺点： 优点：提供“真正的新信念”（结论超出前提，非暗含信息）； 缺点：错误风险更高——即使是最强的归纳，也可能因“经验规律在新场合失效”而得出假结论。 演绎论证与归纳论证的核心对比维度 演绎论证 归纳论证 结论与前提的关系 结论信息暗含在前提中，不超出前提 结论信息超出前提 前提真对结论的作用 保证结论真（无例外）  …  </content></entry><entry><title>1.1 论证的要素</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0101-%E8%AE%BA%E8%AF%81%E7%9A%84%E8%A6%81%E7%B4%A0/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  论证的要素论证的核心定义论证是一套以 “为结论辩护、提供理由” 为目的的陈述系列，核心是通过前提推导结论。
论证的核心要素前提：论证中支持结论的陈述，数量可任意，需为 “可判断真假” 的内容，是结论成立的依据。 结论：论证中被前提辩护的陈述，是论证的核心目标，需从前提中合理推导得出。 论证的关键特征陈述属性：论证中的语句必须表达 “陈述”（即有真假属性），疑问句、祈使句、感叹句等无真假属性的语句无法构成论证。 逻辑关联：即使所有语句均为陈述，若彼此无 “支持与被支持” 的关联（无辩护对象、无接受结论的理由），也不构成论证。 结构灵活性：一个论证可被其他论证包围或嵌入（如子论证的结论作为核心论证的前提）。 区分 “论证” 与 “非论证” 的意义区分二者并非单纯的逻辑理论知识，其核心价值在于为普通人日常生活提供 “理性决策、有效沟通、清醒认知” 的实用工具，具体可总结为 4 点：
规避认知陷阱，不被误导：识别 “无理由支撑的伪观点”，通过追问 “是否有前提为结论辩护”，避免因盲目相信错误信息造成损失。 提升表达说服力，减少沟通矛盾：家庭协商、职场协作等场景中，用 “论证思维”（结论 + 支撑理由）替代单纯的 “我觉得”“我认为”（非论证的情绪 / 观点表达），让观点更清晰、有依据，减少 “各说各话” 的无效沟通，提升他人接受度。 助力理性决策，降低后悔风险：面对 “买哪款产品”“要不要换工作” 等选择时，用 “论证” 梳理 “选择结论 + 自身需求 / 客观理由”，替代 “凭直觉”“随大流”（非论证式决策），让选择贴合实际需求，减少冲动或外界压力导致的决策失误。 促进建设性讨论，避免情绪内耗：遇到争议话题时，聚焦 “对方观点是否有理由支撑”，而非陷入 “情绪攻击”，让讨论围绕 “理由合理性” 展开，减少 “为吵架而吵架” 的内耗，让争议更具建设性。   </content></entry><entry><title>附录 JS库</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E9%99%84%E5%BD%95-js%E5%BA%93/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>CDN</tag><tag>JavaScript</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 库的核心概念与优缺点什么是 JS 库？JS 库是封装好的可重用代码包，旨在简化常见开发任务（如 DOM 操作、动画、AJAX），避免重复编写繁琐代码，同时解决跨浏览器兼容问题。
库的核心优势可靠性高：代码经过大量用户测试和验证，bug 更少，稳定性优于自定义代码。 集成性强：可轻松与现有开发框架（如 Vue、React）或项目集成，无需重构底层逻辑。 效率提升：为 DOM 操作、表单验证、网络请求等日常任务提供简洁 API，一行代码可替代数十行原生 JS（如 jQuery 的 $(&amp;amp;quot;.class&amp;amp;quot;).hide() 隐藏元素）。 跨浏览器兼容：库内部已处理不同浏览器的差异（如早期 IE 与现代浏览器的 DOM 接口差异），开发者无需手动适配。 库的潜在问题黑箱风险：代码由第三方编写，内部逻辑不透明，出现 bug 时难以调试（如库的方法返回异常，需查阅文档或源码定位问题）。 性能负担：库文件需额外加载，会增加页面 HTTP 请求次数和带宽消耗（尤其大型库，可能导致首屏加载变慢）。 冲突与冗余： 多库混用可能引发命名冲突（如两个库都定义 $ 变量）； 库的功能可能超出需求（如仅需 DOM 操作，却引入包含动画、AJAX 的全量库），造成代码冗余。 如何选择合适的 JS 库？需从功能、体积、维护性等维度综合评估，核心考量以下 6 个问题：
考量维度 关键问题与说明 功能匹配度 1. 库是否包含项目所需的全部核心功能（如仅需表单验证，无需选择包含地图、图表的全能库）？
避免 “功能过剩”，减少冗余代码。 模块化设计 库是否支持按需加载（如只引入 DOM 操作模块，而非全量引入）？
模块化设计可降低体积，提升性能。 支持与维护 1. 库的更新频率如何（是否长期维护，修复漏洞、适配新浏览器）？ 2. 是否有活跃的社区（如 GitHub Issues 响应及时、Stack Overflow 有大量解答）？ 文档质量 是否有完整、易懂的官方文档（含 API 说明、示例代码、常见问题）？
优质文档可降低学习和使用成本。 许可协议 库的开源协议（如 MIT、Apache）是否允许商业使用？
避免因协议限制导致法律风险（如部分协议要求开源衍生代码）。 体积与性能 库的压缩后体积多大？是否会显著影响页面加载速度？
优先选择轻量级库（如需求简 …  </content></entry><entry><title>第十章 用JS实现动画效果</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/10--%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>CSS</tag><tag>前端开发</tag></tags><content type="html">  动画基础知识：核心原理JS 动画的本质是按预定时间间隔重复调用函数，动态修改元素样式（尤其是位置相关样式），从而实现 “随时间变化” 的视觉效果。核心依赖两个维度：元素位置控制和时间调度。
元素位置控制：position 属性通过 CSS position 属性定义元素的定位方式，是实现动画的基础。position 有 4 个合法值，核心差异在于元素是否脱离文档流及定位基准：
属性值 定位规则 static 默认值，元素按文档流顺序排列，无法通过 top/left 等属性调整位置。 relative 元素仍在文档流中，但可通过 top/left 等属性 “相对自身原位置” 偏移，不影响其他元素。 absolute 元素脱离文档流，定位基准为最近的已定位祖先元素（position 为 relative/fixed/absolute），若无则以文档为基准。位置由 top/left/right/bottom 决定。 fixed 元素脱离文档流，定位基准为浏览器窗口，滚动页面时位置固定不变。 位置属性使用注意：避免冲突：设置位置时建议只使用 top 或 bottom（垂直方向）、left 或 right（水平方向），同时设置可能导致定位混乱。
容器定位：若需让 absolute 元素在指定容器内定位，需将容器的 position 设为 relative（此时容器成为定位基准）
时间调度：setTimeout 与 clearTimeout通过 JS 时间函数控制动画的 “节奏”，实现 “延迟执行” 或 “定时重复”。
setTimeout：延迟执行函数语法：
const timerId = setTimeout(func, delay)func：延迟后执行的函数（可直接写函数体或函数名，推荐用函数体避免字符串解析问题）； delay：延迟时间（毫秒，1 秒 = 1000 毫秒）； 返回值：timerId（定时器唯一标识，用于取消定时器）。 clearTimeout：取消延迟执行语法：
clearTimeout(timerId)作用：取消已通过 setTimeout 排队的函数，避免其执行 数值处理：parseInt 与 parseFloat动画中常需从样式字符串（如 100px）中提取数值，需用到这两个函数：
函数 功能 parseInt 提取字符串中的整 …  </content></entry><entry><title>归档</title><url>/archives/custom_archieves/</url><categories/><tags/><content type="html">  {{ define "main" }}{{ T "archive" }}{{ range .Site.RegularPages.ByDate.Reverse.GroupByDate "2006-01" }}{{ .Key | time.Format "2006年1月" }}({{ len .Pages }}){{ range .Pages }}{{ .Date.Format "02日" }}{{ .Title }}{{ end }}{{ end }}{{ end }}  </content></entry><entry><title>第八章 充实的文档的内容</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/08--%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>HTML</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  &lt;abbr&gt; 与 &lt;acronym&gt; 标签&lt;abbr&gt;：表示缩略语（对单词或短语的缩写，如 &ldquo;Mr.&rdquo; 是 &ldquo;Mister&rdquo; 的缩写），通常建议通过 title
属性提供完整含义，例如：
&lt;abbr title=&#34;HyperText Markup Language&#34;&gt;HTML&lt;/abbr&gt;&lt;acronym&gt;：专门表示首字母缩写词（由多个单词首字母组成，且发音为一个单词，如 &ldquo;NASA&rdquo; 读作 &ldquo;nasa&rdquo;）。
注意：HTML5 中已废弃 &lt;acronym&gt;，推荐统一使用 &lt;abbr&gt; 替代，因其语义更通用。 DOCTYPE 与浏览器渲染模式DOCTYPE 的作用：告知浏览器文档使用的 HTML 版本，决定浏览器以标准模式还是兼容模式渲染页面。
标准模式：浏览器严格遵循 W3C 规范渲染页面，保证跨浏览器一致性。 兼容模式（怪异模式）：模仿早期浏览器（如 IE6）的非标准行为，允许不规范的代码正常运行（如忽略闭合标签、错误的盒模型计算）。 HTML5 的 DOCTYPE：
&lt;!DOCTYPE html&gt;此声明简洁且默认触发标准模式，无需指定具体版本，是现代网页的推荐写法。
换行符与 DOM 文本节点部分浏览器（如早期 IE、部分基于 WebKit 的浏览器）会将 HTML 中的换行符解析为文本节点（nodeType = 3），导致 childNodes 等集合中包含空文本节点。 影响：遍历子节点时需注意过滤空文本节点（可通过 nodeValue.trim() === &quot;&quot; 判断），避免逻辑错误。 accesskey 属性作用：为元素绑定键盘快捷键，提升可访问性（尤其适合键盘用户）。
用法：
&lt;a href=&#34;index.html&#34; accesskey=&#34;h&#34;&gt;首页&lt;/a&gt;触发方式：
Windows 系统：Alt + 快捷键（如 Alt + h）； macOS 系统：Ctrl + 快捷键（如 Ctrl + h）。 注意：避免与浏览器默认快捷键冲突（如 Alt + F 通常打开文件菜单），且需在页面中明确提示快捷键（如通过文字说明）。
JS 与文档内容的关系原则：JS 应作为内容的增强工具，而非创建核心内容的依赖。 核心内容（如标题、正文、导航链接）应直接通过 HTML 编写，确保在 JS 禁用时仍可访问。 JS 可动态添加交互元素（如弹窗、表单验证）、加载非核心内容（如评论、推荐），但需遵循 “平稳退化” 原则。   ]]></content></entry><entry><title>第九章 CSS DOM</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/09--css-dom/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>CSS</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  网页的三层结构网页的呈现和交互由结构层、表示层、行为层共同构成，三者各司其职又协同工作：
结构层： 由 HTML/XHTML 标记语言实现，通过标签（如 &amp;lt;p&amp;gt;、&amp;lt;div&amp;gt;）描述内容的语义和结构（如标题、段落、列表），不包含样式或行为信息。 示例：&amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt; 仅定义 “这是一个一级标题”，不规定其颜色、大小。 表示层： 由 CSS 负责，定义内容的视觉呈现（如颜色、字体、布局）。 即使未显式编写 CSS，浏览器也会应用默认样式（如 &amp;lt;h1&amp;gt; 默认加粗、字号较大）。 行为层： 由 JavaScript 和 DOM 控制，定义内容对事件的响应方式（如点击、鼠标悬停）。 浏览器默认也有基础行为（如链接点击跳转、表单提交），JS 可扩展或修改这些行为。 通过 DOM 操作样式：style 属性style 属性的特性每个元素节点的 style 属性是一个对象，包含该元素的内嵌样式（即通过 style 属性直接定义的样式，如 &amp;lt;div style=&amp;quot;color: red&amp;quot;&amp;gt;）。
命名规则：CSS 属性名中的减号（如 font-size）在 style 对象中需转换为驼峰命名法（如 style.fontSize），避免与 JS 语法冲突。
局限性：
仅能获取 / 修改内嵌样式，无法访问外部 CSS 文件或 &amp;lt;style&amp;gt; 标签中定义的样式。
示例：
&amp;lt;div id=&amp;#34;box&amp;#34; style=&amp;#34;width: 100px; color: blue;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const box = document.getElementById(&amp;#34;box&amp;#34;); console.log(box.style.width); // 输出 &amp;#34;100px&amp;#34;（获取内嵌样式） console.log(box.style.fontSize); // 输出 &amp;#34;&amp;#34;（非内嵌样式无法获取） &amp;lt;/script&amp;gt;通过 style 属性设置样式style 对象的属性是可读写的，可通过赋值修改样式，值需为字符串（需加引号）。
示例：
const box = …  ]]></content></entry><entry><title>第七章 动态创建标记</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/07--%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>AJAX</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  传统文档操作方法document.write()功能：将字符串直接插入到文档中，语法简单（如 document.write(&amp;quot;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;quot;)）。 缺点： 违背 “行为与表现分离” 原则，需在 HTML 中嵌入 &amp;lt;script&amp;gt; 调用，导致代码耦合。 可能引发文档验证错误，且与 application/xhtml+xml 类型文档不兼容（浏览器会忽略该方法）。 innerHTML功能：读写元素内的 HTML 内容（如 div.innerHTML = &amp;quot;&amp;lt;span&amp;gt;Hi&amp;lt;/span&amp;gt;&amp;quot; 可设置内容，const html = div.innerHTML 可读取内容）。 特点： 简洁高效，适合批量操作 HTML 片段，但无法精确控制单个节点（会整体替换元素内容）。 局限性：HTML 专有属性，不支持 XHTML 文档；安全性风险（可能引入 XSS 攻击，需谨慎处理用户输入）。 替代方案：标准 DOM 方法（如 createElement、appendChild）虽代码量增加，但可精确控制节点，兼容性更强。 标准 DOM 操作方法核心思想DOM 是文档的双向映射：既能读取文档结构（通过节点属性和方法），也能修改节点树（实时反映到浏览器渲染结果）。 浏览器显示的是 DOM 节点树，而非原始 HTML 代码，因此修改 DOM 会直接改变页面表现。 创建与插入节点创建元素节点：document.createElement(tagName)
示例：const newDiv = document.createElement(&amp;quot;div&amp;quot;);（创建 &amp;lt;div&amp;gt; 元素，初始为 “文档碎片”，未插入文档）。 创建文本节点：document.createTextNode(text)
示例：const textNode = document.createTextNode(&amp;quot;Hello DOM&amp;quot;);（创建包含文本的节点）。 插入节点到文档：
parent.appendChild(child)：将子节点添加到父节点的子节点列表末尾。
示例：
const parent = …  ]]></content></entry><entry><title>第六章 案例研究：图片库改进版</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/06--%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  JS 与网页结构的解耦原则核心思想：为网页添加行为时，JS 代码应尽量避免依赖特定的 HTML 结构（如固定的标签嵌套、类名顺序等）。 好处：当 HTML 结构调整时，JS 代码无需频繁修改，提高可维护性。 命名规范与注意事项命名原则可读性：使用有意义的单词命名变量、函数（如 calculateTotal 而非 fn1），通过命名体现用途。 风格统一：变量和函数名推荐使用驼峰命名法（如 userName、handleClick），常量常用全大写（如 MAX_SIZE）。 命名禁忌避免保留字：不能使用 JS 语言的保留字（如 if、function、class 等）作为变量名。 避免覆盖内置 API：不使用现有 JS 函数 / 方法名（如 alert、push）作为变量名，防止覆盖内置功能。 节点链表（NodeList）定义：由 DOM 方法（如 getElementsByTagName、querySelectorAll）返回的节点集合，类似数组但并非真正的数组（是类数组对象）。 特性： 每个节点都有自身的属性（如 nodeType、nodeName）和方法（如 appendChild）。 动态性：部分 NodeList（如 getElementsByTagName 返回的集合）会随 DOM 变化自动更新。 共享 onload 事件：addLoadEvent 函数问题：window.onload 只能绑定一个函数，多次赋值会覆盖之前的函数。 解决方案：addLoadEvent 函数用于将多个函数追加到 window.onload 事件中，确保所有函数在页面加载完成后执行。 实现逻辑：function addLoadEvent(func) { const oldOnload = window.onload; // 保存现有 onload 函数 if (typeof window.onload !== &#34;function&#34;) { // 若 onload 未绑定函数，直接赋值 window.onload = func; } else { // 若已绑定函数，追加新函数 window.onload = function () { oldOnload(); // 执行原有函数 func(); // 执行新函数 }; } }nodeName 属性特性：返回元素节点的标签名，始终为大写字母（即使 HTML 中标签是小写，如 &lt;div&gt; 的 nodeName 为 &quot;DIV&quot;）。 用途：判断元素类型（如 if (element.nodeName === &quot;LI&quot;) 检测是否为列表项）。 键盘事件与交互一致性onkeypress 事件触发时机：按下键盘上的任意按键（包括字母、数字、符号等）时触发。 用途：监听键盘输入（如表单验证、快捷键操作）。 键盘与鼠标事件的一致性用 Tab 键聚焦到链接后按 Enter 键，会触发该链接的 onclick 事件，与鼠标点击效果一致。 意义：确保键盘用户与鼠标用户获得相同的交互体验，提升可访问性。   ]]></content></entry><entry><title>第四章 案例研究：JS图片库</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/04-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  元素属性操作的两种方式直接属性赋值（传统方式）语法：element.属性名 = 值（如 input.value = &amp;quot;hello&amp;quot;）。 适用场景：大部分 HTML 元素的标准属性（如 value、src、href 等）。 特点：简单直接，但仅支持预定义的标准属性，不支持自定义属性。 setAttribute() 方法（DOM Level 1）语法：element.setAttribute(属性名, 属性值)（如 div.setAttribute(&amp;quot;data-id&amp;quot;, &amp;quot;123&amp;quot;)）。 优势： 可设置任意元素的任意属性（包括自定义属性），兼容性更强。 遵循 DOM 标准，可移植性好（适用于多种环境和编程语言）。 注意：修改后会实时反映在 DOM 中，但不会改变原始 HTML 源代码。 JS 文件优化：合并文件目的：减少 HTTP 请求次数，提高页面加载性能。 做法：将多个 .js 文件合并为一个文件，通过单次请求加载。 事件处理函数基本概念作用：在特定事件发生时执行指定 JS 代码（如点击、鼠标悬停等）。 语法：元素.事件处理函数 = &amp;quot;JS 语句&amp;quot; 或通过 DOM 方法绑定（如 element.onclick = function() {}）。 常用事件： onclick：用户点击元素时触发； onmouseover：鼠标指针悬停在元素上时触发； onmouseout：鼠标指针离开元素时触发； onload：页面或资源（如图片）加载完成时触发（常用于页面初始化）。 事件处理函数的返回值事件触发的 JS 代码可返回一个值，该值会传递给事件处理函数。 典型应用：阻止默认行为 例如，在&amp;lt;a&amp;gt;标签的 onclick 中返回 false，可阻止链接跳转： 子节点获取：childNodes作用：返回当前元素的所有子节点（包含元素节点、文本节点、空格 / 换行节点等），结果为类数组对象。
示例：
const parent = document.getElementById(&amp;#34;parent&amp;#34;); const children = parent.childNodes; // 所有子节点（含文本、空格等） 节点类型判断：nodeType作用：通过数值区分节点类 …  ]]></content></entry><entry><title>第五章 最佳实践</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/05--%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>前端开发</tag><tag>性能优化</tag><tag>平稳退化</tag></tags><content type="html"><![CDATA[  平稳退化定义：确保网站在浏览器不支持 JavaScript 或 JS 被禁用时，核心功能仍可正常使用（如链接可点击、内容可访问）。 关键原则： 为 JS 功能提供 “退路”，例如将链接的 href 属性设置为真实 URL，而非仅依赖 onclick 事件。 避免过度依赖 JS 实现基础功能（如导航、跳转）。 弹出窗口与平稳退化window.open() 方法：用于创建新窗口，语法为window.open(url, name, features)，参数分别为目标 URL、窗口名称、窗口属性（如尺寸、功能）。
示例函数：
function popUp(winUrl) { window.open(winUrl, &amp;#34;popup&amp;#34;, &amp;#34;width=320,height=480&amp;#34;); }调用方式的问题：
伪协议（javascript:）：如 &amp;lt;a href=&amp;quot;javascript:popUp(&#39;url&#39;)&amp;quot;&amp;gt;，在禁用 JS 时失效，不推荐。 空链接（#）：如 &amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;popUp(&#39;url&#39;);return false&amp;quot;&amp;gt;，禁用 JS 时点击会跳转至页面顶部，体验差。 正确做法：
让 href 指向真实 URL，onclick 中通过 return false 阻止默认跳转，确保 JS 禁用时仍能正常访问：
&amp;lt;a href=&amp;#34;http://www.baidu.com&amp;#34; onclick=&amp;#34;popUp(&amp;#39;http://www.baidu.com&amp;#39;);return false;&amp;#34; &amp;gt;baidu&amp;lt;/a &amp;gt;分离 JavaScript核心思想：将 JS 代码从 HTML 中剥离，通过外部脚本文件管理，避免 HTML 与 JS 耦合。
实现步骤：
HTML 保留基础功能：链接使用真实 href，通过 class 或 id 标识需要特殊处理的元素：
&amp;lt;a href=&amp;#34;http://www.baidu.com&amp;#34; class=&amp;#34;popup&amp;#34;&amp;gt;baidu&amp;lt;/a&amp;gt;外部 JS 绑定事件：在外部脚本中通过 DOM 方法找到 …  ]]></content></entry><entry><title>第二章 JS语法</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/02-js%E8%AF%AD%E6%B3%95/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  语法变量定义：变量是存储可变值的容器，将值存入变量的操作称为赋值。 声明与赋值： JS 中，未声明的变量赋值时会自动声明（不推荐，易导致全局污染）。 可一次性声明多个变量：var a, b, c;。 可在声明时赋值：var x = 10, y = &amp;quot;hello&amp;quot;;。 命名规则： 区分大小写（name 与 Name 是不同变量）。 允许包含字母、数字、$、_，但不能以数字开头，不能包含空格或标点符号（$ 除外）。 长变量名可读性优化： 下划线命名法：user_name； 驼峰命名法：userName（第二个单词起首字母大写）。 字面量：直接在代码中写出的数据（如 123、&amp;quot;abc&amp;quot;、true）。 数据类型弱类型特性：JS 是弱类型语言，无需声明变量类型，可随时修改变量的类型（与强类型语言需显式声明类型不同）。 字符串： 由零个或多个字符组成，需用单引号（&#39;）或双引号（&amp;quot;）包裹。 引号选择规则：字符串包含双引号时用单引号包裹（如 &#39;He said &amp;quot;Hi&amp;quot;&#39;），反之亦然。 转义字符：用反斜线（\）转义特殊字符，如 \&amp;quot; 表示双引号（&amp;quot;She said \&amp;quot;Hello\&amp;quot;&amp;quot;）。 数值： 支持整数（如 42）和浮点数（如 3.14），可带正负号（如 -5、-2.7）。 布尔值： 仅两个值：true（真）和 false（假），不可用引号包裹（否则为字符串）。 数组定义：用一个变量存储一组值（元素），元素可通过下标访问（下标从 0 开始）。 声明与初始化： 用 Array 关键字：var arr = new Array(); 或 var arr = new Array(3);（指定初始长度，可选）。 简洁语法（推荐）：var arr = [1, &amp;quot;a&amp;quot;, true];（直接用方括号包裹元素，元素类型可混合）。 元素操作： 赋值：arr[0] = 10;（通过下标赋值）。 嵌套数组：数组元素可是另一个数组（如 var nested = [1, [2, 3]];）。 关联数组： 用字符串作为下标（如 arr[&amp;quot;name&amp;quot;] = &amp;quot;Alice&amp;quot;），本质是为数组对象添加属性。 注意： …  ]]></content></entry><entry><title>第三章 DOM</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/03--dom/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  DOM 的核心概念DOM（Document Object Model，文档对象模型）是一套用于抽象和概念化文档内容的接口，它将网页文档转换为可通过 JavaScript 操作的对象树结构。
D：文档（Document）当网页加载到浏览器时，浏览器会自动将 HTML/XML 文档解析为一个 文档对象，即 DOM 的基础。 O：对象（Object）对象是包含数据和方法的集合： 属性：对象关联的变量（如 element.id）； 方法：对象可调用的函数（如 element.appendChild()）。 JS 中的对象类型： 用户定义对象：开发者创建的自定义对象； 内建对象：JS 自带的对象（如 Array、Date）； 宿主对象：浏览器环境提供的对象（如 window、document）。 关键宿主对象： window：对应浏览器窗口，属于 BOM（浏览器对象模型）； document：对应网页内容，是操作 DOM 的核心对象。 M：模型（Model）DOM 将文档表示为一棵节点树（类似家谱树），用 “父子”“兄弟” 等关系描述元素间的层次结构： 根元素是 &amp;lt;html&amp;gt;，所有其他元素都是其后代； 节点树清晰展示了元素的嵌套关系，便于通过 JS 遍历和操作。 节点（Node）DOM 文档由多种节点组成，核心类型包括：
元素节点（Element Node）文档的基本构成单位，对应 HTML 标签（如 &amp;lt;div&amp;gt;、&amp;lt;p&amp;gt;）。 特点：可包含其他元素节点或文本节点，是节点树的 “骨架”。 根元素：&amp;lt;html&amp;gt; 是唯一不被其他元素包含的元素节点。 文本节点（Text Node）包含文本内容（如文字、空格），总是被元素节点包含（如 &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; 中，“Hello” 是文本节点）。 注意：并非所有元素节点都包含文本节点（如空标签 &amp;lt;img&amp;gt;）。 属性节点（Attribute Node）描述元素的附加信息（如 class、id、src），仅存在于元素的起始标签中。 特点：依赖元素节点存在，无法独立于元素存在（如 &amp;lt;a href=&amp;quot;url&amp;quot;&amp;gt; 中，href 是属性节点）。 CSS 与 DOM 的关联CSS 通过节点树结构应用样式，子元素会继承父元 …  ]]></content></entry><entry><title>第一章 JS简史</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/01--js%E7%AE%80%E5%8F%B2/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  DOM（文档对象模型）核心定义：DOM 是一套对文档内容进行抽象和概念化的方法，它将 HTML/XML 文档的结构转化为一个树形的对象模型，使得程序（如 JS）可以访问和操作文档的内容、结构和样式。 作用：作为 JS 与网页内容之间的桥梁，允许开发者通过代码动态修改文档的元素、属性、文本等（例如添加节点、修改样式、绑定事件等）。 DHTML（动态 HTML）本质：DHTML 并非一项独立技术，而是 HTML、CSS 和 JavaScript 三种技术的组合术语，用于描述 “动态操控网页内容和样式” 的技术方案。 核心组成与目标： HTML：负责标记网页的结构和内容（如 &lt;div&gt;、&lt;p&gt; 等元素）； CSS：负责定义元素的样式（颜色、布局、位置等）； JavaScript：负责实时操控页面元素和样式（如动态修改 CSS 属性、显示 / 隐藏元素、响应用户交互等）。 核心价值：通过三者协同，实现网页内容的动态更新，无需重新加载页面即可改变外观和行为（如表单验证、菜单切换、实时数据展示等）。 API（应用程序编程接口）定义：API 是一组得到各方共同认可的基本约定，规定了不同组件（如软件、库、服务）之间如何交互的规则（包括可调用的函数、参数格式、返回值类型等）。 举例： DOM API：如 document.getElementById()、element.appendChild() 等，规定了 JS 操作文档的方法； 浏览器 API：如 fetch()（网络请求）、localStorage（本地存储）等，提供了 JS 与浏览器功能交互的接口。 作用：简化开发，使不同模块或系统能够按照统一规则协作，无需关注内部实现细节。   ]]></content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0405--%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>Web Worker</tag><tag>性能优化</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Web Worker 基础定义与作用：
Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。 创建与类型：
专用 Worker（Dedicated Worker）：通过 new Worker(&#39;script.js&#39;) 创建，与主程序是一对一关系，仅能与创建它的程序通信。
示例：
// 主程序中创建专用 Worker const w1 = new Worker(&amp;#34;worker.js&amp;#34;);Worker 通信机制消息传递：
不共享作用域 / 资源，通过 message 事件双向通信，数据传递基于结构化克隆或所有权转移。
主程序与 Worker 内部均通过 postMessage(data)发送消息，通过 onmessage 监听消息：
// 主程序 w1.postMessage(&amp;#34;hello&amp;#34;); // 发送消息到 Worker w1.onmessage = (e) =&amp;gt; console.log(&amp;#34;收到 Worker 消息：&amp;#34;, e.data); // worker.js 内部 self.onmessage = (e) =&amp;gt; { console.log(&amp;#34;收到主程序消息：&amp;#34;, e.data); self.postMessage(&amp;#34;hi&amp;#34;); // 发送消息到主程序 };终止 Worker：
主程序中调用 w1.terminate() 可立即终止 Worker（无清理机会）； Worker 内部可调用 self.close() 主动终止自身。 Worker 运行环境限制与可用资源： 不可访问 DOM、主程序全局变量，但可使用 navigator、location、JSON、setTimeout 等，支持网络请求（如 fetch）。 可通过 importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;) 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。 典型应用场景： 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。 数据传递方式结构化克 …  ]]></content></entry><entry><title>4.4节 生成器</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0404--%E7%94%9F%E6%88%90%E5%99%A8/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  生成器的基本概念与特性定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 生成器产生值：生产者与迭代器迭代器接口作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 for..of循环自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 Iterable（可迭代对象）定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 生成器迭代器的特性生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 异步迭代生成器生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&amp;amp;#34;http://...&amp;amp;#34;, (err, data) =&amp;amp;gt; { if (err) it.throw(err); // 向生成器抛 …  </content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0403--promise/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  什么是 Promise未来值核心特性：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。 状态与不可变性： 封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。 一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。 then 方法的双回调：调用then(onFulfilled, onRejected)时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。 完成事件（流程控制）本质：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。 反控制反转： 传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过then注册回调，等待 Promise 决议后触发，将控制返还给调用代码。 信号特性：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。 具有 then 方法的鸭子类型thenable 定义：任何具有then方法的对象或函数，被视为与 Promise 一致的 “thenable”。 鸭子类型：通过值的形态（是否有then方法）假定其类型，这是识别 Promise 的核心逻辑。 Promise 信任问题（可靠性保障）异步回调：对 Promise 调用then时，即使 Promise 已决议，回调也始终异步执行（下一个事件循环 tick），确保行为一致。 决议的唯一性： Promise 只能被决议一次（首次调用resolve或reject生效，后续调用被忽略），因此then注册的回调仅执行一次。 若同一回调多次注册，会按注册次数执行。 决议值的单一性： 至多有一个决议值（未显式决议时为undefined），传给所有注册的回调。 调用resolve/reject时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。 异常处理：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。 Promise.resolve 的作用： 传入非 Promise / 非 thenable 值：返 …  </content></entry><entry><title>4.1节 异步：现在与将来</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0401--%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  分块的程序与异步机制分块程序的本质： 将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。 console.log 的异步特性： 部分浏览器的console.log并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。 事件循环核心机制： 事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个tick：
若队列中有等待事件（即回调函数），则从队列中取出一个执行； 无事件时，循环等待新事件加入。 核心流程，循环周期（tick）：检查 “宏任务队列”（如setTimeout、DOM事件），若有等待任务，取出第一个执行； 执行完当前任务后，检查 “微任务队列”（如Promise.then），清空所有微任务； 更新 UI（浏览器环境）； 重复步骤 1-3。 setTimeout 的作用： 并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。
并行执行异步与并行的区别： 异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）； 并行：关注 “同时发生”（多个操作在物理上同时进行）。 进程与线程： 进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存； JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。 JS 的单线程特性： 函数代码具有原子性（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）； 若函数执行顺序不确定，可能导致竞态条件（因共享状态的修改顺序不可控引发的逻辑错误）。 并发定义： 两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。
JS 的并发形式： 单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。
并发交互的协调方式：
门（Gate）：等待多个条件都满足后再执行下一步。例如： …  </content></entry><entry><title>4.2节 回调</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0402--%E5%9B%9E%E8%B0%83/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  回调函数的本质回调函数的核心作用是包裹或封装程序的延续逻辑—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。
回调地狱（Callback Hell）的成因回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：
思维与代码的不匹配：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。
控制反转导致的信任问题： 回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：
无法确保回调被调用的次数（可能被多次调用或不调用）； 无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）； 无法确保回调的参数符合预期。 回调模式的优化设计为缓解回调地狱和信任问题，常见的回调模式设计：
分离回调（Split Callbacks）： 为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。
错误优先回调（Error-First Callbacks，Node 风格）： 回调函数的第一个参数固定为错误对象，后续参数为成功结果：
若操作成功，错误参数为null或undefined； 若操作失败，错误参数为非空值（通常是Error对象）。 回调调用的最佳实践：永远异步执行即使回调逻辑可以同步完成，也应强制异步调用（如通过setTimeout或队列机制），确保回调行为的一致性：
避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）； 保证所有回调都遵循相同的异步逻辑，减少不可预测性。   </content></entry><entry><title>3.5节 语法</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0305--%E8%AF%AD%E6%B3%95/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>ASI</tag><tag>前端开发</tag></tags><content type="html">  语句与表达式的基本概念表达式：能返回一个结果值的代码片段（如1 + 2返回3，obj.prop返回属性值）。 语句：执行某种操作的代码（如if、for、return），所有语句都有结果值，但语法默认不允许直接获取。 语句的结果值常见语句的结果值： 赋值语句a = b：结果值为被赋予的值（即b的值）。 变量声明var a：结果值为undefined（let/const同理）。 代码块{...}：结果值为块内最后一个语句 / 表达式的结果（如{1; 2; 3}结果为3）。 获取语句结果值的方式：语法不直接支持，但可通过eval()获取（如eval(&amp;#39;{a=1; b=2}&amp;#39;)返回2）。 表达式的副作用副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。
常见有副作用的表达式函数调用：最常见（如console.log(1)会输出内容，改变控制台状态）。 自增 / 自减运算符： a++：先返回a的当前值，再将a加 1（副作用在后）。 ++a：先将a加 1，再返回新值（副作用在前）。 注意：++a++会报错（ReferenceError），因运算符需要可赋值的变量作为操作数。 逗号运算符：将多个表达式串联为一个语句，返回最后一个表达式的结果（如a=1, b=2, a+b结果为3），副作用是执行所有表达式。 delete 操作符： 作用：删除对象属性或数组单元。 结果值：成功删除（属性不存在或可配置）返回true；失败（不可配置属性）返回false或报错。 副作用：实际移除属性 / 单元（如delete obj.prop后obj.prop为undefined）。 赋值语句：a = 42结果为42，副作用是a被赋值为42；链式赋值（如a = b = 42）利用赋值表达式的结果值实现。 上下文规则大括号{}的用法对象常量：定义对象字面量（如{a: 1, b: 2}）。
标签（label）：用于标记代码块，配合break/ continue跳转：
break 标签：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。 continue 标签：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。 注意：标签不能用双引号；非循环代码块可使用break 标签，但不能用continue 标签。 JSON 与 JSON-P：
JSON …  </content></entry><entry><title>附录 混合环境JS</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>宿主环境</tag><tag>Annex B 规范</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Annex B（ES 规范的兼容性补充）背景： ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。
主要兼容性差异：
非严格模式允许八进制数值常量（如012，严格模式下为语法错误）；
浏览器提供window.escape()和window.unescape()，用于转义 / 还原带%分隔符的十六进制字符串（非标准方法，建议避免使用）；
String.prototype.substr与String.prototype.substring
的区别：
substring(start, end)：第二个参数为结束位置索引（不包含该位置）； substr(start, length)：第二个参数为截取长度。 Web ES 规范的额外差异：
&amp;lt;!--和--&amp;gt;被视为合法单行注释分隔符； String.prototype包含返回 HTML 格式字符串的附加方法（如anchor()、bold()）； 正则表达式（RegExp）扩展及Function.prototype附加方法（非标准，依赖浏览器实现）。 宿主对象定义：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如window、document、console），包括内建对象和工具函数。 特殊行为差异： 部分宿主对象强制转换为布尔值时可能为假值（如document.all，不符合 JS 标准假值规则）； 其他特性： 可能无法访问普通Object的内建方法（如toString()）； 部分属性为只读，无法覆盖； 方法的this无法重绑定到其他对象。 console 对象： 宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。 全局 DOM 对象全局变量与 global 对象：声明全局变量会同时在全局对象（如浏览器的window）中创建同名属性。 DOM 元素 ID 的副作用：因浏览器历史遗留问题，带id属性的 DOM 元素会自动创建同名全局变量（如&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;会生成window.app）。 原生原型扩展的注意事项不建议扩展原生原型：除非确保无代码冲突（如第三方库 …  ]]></content></entry><entry><title>3.4节 强制类型转换</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0304--%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  值类型转换的基本概念定义与区分： 显式类型转换：主动将值从一种类型转换为另一种（如String(123)）。 隐式强制类型转换：操作中自动发生的类型转换（如1 + &amp;quot;2&amp;quot;）。 特性：JS 强制类型转换始终返回标量基本类型值，对象封装（如new Number(1)）不算严格意义上的强制转换。 与其他语言的差异： 静态类型语言的 “类型转换” 发生在编译阶段； 动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。 抽象值操作（内部使用的转换规则）抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括ToString、ToNumber、ToBoolean。
ToString（非字符串 → 字符串）基本类型转换规则：
null → &amp;quot;null&amp;quot;；undefined → &amp;quot;undefined&amp;quot;；true → &amp;quot;true&amp;quot;；false → &amp;quot;false&amp;quot;。 数字：常规数字直接转换（如123→&amp;quot;123&amp;quot;），极小 / 极大数字用指数形式（如1e-20、1e+20）。 对象 / 数组转换：
普通对象：默认返回内部属性[[Class]]值（如&amp;quot;[object Object]&amp;quot;）；若自定义toString()方法，则调用该方法并使用其返回值。 数组：toString()将所有元素字符串化后用,连接（如[1, 2, 3].toString() → &amp;quot;1,2,3&amp;quot;）。 JSON.stringify () 的特殊处理：
作用：将 JSON 对象序列化为字符串，遵循ToString规则但结果必为字符串。
安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ undefined、function 、symbol、循环引用对象）的处理：
对象中遇到非安全值：自动忽略。 数组中遇到非安全值：返回null（保持数组长度）。 循环引用对象：直接报错。 toJSON()方法：若对象定义了toJSON()，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：toJSON()应返回安全值，而非字符串）。
可选参数：
replacer（数组 / 函 …  ]]></content></entry><entry><title>3.3节 原生函数</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0303--%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内部属性 [[Class]]基本概念： 内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。 属性特征： 所有typeof返回值为object的对象都包含内部属性[[Class]]，该属性无法直接访问。 通常通过Object.prototype.toString()方法查看[[Class]]的值。 对应关系： 多数情况下，对象的[[Class]]属性值与创建该对象的内建原生构造函数相对应。 特殊情况：虽然不存在Null()和undefined()原生构造函数，但null和undefined的[[Class]]属性值分别为&#39;Null&#39;和&#39;Undefined&#39;。 封装对象包装自动包装机制： 基本类型值（如string、number等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。 手动封装与拆封： 手动封装：使用Object()函数（不带new关键字）可将基本类型值封装为对象。 拆封：通过valueOf()方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。 使用建议：除非必要，应避免使用构造函数创建封装对象。 原生函数作为构造函数Array()：
不带new关键字时会被自动补全（等效于new Array()）。 仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。 替代方案：ES6 的Array.of()（无歧义，始终将参数作为元素） 稀疏数组：包含至少一个空单元的数组，可通过以下方式创建： 设置length属性值超过实际单元数； 使用delete删除数组单元。 可通过Array.apply(null, {length: 3})创建包含undefined单元（非空单元）的数组。 不建议使用的构造函数： 除非特殊需求，尽量避免使用Object()、Function()、RegExp()作为构造函数。
Date()：
必须使用new Date()创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。 时间戳获取：getTime()方法或Date.now()（ES5+）可获取 Unix 时间戳。 特殊情况：不带new关键字调用Date()时，返回当前日期的字符串值（格式无统一规范）。 Error()： 带或不带new关键字均可使用。  …  ]]></content></entry><entry><title>3.2节 值</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0302--%E5%80%BC/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  数组特性： 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。 使用delete运算符删除单元后，位置变为空白单元，数组length属性不变。 稀疏数组： 指含有空白 / 空缺单元的数组，空白单元值为undefined，但与显式赋值为undefined的单元有区别（如[,,]与[undefined, undefined]行为不同）。 索引与属性： 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在length内，length只计算数字索引的最大整数 + 1）。 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。 类数组转换： 类数组特征：有length和数字索引，但无数组方法（如arguments、DOM 集合NodeList） 可转换为真正的数组，常用方法： Array.prototype.slice.call(类数组) ES6 的Array.from(类数组) 扩展运算符（需类数组为可迭代对象） 字符串与数组的区别： 是类数组（有length、indexOf()、concat()等），但并非字符数组。 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。 数组方法的借用： 可借用数组的非变更方法（如Array.prototype.indexOf.call(str, &#39;a&#39;)）处理字符串。 不可借用数组的变更方法（因字符串不可变），需先通过split(&#39;&#39;)转为数组，处理后再用join(&#39;&#39;)转回字符串。 数字类型与格式：
JS 只有一种数值类型number（双精度浮点数），包含整数（如42.0）和带小数的十进制数。 字面量表示： 十进制：可省略小数点前的 0（.42）或后多余的 0（42.）。 特殊格式：指数形式（1e3）、二进制（0b1010）、八进制（0o12）、十六进制（0xa）。 显示规则：
大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同toExponential()）。 Number 对象方法：
toFixed(n)：指定小数部分显示位数，不足用 0 补齐（返回字符串）。 toPrecision(n)：指定有效数位的显示位数。 注意：数字字面量调用方法时，需避免.被误判为数字一部分（如42..toFixed(2)或42 …  ]]></content></entry><entry><title>3.1节 类型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0301--%E7%B1%BB%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内置类型概述定义：类型是值的内部特征，决定值的行为，以区分于其他值。 分类： 基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。 对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。 typeof 运算符作用：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。 特殊情况： null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理） 检测 null 值类型的复合条件：!a &amp;&amp; typeof a === 'object'（因 null 是假值，且是唯一用 typeof 检测返回 &lsquo;object&rsquo; 的基本类型值）。 对象子类型函数（function）： 是 object 的子类型，属于可调用对象。 具有内部属性 [[Call]]，使其可被调用。 可拥有属性，如 length 属性表示其声明的参数个数。 typeof function返回&quot;function&quot;，是历史遗留的特殊处理 数组： 是 object 的子类型。 元素按数字顺序索引，length 属性表示元素个数。 值和类型的特性变量与类型的关系： JS 中变量无类型，只有值有类型。 变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。 对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。 undefined 与 undeclared 的区别： undefined：变量已在作用域中声明但未赋值。 undeclared：变量未在作用域中声明过。 typeof 的安全防范机制： 对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。 应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。 其他安全检查方法： 检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。 依赖注入设计模式：将依赖通过参数显式传递到函数中。   ]]></content></entry><entry><title>11. git flow</title><url>/post/git/11-git-flow/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  根据 Git Flow 的建议，分支主要分为以下几类：
master 分支 develop 分支 hotfix 分支 release 分支 feature 分支 其中：
master 和 develop 被称为 长期分支，因为它们会一直存在于整个 Git Flow 生命周期中。 其他分支（如 hotfix、release、feature）属于 临时分支，会在任务完成后被删除。 各分支职责master 分支
用于存放 稳定、可随时上线的项目版本。 来源：只能从其他分支合并，开发者不会直接在 master 上 commit。 特征：每个稳定版本的 commit 通常会打上 版本号标签（tag）。 develop 分支
是 所有开发分支的基础分支。 新增功能时，所有的 feature 分支 都从 develop 分支划出。 当 feature 分支的功能完成后，会被 合并回 develop 分支。 hotfix 分支
当 线上产品出现紧急问题 时，从 master 分支 划出一个 hotfix 分支进行修复。 修复完成后： 合并回 master 分支（发布修复版本）。 同时合并一份到 develop 分支。 合并到 develop 的原因
如果不这样做，当 develop 分支未来合并回 master 时，之前修复过的问题会再次出现。
不从 develop 分支划出的原因
因为 develop 分支的功能可能尚未完成，若从中直接切出修复分支再合并回 master，反而可能造成更大的问题。
release 分支
当 develop 分支 的代码足够成熟时，将其合并到 release 分支，进行上线前的 最终测试。 测试完成后： 合并到 master 分支（正式上线版本）。 同时合并回 develop 分支。 合并回 develop 的原因
在 release 阶段可能会发现并修正问题，需同步回 develop，避免未来版本再次出现同样的错误。
feature 分支
用于 新增功能的开发。 所有 feature 分支都从 develop 分支 划出。 功能开发完成后，合并回 develop 分支。 层级关系master ← release ← develop ← feature ↑ ↑ └── hotfix ┘  </content></entry><entry><title>10. 使用github</title><url>/post/git/10-%E4%BD%BF%E7%94%A8github/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  把内容推送到 GitHub 上GitHub 是全球最大的 git 服务器。
git 是工具，GitHub 是网站，其本质是一个 git 服务器。
设置远端节点git remote add origin xxx.gitgit remote：进行与远端有关的操作。
add：加入一个远端节点。
origin：指向远端 GitHub 服务器的位置，是 默认代名词。
从服务器 clone 下来的项目默认远端名就是 origin，但该名称可以修改。
推送内容到远端git push -u origin main该命令完成以下操作：
将 main 分支内容推送到 origin。 若远端不存在 main 分支，则 创建一个名为 main 的分支。 若存在，则 移动远端 main 分支到最新进度。 -u 参数：设置 upstream。 upstream（上游分支）upstream 翻译成中文意思是上游，其实就是另一个分支的名称
每个分支最多可设置一个上游（upstream）。
upstream 可追踪远端分支，也可指向本地分支。
若设置了 upstream，之后执行 git push 可 自动推送到默认目标。
若未设置，则需 每次明确指定分支与目标。
修改远端分支名称git push -u origin main:main与上方命令效果相同。
若希望远端分支名称不同，可修改为：
git push -u origin main:cat此时会在远端创建名为 cat 的分支。
拉取更新（pull）fetch 指令执行 fetch 指令
git fetch执行后：
Git 会拉取远端更新，并同步到本地的 origin/ 分支。 远端分支命名如：origin/HEAD、origin/main。 因使用过 -u 参数，origin/main 即为本地 main 的 upstream。 fetch 后若远端有新内容，会更新本地对应的 origin 分支。 接下来可执行 merge 合并更新。 pull 指令git pull = git fetch+git merge
git pull -rebasepull 会拉取远端内容并更新本地进度。
使用 -rebase 参数时，fetch 后采用 rebase 方式合并。
在多人协作时，rebase …  </content></entry><entry><title>9. git其他知识</title><url>/post/git/09-git%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  手边的工作做到一半，临时要切换到别的任务简单做法先保存当前所有修改。 切换到有问题的分支进行修复。 修复完成后切换回原分支。 执行 reset 命令，衔接上已完成的部分。 继续之前的工作。 使用 stash使用 git stash 将修改暂存。
注意：untracked 状态的文件默认无法被 stash，需要使用 -u 参数。 使用 git stash list 查看当前状态栈。
最前面的 stash@{0} 表示最新的 stash。 WIP 表示 “work in progress”（工作进行中）。 取回暂存内容
git stash pop stash@{0}pop 会将指定的 stash 应用到当前分支上，并 自动删除 它。
若未指定，默认取出 stash@{0}（最后保存的那次）。
删除指定的 stash。
git stash drop stash@{0}不删除地取回
git stash apply stash@{0}将指定的 stash 套用到当前分支上，但 不会被删除。
可理解为：pop = apply + drop。
不小心把账号密码放进 git，想删掉砍断重练法：删除 .git 目录。 删除密码文件。 重新 commit。 优点：简单直接。 缺点：所有历史记录都会消失，仅适合个人项目。
使用 filter-branch可一次性从每个 commit 中移除文件。
git filter-branch --tree-filter &amp;amp;#34;操作&amp;amp;#34;说明filter-branch 会逐个处理 commit。 --tree-filter 会在每个 commit 被 checkout 后执行指定操作，再重新 commit。 删除文件后，后续 commit 会重新计算，产生新的历史记录。 恢复到执行前状态执行 filter-branch 时，git 会将原状态备份到.git/refs/original/refs/heads 目录中，可以通过该目录找出 SHA-1，再执行：
git reset refs/original/refs/heads/master --hard即可回到执行前状态。
如果已经推出去了执行：
git push -f强制推送修改后的历史。
将其他分支的 commit 捡过来合并使用 cherry-pick： …  </content></entry><entry><title>8. 修改历史记录</title><url>/post/git/08-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  修改历史信息用 --amend 修改最后一次提交只能修改最后一次 commit 的信息。
git commit --amend使用互动模式修改更早的历史记录可使用 git rebase 的互动模式来改动过去的历史记录。
git rebase -i SHA-1-i：进入 rebase 的互动模式。SHA-1：表示从当前到该 commit 的范围。
进入后会弹出 vim 编辑器。
编辑器中的顺序与 git log 结果相反。
pick：保留这次 commit，不改动。
reword（或 r）：修改 commit 信息。
修改后保存并退出，会弹出另一个 vim 编辑器以修改 commit 信息。 保存并退出后，git 会自动完成剩下的操作。
修改 commit 信息后，SHA-1 值会改变。
被修改的 commit 会成为新的对象。
之后的所有 commit 都会重新生成新的 commit 对象。
如果要取消当前 rebase，可执行：
git reset ORIG_HEAD --hard即可回到 rebase 之前的状态。
把多个 commit 合并为一个使用互动模式的 rebase：
将 pick 改为 squash。 被标记为 squash 的 commit 会与前一行的 commit 合并。 保存并退出后，会进入编辑器重新编写合并后的 commit 信息。 把一个 commit 拆分为多个使用互动模式的 rebase，将 pick 改为 edit。当 rebase 执行到该 commit 时会暂停。
使用以下命令重置该 commit：
git reset HEAD^使用多次 add + commit 将内容分成多个 commit。
执行以下命令让 rebase 继续：
git rebase --continue在两个 commit 之间插入新的 commit使用互动模式的 rebase，将 pick 改为 edit。
当执行到该 commit 时会暂停。
添加新的 commit。继续执行 rebase
注意：rebase 状态下的 commit 列表顺序与正常日志相反，需确认停下的点是否正确。
删除或调整 commit 顺序使用互动模式的 rebase：
调整顺序：直接调整列表中 commit 的顺序。 删除 commit： 将 pick 改为 drop，或直接删除该行。 注意：删除或调整顺序时需考虑 commit 的相依性。
revert取消最后一次 commit：
git revert HEAD --no-edit--no-edit：不编辑 commit 信息。
该操作会新增一个 commit 来撤销目标 commit，原 commit 仍保留。
取消 revert再开一个 revert
对刚才的 revert 再执行一次 revert。 直接使用 reset
git reset HEAD^ --hard可回到 revert 之前的状态。
适用场景单人项目：通常直接使用 reset。
多人协作项目：若不允许使用 reset 或 rebase 修改历史，可使用 revert 生成一个反向操作的 commit。
三个指令的区别指令 作用 是否修改历史 适用场景 reset 修改当前状态到指定 commit ✅ 是 尚未推送的 commit rebase 编辑、删除或整理历史记录 ✅ 是 尚未推送的 commit revert 新增一个 commit 来反转之前的内容 ❌ 否（新增 commit） 已推送或禁止改历史的情形   </content></entry><entry><title>7. 标签</title><url>/post/git/07-%E6%A0%87%E7%AD%BE/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  使用标签在 Git 中，标签是一个指向某个 commit 的指示标。
通常在完成特定的里程碑时，使用标签来做标记。
标签分类标签分为两种：轻量标签和有附注的标签
不管哪种标签，都可以看作是一张贴纸贴在某个 commit 上。
轻量标签 使用方法简单，只需指定要贴上的 commit：
git tag 标签名 SHA-1若不加 SHA-1 值，则会贴在当前所在的 commit 上。
轻量标签仅是一个指向 commit 的指示标，不含其他信息。
Git 更推荐使用有附注的标签。
有附注的标签 创建方法：
git tag 标签名 SHA-1 -a -m &amp;#34;xxx&amp;#34;-a：创建有附注的标签。
-m：输入信息，类似于 commit 信息。
若省略 -m，会自动进入 Vim 编辑器输入说明。
区别 有附注的标签主要用作 软件版本号。轻量标签适合个人使用或临时标记。
有附注的标签包含更多信息：谁、何时贴上标签。
存储方式：
轻量标签 → 直接指向 commit。 有附注的标签 → 指向 tag 对象，再由 tag 对象指向 commit。 标签与分支一样，以文档形式存放在 .git/refs/tags 目录下。内容是一个 40 字节的 SHA-1 值，指向某个对象。
删除标签标签本质是一张贴纸，删除标签不会影响 commit 或文件。
删除方法：
git tag -d 标签名标签与分支的区别共同点
都是指示标。 都存放在 .git/refs 目录下：分支在 heads 目录。标签在 tags 目录。 都是 40 字节的 SHA-1 值。 删除不会影响被指向的对象。 区别
分支会随着 commit 前进而移动。 标签一旦贴上去就固定在该 commit 上，不随 commit 变化。   </content></entry><entry><title>6. 合并分支</title><url>/post/git/06-%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  使用 merge 合并分支如果想要用 master 分支来合并 cat 分支，需要先切换回 master 分支，再使用 git merge 命令。
git merge cat合并后，落后的 master 分支会和 cat 分支处于同一个 commit。
假设从 master 分支创建了 cat 和 dog 两个分支，并且当前在 cat 分支：
master 合并 cat 或 dog → 快转模式（fast-forward），master 直接收割成果。 cat 与 dog 互相合并 → Git 会生成一个 额外的 commit，该 commit 会指向两个父 commit。 谁合并谁，两个分支上的 commit 都是对等的。
差别在于：
谁合并谁，谁的分支就会往前移动。 额外生成的 commit 对象中会记录两个 parent，合并方向决定顺序。 使用 --no-ff 参数可避免快转模式，强制生成一个新的 commit 对象。
这样做出来的 commit 对象一样会指向前面的两个 commit。
合并过的分支是否保留可自行决定。删除分支只是移除一张贴纸，不影响原 commit。 所谓合并分支，其实是合并 分支指向的 commit，而不是分支本身。
恢复已被删除但未合并的分支分支只是一个指向某个 commit 的指标，删除分支不会使 commit 消失。
删除分支后，commit 仍存在，只是若未记下 SHA-1 值，不易再利用。
git branch new_branch SHA-1如果未记录 SHA-1 值，可用 git reflog 查找。reflog 默认保留 30 天，在此期间可找回。
使用 rebase 合并分支git rebase 的含义是 重新定义分支的参考基准，功能与 git merge 类似。
例如：cat 和 dog 两个分支的基准都是 master。使用 git rebase：
git rebase dog含义：cat 分支重新定义基准，dog 分支作为新的基准。
过程：
把 cat 分支的 commit 接到 dog 分支上。 重新计算 commit 的 SHA-1，生成新的 commit 对象。 cat 分支指向新的 commit，HEAD 继续指向 cat。 原本的 commit 依然存在，只是没有分支指向，最终可能被 Git …  </content></entry><entry><title>5. 使用分支</title><url>/post/git/05-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  使用分支在 Git 中使用分支很简单，只要使用 git branch 命令即可。
如果 git branch 后面没有接任何参数，它仅会输出当前在这个项目中有哪些分支。
Git 默认会设置一个名为 main 的分支，前面的 星号 表示现在正在这个分支上。
新增分支执行 git branch 命令时，在后面加上分支的名字即可新增一个分支。
更改分支名称使用 -m 参数更改分支名称。
git branch -m old new即使是 main 分支 也可以改。
更改分支名称不会影响文件或目录。
删除分支使用 -d 参数删除分支。
git branch -d 分支名如果要删除的分支还没有被完全合并，Git 会有提示。
此时改用 -D 参数即可强制删除。
任何分支都可以删除，包括 main 分支。
当前所在的分支不能删，必须先切换到其他分支再删除。
切换分支使用 git checkout 切换分支。
git checkout 分支名切换后，执行 add 和 commit 操作时，只有 当前所在的分支 会前进。
要切换到的分支必须先存在，否则会报错。
使用 -b 参数可在切换时直接创建新分支：
如果分支存在 → 直接切换 如果分支不存在 → 创建并切换过去 分支的原理分支就是一张贴纸，贴在某一个 commit 上。
新的 commit 会指向前一个 commit，而当前分支（HEAD 所指）会贴到新的 commit 上，HEAD 也会跟着前进。
Git 的分支不是通过复制目录或文件生成的，而只是一个指标。
分支其实就是一个 只有 40 个字节的文件，位于 .git/refs/heads 目录中。
切换分支时发生的事更新暂存区和工作目录
Git 会用目标分支指向的 commit 内容更新暂存区和工作目录。 切换前的改动会保留在工作目录中，不受影响。 每次 commit 都是一个对象，指向某个 tree 对象，而这些 tree 又指向其他 tree 或 blob 对象，类似葡萄串。 → 切换分支不会影响工作目录中已有的改动。
变更 HEAD 的位置
HEAD 会指向刚切换过去的分支。 .git/HEAD 文件内容会被改动。 git 如何知道现在是在哪个分支执行 git branch 可看到所有分支列表，星号表示当前分支。
.git 目录中的 HEAD 文件 记录了当前指向的分支。
切换分支时，HEAD 内容会变化。
使用 @ 可代替 HEAD。
ORIG_HEAD.git 目录中有一个 ORIG_HEAD 文件。
在执行危险操作时，Git 会把 HEAD 的状态存放在其中，方便随时回退到危险动作前的状态。
git reflog 也能查到相关信息，但数据较复杂。
ORIG_HEAD 可方便地找到最近一次危险动作之前的 SHA-1 值。
从过去的某个 commit 再创建一个新的分支回到目标 commit：
git checkout SHA-1从该 commit 开出新分支并切换：
git checkout -b 分支名也可以直接一行完成：
git branch -b 分支名 SHA-1  </content></entry><entry><title>4. git目录中有什么</title><url>/post/git/04-.git%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  head 是什么HEAD 是一个指标，指向某一个分支，通常可以当作当前所在分支。
在 .git 目录中有一个名为 head 的文件，其中记录的就是 HEAD 的内容。
HEAD 特点：
通常指向当前所在分支 不一定总是指向分支，当未指向分支时会出现 detached head 状态 在切换分支时，HEAD 内容会改变 当 HEAD 改变时，reflog 会留下记录 SHA-1 值SHA-1 值是一种杂凑算法，结果为 40 个十六进制数字。
特点：
相同输入 → 相同输出 不同输入 → 不同输出 Git 中所有对象的编号都是用 SHA-1 产生的。
SHA-1 值会重复吗相同输入：相同结果，不代表重复。
不同输入，相同结果：称为 碰撞。发生概率极低。
Git 计算时不仅使用文件内容，还会额外加内容，进一步降低碰撞概率。
对象 SHA-1 计算方式Blob 对象计算模式： blob 字样 一个空白字节 输入内容的长度 null 结束符 输入内容 Tree / Commit / Tag：第一项改成对应的对象名。 git 中的对象Git 有四种重要对象：Blob、Tree、Commit、Tag
Blob 对象当文件加入暂存区，Git 在 .git 中生成 blob 对象
存储规则：
前 2 个字节 → 目录名 后 38 个字节 → 文件名 文件内容经过压缩，一般编辑器无法直接查看
使用命令查看：
git cat-file -t SHA-1值 # 查看对象类型 git cat-file -p SHA-1值 # 查看对象内容关键点：
git add 时，计算 SHA-1 并存储 使用前两位作为目录，后 38 位作为文件名 内容存放于 .git/object 文件内容是压缩后的结果 空目录无法加入 Git，但空文件可以（内容为空） Tree 对象文件以 blob 存放
目录及文件名以 tree 存放
Tree 对象会指向：
一个或多个 blob 一个或多个其他 tree 这种关系称为 DAG（有向无环图）
commit 对象包含信息：
某个 tree（根目录的 tree） 提交时间 作者和提交者（一般相同） 提交信息 分支分支像一张“贴纸”，贴在某个 commit 上，并随 commit 移动
HEAD 指向某个分支，可理解为当前分支
特点： …  </content></entry><entry><title>3. commit相关</title><url>/post/git/03-commit%E7%9B%B8%E5%85%B3/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  修改 commit 记录修改方式删除整个 .git 目录 使用 git rebase 删除并整理后重新 commit 使用 git reset 删除并整理后重新 commit 使用 --amend 改动最后一次的 commit 使用 &amp;amp;ndash;amend 参数修改最后一次 commit在 commit 命令后加 --amend 即可
如果没有加 -m，会弹出 vim 编辑器编辑信息
虽然只是修改 commit 信息，但 git 会认为内容改变，重新生成新的 commit 对象（一次全新的 commit）
修改更早的 commit使用 git rebase
注意：不要在已经 push 的 commit 上改动，否则会造成困扰
追加文件到最近一次 commit采用下面两种方式：
使用 git reset 删除最近一次 commit，加入新文件后重新 commit 使用 --amend 操作流程git add 把文件加到暂存区 git commit --amend 可加 --no-edit 避免编辑信息 git commit --amend --no-edit注意：尽量不要在已 push 的 commit 上执行
新增目录Git 根据文件内容计算对象，空目录无法提交
解决方法：在空目录中放置一个文件（如 .keep 或 .gitkeep）
然后按正常流程 add 和 commit
忽略文件使用 .gitignore在项目目录新增 .gitignore 文件并设置规则
即使 .gitignore 未 commit/push 也有效，但建议提交共享
规则只对之后新增的文件有效，已存在的文件无效
若需让已存在的文件生效：
git rm --cached 文件名忽略忽略在 git add 时加 -f 参数可忽略 .gitignore 规则
git add -f 文件名称清除忽略的文件使用 git clean -fX
-f：强制删除 -X：删除被忽略的文件 查看特定文件的 commit 记录查看单一文件的历史
git log index.html查看改动内容
git log -p index.html+ 表示新增，- 表示删除
查看某行代码是谁写的使用 git blame
显示每行代码的提交者和提交信息
可加 -L 参数指定范围
git …  </content></entry><entry><title>2. 开始使用 Git</title><url>/post/git/02-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html"><![CDATA[  新增、初始 Repositorygit init：在当前目录中创建一个 .git 目录，整个 Git 的核心都集中在此目录中。
如果不想让当前目录被 Git 管控，或只想提供不含版控记录的内容，只需移除 .git 目录，Git 就会失去对该目录的控制权。
把文件交给 git 管控创建文件后交给 gitgit status：查看当前目录状态。
untracked files：文件尚未被加到 Git 版控系统中，只是新加入目录，尚未被追踪。 git add [文件名]：将文件交给 Git 管控。
状态从 untracked files → new files。 表示该文件已经进入 暂存区（index），稍后可与其他文件一起提交到存储库。 使用万用字元：
git add *.html把所有后缀名是.html 的文件全部加到暂存区。
加入所有文件：
git add --all--all 与 . 的区别git add .：将当前目录及其子目录中的修改加入暂存区，不包含该目录以外的内容。
git add --all：不论在哪一层目录执行，都会将整个项目的所有修改加入暂存区。
提交暂存区内容到存储库git commit -m &amp;quot;xxx&amp;quot;：将暂存区的内容永久保存到存储库。
-m &amp;quot;xxx&amp;quot; 用于说明此次提交的内容。可以使用中英文，只要简单、清晰即可。说明的重点是 让自己和别人都能快速理解本次改动。
完成 commit 才算完成整个流程。
git commit 只会处理暂存区的内容。尚未 git add 到暂存区的文件 不会被提交。
提交说明是必需的，否则提交不会完成。若未指定 -m 参数，Git 会打开默认编辑器（通常是 vim）以填写提交信息。
使用 --allow-empty 参数可以创建 没有内容变更 的提交：
git commit --allow-empty -m &amp;#34;&amp;#34;工作区、暂存区与存储库三个主要区域工作目录 → 暂存区：git add 暂存区 → 存储库：git commit 注意：执行 commit 才算完成整个流程。
是否一定要二段式使用 -a 参数可省略 git add
git commit -a -m &amp;#34;xxx&amp;#34;-a 参数只对 已存在于存储库的文件 有效， …  ]]></content></entry><entry><title>1. git概述</title><url>/post/git/01-git%E6%A6%82%E8%BF%B0/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html"><![CDATA[  git 概述Git：一种 分布式版本控制系统。
git 的优点免费开源
速度快、文件体积小
其他版本控制系统：记录的是各版本之间的差异。 Git：记录的是 文本内容的快照，可快速切换版本。 分布式系统
即使没有服务器或网络，也可以使用 Git 进行版本控制。 待服务器恢复或网络可用时再进行同步，不受影响。 终端机/命令提示符常用命令Windows macOS/Linux 说明 cd cd 切换目录 cd pwd 获取当前位置 dir ls 列出文件列表 mkdir mkdir 创建目录 无 touch 创建文件 copy cp 复制文件 move mv 移动文件 del rm 删除文件 cls clear 清屏 目录切换及显示# 切换到 /tmp 目录（绝对路径） cd /tmp # 切换到 my_project 目录（相对路径） cd my_project # 切换到上一层目录 cd .. # 切换到 home/project/namecards 目录 cd ~/project/namecards/ # 显示当前所在目录 pwd文件列表ls：列出当前目录下文件及目录。
ls -al：显示包含以.开头的文件，及完整权限、所有者、时间信息。
ls -al创建文件、目录# 创建文件 touch index.html # 创建目录 mkdir demotouch：
不存在 → 创建空白文件。 已存在 → 修改最后修改时间，不改动内容。 mkdir：创建目录。
文件操作# 复制 cp index.html about.html # 重命名 / 移动 mv index.html info.html # 删除文件 rm index.html # 删除目录下所有 .html 文件 rm *.htmlvim 操作介绍模式切换：
Normal 模式：命令模式，无法输入文本。 Insert 模式：文本输入模式。 进入 Insert 模式：
i → insert a → append o → 新建一行并输入 切换模式：
Insert → Normal：Esc 或 Ctrl + [ 常用命令：
:w → 存储文件 :q → 关闭文件（未存储会提示先保存） :wq → 存储并关闭文件 设置 Git用户设置git config --global user.name &#34;Allay&#34; git config --global user.email &#34;allay@qq.com&#34;检查配置：
git config --list配置保存在 ~/.gitconfig 文件中，可手动修改。
每个项目设置不同的作者针对特定的项目设置不同的作者，可以用&ndash;local 参数
git config --local user.name &#34;Andy&#34; git config --local user.email &#34;andy@qq.com&#34;local 设置：仅对该项目生效。
其他项目仍使用 global 设置。
设置缩写git config --global alias.co checkout git config --global alias.l &#34;log --oneline --graph&#34;示例：
git co = git checkout git l = git log --oneline --graph 这些 alias 配置可在 ~/.gitconfig 中修改。
  ]]></content></entry><entry><title>10. 模块</title><url>/post/ts/10-%E6%A8%A1%E5%9D%97/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  JavaScript 模块是如何定义的在 TypeScript 中，任何包含顶级 import 或 export 的文件都被视为模块。
没有顶级导入或导出声明的文件将被视为脚本，其内容在全局范围内可用。
模块在其自身作用域内执行，不在全局作用域执行。
模块中声明的变量、函数、类等在模块外不可见，除非显式导出。
使用其他模块的导出内容时，必须显式导入。
非模块JavaScript 规范规定，没有 import、export 或顶层 await 的文件被视为脚本。
在脚本文件中：
变量和类型被声明在共享的全局范围内。 假定使用 outFile合并多个文件，或在 HTML 中通过多个 &amp;lt;script&amp;gt; 标签加载。 将文件显式设为模块：
export {};此语法有效地将文件转换为一个不导出任何内容的模块。
TypeScript 中的模块编写模块化 TypeScript 代码时，需考虑三点：
语法：选择导入和导出的语法形式。 模块解析：确定模块名称/路径与文件之间的关系。 模块输出目标：确定编译后的 JavaScript 模块形式。 ES 模块语法默认导出与导入：
export default function helloWorld() { console.log(&amp;#34;Hello, world!&amp;#34;); } import helloWorld from &amp;#34;./hello.js&amp;#34;; helloWorld();命名导出与导入：
export var pi = 3.14; export let squareTwo = 1.41; export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) { if (num &amp;lt; 0) return num * -1; return num; } import { pi, phi, absolute } from &amp;#34;./maths.js&amp;#34;;附加导入语法可通过 import {old as new} 重命名导入。
可通过 import * as name 导入整个命名空间。
import RandomNumberGenerator, …  ]]></content></entry><entry><title>9. 类</title><url>/post/ts/09-%E7%B1%BB/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html">  类成员字段字段声明在类上创建公共可写属性。类型注释可选，若未指定则为隐式 any。
字段可带初始化程序，实例化时自动运行。类属性的初始化器会用于推断类型。
strictPropertyInitialization控制字段是否必须在构造函数中初始化。
TypeScript 不会分析构造函数中调用的方法是否初始化字段。
若字段在构造函数外初始化，可使用明确赋值断言运算符 !。
class OKGreeter { name!: string; // 不初始化但不报错 }readonly使用 readonly 前缀修饰字段，禁止在构造函数之外赋值。
构造函数类构造函数可添加参数、类型注释、默认值和重载。
class Point { x: number = 0; y: number = 0; constructor(x: number, y: number); constructor(xy: string); constructor(x: string | number, y: number = 0) {} }类构造函数签名和函数签名之间的差异：
不能有类型参数。 不能指定返回类型注释。 继承规则：若类继承自基类，需在使用 this 前调用 super()。
方法类上的函数属性称为方法。
TypeScript 对方法无新增特性。
方法体中必须通过 this. 访问成员。
Getter/Setter类可以有访问器（getter/setter）
在 JavaScript 中，没有额外逻辑的、由字段支持的 get/set 对很少用到。如果不需要在 get/set 操作中添加额外的逻辑，那么暴露公共字段也是可以的。
TypeScript 对于访问器有一些特殊的推理规则：
若仅存在 get，则该属性为 readonly。 若 set 未声明参数类型，则从 get 返回类型推断。 索引签名与普通对象索引签名相同。
class MyClass { [s: string]: boolean | ((s: string) =&amp;amp;gt; boolean); check(s: string) { return this[s] as boolean; } }一般不推荐直接在类实例上存储索引数据。
类继承implements 子句用于检查类是否满足某个接口。
仅进行类型检查，不 …  </content></entry><entry><title>7. 类型运算符</title><url>/post/ts/07-%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  keyof 类型运算符keyof 运算符接受一个对象类型，并生成其键的字符串或数字字面量并集。
如果类型具有 string 或 number 索引签名，则 keyof 将返回这些类型。
typeof 类型运算符JavaScript 已经有一个可以在表达式上下文中使用的 typeof 运算符。
TypeScript 添加了一个可以在类型上下文中使用的 typeof 运算符，用于引用变量或属性的类型。
对于基本类型来说，typeof 用处不大。但结合其他类型运算符，可以方便地表达许多类型模式。
预定义类型 ReturnType&lt;T&gt;：接受一个函数类型，并生成其返回类型。
若尝试直接在函数名上使用 ReturnType，会看到一个错误，值和类型不是一回事。要引用值 f 的类型 ，需使用 typeof。
function f() { return { x: 10, y: 3 }; } type P = ReturnType&lt;typeof f&gt;;限制TypeScript 有意限制了可使用 typeof 的表达式种类：typeof 仅能用于标识符（变量名）或其属性上。
  ]]></content></entry><entry><title>8. 其他常用类型</title><url>/post/ts/08-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  索引访问类型可以使用 索引访问类型 来查找另一种类型的特定属性。
索引类型本身也是一种类型，因此可以使用 联合类型、keyof 或其他类型。
type Person = { age: number; name: string; alive: boolean }; type Age = Person[&amp;#34;age&amp;#34;]; // type Age = number type I1 = Person[&amp;#34;age&amp;#34; | &amp;#34;name&amp;#34;]; // type I1 = string | number type I2 = Person[keyof Person]; // type I2 = string | number | boolean 如果尝试索引不存在的属性，会看到错误。
使用 number 可以获取数组元素的类型。可与 typeof 结合使用，方便捕获数组字面量的元素类型。
const MyArray = [ { name: &amp;#34;Alice&amp;#34;, age: 15 }, { name: &amp;#34;Bob&amp;#34;, age: 23 }, { name: &amp;#34;Eve&amp;#34;, age: 38 }, ]; type Person = (typeof MyArray)[number]; // type Person = { name: string; age: number; } type Age = (typeof MyArray)[number][&amp;#34;age&amp;#34;]; // type Age = number type Age2 = Person[&amp;#34;age&amp;#34;]; // type Age2 = number 索引时只能使用类型，不能使用 const 创建变量引用。
可以使用 类型别名 实现类似的重构风格。
const key = &amp;#34;age&amp;#34;; type Age = Person[key]; // error type key = &amp;#34;age&amp;#34;; type Age = Person[key];条件类型条件类型 用于描述输入和输出类型之间的关系。
语法形式：
SomeType extends OtherType ? TrueType : FalseType; …  ]]></content></entry><entry><title>6. 泛型</title><url>/post/ts/06-%E6%B3%9B%E5%9E%8B/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  使用泛型变量类型变量：一种特殊的变量，它作用于类型而不是值。
调用泛型函数的方式
显式传入类型参数：将所有参数（包括类型参数）传递给函数。
类型参数推断
编译器自动推断类型参数。 若编译器无法推断类型（如复杂示例中），则需显式传递类型参数。 创建泛型函数时，编译器会强制在函数体中正确使用泛型参数，将其视为任意类型。
泛型类型泛型函数的类型与非泛型函数类似，类型参数列在最前：
let myIdentity: &amp;lt;Type&amp;gt;(arg: Type) =&amp;gt; Type = identity;可以在类型中使用不同名称的类型变量，只要数量和使用方式一致。
也可以将泛型类型写为对象文字类型的调用签名：
interface GenericIdentityFn { &amp;lt;Type&amp;gt;(arg: Type): Type; } interface GenericIdentityFn&amp;lt;Type&amp;gt; { (arg: Type): Type; }除了泛型接口，还可以创建泛型类。但无法创建泛型枚举和泛型命名空间。
泛型类泛型类的结构与泛型接口类似。在类名后的尖括号 (&amp;lt;&amp;gt;) 中定义泛型类型参数。
类的类型有两个方面：静态方面与实例方面。泛型类仅在实例方面是泛型。静态成员不能使用类的类型参数。
泛型参数默认值通过为泛型类型参数声明默认值，可根据需要指定类型参数。
declare function create&amp;lt; T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[] &amp;gt;(element?: T, children?: U): Container&amp;lt;T, U&amp;gt;;规则：
若类型参数有默认值，则该类型参数被视为可选。 必需类型参数不得跟随可选类型参数。 默认类型必须满足约束。 指定类型实参时，只需为必需类型参数指定类型。未指定的类型参数将解析为其默认类型。 若推断无法选择候选项，则推断为默认类型。 与现有类或接口声明合并时，可为现有类型参数引入默认值。 也可引入新的类型参数，只要其指定默认值。 方差方差：指泛型类型中的可变性，决定类型参数如何与子类型和超类型交互。
协变和逆变描述泛型类型间的关系。
协变（Covariance）： …  ]]></content></entry><entry><title>5. 对象类型</title><url>/post/ts/05-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html">  属性修饰符对象类型中的每个属性都可以指定几件事：类型、属性是否可选以及属性是否可以写入。
可选属性很多时候，我们会处理可能设置了属性的对象。在这种情况下，可以在属性名称末尾添加问号（?）将属性标记为可选。
interface PaintOptions { shape: Shape; xPos?: number; yPos?: number; }可选属性若被设置，则最好具有特定的类型。
在启用 strictNullChecks 时，TypeScript 会提示这些属性可能是 undefined。
在 JavaScript 中，未设置的属性访问结果为 undefined，可通过判断 undefined 特殊处理。
为未指定的值设置默认值是一种常见模式，JavaScript 对此有专门语法支持。
当前无法在解构模式中添加类型注解，因为语法在 JavaScript 中已有不同含义。
readonly 属性在类型检查期间无法写入被标记为 readonly 的属性。
并不意味着值完全不可变，仅表示属性本身不能被重写。
在类型兼容性检查中，readonly 属性不会被特殊对待，仍可通过别名更改。
有助于在开发中明确对象的使用意图。
索引签名当事先不知道所有属性名，但知道值的形状时，可使用索引签名：
interface StringArray { [index: number]: string; }当 StringArray 被 number 索引时，返回值为 string。
允许的索引类型：string、number、symbol、模板字符串模式及其联合。
当同时存在数字与字符串索引器时，数字索引器返回类型必须是字符串索引器类型的子类型。
字符串索引签名会使所有属性类型与返回类型匹配。
可以将索引签名设为 readonly 以防止写入。
额外的属性检查对象在被创建并分配类型时，会触发更严格的验证，即额外的属性检查。
对象字面量在赋值或作为参数传递时，会进行额外检查。
若存在“目标类型”中未定义的属性，会报错。
绕过方式：
使用类型断言。 添加一个字符串索引签名。 赋值给变量后再使用（变量赋值不会触发额外检查）。 若两个对象至少有一个共同属性（如 width），上述方式有效，否则无效。
扩展类型extends 关键字允许接口从其他类型复制成员并新增属性。 …  </content></entry><entry><title>4. 更多关于函数</title><url>/post/ts/04-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  函数类型表达式描述函数最简单的方法是使用函数类型表达式。这些类型在语法上类似于箭头函数。
type GreetFunction = (a: string) =&amp;gt; void; function greeter(fn: GreetFunction) { // ... }(a: string) =&amp;gt; void 表示一个带有一个参数 a 的函数，该参数的类型为 string，没有返回值。
如果未指定参数类型，则隐式为 any。
参数名称是必需的。(string) =&amp;gt; void 表示“具有 any 类型名为 string 的参数的函数”。
调用签名函数类型表达式语法不允许声明属性。如果想描述可调用且带属性的函数，可以用对象类型编写调用签名。
type DescribableFunction = { description: string; (someArg: number): boolean; }; function doSomething(fn: DescribableFunction) { console.log(fn.description + &amp;#34; returned &amp;#34; + fn(6)); } function myFunc(someArg: number) { return someArg &amp;gt; 3; } myFunc.description = &amp;#34;default description&amp;#34;; doSomething(myFunc);与函数类型表达式不同，在参数列表和返回类型之间使用 : 而不是 =&amp;gt;。
构造函数签名JavaScript 函数可以通过 new 调用，TypeScript 称这些为构造函数。 通过在调用签名前添加 new 来编写构造函数签名。
type SomeConstructor = { new (s: string): SomeObject; }; function fn(ctor: SomeConstructor) { return new ctor(&amp;#34;hello&amp;#34;); }可组合调用与构造签名：
interface CallOrConstruct { (n?: number): string; new (s: string): Date; }泛型函数当输入 …  ]]></content></entry><entry><title>3. 缩小</title><url>/post/ts/03-%E7%BC%A9%E5%B0%8F/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  TypeScript 会将类型分析覆盖在 JavaScript 的运行时控制流结构上，例如 if/else、条件表达式、循环、真值检查等，这些结构都会影响类型判断。
当 TypeScript 看到如 typeof padding === &amp;quot;number&amp;quot; 的检查时，会将其识别为一种称为类型保护（Type Guard）的特殊代码形式。TypeScript 会跟踪程序可能的执行路径，分析各位置值的最具体类型，并通过这些检查和赋值将类型细化为更具体的类型，这一过程称为缩小（Narrowing）。
typeof 类型保护JavaScript 的 typeof 操作符能在运行时提供值的类型信息。
TypeScript 能理解 typeof 的结果，用以在不同分支中缩小类型范围。
TypeScript 内置了对 typeof 的行为规则，因此能正确处理 JavaScript 的一些特例。
真实性缩小在 JavaScript 中，if、&amp;amp;&amp;amp;、||、! 等条件语句可以接受任意类型的表达式。
条件判断时会先将表达式强制为 boolean，再根据结果选择分支。
可通过：Boolean(value)或 !!value将值强制为布尔类型。
这种方式常用于防范 null 或 undefined。但对原始值的真值检查容易出错，TypeScript 仅能在有限范围内帮助发现问题。
带有 ! 的布尔否定会从否定分支中过滤掉原值。
相等缩小TypeScript 会利用 switch、===、!==、==、!= 来缩小类型。
即使使用宽松等式（==、!=），TypeScript 也能正确缩小。
x == null 同时检查 x 是否为 null 或 undefined。 x == undefined 亦同理。 in 操作符缩小JavaScript 的 in 操作符可判断某对象或其原型链中是否存在指定属性。TypeScript 利用此信息缩小可能的类型范围。
可选属性在缩小时会同时存在于两侧分支。
instanceof 缩小instanceof 用于检查某值是否是另一构造函数的实例。
TypeScript 将其视为一种类型保护，可根据结果缩小分支类型。
x instanceof Foo 会检查 x 的原型链中是否包含 Foo.prototype。
赋值当变 …  ]]></content></entry><entry><title>2. 日常类型</title><url>/post/ts/02-%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  原始类型：字符串、数字和布尔值JavaScript 有三个常用的原始类型：string、number、boolean。
TypeScript 中对应的类型名称与 JavaScript 中 typeof 运算符的结果一致。
应始终使用 小写的 string、number、boolean 作为类型。
以大写开头的 String、Number、Boolean 是特殊内置类型，几乎不使用。
数组数组类型的写法：
number[]：数字数组 string[]：字符串数组 Array&amp;lt;number&amp;gt;：与 number[] 含义相同 注意：[number] 是不同的东西。
any特殊类型 any 用于在不希望引发类型检查错误时使用。
当值为 any 类型时：
可以访问任何属性； 可以像函数一样调用； 可以赋值给任意类型或从任意类型赋值； 可执行所有语法合法的操作。 当不想写出冗长类型以通过编译时，any 很有用。
noImplicitAny当未指定类型且 TypeScript 无法推断类型时，编译器默认将其设为 any。应避免这种情况。
使用编译器标志 noImplicitAny 可将隐式 any 标记为错误。
变量的类型注解使用 const、var 或 let 声明变量时，可选择添加类型注解。
let myName: string = &amp;#34;Alice&amp;#34;;TypeScript 不使用“左侧类型”声明（如 int x = 0;），类型注解总是写在变量之后。
多数情况下无需显式类型注解，TypeScript 会自动 推断类型。
函数参数类型注解在参数名后添加类型注释声明函数的参数类型。
TypeScript 会检查：
参数类型是否匹配； 参数数量是否正确。 function greet(name: string) { console.log(&amp;#34;Hello, &amp;#34; + name.toUpperCase() + &amp;#34;!!&amp;#34;); }返回类型注释返回类型注释位于参数列表之后。
TypeScript 通常能自动推断返回类型，但可显式指定以增强可读性。
function getFavoriteNumber(): number { return 26; }匿名函数当函数出现在 TypeScript 能确定其调用方式的位置 …  ]]></content></entry><entry><title>1. 基础知识</title><url>/post/ts/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>Typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 与类型系统每个值都有一组行为，可以通过运行不同的操作观察这些行为。JavaScript 运行时根据值的 类型 来决定执行的操作。
对于原始类型（如 string、number），可使用 typeof 运算符识别。对于函数等复杂类型，没有运行时机制可识别其类型。
在纯 JavaScript 中，了解函数如何处理特定值的唯一方法是 调用它并观察结果。这种特性导致在代码运行前 难以预测行为。
类型 是描述哪些值可以传递给函数、哪些值会导致崩溃的概念。
JavaScript 提供的是 动态类型系统 —— 运行代码才能看到结果。静态类型系统 则能在代码运行 之前 预测执行行为。
静态类型检查目的
帮助在运行代码 之前 发现错误。 TypeScript 通过描述运行时值的形状与行为，提前检测潜在异常。 问题背景
运行时错误被视为 bug。 测试不足或重构复杂时，错误难以发现或修复。 非异常失败JavaScript 遵循 ECMAScript 规范，在遇到意外情况时会定义特定行为。
静态类型系统需自行决定哪些代码应被视为错误，即使这些代码在 JavaScript 中是“合法”的。
TypeScript 的目标是捕获合法 bug，如：拼写错误，未调用的函数，基本逻辑错误
工具类型TypeScript 不仅能捕获错误，还能 防止错误的发生。
类型检查器可以：
检查属性访问是否正确； 提供属性建议； 提供代码补全与错误提示。 支持 TypeScript 的编辑器还提供：
快速修复 重构 跳转定义 查找引用 tsc，TypeScript 编译器安装
npm install -g typescript编译
tsc hello.ts若无类型错误，无输出（表示无问题）。 生成对应的 hello.js 文件，代码清晰且保留注释。 发出错误若存在类型检查错误，命令行会显示错误信息，但仍会生成 hello.js。
TypeScript 假设 开发者比编译器更了解代码意图。
可使用 noEmitOnError 参数让编译器在错误时不生成输出文件。
显式类型function greet(person: string, date: Date) { console.log(`Hello ${person}, today is …  </content></entry><entry><title>2.4节 原型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0204--%E5%8E%9F%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  [[Prototype]] 基础定义：对象的特殊内置属性，本质是对其他对象的引用 默认值：几乎所有对象创建时，[[Prototype]] 都会被赋予非空值 [[Get]] 操作逻辑（属性查找）： 优先检查对象本身是否有目标属性，有则使用； 若无，沿 [[Prototype]] 链向上查找； 直至找到属性或遍历完整条原型链，未找到则返回 undefined 原型链终点：Object.prototype地位：所有普通对象的 [[Prototype]] 链最终都会指向 Object.prototype 作用：包含 JS 通用功能（如 toString()、hasOwnProperty() 等），供所有普通对象继承 核心通用方法方法 作用 示例 toString() 返回对象的字符串表示（默认&amp;quot;[object Object]&amp;quot;） ({}).toString() → &amp;quot;[object Object]&amp;quot; hasOwnProperty(key) 检查属性是否为对象自身所有（不含原型链） cat.hasOwnProperty(&amp;quot;eat&amp;quot;) → false（eat 在原型上） isPrototypeOf(obj) 检查当前对象是否在obj的原型链上 animal.isPrototypeOf(cat) → true valueOf() 返回对象的原始值（默认返回对象本身） (new Number(123)).valueOf() → 123 属性设置与屏蔽（myObject.foo = &#39;bar&#39;）基础逻辑若 myObject 本身有 foo 普通数据属性：仅修改属性值； 若 foo 不在 myObject 中：沿 [[Prototype]] 链查找，未找到则直接在 myObject 上添加 foo； 若 foo 既在 myObject 中，也在原型链上层：myObject 的 foo 屏蔽原型链上层的 foo（优先取最底层属性）。 特殊场景（foo 在原型链上层）原型链上层 foo 特性 结果 普通数据属性（非只读） 在 myObject 上添加 foo 屏蔽属性 只读数据属性（writable: false） 非严格模式：忽略赋值；严格模式：报错（无法添加屏蔽属性或修改原属性） 访问描述符（含 setter） 调 …  ]]></content></entry><entry><title>2.5节 行为委托和class</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0205--%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  对象关联风格的核心特性与设计原则状态存储原则核心规则：状态（数据属性）应保存在委托者对象上，而非委托目标（原型链上层对象）。 避免委托目标状态被多个委托者共享，导致数据污染或不可预期的修改。 方法命名原则核心规则：尽量避免在 [[Prototype]] 链不同级别使用相同命名的方法（与类风格的“重写”逻辑相反）。 设计建议：使用描述性方法名（需体现对象行为类型），降低命名冲突风险，提升代码可理解性与可维护性。 委托本质委托行为的核心：当对象自身找不到属性/方法时，会将请求委托给 [[Prototype]] 关联的对象（沿原型链向上查找）。 委托限制禁止循环委托：无法在两个及以上对象间创建互相委托（如 A 关联 B、B 关联 A），会触发错误。 思维模型与灵活性维度 特点 思维模型 仅关注对象之间的关联关系，不强调实体及实体间的层级（如父类-子类） 创建与初始化分离 支持“创建对象”与“初始化状态”分步执行，更符合关注分离原则，灵活性更高 对比类风格 类风格通常强制“构造+初始化”合并为一步（如 new 调用构造函数时同步初始化） class 语法特点（ES6+）多态实现支持通过 super() 实现相对多态：子类方法可通过 super 引用原型链上层的同名方法（模拟类继承中的“调用父类方法”）。 声明限制仅能声明方法：class 字面量语法中，无法直接声明数据属性（需在构造函数 constructor 中通过 this.属性名 定义）。 示例：class A { foo() {}; // 允许；bar = 1; // 类字段语法（ESNext，非标准字面量声明） } 扩展能力支持通过 extends 关键字自然扩展对象类型，包括内置对象类型（如 class MyArray extends Array {}），模拟类继承的“子类扩展父类”逻辑。 本质与局限性维度 特点 本质 是 [[Prototype]] 机制的语法糖，并非真正实现面向类语言的“类”（无类实例化复制、无类级别的类型约束） super 绑定方式 静态绑定：super 指向的原型链上层对象在 class 定义时确定，无法动态修改（与类风格的动态关联不同） 动态修改难度 class 定义后，难以对其原型链、方法等进行动态调整（如修改 prototype 指向、新增/删除方法），灵活性低于原生对象关联   </content></entry><entry><title>2.3节 混合对象类</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0203--%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  类理论类/继承 描述了一种代码的组织结构形式，是一种在软件中对真实世界中问题领域的建模方法。
面向对象编程（OOP） 强调数据与操作数据的行为是互相关联的。
好的设计：将数据及与其相关的行为封装在一起。在计算机科学中，这种封装有时被称为 数据结构。
类可以用于对数据结构进行分类。任意数据结构 都可以看作是某个范围更广定义的特例。
多态：父类的通用行为可以被子类用更特殊的行为重写。
相对多态性：允许在重写行为中引用基础行为。
建议父类与子类应使用相同的方法名来表示特定行为，以支持重写机制。
类的机制一个类就是一张蓝图。为了获得可交互的对象，必须依据类进行构造（实例化），生成的对象称为 实例（instance）。
实例可直接调用方法和访问公有属性，是类中描述的所有特性的一份 副本。
可判断实例来源的类，但一般不会直接操作其类定义。
实例化的本质：通过复制操作将类转化为对象形式。
构造函数构造函数（Constructor） 是类中的特殊方法，名称通常与类名相同，用于初始化实例的所有必要信息。
类构造函数属于属于类本身，需通过 new 关键字调用，以指示语言引擎构造新实例。
类的继承继承：在面向类的语言中，可以先定义一个类（父类），再定义一个继承自它的类（子类）。
子类是独立且完全不同的类，包含父类行为的原始副本。
子类可以重写继承的行为，定义新行为。
多态多态是一个广泛的概念，这里指的是继承层次中方法的多态性。
相对引用机制：方法可引用继承层次中的高层方法，而无需指定绝对层次。
关键字super：表示当前类的父类或祖先类。在子类构造函数中可通过 super 调用父类构造函数。
同一方法名可在不同继承层中多次定义， 调用方法时会自动选择最合适的定义。
方法多态性 取决于：引用该方法的实例所属的类。
子类可相对引用父类的方法（通过 super）。
子类继承的只是父类行为的一份副本，重写不会影响父类，父类与子类方法互不影响。
继承本质上是复制行为：子类与父类在逻辑上并无直接关联，子类仅获得父类行为的副本。
多重继承某些语言允许一个类同时继承多个父类。
多重继承：所有父类的定义会被复制到子类中。
混入在 JS 中对象机制不会自动执行复制行为。JS 中没有类的真实复制机制，只有对象。对象之间不是复制，而是 关联。
由于其他语言的类表现为复制行为，JS 开发者发明了 混 …  </content></entry><entry><title>2.2节 对象</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0202--%E5%AF%B9%E8%B1%A1/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  语法对象可以通过两种形式定义：声明文字形式和构造形式。
两种形式生成的对象是一样的。唯一的区别是文字声明中可以添加多个键值对，但是构造形式中必须逐个添加属性。
类型在 JavaScript 中共有六种主要类型：string、number、boolean、null、undefined、object
简单基本类型本身并不是对象。
存在一些特殊的对象子类型，可称为复杂基本类型：
函数：对象的一个子类型，是可调用的对象，是 JavaScript 中的一等公民，可以像对象一样被操作、作为参数传递。 数组：对象的一种类型，具有更结构化的值存储方式，内容的组织方式比一般对象更复杂。 内置对象常见的内置对象包括：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error
这些内置函数可作为构造函数使用，构造对应子类型的新对象。
语言会在必要时自动装箱（将字面量转换为对象），无需显式创建。
null 和 undefined只有文字形式；Date只有构造形式。
对于 Object、Array、Function、RegExp，无论使用文字形式还是构造形式，都生成对象，推荐使用文字形式，仅在需要额外选项时使用构造形式。
Error 对象通常在抛出异常时自动创建，很少显式使用 new Error()。
内容对象的内容由属性组成，每个属性存储一个值。属性名称像“指针”一样指向值的存储位置。
访问语法：
点操作符（.）：属性访问； 方括号（[]）：键访问 . 要求属性名符合标识符命名规范；[] 可以接受任意 UTF-8 / Unicode 字符串；
[] 可在程序中动态构造属性名。
在对象中，属性名永远是字符串，若使用非字符串值作为属性名，会先被转换为字符串。
可计算属性名可在对象文字形式中使用方括号包裹表达式作为属性名。
符号：一种新的基础数据类型，值是不可预测、引擎间不同的，通常只接触到符号名称，而非其真实值。
属性与方法从技术角度看，函数不属于对象。若属性访问返回函数，该函数仍是普通函数，即使在对象字面量中声明函数，也只是对同一函数对象的引用。
数组数组支持 [] 访问形式；使用**数值下标（索引）**访问；
数组也是对象，可以添加属性，添加命名属性不会改变 length
最好使用对象来存储键值对，只用数组来存储 …  </content></entry><entry><title>2.1节 关于this</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0201--%E5%85%B3%E4%BA%8Ethis/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  this 是什么this 是在运行时进行绑定的，而不是在编写时绑定的。它的上下文取决于函数调用时的各种条件，与函数声明的位置无关，只取决于函数的调用方式。
函数被调用时会创建一个活动记录（执行上下文），其中包含：
函数的调用位置（调用栈） 函数的调用方式 传入的参数 this 是这个记录的一个属性，在函数执行过程中会被使用。
调用位置：函数在代码中被调用的位置（非声明位置）。
调用栈：为了到达当前执行位置而调用的所有函数。当前执行的函数的调用位置是其调用栈中的前一个调用。
绑定规则默认绑定独立函数调用：直接调用函数引用（不带修饰）。只能使用默认绑定，无法应用其他规则。
非严格模式：this 绑定到全局对象。
严格模式：this 绑定到 undefined。
隐式绑定当函数引用有上下文对象时，this 会绑定到该上下文对象。
对象属性引用链中，只有最后一层在调用位置起作用。
若隐式绑定的函数丢失绑定对象，则会使用默认绑定：this 会绑定到全局对象或 undefined。
显示绑定若不想在对象中包含函数引用，可使用 call 或 apply 强制绑定。
它们的第一个参数是 this 的绑定对象。
若传入原始值作为绑定对象，会被装箱成对应的对象形式。
硬绑定：显示绑定的强制版本。典型做法是创建一个包装函数，接收并返回原函数调用结果。
可用于创建可复用的辅助函数。
ES5 提供了内置方法 Function.prototype.bind：
返回一个硬编码的新函数； 该函数的 this 被固定为指定对象； 可传入部分参数（部分应用 / 柯里化）。 许多函数提供可选参数 context，与 bind 作用相同。这些函数内部通常通过 call 或 apply 实现显示绑定。
new 绑定在 JS 中，构造函数是被 new 操作符调用的普通函数。包括内置对象函数在内的所有函数都可用 new 调用。
使用 new 时的步骤：
创建一个全新的对象。 将该新对象的 [[prototype]] 连接起来。 将该新对象绑定到函数调用的 this。 若函数未返回其他对象，则返回该新对象。 优先级bind 的功能之一：除 this 绑定外，还可传递其他参数（部分应用 / 柯里化）。
在判断 this 绑定规则时，遵循以下优先级顺序：
new 调用：this 绑定到新创建的对象。 …  </content></entry><entry><title>1.4节 作用域闭包</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0104--%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  闭包本质闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
无论通过何种方式将内部函数传递到所在的词法作用域之外，它都会持有对原始定义作用域的引用。无论函数在何处执行，都会使用闭包。
只要将访问词法作用域的函数作为第一类值类型传递，就会使用闭包。只要使用了回调函数，实际上就是在使用闭包。
循环和闭包在迭代内部使用 IIFE（立即执行函数表达式），会为每次迭代创建一个新的作用域。延迟函数的回调可以封闭在该新的作用域中，从而在每个迭代中都能访问到正确的变量值。
本质上这是将一个块转换为可被关闭的作用域。
for 循环头部的 let 声明有特殊机制：变量在循环过程中不只被声明一次，每次迭代都会重新声明，每次新的迭代都会使用上一个迭代结束时的值来初始化变量。
模块最常见的模块实现方式被称为 模块暴露。
模块模式的两个必要条件
必须有外部封闭函数，并且该函数至少被调用一次；每次调用都会创建一个新的模块实例。 封闭函数必须返回至少一个内部函数，内部函数在私有作用域中形成闭包，能够访问或修改私有状态。 模块模式可以为即将作为公共 API 返回的对象命名。
模块模式的两个特点：调用一个包装了函数定义的包装函数；将返回值作为模块的 API。
未来的模块机制基于函数的模块无法被静态识别，编译器不能识别其 API 语义，只有在运行时，模块的 API 才能被解析，因此，模块的 API 可在运行时动态修改。
ES6 模块的特征：API 是静态的，不会在运行时改变，编译器可在编译时检查导入 API 是否存在，若不存在，编译器会在编译期抛出早期错误，而非运行期错误。
ES6 模块必须定义在独立文件中，一个文件就是一个模块，浏览器或引擎内置默认模块加载器，可被重载，导入模块时，可以同步加载模块文件。
import：将模块中的一个或多个 API 导入当前作用域，并绑定到变量上；
export：将模块中的标识符、变量或函数导出为公共 API；可在模块定义中多次使用。
模块文件中的内容会被当作包含在作用域闭包中一样处理。
  </content></entry><entry><title>1.2节 词法作用域和动态作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0102--%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  词法阶段词法作用域是定义在 词法阶段 的作用域。即作用域由代码中变量和块作用域书写的位置决定。当词法分析器处理代码时，会保持作用域不变。
作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中可以定义同名标识符，称为 遮蔽效应。
查找过程：从运行时所处的最内部作用域开始，逐级向外（或向上）查找，直到遇到第一个匹配的标识符为止。
全局变量会自动成为全局对象的属性，可以通过全局对象属性引用访问被同名变量遮蔽的全局变量。
函数的词法作用域由函数声明时所处的位置决定。无论函数在哪里被调用或如何被调用，其词法作用域始终不变。
词法作用域查找只会查找一级标识符。
欺骗词法evaleval() 可以接受一个字符串参数，并将其内容视为写在当前位置的代码。
执行 eval 后，引擎仍会进行词法作用域查找，并不关心代码是动态插入的。
行为特性：
可以通过逻辑动态拼接字符串再传入执行。常用于执行动态创建的代码。
若执行的字符串中包含声明，则会修改 eval 所处的词法作用域。
在 严格模式 下，eval 具有独立的词法作用域，不会修改外部作用域。
相关机制：
setTimeout() 和 setInterval() 的第一个参数可以是字符串，被解释为动态生成的函数代码。 new Function() 的最后一个参数可接受代码字符串并生成函数，前面的参数为形参。 withwith 常被用作引用同一对象多个属性的快捷方式，无需重复书写对象名。
with 可以将一个对象视为一个独立的词法作用域。对象的属性会被视为该作用域中的词法标识符。
with 块内部的正常声明不会被限制在块作用域中，而是被添加到 with 所处的函数作用域中。
eval 会修改所在作用域，而 with 会创建一个全新的词法作用域。
JS 引擎在编译阶段会根据词法结构进行优化。若出现 eval 或 with，则无法静态确定变量位置，优化将失效。因此，大量使用 eval 或 with 的代码运行速度会显著变慢。
动态作用域动态作用域不关心函数声明的位置，只关心函数调用的位置。作用域链基于调用栈，而非代码中的嵌套结构。
JavaScript 不具有动态作用域，它只有词法作用域。但 this 机制 与动态作用域的行为类似。
对比项 词法作用域 动态作用域 确定时机 写代码时（定义时） 运行时 关注点 函数在何处声明 函数从何处调用 箭头函数在 this 绑定上与普通函数完全不同：它放弃普通的 this 绑定规则，而是使用当前词法作用域覆盖原有的 this 值。
  </content></entry><entry><title>1.3节 函数作用域和块作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0103--%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  函数中的作用域函数作用域：属于函数的全部变量都可以在整个函数范围内使用及复用。在嵌套作用域中，也可以访问外层作用域中的变量。
隐藏内部实现通过将变量和函数包裹在一个函数作用域中，可以隐藏内部实现。
这一做法体现了 最小特权原则（最小授权/最小暴露原则）：在软件设计中应尽量只暴露必要内容，将其他内容隐藏起来（如模块或对象的 API 设计）。
优点避免命名冲突：隐藏作用域中的变量和函数，可防止同名标识符覆盖或污染。
防止全局冲突：多个第三方库若未隐藏私有内容，可能在全局作用域中造成冲突。
常见解决方法：在全局声明一个独特名称的对象作为命名空间；所有需要暴露的功能作为该对象的属性。
现代模块机制通过模块管理器避免冲突：
无需在全局作用域中暴露标识符； 依赖管理器可将库的标识符显式导入特定作用域。 函数作用域函数声明（Function Declaration）：function 是声明中的第一个词。
函数表达式（Function Expression）：function 出现在声明的中间或末尾。
区别：
函数声明的名称标识符绑定在所在作用域中； 函数表达式的名称标识符绑定在函数自身内部作用域中。 匿名和具名函数声明 必须有函数名，函数表达式可以匿名。
匿名函数问题：
栈追踪中没有有意义的名称，调试困难； 无法引用自身，只能使用已废弃的 arguments.callee； 缺乏描述性名称，降低代码可读性。 最佳实践：始终为函数表达式命名。
立即执行函数表达式IIFE：将函数包含在括号中，使其成为表达式，并在末尾加括号立即执行。
常见用法：
使用匿名函数表达式； 可向 IIFE 传递参数； 可防止 undefined 被覆盖； 可用于倒置运行顺序：先定义后执行。 提升JS 引擎在执行代码前会先编译；编译时会找到所有声明并与作用域关联；
声明会被提升，而赋值和逻辑留在原处；
每个作用域都会执行提升操作。
函数声明会被提升；函数表达式不会被提升；即使具名函数表达式，其名称在赋值前也不可用。
函数优先函数的提升优先于变量；
重复的 var 声明会被忽略；后出现的函数声明会覆盖前面的声明；
普通块中的函数声明也会被提升，应避免在块内声明函数。
块作用域变量应尽量局部化，距离使用处越近越好；
块作用域可视为最小授权原则的延伸：从“函数中隐藏信息”扩展到“块中隐藏信息”。 …  </content></entry><entry><title>1.1节 作用域是什么</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0101--%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  储存和访问变量值的能力为程序带来了状态。
一套用于存储变量并方便后续访问的规则被称为 作用域。
编译原理在传统编译语言中，程序在执行前会经历三个步骤，统称为 编译：
分词 / 词法分析：将由字符组成的字符串分解成有意义的代码块，称为 词法单元。
解析 / 语法分析：将词法单元流数组转换为一个代表程序语法结构的嵌套树，称为 抽象语法树（AST）。
代码生成：将 AST 转换为可执行代码。
对于 JavaScript，大部分编译过程发生在代码执行前的几微秒内。
理解作用域三个核心角色引擎：负责整个 JavaScript 程序的编译及执行。
编译器：负责语法分析及代码生成。
作用域：负责收集并维护所有声明的标识符集合，并实施规则来确定当前代码是否能访问这些标识符。
示例分析：var a = 2编译阶段：
遇到 var a 时，编译器会询问作用域中是否已存在名为 a 的变量。 如果存在，则忽略该声明；如果不存在，则要求作用域声明一个新的变量 a。 执行阶段：
引擎运行时会询问作用域中是否存在变量 a。 若存在，则对其赋值为 2；若不存在，则继续向上查找该变量。 若最终仍未找到变量 a，则抛出异常。 变量的赋值操作包含两个步骤：
编译阶段：若变量未声明，则在当前作用域中声明它。 执行阶段：引擎查找该变量，若找到则赋值。 RHS 查询：用于查找变量的 值。
LHS 查询：用于查找变量的 容器本身，以便进行赋值操作。
函数声明：编译器可以在代码生成的同时处理函数的 声明 和 值定义。
作用域嵌套当一个 块或函数 嵌套在另一个块或函数中时，就形成了 作用域嵌套。
若在当前作用域中找不到变量，引擎会逐层向外查找，直到找到该变量或到达最外层作用域。
异常RHS 查询失败：若在所有嵌套作用域中均找不到变量，引擎会抛出 引用错误（ReferenceError）。
LHS 查询失败（非严格模式）：若在全局作用域中也找不到目标变量，引擎会自动创建一个同名全局变量并返回。
严格模式下的 LHS 查询：严格模式禁止自动创建全局变量。LHS 查询失败时会抛出与 RHS 查询相同的 引用错误。
当 RHS 查询成功找到变量，但对其值进行不合理操作时，引擎会抛出 类型异常（TypeError）。
  </content></entry><entry><title>1.3 日期时间和数字格式化</title><url>/post/vue-i18n/0103-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96/</url><categories><category>Vue I18n</category></categories><tags><tag>vue</tag><tag>i18n</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  日期时间基本用法可以使用自定义的格式定义来本地化日期时间。
const datetimeFormats = { &amp;#34;en-US&amp;#34;: { short: { year: &amp;#34;numeric&amp;#34;, month: &amp;#34;short&amp;#34;, day: &amp;#34;numeric&amp;#34;, }, long: { year: &amp;#34;numeric&amp;#34;, month: &amp;#34;short&amp;#34;, day: &amp;#34;numeric&amp;#34;, weekday: &amp;#34;short&amp;#34;, hour: &amp;#34;numeric&amp;#34;, minute: &amp;#34;numeric&amp;#34;, }, }, &amp;#34;ja-JP&amp;#34;: { short: { year: &amp;#34;numeric&amp;#34;, month: &amp;#34;short&amp;#34;, day: &amp;#34;numeric&amp;#34;, }, long: { year: &amp;#34;numeric&amp;#34;, month: &amp;#34;short&amp;#34;, day: &amp;#34;numeric&amp;#34;, weekday: &amp;#34;short&amp;#34;, hour: &amp;#34;numeric&amp;#34;, minute: &amp;#34;numeric&amp;#34;, hour12: true, }, }, };可以定义命名的日期时间格式（例如 short、long 等）。
使用 ECMA-402 Intl.DateTimeFormat 的选项定义格式。
在使用本地化消息时，需要指定 datetimeFormats 的 createI18n 选项：
const i18n = createI18n({ datetimeFormats, });在 Vue I18n 中使用 $d 来本地化日期时间值。
注意：在 VueI18n v9 中，选项名称是 datetimeFormats，而不是 dateTimeFormats。
支持的本地化方法
$d（用于传统 API 模式和组合式 API 模式） 内置组件 DatetimeFormat（i18n-d） 从 useI18n 导出的 d（用于组合式 API 模式） &amp;lt;p&amp;gt;{{ $d(new Date(), …  ]]></content></entry><entry><title>1.4 作用域和区域更改</title><url>/post/vue-i18n/0104-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8C%BA%E5%9F%9F%E6%9B%B4%E6%94%B9/</url><categories><category>Vue I18n</category></categories><tags><tag>vue</tag><tag>i18n</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  作用域Vue I18n 管理资源以提供国际化功能，包括：
地区切换 每种语言的消息（称为地区消息） 日期时间和数字的命名格式 这些资源通过 VueI18n 实例 进行管理。
Vue 应用由树状结构中的组件构建。要在 Vue I18n 中实现组件的本地化，需要理解 作用域（scope） 的概念。
Vue I18n 有两种作用域：全局作用域、 局部作用域
全局作用域全局作用域允许访问和管理应用中所有组件的国际化资源。
使用 createI18n 创建 i18n 实例时，会自动创建全局作用域。
全局作用域与 VueI18n 实例绑定，可通过 i18n.global 属性访问。
如果组件中未指定 i18n 选项，则会自动启用全局作用域。
在组件中通过 this.$i18n 访问的 VueI18n 实例 ≡ 通过 i18n.global 属性访问的全局实例。
局部作用域局部作用域允许按组件管理 i18n 资源，类似于 &lt;style scoped&gt; 的工作方式。
当组件具有局部作用域时，仅该组件的 i18n 资源生效。
通过在组件中指定 i18n 选项 启用局部作用域。
初始化时会创建一个新的 VueI18n 实例。
在局部作用域中通过 this.$i18n 访问的实例 ≠ 通过 i18n.global 访问的全局实例。
区域变更全局作用域若要为整个应用程序变更语言区域，可在任意组件中使用 $i18n.locale。
&lt;template&gt; &lt;div class=&#34;locale-changer&#34;&gt; &lt;select v-model=&#34;$i18n.locale&#34;&gt; &lt;option v-for=&#34;locale in $i18n.availableLocales&#34; :key=&#34;`locale-${locale}`&#34; :value=&#34;locale&#34; &gt; {{ locale }} &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/template&gt;本地作用域本地作用域的 locale 默认继承自全局作用域，当全局作用域的 locale 变化时，本地作用域也随之变化。
若要切换整个应用的语言环境，需通过 createI18n 创建的 i18n 实例的 global 属性 进行更改。
若不想继承全局作用域，将组件的 i18n 选项的 sync 设置为 false。
注意事项：
更改本地作用域的 locale 不会影响全局作用域。 本地作用域组件中更改 $i18n.locale 仅影响该组件。 若要修改全局设置，请使用 $root.$i18n.locale。 const i18n = createI18n({ locale: &#34;ja&#34;, // set current locale // vue-i18n something options here ... // ... }); // create Vue app instance, install Vue I18n, and mount! createApp({ // something vue options here ... // ... }) .use(i18n) .mount(&#34;#app&#34;); // change locale via `global` property // when vue-i18n is being used with legacy: false, note that i18n.global.locale is a ref, so we must set it via .value: i18n.global.locale.value = &#34;en&#34;; // otherwise - when using legacy: true, we set it like this: i18n.global.locale = &#34;en&#34;;  ]]></content></entry><entry><title>1.5 回退</title><url>/post/vue-i18n/0105-%E5%9B%9E%E9%80%80/</url><categories><category>Vue I18n</category></categories><tags><tag>vue</tag><tag>i18n</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  fallbackLocale: '&lt;lang&gt;' 用于选择当首选语言没有翻译时所使用的语言。
使用地区进行隐式回退当给定一个包含地区和可选方言的 locale 时，会自动激活隐式回退。
例如：de-DE-bavarian 会按以下顺序回退：
de-DE-bavarian de-DE ``de` 要抑制自动回退，请在后缀添加感叹号 !，例如：de-DE!
显式回退（使用一个区域设置）当某些项目未被翻译时，可以设置一个备用语言。
例如：项目 hello 仅在英语中可用，但在日语中不可用。此时可以在 createI18n 中设置 fallbackLocale：
const i18n = createI18n({ locale: &#34;ja&#34;, fallbackLocale: &#34;en&#34;, messages, });**默认行为：**回退到 fallbackLocale 时会生成两个控制台警告：
第一个警告提示：$t 的键不在 ja 语言环境消息中。 第二个警告提示：回退到 en 语言环境消息时的解析过程。 这些警告仅在开发模式（process.env.NODE_ENV !== 'production'）中显示， 生产环境中不会出现。
使用语言环境数组进行显式回退可以设置多个备用语言环境：
fallbackLocale: [ &#39;fr&#39;, &#39;en&#39; ],使用决策映射进行显式回退如果需要更复杂的备用逻辑，可使用**决策映射（mapping）**定义相应的回退区域。
fallbackLocale: { /* 1 */ &#39;de-CH&#39;: [&#39;fr&#39;, &#39;it&#39;], /* 2 */ &#39;zh-Hant&#39;: [&#39;zh-Hans&#39;], /* 3 */ &#39;es-CL&#39;: [&#39;es-AR&#39;], /* 4 */ &#39;es&#39;: [&#39;en-GB&#39;], /* 5 */ &#39;pt&#39;: [&#39;es-AR&#39;], /* 6 */ &#39;default&#39;: [&#39;en&#39;, &#39;da&#39;] },后备插值通过设置 formatFallbackMessages: true，当某个键在当前语言中没有翻译时，会对翻译键进行模板插值。
翻译键是字符串，可以使用用户可读消息作为键。不必为基础语言重复编写翻译模板。可以在键中包含模板参数。
const messages = { ru: { &#34;Hello {name}&#34;: &#34;Здравствуйте {name}&#34;, }, }; const i18n = createI18n({ locale: &#34;ru&#34;, fallbackLocale: &#34;en&#34;, formatFallbackMessages: true, messages, });  ]]></content></entry><entry><title>1.1 入门指南</title><url>/post/vue-i18n/0101-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url><categories><category>Vue I18n</category></categories><tags><tag>vue</tag><tag>i18n</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  &lt;template&gt; &lt;h1&gt;{{ $t(&#34;message.hello&#34;) }}&lt;/h1&gt; &lt;/template&gt;在模板中，使用 Vue I18n 注入的 $t 翻译 API 进行本地化。
这允许 Vue I18n 在不重写模板的情况下更改语言环境，同时能够支持全局应用程序。
创建 i18n 实例通过调用 createI18n 函数创建 i18n 实例。
可以为 createI18n 指定以下重要选项：
locale：要本地化的 Vue 应用的语言。 fallbackLocale：如果 $t 翻译 API 中指定的键资源在当前语言中找不到，则回退到的语言。 messages：使用 $t 翻译 API 进行翻译的本地化消息。本地化消息的结构是层次化的对象结构，每个本地化语言作为顶层属性。 const i18n = createI18n({ locale: &#34;ja&#34;, fallbackLocale: &#34;en&#34;, messages: { en: { message: { hello: &#34;hello world&#34;, }, }, ja: { message: { hello: &#34;こんにちは、世界&#34;, }, }, }, });注册 i18n 插件创建好 i18n 实例后，需要通过 use 方法在应用上注册插件：
const app = createApp(Vue); app.use(i18n); app.mount(&#34;#app&#34;);与大多数 Vue 插件一样，调用 use 必须在调用 mount 之前。
插件的职责：
添加全局属性和方法，如 $t、$i18n 启用 useI18n 组合式 API 全局注册 i18n-t、i18n-d 和 i18n-n 组件   ]]></content></entry><entry><title>1.2 消息格式语法</title><url>/post/vue-i18n/0102-%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url><categories><category>Vue I18n</category></categories><tags><tag>vue</tag><tag>i18n</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Vue I18n 通过支持插值和各种特性语法来实现消息的本地化。
插值类型命名插值使用占位符 {} 来插入 JavaScript 中定义的变量。
const messages = { en: { message: { hello: &amp;#34;{msg} world&amp;#34;, }, }, };&amp;lt;p&amp;gt;{{ $t(&amp;#39;message.hello&amp;#39;, { msg: &amp;#39;hello&amp;#39; }) }}&amp;lt;/p&amp;gt;命名插值的变量名必须以字母（a-z，A-Z）或下划线（）开头，后续可跟字母、数字、下划线（）、连字符（-）或美元符号（$）。
列表插值使用 JavaScript 中定义的数组进行插值。
const messages = { en: { message: { hello: &amp;#34;{0} world&amp;#34;, }, }, };&amp;lt;p&amp;gt;{{ $t(&amp;#39;message.hello&amp;#39;, [&amp;#39;hello&amp;#39;]) }}&amp;lt;/p&amp;gt;字面量插值在占位符中使用字面字符串进行插值，特别适用于特殊字符（如 { 和 }）。
const messages = { en: { address: &amp;#34;{account}{&amp;#39;@&amp;#39;}{domain}&amp;#34;, }, };&amp;lt;p&amp;gt;email: {{ $t(&amp;#39;address&amp;#39;, { account: &amp;#39;foo&amp;#39;, domain: &amp;#39;domain.com&amp;#39; }) }}&amp;lt;/p&amp;gt;关联消息将某个地区的消息键与另一个消息键进行链接，适用于内容相同的消息。
const messages = { en: { message: { the_world: &amp;#34;the world&amp;#34;, dio: &amp;#34;DIO:&amp;#34;, linked: &amp;#34;@:message.dio @:message.the_world !!!!&amp;#34;, }, }, };内置修饰符控制链接消息的大小写格式。
可用的修饰符有：
upper：将链接消息中的所有字符转换为大写。 lower：将链接消息中的所有字符转换为小写。 capitalize：将链接消息的首字母大写。 …  ]]></content></entry><entry><title>8.4 渲染机制</title><url>/post/vue3/0804-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  虚拟 DOM虚拟 DOM (Virtual DOM, VDOM)：一种编程概念，将目标 UI 用数据结构“虚拟”表示，保存在内存中，并与真实 DOM 保持同步。
虚拟 DOM 不是具体技术，而是一种模式，没有标准实现。
挂载 (mount)：运行时渲染器遍历虚拟 DOM 树，构建真实 DOM 树。
更新 (patch / diffing / reconciliation)：比较两份虚拟 DOM 树的差异，并将变化应用到真实 DOM。
主要收益：
声明式、灵活地创建、检查和组合 UI 结构。 具体 DOM 操作交由渲染器处理。 渲染管线Vue 组件挂载时的步骤：
编译 Vue 模板被编译为渲染函数（返回虚拟 DOM 树的函数）。 可通过构建步骤提前完成，也可使用运行时编译器即时完成。 挂载 渲染器调用渲染函数，遍历虚拟 DOM 树并创建真实 DOM 节点。 作为响应式副作用执行，追踪所有响应式依赖。 更新 当依赖变化时，副作用重新运行，创建新的虚拟 DOM 树。 渲染器比较新旧树，应用必要更新到真实 DOM。 模板 vs. 渲染函数模板：预编译为虚拟 DOM 渲染函数。
渲染函数：直接使用 JavaScript 手写 vnode。
渲染函数的灵活性：更适合处理高度动态逻辑。
模板的优势：
贴近 HTML
更易重用 HTML 片段。 提供更好的可访问性。 更方便使用 CSS。 设计师更容易理解和修改。 确定语法
模板可被静态分析。 编译器可进行编译时优化，提升虚拟 DOM 性能。 模板对大多数场景够用且高效；渲染函数主要用于可重用组件的动态渲染逻辑。
带编译时信息的虚拟 DOMReact 等纯运行时实现的问题
更新算法无法预知新树结构。 每次都需遍历整棵树并比较 props。 即使未变部分，每次也会创建新 vnode。 带来 性能开销 和 内存压力。 Vue 的优化
框架同时控制 编译器 和 运行时。 编译器静态分析模板，在生成代码中添加标记。 运行时可基于标记走捷径。 保留使用渲染函数的能力。 称为 带编译时信息的虚拟 DOM。 缓存静态内容模板中无动态绑定的部分：
首次渲染后缓存 vnode。 后续渲染直接使用缓存，跳过比对。 多个连续静态元素：
压缩为 静态 vnode（纯 HTML 字符串）。 挂载时通过 innerHTML 渲染。 更新类型标记编译 …  </content></entry><entry><title>8.5 渲染函数和 JSX</title><url>/post/vue3/0805-%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E5%92%8Cjsx/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  在绝大多数情况下，Vue 推荐使用模板语法来创建应用。 然而在某些需要完整 JavaScript 编程能力的场景下，渲染函数就派上用场了。
基本用法创建 VnodesVue 提供了 h() 函数用于创建 vnodes。
h 是 hyperscript 的简称，意为“能生成 HTML 的 JavaScript”。更准确的名称是 createVNode()，但 h() 更简洁。
h() 的使用方式：
// 类型必填，其他参数可选 h(&amp;#39;div&amp;#39;) h(&amp;#39;div&amp;#39;, { id: &amp;#39;foo&amp;#39; }) // attribute 和 property 都能在 prop 中书写 // Vue 会自动将它们分配到正确的位置 h(&amp;#39;div&amp;#39;, { class: &amp;#39;bar&amp;#39;, innerHTML: &amp;#39;hello&amp;#39; }) // 像 `.prop` 和 `.attr` 这样的的属性修饰符 // 可以分别通过 `.` 和 `^` 前缀来添加 h(&amp;#39;div&amp;#39;, { &amp;#39;.name&amp;#39;: &amp;#39;some-name&amp;#39;, &amp;#39;^width&amp;#39;: &amp;#39;100&amp;#39; }) // 类与样式可以用数组或对象 h(&amp;#39;div&amp;#39;, { class: [foo, { bar }], style: { color: &amp;#39;red&amp;#39; } }) // 事件监听器应以 onXxx 的形式书写 h(&amp;#39;div&amp;#39;, { onClick: () =&amp;gt; {} }) // children 可以是字符串 h(&amp;#39;div&amp;#39;, { id: &amp;#39;foo&amp;#39; }, &amp;#39;hello&amp;#39;) // 没有 props 可省略 h(&amp;#39;div&amp;#39;, &amp;#39;hello&amp;#39;) h(&amp;#39;div&amp;#39;, [h(&amp;#39;span&amp;#39;, &amp;#39;hello&amp;#39;)]) // children 数组可包含 vnode 与字符串 h(&amp;#39;div&amp;#39;, [&amp;#39;hello&amp;#39;, h(&amp;#39;span&amp;#39;, &amp;#39;hello&amp;#39;)]) …  ]]></content></entry><entry><title>8.3 深入响应式系统</title><url>/post/vue3/0803-%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  什么是响应性响应性是一种可以使我们声明式地处理变化的编程范式。
let A2; function update() { A2 = A0 + A1; } whenDepsChange(update);核心术语作用 (effect)：update() 函数会更改程序状态，因此称为副作用或作用。 依赖 (dependency)：A0 和 A1 被用来执行作用，因此它们是依赖。 订阅者 (subscriber)：依赖的订阅者即作用。 我们需要一个魔法函数，能够在 A0 或 A1 (这两个依赖) 变化时调用 update() (产生作用)。
魔法函数 whenDepsChange()任务如下：
当变量被读取时进行追踪。 如果变量在当前副作用中被读取，则将副作用设为该变量的订阅者。 当变量变化时，通知所有订阅副作用重新执行。 Vue 中的响应性是如何工作的无法追踪局部变量的读写。可以追踪对象属性的读写。
两种方式Vue 2：getter / setter（为支持旧浏览器）。 Vue 3：Proxy（主要），仅在 ref 中使用 getter / setter。 function reactive(obj) { return new Proxy(obj, { get(target, key) { track(target, key); return target[key]; }, set(target, key, value) { target[key] = value; trigger(target, key); }, }); } function ref(value) { const refObject = { get value() { track(refObject, &amp;#34;value&amp;#34;); return value; }, set value(newValue) { value = newValue; trigger(refObject, &amp;#34;value&amp;#34;); }, }; return refObject; }reactive() 的局限性属性赋值/解构到本地变量后，访问不再响应式。 从 reactive() 返回的代理与原对象不同，可通过 === 区分。 依赖追踪与触发track()：
检查是否有活跃副作用。 若有，将副作用 …  ]]></content></entry><entry><title>8.1 使用 Vue 的多种方式</title><url>/post/vue3/0801-%E4%BD%BF%E7%94%A8vue%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  独立脚本Vue 可以以一个单独 JS 文件的形式使用，无需构建步骤。
适用场景：
后端框架已渲染大部分 HTML 前端逻辑不复杂 在这些场景中，Vue 可以看作一个更声明式的 jQuery 替代品。
另一个适用版本：petite-vue
为渐进式增强已有 HTML 优化 功能更精简 十分轻量 作为 Web Component 嵌入Vue 可用于构建标准的 Web Component。
这些组件能嵌入到任何 HTML 页面中，不论其如何渲染。
优点：
无需顾虑最终使用场景 可嵌入旧应用、静态 HTML，或其他框架构建的应用 单页面应用 (SPA)应用特征：
需要丰富交互性 较深会话 复杂状态逻辑 架构：
Vue 控制整个页面 处理数据抓取 页面切换无需重新加载 这种应用称为 单页应用 (SPA)。
Vue 提供核心库和工具链支持，包括：
客户端路由 极快的构建工具 IDE 支持 浏览器开发工具 TypeScript 支持 测试工具 与后端的关系
SPA 一般要求后端提供 API 数据接口。 也可结合 Inertia.js 使用 → 保留服务端开发模型同时获得 SPA 益处。 全栈 / SSR纯客户端 SPA 在首屏加载和 SEO 上存在显著问题。浏览器先收到空 HTML，需等待 JavaScript 才渲染内容。
解决方案：
Vue 提供 API，将应用在服务端渲染为 HTML 字符串。 服务器直接返回渲染好的 HTML。 用户可在 JavaScript 下载前看到内容。 客户端随后对应用进行激活 (hydrate) → 重获交互性。 服务端渲染 (SSR) 的优势：极大改善 Web 核心指标性能，如 最大内容绘制 (LCP)。
相关框架：NuxtJS → 基于 Vue 的全栈框架。
JAMStack / SSG若数据是静态的，可提前完成服务端渲染。整个应用预渲染为 HTML → 部署为静态文件。
优点：
性能提升 部署更容易（无需请求时动态渲染） Vue 仍可通过激活在客户端提供交互。这种技术称为 静态站点生成 (SSG)，也称 JAMStack。
SSG 有两种风格：
单页 SSG 初始加载后激活为 SPA 成本：更多前期 JS 加载和激活 好处：后续导航更快（部分更新页面内容） 适用场景：重交互、深会话，或需要持久化状态/元素 多页 SSG 每次导航加载新页面 优点：JS 最少，甚至可不需要 JS 一些框架（如 Astro）支持“部分激活” → 静态 HTML 中通过 Vue 组件创建交互孤岛 相关工具：
VitePress（Vue 官方维护的 SSG） NuxtJS → 同时支持 SSR 与 SSG Web 之外&amp;hellip;Vue 不局限于浏览器，还可用于：
Electron / Wails → 桌面应用 Ionic Vue → 移动端应用 Quasar / Tauri → 同一代码同时开发桌面和移动应用 TresJS → 构建 3D WebGL 体验 Vue 的自定义渲染 API → 构建自定义渲染器（如 终端命令行）   </content></entry><entry><title>8.2 组合式 API 常见问答</title><url>/post/vue3/0802-%E7%BB%84%E5%90%88%E5%BC%8F-api-%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  什么是组合式 API组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。
它涵盖以下方面：
响应式 API：如 ref()、reactive()，用于创建响应式状态、计算属性和侦听器。 生命周期钩子：如 onMounted()、onUnmounted()，用于在组件生命周期阶段添加逻辑。 依赖注入：如 provide()、inject()，结合响应式 API 使用 Vue 的依赖注入系统。 在 Vue 3 中，组合式 API 通常配合 &amp;lt;script setup&amp;gt; 语法使用。
组合式 API 并不是函数式编程：
组合式 API 基于 Vue 的响应性系统（数据可变、细粒度）。 函数式编程通常强调数据不可变。 为什么要有组合式 API更好的逻辑复用通过 组合函数 实现简洁高效的逻辑复用。
解决了 mixins 的缺陷。
更灵活的代码组织选项式 API 的限制：
多个逻辑关注点被拆分到不同选项中，阅读和重构成本高。 抽取逻辑时需在多个位置寻找代码片段。 组合式 API 的改进：
相同逻辑关注点的代码被组织到一起。 方便移动到外部文件，降低重构成本。 更适合大型项目的长期维护。 更好的类型推导使用变量和函数，天然类型友好。
代码可享受完整的类型推导，减少类型标注需求。
TypeScript 和 JavaScript 用户都能受益。
更小的生产包体积&amp;lt;script setup&amp;gt; 与组合式 API 更高效，代码压缩更友好。
模板被编译为内联函数，与 &amp;lt;script setup&amp;gt; 代码同作用域。
不依赖 this，可直接访问变量。
优势：本地变量名可压缩，对象属性名不能。
与选项式 API 的关系组合式 API：
不限制代码放置位置，可运用 JavaScript 最佳实践。 提供更好的长期可维护性。 选项式 API：
允许“少思考”，但被锁定在固定模式中。 在大型项目中难以重构或提高质量。 组合式 API 是否覆盖了所有场景组合式 API 能覆盖所有状态逻辑需求。
仅需保留少量选项：props、emits、name、inheritAttrs。
可配置编译时标记移除选项式 API 代码，减小包体积。
可以在同一个组件中使用两种 API 吗可以在 …  ]]></content></entry><entry><title>7.3 无障碍访问</title><url>/post/vue3/0703-%E6%97%A0%E9%9A%9C%E7%A2%8D%E8%AE%BF%E9%97%AE/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Web 无障碍访问 (a11y) 指创建可供任何人使用的网站的做法——无论是：
身患某种障碍 通过慢速的网络连接访问 使用老旧或损坏的硬件 处于某种不方便的环境 示例：
视频添加字幕 → 帮助失聪、有听力障碍或身处嘈杂环境的用户 确保文字对比度足够 → 帮助低视力用户或在强光下使用手机的用户 跳过链接在每个页面顶部添加一个直接指向主内容区域的链接，用户可跳过重复内容。
通常放在 App.vue 顶部 → 成为所有页面的第一个可聚焦元素。
当路由改变时，应将焦点置回页面最开始（跳过链接之前）。
可通过调用 backToTop 模板引用的 focus 实现（假设使用 vue-router）。 内容结构目标：设计支持易于访问的实现。
包括：颜色对比度、字体选择、文本大小、语言、内容组织。
标题用户可通过标题在应用中导航。
实践建议：
按级别顺序嵌套标题：&lt;h1&gt; - &lt;h6&gt; 不要在章节内跳跃标题级别 使用实际标题标签，而不是仅用样式模拟标题 LandmarksLandmark 提供访问规划，辅助技术用户可直接导航至应用的各个部分，可使用 ARIA role 实现
语义化表单表单常用元素：&lt;form&gt;、&lt;label&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;button&gt;。
标签通常位于表格字段的顶部或左侧。
标签提供标签来描述所有表单控件用途，使用 for 与 id 关联
如果在 Chrome 开发者工具中检查这个元素，并打开 Elements 选项卡中的 Accessibility 选项卡，将看到输入是如何从标签中获取其名称的
aria-label：为 input 框配置无障碍访问名
aria-labelledby：
类似于 aria-label，但标签文本在屏幕上可见 通过 id 与其他元素配对，可链接多个 id aria-describedby：用法与 aria-labelledby 相同，提供用户可能需要的附加描述信息。可用于描述输入标准
占位符避免使用占位符：容易让用户困惑
缺陷：默认不符合 颜色对比度标准
解决：修改颜色，让其看起来像预填数据
建议：在表单外提供所有必要输入说明
用法说明确保用法说明正确链接到目标 input 框
方法：
在 aria-labelledby 内绑定多个 id 或通过 aria-describedby 将说明附加到 input 隐藏内容一般不建议隐藏标签，即使 input 有无障碍名称
特例：如果上下文足以说明输入功能，可隐藏视觉标签
aria-hidden=&quot;true&quot;对无障碍访问隐藏，但对视觉用户可见
注意：不要在可聚焦元素上使用
仅用于装饰性、重复或屏幕外内容
按钮在表单中使用按钮时，必须设置 type，防止误提交表单
也可以使用 &lt;input&gt; 元素创建按钮
  ]]></content></entry><entry><title>7.4 安全</title><url>/post/vue3/0704-%E5%AE%89%E5%85%A8/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  首要规则：不要使用无法信赖的模板使用 Vue 时最基本的安全规则就是：不要将无法信赖的内容作为组件模板。
使用无法信赖的模板 = 允许任意 JavaScript 在应用中执行。
在服务端渲染时执行这些代码 → 可能导致服务器被攻击。
原因：
Vue 模板会被编译成 JavaScript，模板内的表达式将作为渲染过程的一部分被执行。 由于全局执行环境的复杂性，Vue 无法在性能开销合理的前提下完全避免潜在的恶意代码执行。 直接方法：确保 Vue 模板始终可信，并完全由自己控制。
Vue 自身的安全机制HTML 内容无论使用模板还是渲染函数，内容都会自动转义。
转义通过 textContent 等浏览器原生 API 完成。
只有浏览器本身存在漏洞时，才会出现漏洞。
Attribute 绑定动态 attribute 的绑定也会自动转义。
转义通过 setAttribute 等浏览器原生 API 完成。
同样，只有浏览器存在漏洞时才会受影响。
潜在的危险在任何 Web 应用中，允许执行未经无害化处理的用户提供内容（HTML、CSS、JavaScript）都存在安全隐患，应尽可能避免。
注入 HTMLVue 会自动转义 HTML，避免可执行 HTML 注入。
例外：当确定 HTML 安全时，可以显式渲染 HTML。
结论：用户提供的 HTML 永远不安全，除非：
在 iframe 沙盒环境中，或 该 HTML 仅被该用户看到。 允许用户编写自己的 Vue 模板也存在类似危险。
URL 注入如果 URL 允许通过 javascript: 执行 JavaScript → 存在潜在问题。
结论：
任何用户提供的 URL 必须在后端先做无害化处理，然后再保存到数据库。 即使是经过无害化处理的 URL，Vue 也不能保证其目标安全。 样式注入恶意用户能利用 CSS 进行“点击劫持”。
若允许在 &lt;style&gt; 中插入用户提供内容 → 更大漏洞（控制整个页面样式）。
Vue 阻止在模板中渲染 &lt;style&gt; 标签。
建议：
仅在沙盒 iframe 中允许用户控制 CSS。 当允许样式绑定时，应使用 对象值形式，并限制为可安全控制的特定属性。 JavaScript 注入禁止在 Vue 中渲染 &lt;script&gt;。
HTML 元素的事件属性（如 onclick、onfocus、onmouseenter）也可能接受 JavaScript 字符串，存在风险。
结论：用户提供的 JavaScript 永远不安全，除非：
在 iframe 沙盒环境中，或 仅在该用户登录页面上执行。 常见问题场景开发者显式渲染了未经无害化处理的用户内容 → 本身不安全。 开发者将 Vue 挂载到包含服务端渲染或用户提供内容的 DOM 节点上 → 与 #1 类似的风险。 最佳实践：
不要将 Vue 挂载到可能包含服务端渲染或用户提供内容的 DOM 节点上。 最佳实践核心规则：只要执行了未经无害化处理的用户内容（HTML、JavaScript、CSS），就可能遭受攻击。
使用 Vue、其他框架，或不使用框架，结论都相同。
  ]]></content></entry><entry><title>7.1 生产部署</title><url>/post/vue3/0701-%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  开发环境 vs. 生产环境在开发过程中，Vue 提供了许多功能来提升开发体验：
对常见错误和隐患的警告 对组件 props / 自定义事件 的校验 响应性调试钩子 开发工具集成 这些功能在生产环境中不会被使用。 一些警告检查会带来少量性能开销。
在部署到生产环境时，应移除所有 仅用于开发环境 的代码分支，以获得 更小的包体积 和 更好的性能。
不使用构建工具如果没有使用构建工具，而是通过 CDN 或其他源 加载 Vue：
必须确保部署时使用 生产环境版本（文件名以 .prod.js 结尾）。 生产环境版本特点： 经过最小化处理 移除了所有仅用于开发环境的代码分支 选择版本全局变量版本（通过 Vue 全局变量访问）：使用 vue.global.prod.js ESM 版本（通过原生 ESM 导入访问）：使用 vue.esm-browser.prod.js 使用构建工具通过以下工具搭建的项目已经预先配置好生产环境：
create-vue (基于 Vite) Vue CLI (基于 webpack) 自定义构建时的注意事项
vue 被解析为 vue.runtime.esm-bundler.js。 编译时功能标记已正确配置。 process.env.NODE_ENV 在构建时被替换为 &quot;production&quot;。 追踪运行时错误可以使用 应用级错误处理来向追踪服务报告错误：
import { createApp } from &#39;vue&#39; const app = createApp(...) app.config.errorHandler = (err, instance, info) =&gt; { // 向追踪服务报告错误 }  ]]></content></entry><entry><title>7.2 性能优化</title><url>/post/vue3/0702-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>性能优化</tag></tags><content type="html">  概述Web 应用性能的两个主要方面：
页面加载性能：首次访问时，应用展示出内容与达到可交互状态的速度。 更新性能：应用响应用户输入更新的速度。 结论：优化性能的第一步是为应用类型确定合适的架构。
页面加载优化选用正确的架构如果应用对 页面加载性能 敏感：
避免纯客户端的 SPA 使用 SSR 或 SSG 来缓解首屏加载缓慢的问题 如果应用对 交互性要求不高：
使用传统后端渲染 HTML 在客户端用 Vue 进行增强 如果主应用必须是 SPA，但有营销相关页面（如落地页、关于页、博客等）：
将这些页面单独部署 理想情况：使用 静态 HTML，尽量少 JS，用 SSG 部署 包体积与 Tree-shaking 优化减少打包产物体积的方法：
尽可能地采用构建步骤 模板预编译 → 避免在浏览器中加载 Vue 编译器 体积缩小 14kb（最小化 + gzip） 避免运行时编译开销 谨慎引入依赖 包体积膨胀常因无意识引入过重依赖 优先选择 提供 ES 模块格式 的依赖（对 tree-shaking 友好） 实际体积大小取决于导入的 API 渐进式增强场景 如果不使用构建步骤，可考虑使用 petite-vue 代码分割定义：构建工具将 JS 包拆分为多个较小文件，可按需或并行加载。
优点：
初次加载只下载必要功能 额外功能仅在需要时加载 在 Vue 应用中：
结合 异步组件使用 Vue Router 应用强烈建议：路由组件使用 异步组件 更新优化Props 稳定性子组件只在至少一个 props 改变时 才会更新。应保持传给子组件的 props 稳定
v-once内置指令。用于渲染依赖运行时数据但无需再更新的内容。整个子树会在未来更新中被跳过
v-memo内置指令。有条件地跳过某些大型子树或 v-for 列表的更新
计算属性稳定性Vue 3.4+：计算属性仅在值变更时触发副作用
问题：若每次计算都创建新对象 → Vue 认为始终不同
优化方法：
手动比较新旧值 若无变化则返回旧值 必须先完整计算，确保依赖收集一致 通用优化大型虚拟列表渲染大型列表 → 性能瓶颈
浏览器需处理大量 DOM 节点
解决方法：列表虚拟化
仅渲染用户视口中可见部分 减少大型不可变数据的响应性开销Vue 响应性系统默认是 深度的
在数据量巨大时 → 性能负担明显
解决方法：
使用 shallowRef() 使用 shallowReactive() 浅层式 API → 仅顶层响应式，深层对象不可变 更新方式：替换整个根状态 避免不必要的组件抽象创建无渲染组件或高阶组件会增加组件实例数量
组件实例比 DOM 节点更昂贵
过多抽象 → 性能损失
注意：减少少量组件实例对性能改善不明显
  </content></entry><entry><title>5.3 KeepAlive 组件</title><url>/post/vue3/0503-keepalive/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  &lt;KeepAlive&gt; 组件&lt;KeepAlive&gt; 是一个内置组件，用于在多个组件间动态切换时 缓存被移除的组件实例。
动态组件的实现：通过 &lt;component&gt; 元素。
默认行为：
组件实例在被替换后会被销毁。 组件销毁后，其内部所有已变化的状态都会丢失。 当组件再次显示时，会创建一个带有 初始状态 的新实例。 解决方案：使用 &lt;KeepAlive&gt; 包装动态组件以缓存实例。
DOM 内模板写法：需写为 &lt;keep-alive&gt;。
包含/排除默认行为：缓存内部所有组件实例。
定制方式：通过 include 和 exclude prop。
可选值： 英文逗号分隔的字符串 正则表达式 包含上述类型的数组 匹配依据：根据组件的 name选项。
要求：若组件需要条件性缓存，必须显式声明 name 选项。
Vue 3.2.34+ 特性：
使用 &lt;script setup&gt; 的单文件组件会自动根据文件名生成对应的 name 选项，无需手动声明。 最大缓存实例数通过 max prop 限制缓存的最大组件实例数。
行为特点：
在指定 max 时，&lt;KeepAlive&gt; 的行为类似 LRU 缓存。 当缓存数量即将超过最大值时，最久未被访问的实例将被销毁，以便为新的实例腾出空间。 缓存实例的生命周期状态变化：
当组件实例从 DOM 移除但被 &lt;KeepAlive&gt; 缓存时 → 变为 不活跃，而不是被卸载。 当组件实例再次插入 DOM 时 → 被重新 激活。 生命周期钩子：
onActivated() onDeactivated() 注意事项：
onActivated 在组件挂载时也会调用。onDeactivated 在组件卸载时也会调用。 这两个钩子适用于 &lt;KeepAlive&gt; 缓存的 根组件和后代组件。   ]]></content></entry><entry><title>5.4 Teleport</title><url>/post/vue3/0504-teleport/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  &lt;Teleport&gt; 组件&lt;Teleport&gt; 是一个内置组件，它可以将组件内部的一部分模板 “传送”到该组件 DOM 结构外层的位置。
使用场景：模板的一部分逻辑上属于该组件，但在 DOM 中需要渲染到其他位置，甚至 Vue 应用外部。
常见例子：全屏模态框。
触发按钮和模态框属于同一个组件，逻辑紧密相关。 若不使用 &lt;Teleport&gt;，模态框会深嵌在 DOM 结构中，导致 CSS 布局困难。 解决方案：使用 &lt;Teleport&gt; 将模板片段传送到 DOM 中的其他位置，避免 DOM 结构的限制。
to prop：
用于指定传送的目标。 值类型： CSS 选择器字符串 DOM 元素对象 含义：将以下模板片段 传送到 to 指定的标签下。 结合使用：
&lt;Teleport&gt; 可以与 Transition搭配，创建带动画的模态框。 挂载要求：
&lt;Teleport&gt; 挂载时，目标 to 必须已存在于 DOM 中。 理想情况下，目标元素应位于 Vue 应用 DOM 树外部。 若目标元素由 Vue 渲染，则必须在 &lt;Teleport&gt; 挂载前挂载该元素。 搭配组件使用&lt;Teleport&gt; 只改变 渲染的 DOM 结构，不会影响组件的逻辑关系。
逻辑保持：
如果 &lt;Teleport&gt; 包含组件，该组件仍与使用 &lt;Teleport&gt; 的组件保持 父子关系。 props 传递和事件触发依然照常工作。 开发工具表现：
父组件的注入正常生效。 子组件在 Vue Devtools 中依然嵌套在父组件下，而不是出现在实际渲染的位置。 禁用 Teleport通过动态传入 disabled prop，可以按需禁用 &lt;Teleport&gt;。
多个 Teleport 共享目标在多个实例共存的场景下（如 &lt;Modal&gt; 可复用组件）：
多个 &lt;Teleport&gt; 可将内容挂载到同一个目标元素。 顺序规则：后挂载的内容会排在目标元素下更后的位置，但都属于该目标元素。 延迟解析的 Teleport版本要求：Vue 3.5+
使用 defer prop 可以 推迟目标解析，直到应用的其他部分挂载完成。
适用场景：目标容器由 Vue 渲染，且位于组件树之后部分。
注意事项：
目标元素必须与 &lt;Teleport&gt; 在 同一个挂载/更新周期 内渲染。 若目标元素延迟过久（如 1 秒后才挂载），Teleport 仍会报错。 延迟原理与 mounted 生命周期钩子类似。   ]]></content></entry><entry><title>6.1 单文件组件</title><url>/post/vue3/0601-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  介绍定义：Vue 的单文件组件（Single-File Component，简称 SFC，即 *.vue 文件）是一种特殊的文件格式。 它允许我们将一个 Vue 组件的 模板、逻辑与样式 封装在单个文件中。
特点：
是 HTML、CSS 和 JavaScript 经典组合的自然延伸。 使用 &lt;template&gt;、&lt;script&gt; 和 &lt;style&gt; 三个块在同一文件中封装和组合视图、逻辑、样式。 为什么要使用单文件组件前提：使用单文件组件必须依赖构建工具。
优点：
使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件。 让强相关的关注点自然内聚。 预编译模板，避免运行时编译开销。 支持 组件作用域的 CSS。 组合式 API 下语法更简单。 可通过交叉分析模板和逻辑进行更多编译时优化。 更好的 IDE 支持，包括自动补全和类型检查。 开箱即用的模块热更新 (HMR) 支持。 推荐使用场景：
单页面应用 (SPA) 静态站点生成 (SSG) 需要构建步骤以获得更好开发体验 (DX) 的项目 非推荐场景：
在轻量级场景下，SFC 可能显得过于复杂。 Vue 也支持无构建步骤的纯 JavaScript 使用方式。 如果只需在静态 HTML 中添加简单交互，可以使用 petite-vue（约 6 kB，预优化的 Vue 子集）。 单文件组件是如何工作的编译：
SFC 是框架指定的文件格式。 必须由 @vue/compiler-sfc 编译为标准 JavaScript 和 CSS。 编译后的 SFC 是标准的 JavaScript (ES) 模块，可以像其他 ES 模块一样导入。 样式处理：
开发环境：&lt;style&gt; 标签会注入为原生 &lt;style&gt;，支持热更新。 生产环境：样式会被抽取、合并为独立 CSS 文件。 如何看待关注点分离？关键观点：
前端开发的关注点不是完全基于文件类型分离的。 关注点分离的目标是提高可维护性，而不仅仅是文件类型上的分离。 现代实践：
与其将代码库拆为三个庞大的层（HTML、CSS、JavaScript 相互交织），不如划分为松散耦合的组件，再按需组合。 在一个组件中：模板、逻辑、样式本就是耦合的。将它们放在一起，使组件 更内聚、更可维护。   ]]></content></entry><entry><title>5.1 Transition</title><url>/post/vue3/0501-transition/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Vue 内置过渡与动画Vue 提供了两个内置组件，用于基于状态变化的过渡和动画：
&amp;lt;Transition&amp;gt;：在一个元素或组件进入和离开 DOM 时应用动画。 &amp;lt;TransitionGroup&amp;gt;：在 v-for 列表中的元素或组件被插入、移动、或移除时应用动画。 其他动画方式：
切换 CSS class 用状态绑定样式来驱动动画 &amp;lt;Transition&amp;gt; 组件内置组件：无需注册，任意组件中均可使用。
作用：将进入和离开动画应用到通过默认插槽传递的元素或组件上。
触发条件：
由 v-if 触发的切换 由 v-show 触发的切换 &amp;lt;component&amp;gt; 动态组件切换 改变特殊的 key 属性 限制：
仅支持单个元素或组件作为插槽内容。 如果内容是组件，该组件必须仅有一个根元素。 当 &amp;lt;Transition&amp;gt; 内元素被插入或移除时：
Vue 自动检测目标元素是否应用了 CSS 过渡或动画，添加/移除相应的 CSS class。 如果提供了 JavaScript 钩子，在适当时机被调用。 如果无 CSS 动画或 JS 钩子，DOM 插入/删除操作将在浏览器的下一个动画帧执行。 基于 CSS 的过渡效果CSS 过渡 class一共 6 个 class：
v-enter-from：进入起始状态。插入前添加，插入后下一帧移除。 v-enter-active：进入生效状态。插入前添加，过渡完成后移除。可定义进入动画的持续时间、延迟和速度曲线。 v-enter-to：进入结束状态。插入后下一帧添加，同时移除 v-enter-from，过渡完成后移除。 v-leave-from：离开起始状态。离开触发时立即添加，一帧后移除。 v-leave-active：离开生效状态。离开触发时立即添加，过渡完成后移除。可定义离开动画的持续时间、延迟和速度曲线。 v-leave-to：离开结束状态。离开触发后下一帧添加，同时移除 v-leave-from，过渡完成后移除。 v-enter-active 和 v-leave-active 可以为进入和离开动画指定不同速度曲线。
为过渡效果命名使用 name prop 声明过渡效果名。
命名过渡的 class 前缀使用该名字而不是 v。
CSS 过渡与动画CSS transition： …  ]]></content></entry><entry><title>5.2 TransitionGroup</title><url>/post/vue3/0502-transitiongroup/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  &lt;TransitionGroup&gt; 组件&lt;TransitionGroup&gt; 是一个内置组件，用于对 v-for 列表中的元素或组件的 插入、移除和顺序改变 添加动画效果。
和 &lt;Transition&gt; 的区别支持与 &lt;Transition&gt; 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器。
区别：
默认情况下不会渲染容器元素，可通过 tag prop 指定容器元素。 过渡模式不可用，因为不是在互斥元素之间切换。 列表中的每个元素都 必须 有独一无二的 key attribute。 CSS 过渡 class 作用在列表内元素上，而不是容器元素上。 当在 DOM 内模板中使用时，组件名需要写为 &lt;transition-group&gt;。
自定义过渡组 class通过 moveClass prop 可以为 移动元素 指定自定义过渡 class。类似于 自定义过渡 class。
渐进延迟列表动画实现方法：
将每个元素的 索引 渲染为该元素的 data attribute。 在 JavaScript 钩子中，基于元素的 data attribute，给该元素的 进场动画添加延迟。   ]]></content></entry><entry><title>4.1 组合式函数</title><url>/post/vue3/0401-%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  组合式函数组合式函数 (Composables)：利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。
无状态逻辑：接收输入并立即返回输出，例如格式化时间函数。
有状态逻辑：负责管理随时间变化的状态。
特点：
核心逻辑与组件中一致，只是移到外部函数并返回需要暴露的状态。 在组合式函数中可以使用所有的 组合式 API。 组合式函数可以嵌套调用，像组件一样组合成更复杂的逻辑。 接收响应式状态toValue()（Vue 3.3+）：将 ref 或 getter 规范化为值。
参数是 ref → 返回 ref 的值。 参数是函数 → 调用并返回函数结果。 否则 → 原样返回参数。 类似 unref()，但对函数有特殊处理。
约定和最佳实践命名使用驼峰命名法。以 use 开头。
输入参数组合式函数可以接收 ref 或 getter 作为参数。
最佳实践：
使用 toValue() 处理参数。 如果函数内创建了响应式 effect：使用 watch() 监视 ref 或 getter，或在 watchEffect() 中调用 toValue()。 返回值推荐返回一个包含多个 ref 的普通非响应式对象。
**原因：**保持解构后的响应性。若直接返回响应式对象，解构时会丢失响应性。
如果需要以对象属性形式使用状态，可以用 reactive() 包装返回对象。
副作用可以执行副作用（DOM 事件监听、请求数据），但需遵守：
SSR 应用中，必须在组件挂载后生命周期钩子中执行 DOM 相关副作用。 在 onUnmounted() 时清理副作用。 使用限制只能在 &amp;lt;script setup&amp;gt; 或 setup() 中调用。
必须同步调用（可在生命周期钩子如 onMounted() 中调用）。
限制原因：需要访问活跃的组件实例上下文，以便：
注册生命周期钩子。 注册计算属性和监听器并在卸载时清理。 特殊情况：&amp;lt;script setup&amp;gt; 支持在 await 之后调用组合式函数，编译器会恢复组件实例。
抽取组合式函数改善代码结构目的：不仅是复用，还能改善代码组织。
随着组件复杂度增加，组合式函数可以将逻辑拆分成更小的函数。
可以视作组件范围内的服务，相互之间可通信。
在选项式 API 中使用组合式函数组合式函数必须在 setup() 中调 …  ]]></content></entry><entry><title>4.2 自定义指令</title><url>/post/vue3/0402-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  自定义指令Vue 内置指令：如 v-model、v-show。
自定义指令：用于复用涉及普通元素的底层 DOM 访问逻辑。
与其他复用方式的比较：
组件：主要构建模块。 组合式函数：侧重有状态逻辑。 自定义指令：专注底层 DOM 操作逻辑。 自定义指令由一个包含类似组件生命周期钩子的对象来定义。
钩子函数接收指令绑定元素作为参数。
在 &lt;script setup&gt; 中：任何以 v 开头的驼峰命名变量都可作为自定义指令。
不使用 &lt;script setup&gt;：通过 directives 选项注册。
可在应用层级全局注册。
自定义指令的使用时机推荐：尽可能使用 v-bind 等内置指令。
自定义指令的使用场景：只有当功能只能通过直接 DOM 操作实现时才使用。
原因：内置指令更高效，对服务端渲染更友好。
指令钩子一个指令的定义对象可以提供以下钩子函数（均为可选）
const myDirective = { // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode) { // 下面会介绍各个参数的细节 }, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode) {}, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode) {}, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode) {}, };钩子参数el：指令绑定的元素，用于直接操作 DOM。
binding：对象，包含：
value：传递给指令的值。例如 v-my-directive=&quot;1 + 1&quot; → 值为 2。 oldValue：之前的值，仅 beforeUpdate 和 updated 可用。无论是否更改都存在。 arg：指令参数。例如 v-my-directive:foo → 参数为 &quot;foo&quot;。 modifiers：修饰符对象。例如 v-my-directive.foo.bar → { foo: true, bar: true }。 instance：使用该指令的组件实例。 dir：指令的定义对象。 vnode：绑定元素的 VNode。
prevVnode：之前渲染中的 VNode，仅 beforeUpdate 和 updated 可用。
注意事项：
除 el 外，其他参数只读，不可更改。 需在不同钩子间共享信息时，推荐通过元素的 dataset 实现。 自定义指令的参数也可为动态值。 简化形式若仅在 mounted 和 updated 中实现相同行为，可直接用函数定义指令。
对象字面量自定义指令可以接收多个值。
可以向指令传递 JavaScript 对象字面量。
指令可接收任意合法的 JavaScript 表达式。
在组件上使用不推荐：在组件上使用自定义指令。
行为：
当组件有单个根节点时，自定义指令会应用到根节点（类似透传 attributes）。 当组件有多个根节点时，指令会被忽略并抛出警告。 限制：指令不能像 attribute 一样通过 v-bind=&quot;$attrs&quot; 传递到其他元素。
  ]]></content></entry><entry><title>4.3 插件</title><url>/post/vue3/0403-%E6%8F%92%E4%BB%B6/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html">  插件插件 (Plugins)：一种能为 Vue 添加全局功能的工具代码。
插件形式：
一个拥有 install() 方法的对象 直接是一个安装函数本身 安装函数参数：
安装它的 应用实例 传递给 app.use() 的额外选项 插件的常见使用场景通过 app.component()和 app.directive() 注册一到多个全局组件或自定义指令。
通过 app.provide()使一个资源 可被注入进整个应用。
向 app.config.globalProperties 中添加一些全局实例属性或方法。
功能库（可能包含上述三种）：例如 vue-router。
注意事项：
谨慎使用全局属性。 如果在整个应用中由不同插件注入过多全局属性，会让应用难以理解和维护。 插件中的 Provide / Inject在插件中，可以通过 provide 为插件用户提供访问某个函数或属性的能力。
  </content></entry><entry><title>2.12 组件基础</title><url>/post/vue3/0212-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  组件概念组件：允许将 UI 划分为独立、可重用的部分，每个部分可单独思考。
结构：组件常常组织成层层嵌套的树状结构，类似于 HTML 元素的嵌套方式。
封装：Vue 提供组件模型，可在每个组件内封装自定义内容与逻辑。
兼容性：Vue 也能很好地配合原生 Web Component。
定义组件单文件组件 (SFC)：使用构建步骤时，将 Vue 组件定义在单独的 .vue 文件中。
对象定义：不使用构建步骤时，以包含 Vue 特定选项的 JavaScript 对象来定义组件。
模板方式：
使用内联 JavaScript 字符串，在运行时编译。 使用 ID 选择器指向一个元素（通常是 &amp;lt;template&amp;gt;），以其内容作为模板来源。 使用组件导入使用：
在父组件中导入子组件。 使用 &amp;lt;script setup&amp;gt; 时，导入的组件在模板中直接可用。 可全局注册组件，使其在应用中任意位置可用。 特点：
组件可被重复使用任意多次。 每次使用组件都会创建一个新的 实例，各自维护独立状态。 命名规范：
在 SFC 中，推荐使用 PascalCase 标签名以区分原生 HTML 元素。 模板编译可区分大小写。 可使用 /&amp;gt; 关闭标签。 DOM 内模板注意 ：必须使用 kebab-case 并显式关闭标签。
传递 propsProps 定义
是一种特殊的 attributes，需要在组件上声明注册。 使用defineProps 宏（仅 &amp;lt;script setup&amp;gt; 中可用，不需要导入）。 返回对象包含所有可传递的 props，自动暴露给模板。 不使用 &amp;lt;script setup&amp;gt; 时，需通过 props 选项声明，作为 setup() 第一个参数传入。 特点
组件可拥有任意数量的 props。 默认所有 props 接受任意类型值。 注册后的 prop 可通过自定义 attribute 传递数据。 监听事件父组件监听：通过 v-on 或 @ 监听子组件抛出的事件。
子组件抛出：
使用内置 $emit 方法传入事件名称抛出事件。 使用 defineEmits宏声明可能抛出的事件，可对事件参数进行验证。 使用说明
defineEmits： 仅 &amp;lt;script setup&amp;gt; 可用，无需导入。 返回等同于 $emit …  ]]></content></entry><entry><title>3.1 组件注册</title><url>/post/vue3/0301-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  一个 Vue 组件 在使用前需要先被 注册，这样 Vue 才能在渲染模板时找到对应的实现。
注册方式：
全局注册 局部注册 全局注册使用 Vue 应用实例的 .component() 方法，让组件在当前 Vue 应用中全局可用。
特点：
可以注册被导入的 .vue 文件。 .component() 方法支持链式调用。 全局注册的组件可在该应用的任意组件模板中使用。 所有子组件也能使用全局注册的组件，即这些子组件可以在 彼此内部使用。 局部注册全局注册的不足
Tree-shaking 无效：全局注册但未使用的组件不会被自动移除，即使未使用仍会出现在打包后的 JS 文件中。 依赖关系不明确：在大型项目中，父组件使用子组件时，不易定位子组件的实现，影响长期可维护性。 局部注册的特性
局部注册的组件必须在父组件中 显式导入，并且只能在该父组件中使用。 依赖关系更加明确。 对 tree-shaking 更加友好。 使用方式
在 &lt;script setup&gt; 的单文件组件中：导入的组件可以直接在模板中使用，无需注册。 未使用 &lt;script setup&gt; 时： 需要在 components 选项中显式注册。 每个 components 对象的 key 是组件名，value 是组件实现。 ⚠️ 注意：局部注册的组件在 后代组件中不可用。
组件名格式推荐使用 PascalCase 作为组件名注册格式。
原因：
PascalCase 是合法的 JavaScript 标识符，便于导入和注册，并且 IDE 能提供更好的自动补全。 &lt;PascalCase /&gt; 在模板中更明显地区分 Vue 组件与原生 HTML 元素或自定义元素 (Web Components)。 适用范围：
单文件组件 内联字符串模板 限制：PascalCase 标签名在 DOM 内模板 中不可用。
Vue 的支持：
模板中使用 kebab-case 标签时，可以解析为 PascalCase 注册的组件。 例如：注册名为 MyComponent 的组件，可以通过 &lt;MyComponent&gt; 或 &lt;my-component&gt; 使用。   ]]></content></entry><entry><title>3.2 Props</title><url>/post/vue3/0302-props/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Props 声明组件需要显式声明 props，Vue 才能区分外部传入的是 props 还是透传 attribute。
声明方式：
&amp;lt;script setup&amp;gt; 中使用 defineProps() 宏。 非 &amp;lt;script setup&amp;gt; 中使用 props 选项。 传递给 defineProps() 的参数与 props 选项的值相同，本质上使用的都是 props 选项。
声明形式：
字符串数组。 对象形式： key：prop 名称。 value：预期类型的构造函数。 优点： 一定程度上充当文档。 类型错误时会在浏览器控制台抛出警告。 TypeScript：在 &amp;lt;script setup&amp;gt; 中可使用 类型标注声明 props。
响应式 Props 解构Vue 响应系统基于属性访问跟踪状态。
在 &amp;lt;script setup&amp;gt; 中，解构的变量会自动加上 props. 前缀。
可使用 JavaScript 默认值语法声明 props 默认值。
Vue VSCode 插件可为解构 props 提供内联提示。
将解构的 props 传递到函数中解构的 prop 传入函数时，传递的是值而非响应式数据源。
Vue 会捕捉并警告此情况。
推荐：将其包装在 getter 中，以保持响应性。
外部函数可调用 getter（或使用 toValue）来追踪 prop 变更。
传递 prop 的细节Prop 名字格式长 prop 名：推荐使用 camelCase（合法的 JS 标识符，可直接在模板表达式中使用）。
实际传递时：通常写为 kebab-case，与 HTML attribute 对齐。
组件名推荐使用 PascalCase，提升可读性。
使用对象绑定多个 prop使用无参数的 v-bind 可将对象所有属性作为 props 传入。
单向数据流所有 props 遵循 单向绑定：
父组件更新 → 子组件接收新值。 子组件不能修改 prop，否则 Vue 会警告。 导致你想要更改一个 prop 的常见需求场景：
作为初始值：子组件需定义新的本地数据属性，并以 prop 初始化。
对传入值做转换：基于该 prop 定义计算属性。
对象 / 数组类型的 props子组件可以修改对象或数组内部的值（按引用传递）。
缺陷：可能导致 …  ]]></content></entry><entry><title>3.3 组件事件</title><url>/post/vue3/0303-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  触发与监听事件在组件模板表达式中，可以直接使用 $emit 方法触发自定义事件。
父组件通过 v-on（缩写为 @）监听事件。
事件监听器支持 .once 修饰符。
事件名提供了 自动格式转换。
触发时可用 camelCase。 父组件监听时可用 kebab-case。 推荐：在模板中使用 kebab-case 形式。
与原生 DOM 事件不同，组件触发的事件没有冒泡机制。只能监听直接子组件触发的事件。
平级或跨层组件通信：应使用 事件总线或全局状态管理方案。
事件参数触发事件时可以附带参数：
在 $emit 中传入额外参数。 父组件监听：
可用内联箭头函数接收参数。 可用组件方法作为事件处理函数接收参数。 结论：所有传入 $emit() 的参数都会直接传给监听器。
声明触发的事件组件可显式通过 defineEmits() 声明要触发的事件。
在 &lt;template&gt; 使用的 $emit，不能在 &lt;script setup&gt; 中使用；
defineEmits() 会返回一个同作用的函数供使用。
限制：只能在 &lt;script setup&gt; 顶级作用域中使用，不能放在子函数内。
使用 setup() 时：
需通过 emits 选项定义事件。 emit 函数在 setup() 上下文对象中被暴露，可安全解构。 emits 选项和 defineEmits() 支持 对象语法。可通过 TypeScript 为参数指定类型，进行参数验证。
在 &lt;script setup&gt; 搭配 TypeScript 时，可使用 纯类型标注声明事件。
虽然声明事件是可选的，但推荐完整声明所有触发的事件：
作为组件文档记录。 帮助 Vue 区分事件和透传 attribute。 避免第三方代码触发的自定义 DOM 事件导致边界问题。 若原生事件名（如 click）被定义在 emits 选项中，监听器只会监听组件触发的事件，不会再响应原生事件。
事件校验与 props 类型校验类似，事件也可使用对象语法进行描述。
校验方式：
将事件赋值为一个函数。 函数接收 emit 传入的参数。 返回布尔值：表示事件是否合法。 &lt;script setup&gt; const emit = defineEmits({ // 没有校验 click: null, // 校验 submit 事件 submit: ({ email, password }) =&gt; { if (email &amp;&amp; password) { return true; } else { console.warn(&#34;Invalid submit event payload!&#34;); return false; } }, }); function submitForm(email, password) { emit(&#34;submit&#34;, { email, password }); } &lt;/script&gt;  ]]></content></entry><entry><title>3.4 组件 v-model</title><url>/post/vue3/0304-%E7%BB%84%E4%BB%B6v-model/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  基本用法v-model 可以在组件上使用以实现双向绑定。
从 Vue 3.4 开始，推荐的实现方式是使用 defineModel() 宏。
defineModel() 返回的值是一个 ref：
.value 与父组件的 v-model 值同步； 子组件变更 .value 时，父组件绑定的值也会更新。 可以用 v-model 把这个 ref 绑定到原生 input 元素，实现包装。
&lt;script setup&gt; const model = defineModel(); function update() { model.value++; } &lt;/script&gt; &lt;template&gt; &lt;div&gt;Parent bound v-model is: {{ model }}&lt;/div&gt; &lt;button @click=&#34;update&#34;&gt;Increment&lt;/button&gt; &lt;/template&gt;底层机制defineModel 是一个便利宏，编译器会将其展开为：
一个名为 modelValue 的 prop，与本地 ref 的值同步； 一个名为 update:modelValue 的事件，在本地 ref 的值变更时触发。 Vue 3.4 之前的实现方式
&lt;script setup&gt; const props = defineProps([&#34;modelValue&#34;]); const emit = defineEmits([&#34;update:modelValue&#34;]); &lt;/script&gt; &lt;template&gt; &lt;input :value=&#34;props.modelValue&#34; @input=&#34;emit(&#39;update:modelValue&#39;, $event.target.value)&#34; /&gt; &lt;/template&gt;父组件中的 v-model=&quot;foo&quot; 将被编译为：
&lt;Child :modelValue=&#34;foo&#34; @update:modelValue=&#34;($event) =&gt; (foo = $event)&#34; /&gt;注意事项defineModel 声明了一个 prop。 可以通过传递选项给 defineModel 来声明底层 prop 的选项。 如果设置了 default 值且父组件没有提供该值，会导致父子组件不同步。 v-model 的参数组件上的 v-model 可以接受参数。
在子组件中，通过将字符串作为 第一个参数传递给 defineModel() 来支持相应的参数。
如果需要额外的 prop 选项，应在 model 名称之后传递。
多个 v-model 绑定利用参数和事件名，可以在单个组件实例上创建多个 v-model 双向绑定。
每个 v-model 会同步不同的 prop，且无需额外选项。
处理 v-model 修饰符获取修饰符通过解构 defineModel() 的返回值，可以在子组件中访问 v-model 的修饰符 &lt;script setup&gt; const [model, modifiers] = defineModel(); &lt;/script&gt; &lt;template&gt; &lt;input type=&#34;text&#34; v-model=&#34;model&#34; /&gt; &lt;/template&gt;基于修饰符调节可以给 defineModel() 传入 get 和 set 选项： get 在读取值时接收当前值，并返回处理后的新值。 set 在设置值时接收当前值，并返回处理后的新值。   ]]></content></entry><entry><title>3.5 透传 Attributes</title><url>/post/vue3/0305-%E9%80%8F%E4%BC%A0-attributes/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Attributes 继承透传 attribute：传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或 v-on 事件监听器。
常见例子：class、style、id。
当一个组件以单个元素为根渲染时，透传的 attribute 会自动添加到根元素上。
对 class 和 style 的合并如果子组件根元素已有 class 或 style，会与继承的值合并。
v-on 监听器继承同样规则适用于 v-on 事件监听器。
根元素自身的监听器与继承的监听器都会被触发。
深层组件继承透传的 attribute 不会包含父组件已声明的 props 或 emits 的 v-on 侦听函数，这些被父组件消费。 符合声明的透传 attribute，可以作为 props 传入子组件。 禁用 Attributes 继承设置 inheritAttrs: false 可禁用自动继承。
在 &lt;script setup&gt; 中可使用 defineOptions 设置。
使用场景：当 attribute 需要应用到根节点以外的其他元素时。设置 inheritAttrs: false 后，可完全控制透传 attribute 的使用。
模板中可用 $attrs 访问透传 attribute。
$attrs 包含除已声明的 props 和 emits 外的所有 attribute：包括 class、style、v-on 监听器等。
注意事项透传 attributes 在 JavaScript 中保留原始大小写。 v-on 事件监听器会暴露为函数，例如：$attrs.onClick。 使用没有参数的 v-bind，可将对象的所有属性作为 attribute 应用到目标元素上。 多根节点的 Attributes 继承多根节点组件没有自动 attribute 透传。
如果 $attrs 没有显式绑定，会抛出运行时警告。
显式绑定 $attrs 时，则不会有警告。
在 JavaScript 中访问透传 Attributes在 &lt;script setup&gt; 中可用 useAttrs() API 访问透传 attribute。
未使用 &lt;script setup&gt; 时，attrs 会作为 setup() 上下文对象的一个属性暴露。
注意事项attrs 对象总是反映最新的透传 attribute，但它不是响应式。 不能通过侦听器监听 attrs 的变化。 如果需要响应性： 使用 prop； 或使用 onUpdated() 在每次更新时结合最新的 attrs 执行副作用。   ]]></content></entry><entry><title>3.6 插槽 Slots</title><url>/post/vue3/0306-%E6%8F%92%E6%A7%BD-slots/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  插槽内容与出口&lt;slot&gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。
插槽内容可以是任意合法的模板内容，不局限于文本。可以传入多个元素，甚至是组件。
渲染作用域插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。
插槽内容无法访问子组件的数据。
Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则一致。
**换言之：**父组件模板中的表达式只能访问父组件的作用域。子组件模板中的表达式只能访问子组件的作用域。
默认内容在外部没有提供任何内容的情况下，可以为插槽指定默认内容。
如果我们提供了插槽内容，被显式提供的内容会取代默认内容。
具名插在一个组件中包含多个插槽出口时，可以为 &lt;slot&gt; 元素添加 name attribute，用来分配唯一 ID。
带 name 的插槽称为具名插槽 (named slots)。
没有提供 name 的 &lt;slot&gt; 出口会隐式地命名为 default。
使用方式：
为具名插槽传入内容时，需要使用带 v-slot 指令的 &lt;template&gt; 元素。 将目标插槽的名字传给该指令。 v-slot 有简写形式：#。 **注意：**当组件同时接收默认插槽和具名插槽时：所有位于顶级的非 &lt;template&gt; 节点都被隐式地视为默认插槽内容。
条件插槽可以通过 $slots 属性与 v-if 结合，来根据插槽是否被传入内容进行渲染。
动态插槽名v-slot 支持动态指令参数。表达式与动态指令参数遵循相同语法限制。
作用域插槽插槽内容可能需要同时使用 父组件域内 和 子组件域内 的数据，子组件在渲染时，可以将一部分数据提供给插槽。
实现方式：
可以像组件传递 props 那样，向插槽出口传递 attributes。 接收插槽 props 时： 默认插槽和具名插槽略有区别。 子组件标签上的 v-slot 指令会接收到一个插槽 props 对象。 插槽 props 可作为 v-slot 的值在插槽表达式中访问。 类比：
作用域插槽类似于传入子组件的函数。 子组件将 props 作为参数传入。 具名作用域插槽工作方式与默认作用域插槽类似。 插槽 props 可通过 v-slot:name=&quot;slotProps&quot; 访问。
如果同时使用具名插槽与默认插槽：
需要为默认插槽使用显式的 &lt;template&gt; 标签。 直接为组件添加 v-slot 指令会导致编译错误。 这是为了避免默认插槽 props 的作用域混淆。 无渲染组件一些组件只包含逻辑，不需要渲染内容，视图输出完全通过作用域插槽交给消费者组件，这种组件称为 无渲染组件。
注意：
大部分无渲染组件的功能可以通过 组合式 API 实现。 使用组合式 API 更高效，并且避免额外的组件嵌套开销。   ]]></content></entry><entry><title>3.7 依赖注入</title><url>/post/vue3/0307-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Prop 逐级透传问题当需要从父组件向子组件传递数据时，会使用 props。
如果组件层级很深，某个深层子组件需要祖先组件的数据，则必须逐级透传 props。这种情况被称为 “prop 逐级透传”，是我们希望避免的。
**解决方式：**使用 provide / inject：
父组件作为依赖提供者。 任意后代组件（无论层级多深）都可以注入该依赖。 Provide (提供)使用 provide()为组件后代提供数据。
如果不使用 &lt;script setup&gt;，必须在 setup() 中同步调用。
参数说明：
第一个参数：注入名
类型：字符串或 Symbol 作用：供后代组件查找依赖 一个组件可多次调用 provide()，使用不同注入名。 第二个参数：提供的值
类型：任意，包括响应式状态（如 ref） 作用：提供响应式状态时，后代组件可与提供者保持响应式联系。 应用层 Provide可以在整个应用层面提供依赖。
应用级提供的数据可被该应用内的所有组件注入。
特别适用于插件，因为插件通常不会使用组件形式提供值。
Inject (注入)使用 inject()注入上层组件提供的数据。
如果多个父组件提供了相同键，就近原则：解析为最近父组件的值。
注意：
如果提供的值是 ref：
注入的是 ref 对象本身，不会自动解包。 注入方组件可通过 ref 保持响应性链接。 如果不使用 &lt;script setup&gt;，必须在 setup() 内同步调用。
注入默认值默认情况下，如果注入名未被提供，会抛出运行时警告。
可以声明一个默认值，类似 props。
默认值可能需要通过函数或类初始化 → 可使用 工厂函数避免不必要的计算。
第三个参数：标识默认值应作为工厂函数使用。
和响应式数据配合使用建议：将响应式状态的变更保持在供给方组件中。状态声明与变更内聚在供给方 → 更易维护。
在注入方更改数据时：推荐由供给方提供更改数据的方法函数。
如果需要确保数据不可更改：使用 readonly() 包装提供的值。
使用 Symbol 作注入名在大型应用或组件库中，建议使用 Symbol 作为注入名，避免冲突。
推荐在单独文件中导出这些注入名 Symbol。
  ]]></content></entry><entry><title>3.8 异步组件</title><url>/post/vue3/0308-%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  基本用法在大型项目中，我们可能需要将应用拆分为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能。
defineAsyncComponent 接收一个返回 Promise 的加载函数：
resolve：在从服务器获得组件定义时调用。 reject(reason)：加载失败时调用。 ES 模块动态导入会返回 Promise，通常与 defineAsyncComponent 搭配使用。
构建工具（如 Vite、Webpack）支持动态导入，并会将其作为打包时的代码分割点，因此可用来导入 Vue 单文件组件。
**结果：**得到的组件是一个包装组件，仅在需要时才加载内部实际组件。
Props 和插槽会传递给内部组件，可以无缝替换原始组件。
异步组件与普通组件一样：
可以用 app.component() 全局注册。 也可以在父组件中直接定义。 加载与错误状态defineAsyncComponent() 支持高级选项来处理加载和错误状态：
const AsyncComp = defineAsyncComponent({ // 加载函数 loader: () =&gt; import(&#34;./Foo.vue&#34;), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000, });加载组件：在内部组件加载时显示。默认延迟 200ms 才展示，避免网络良好时闪烁。
报错组件：在加载器函数的 Promise 抛错时渲染。超时后（如超过 timeout 设置）也会渲染。
惰性激活 (Vue 3.5+)异步组件可以通过提供 激活策略 来控制何时进行激活。
Vue 提供了内置激活策略，需要单独导入（便于 tree-shake）。 保持在底层设计，未来可在框架或上层解决方案中提供语法糖。 在空闲时进行激活使用 requestIdleCallback
import { defineAsyncComponent, hydrateOnIdle } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnIdle(/* 传递可选的最大超时 */), });在可见时激活使用 IntersectionObserver
import { defineAsyncComponent, hydrateOnVisible } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnVisible(), });可传递侦听器的选项对象。
在媒体查询匹配时进行激活通过 媒体查询 控制
import { defineAsyncComponent, hydrateOnMediaQuery } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnMediaQuery(&#34;(max-width:500px)&#34;), });交互时激活在指定事件触发时激活
import { defineAsyncComponent, hydrateOnInteraction } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnInteraction(&#34;click&#34;), });可以是多个事件类型的列表。
激活完成后，触发的事件会被重放。
自定义策略通过自定义函数控制激活
import { defineAsyncComponent, type HydrationStrategy } from &#34;vue&#34;; const myStrategy: HydrationStrategy = (hydrate, forEachElement) =&gt; { // forEachElement 是一个遍历组件未激活的 DOM 中所有根元素的辅助函数， // 因为根元素可能是一个片段而非单个元素 forEachElement((el) =&gt; { // ... }); // 准备好时调用 `hydrate` hydrate(); return () =&gt; { // 如必要，返回一个销毁函数 }; }; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: myStrategy, });  ]]></content></entry><entry><title>2.10 侦听器</title><url>/post/vue3/0210-%E4%BE%A6%E5%90%AC%E5%99%A8/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  计算属性与副作用计算属性用于声明性地计算衍生值。但在某些情况下，需要在状态变化时执行副作用，例如：
更改 DOM 根据异步操作结果修改状态 在组合式 API 中，可以使用 watch 函数 在响应式状态发生变化时触发回调函数。
侦听数据源类型watch 的第一个参数可以是：
一个 ref（包括计算属性） 一个响应式对象 一个 getter 函数 多个数据源组成的数组 注意：不能直接侦听响应式对象的属性值，需要用返回该属性的 getter 函数。
深层侦听器直接传入响应式对象 → 隐式深层侦听器（所有嵌套变更都会触发）。
返回响应式对象的 getter → 仅在返回不同对象时触发。
可显式加上 deep: true 选项，强制为深层侦听器。
watch( () =&amp;amp;gt; state.someObject, (newValue, oldValue) =&amp;amp;gt; { // newValue 和 oldValue 相等 // 除非 state.someObject 被整个替换 }, { deep: true } );deep 可设为数字，表示最大遍历深度。
深度侦听会遍历所有嵌套属性，对大型数据结构开销大。只在必要时使用，并注意性能。
即时回调的侦听器watch 默认懒执行，仅在数据源变化时回调。
使用 immediate: true 可在创建侦听器时立即执行回调。
一次性侦听器默认：每次源变化时都会执行回调。
使用 once: true 可让回调仅执行一次。
watchEffect()用于简化依赖于相同响应式状态的侦听器。
自动跟踪回调中的响应式依赖，无需手动维护依赖列表。
对于嵌套数据结构，仅追踪被访问的属性，比深层侦听更高效。
依赖追踪限制：仅在同步执行期间生效。异步回调中，只有在第一个 await 之前访问到的属性会被追踪。
watch vs. watchEffectwatch：
只追踪明确指定的数据源。 不追踪回调中访问的其他内容。 仅在数据源确实改变时触发回调。 可精确控制回调触发时机。 watchEffect：
在副作用执行期间追踪依赖。 自动追踪所有访问到的响应式属性。 更方便简洁，但依赖关系可能不够明确。 副作用清理使用 onWatcherCleanup()注册清理函数，在侦听器失效并重新运行前调用。
调用限制： …  </content></entry><entry><title>2.11 模板引用</title><url>/post/vue3/0211-%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  模板引用 (ref)Vue 的声明性渲染模型抽象了大部分 DOM 操作，但有时仍需要直接访问底层 DOM 元素。 ref 是一个特殊的 attribute，允许在 DOM 元素或子组件实例被挂载后，获得对它的直接引用。 常见用途：
在组件挂载时将焦点设置到 input 元素 在元素上初始化第三方库 访问模板引用在组合式 API 中，可使用 useTemplateRef()获取引用。
使用 TypeScript 时，Vue 会根据模板中 ref attribute 的元素或组件，自动推断 input.value 的类型。
在 3.5 之前的版本，需要手动声明与模板中 ref 匹配的引用。
如果不使用 &lt;script setup&gt;，需从 setup() 返回 ref。
注意：
只能在组件挂载后访问模板引用。 如果侦听模板引用的变化，需要考虑其值可能为 null。 组件上的 ref模板引用也可以用在子组件上，此时引用的值是组件实例。
如果子组件：
使用 选项式 API 或
未使用 &lt;script setup&gt;
→ 那么被引用的组件实例与子组件的 this 一致，父组件可访问子组件的所有属性和方法。
⚠️ 这会导致父子组件之间的紧密耦合，应只在绝对需要时使用组件引用。常规情况下，应优先使用 props 和 emit 实现父子交互。
例外：
使用 &lt;script setup&gt; 的组件是默认私有的。 父组件无法访问其中任何内容，除非子组件通过 defineExpose 显式暴露。 defineExpose 必须在任何 await 操作之前调用，否则暴露的属性和方法无法访问。 v-for 中的模板引用在 v-for 中使用模板引用时，ref 的值是一个数组。
挂载后，数组包含整个列表对应的所有元素。
注意：ref 数组的顺序 不保证与源数组一致。
函数模板引用ref attribute 也可以绑定为一个函数。
在每次组件更新时，该函数都会被调用，并接收元素引用作为第一个参数。
需要使用 动态绑定 :ref 才能传入函数。
当绑定的元素被卸载时，函数也会被调用一次，此时参数 el 为 null。
可以绑定组件方法而不是内联函数。
  ]]></content></entry><entry><title>2.6 条件渲染</title><url>/post/vue3/0206-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-if用于条件性地渲染一块内容。内容只会在指令的表达式返回真值时才被渲染。
v-else为 v-if 添加一个“else 区块”。
必须紧跟在一个 v-if 或者 v-else-if 元素后面。否则不会被识别。
v-else-if作用：提供 v-if 的“else if 区块”。
特点：
可以连续多次使用。 必须紧跟在一个 v-if 或 v-else-if 元素后面。 &lt;template&gt; 上的 v-ifv-if 必须依附于某个元素。
如果需要切换多个元素，可以在 &lt;template&gt; 元素上使用 v-if。
&lt;template&gt; 是不可见的包装器，渲染结果中不会包含它本身。
v-else 和 v-else-if 也可以在 &lt;template&gt; 上使用。
v-show作用：按条件显示一个元素。
特点：
用法与 v-if 类似。 在 DOM 渲染中始终保留元素，仅通过切换 display CSS 属性控制显示。 限制：
不能在 &lt;template&gt; 元素上使用。 不能与 v-else 搭配使用。 v-if vs. v-showv-if：
是真实的条件渲染。 切换时，条件区块内的事件监听器和子组件会被销毁与重建。 惰性渲染：初次渲染时条件为 false，则不会渲染，只有首次为 true 时才渲染。 v-show：
元素无论初始条件如何，始终会被渲染。 仅切换 CSS display 属性。 结论：
v-if 切换开销更高。 v-show 初始渲染开销更高。 频繁切换时使用 v-show 更好；条件很少改变时用 v-if 更合适。 v-if 和 v-for优先级：当同时存在于一个元素时，v-if 会先执行。
结论：同时使用 不推荐，因为优先级不明显。
  ]]></content></entry><entry><title>2.7 列表渲染</title><url>/post/vue3/0207-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-for基于数组渲染列表。
语法：item in items
items：源数据数组 item：迭代项的别名 特点：
可以访问父作用域内的属性和变量。 可选的第二个参数表示当前项的索引。 支持在定义别名时使用解构。 多层嵌套时，作用域类似函数作用域，每个作用域可访问父级作用域。 of 可以替代 in，更接近 JavaScript 迭代器语法。 v-for 与对象可遍历对象的所有属性。
顺序：基于 Object.values() 的返回顺序。
参数：
第二个参数：属性名 第三个参数：索引 在 v-for 里使用范围值可以直接接受一个整数值。
效果：模板会基于 1...n 的取值范围重复渲染多次。
&lt;template&gt; 上的 v-for可在 &lt;template&gt; 标签上使用 v-for 来渲染包含多个元素的块。
v-for 与 v-if优先级：v-if 比 v-for 更高。 结果：v-if 的条件无法访问 v-for 的别名。 解决方法：在外层包装 &lt;template&gt; 并在其上使用 v-for。 结论：同时使用 不推荐，因优先级不明显。 常见情况： 过滤列表项： 示例：v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; 替代方案：使用新的计算属性（如 activeUsers）。 避免渲染隐藏的列表： 示例：v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; 替代方案：将 v-if 移至容器元素（如 ul、ol）。 通过 key 管理状态默认策略：Vue 按“就地更新”方式更新 v-for 渲染的元素，不移动 DOM 元素顺序。
适用场景：仅当渲染结果不依赖子组件状态或临时 DOM 状态（如表单值）。
提示机制：为每个元素提供唯一的 key 属性。
规则：
使用 &lt;template v-for&gt; 时，key 应放在 &lt;template&gt; 上。 推荐在可行时总是提供 key。 key 的值应为基础类型（字符串或 number），不要使用对象。 组件上使用 v-for用法：可以直接在组件上使用 v-for，需提供 key。
注意：
不会自动传递数据给组件，组件有自己独立作用域。 需通过 props 传递数据。 不自动注入 item 是为了避免组件与 v-for 耦合。 数组变化侦测变更方法Vue 能侦听以下数组方法，并触发更新：
push() pop() shift() unshift() splice() sort() reverse() 替换一个数组变更方法：直接修改原数组。
不可变方法：如 filter()、concat()、slice()，返回新数组，不修改原数组。
做法：使用新数组替换旧数组。
效率：Vue 会最大化 DOM 元素重用，即使新数组部分重叠，也高效。
展示过滤或排序后的结果需求：显示经过过滤或排序的数组，但不修改原始数据。
做法：使用计算属性返回过滤或排序后的数组。
注意：
reverse() 和 sort() 会修改原数组。 计算属性中不应直接修改原数组，应先创建副本再调用这些方法。   ]]></content></entry><entry><title>2.8 事件处理</title><url>/post/vue3/0208-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  监听事件可以使用 v-on 指令 (简写为 @) 监听 DOM 事件，并在事件触发时执行 JavaScript。
事件处理器的形式：
内联事件处理器：执行内联 JavaScript 语句（类似 onclick）。 方法事件处理器：指向组件上定义的方法的属性名或路径。 内联事件处理器通常用于简单场景
方法事件处理器适用场景：逻辑复杂时，使用方法代替内联代码。
特点：自动接收原生 DOM 事件并触发执行。
判断方式：模板编译器会检查 v-on 的值是否是合法的标识符或属性访问路径，以判断使用哪种形式。
在内联处理器中调用方法可以直接在内联事件处理器中调用方法。
作用：可传入自定义参数以替代原生事件。
在内联事件处理器中访问事件参数可通过特殊变量 $event 传入事件对象，或使用内联箭头函数。
事件修饰符目的：避免在方法中编写 event.preventDefault() 或 event.stopPropagation()，让方法更专注于数据逻辑。
修饰符：
.stop .prevent .self .capture .once .passive &amp;lt;!-- 单击事件将停止传递 --&amp;gt; &amp;lt;a @click.stop=&amp;#34;doThis&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 提交事件将不再重新加载页面 --&amp;gt; &amp;lt;form @submit.prevent=&amp;#34;onSubmit&amp;#34;&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;!-- 修饰语可以使用链式书写 --&amp;gt; &amp;lt;a @click.stop.prevent=&amp;#34;doThat&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 也可以只有修饰符 --&amp;gt; &amp;lt;form @submit.prevent&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&amp;gt; &amp;lt;!-- 例如：事件处理器不来自子元素 --&amp;gt; &amp;lt;div @click.self=&amp;#34;doThat&amp;#34;&amp;gt;...&amp;lt;/div&amp;gt;调用顺序：修饰符按声明顺序执行。
@click.prevent.self：阻止元素及其子元素所有点击的默认行为。 …  ]]></content></entry><entry><title>2.9 表单输入绑定</title><url>/post/vue3/0209-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-model定义：用于将表单输入框内容同步到 JavaScript 中的变量，避免手动绑定值和监听事件。
适用元素：可用于 &lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;。
绑定方式：
文本 &lt;input&gt; 和 &lt;textarea&gt;：绑定 value，侦听 input。 &lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt;：绑定 checked，侦听 change。 &lt;select&gt;：绑定 value，侦听 change。 注意：
v-model 会忽略元素上的初始 value、checked、selected 属性。 当前 JavaScript 状态始终是唯一数据来源。 初始值应通过响应式 API 在 JavaScript 中声明。 基本用法&lt;textarea&gt; 中不支持插值表达式，请使用 v-model。
单一复选框：绑定布尔值。
多个复选框：可以绑定到一个数组或 Set。
&lt;select&gt;：
如果初始值不匹配任何选项，则渲染为“未选择”状态。 在 iOS 上此情况可能导致用户无法选择第一项，因此建议提供一个空值的禁用选项。 选项可通过 v-for 动态渲染。 值绑定默认情况：
单选按钮、复选框、选择器的绑定值为静态字符串（复选框为布尔值）。 动态绑定：
使用 v-bind 可绑定组件实例上的动态数据。 支持绑定为非字符串的数据类型。 复选框true-value / false-value：
Vue 特有属性，仅能与 v-model 一起使用。 不影响 value 属性。 因为未选中复选框不会被提交，若需保证一定提交值，请使用单选按钮。 支持非字符串值绑定。
修饰符.lazy默认：每次 input 事件后更新数据（IME 拼字阶段除外）。
使用 .lazy：改为每次 change 事件后更新数据。
.number自动将输入转换为数字。
转换逻辑：
使用 parseFloat()，无法转换时返回原始值。 输入为空时，返回空字符串。 注意：当输入框 type=&quot;number&quot; 时，.number 修饰符会自动启用。
.trim自动去除用户输入内容两端的空格。
  ]]></content></entry><entry><title>1. 简介</title><url>/post/vue3/01-%E7%AE%80%E4%BB%8B/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  什么是 VueVue 是一个用于构建用户界面的 JavaScript 框架，基于标准的 HTML、CSS 和 JavaScript。它提供了一种声明式的、组件化的编程模型，旨在帮助开发高效的用户界面。
核心功能声明式渲染：Vue 通过模板语法，允许你声明式地描述 HTML 与 JavaScript 状态之间的关系。 响应性：Vue 会自动追踪 JavaScript 状态的变化，并且在其发生变化时，自动更新 DOM。 渐进式框架Vue 的设计注重灵活性，可以根据不同需求逐步集成。以下是几种使用 Vue 的方式：
增强静态 HTML，无需构建步骤。 作为 Web Components 嵌入任何页面。 构建单页应用（SPA）。 全栈开发/服务端渲染（SSR）。 Jamstack 和静态站点生成（SSG）。 开发桌面端、移动端、WebGL 或命令行终端界面。 单文件组件在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。
API 风格Vue 的组件有两种主要风格：选项式 API 和 组合式 API。
选项式 API (Options API)使用选项对象描述组件逻辑，如 data、methods 和 mounted。 所有选项定义的属性会暴露在组件的 this 上，this 会指向当前组件实例。 组合式 API (Composition API)通过导入 API 函数来描述组件逻辑。 在单文件组件中，通常与 &lt;script setup&gt; 搭配使用，setup 标记指示 Vue 在编译时处理组件逻辑。 &lt;script setup&gt; 中的导入和顶层变量/函数能在模板中直接使用。 API 风格对比与选择两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。
选项式 API 是在组合式 API 的基础上实现的，Vue 的基础概念和知识在两者间通用。
选项式 API：以“组件实例”为中心，更适合有面向对象语言背景的开发者，且抽象了响应性相关的细节。对初学者更友好。
组合式 API ：核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式灵活性更强，但需要对 Vue 的响应式系统有深入理解。适合处理复杂逻辑和组织/重用代码。
在生产项目中：
选项式 API：适用于不需要构建工具或在低复杂度场景下使用 Vue（如渐进增强的应用场景）。 组合式 API + 单文件组件：推荐用于构建完整的单页应用。   ]]></content></entry><entry><title>2.1 创建一个应用</title><url>/post/vue3/0201-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  应用实例每个 Vue 应用都是通过 createApp函数创建一个新的 应用实例。
传入 createApp 的对象实际上是一个 组件，每个应用都需要一个 根组件，其他组件将作为其子组件。
如果使用单文件组件，可以直接从另一个文件中导入根组件。
挂载应用应用实例必须调用 .mount() 方法后才会渲染。
.mount() 方法接收一个容器参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串。 根组件的内容将会渲染在容器元素内部，但容器元素本身 不会 被视为应用的一部分。 .mount() 方法应在整个应用配置和资源注册完成后调用。
不同于其他资源注册方法，.mount() 返回的是 根组件实例，而非应用实例。 DOM 中的根组件模板根组件的模板：通常是组件本身的一部分，也可以单独提供。
如果根组件没有设置 template 选项，Vue 会自动使用容器的 innerHTML 作为模板。 DOM 内模板：
通常用于 无构建步骤 的 Vue 应用程序。 也可以与 服务器端框架 一起使用，其中根模板可能由服务器动态生成。 应用配置应用实例暴露 .config 对象，用于配置应用级选项。
提供了一些方法，用于注册 应用范围内可用的资源。
确保在挂载应用实例之前完成所有应用配置！
多个应用实例Vue 允许创建多个应用实例，每个应用实例拥有自己的配置和全局资源作用域。
如果使用 Vue 增强服务端渲染 HTML，避免将一个 Vue 应用实例挂载到整个页面上。推荐创建多个小的应用实例，将它们分别挂载到所需的元素上。
  </content></entry><entry><title>2.2 模板语法</title><url>/post/vue3/0202-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Vue 使用基于 HTML 的模板语法，使我们能够声明式地将组件实例的数据绑定到 DOM 上。所有 Vue 模板都是语法层面合法的 HTML，可以被标准浏览器和 HTML 解析器解析。
Vue 会将模板编译为高度优化的 JavaScript 代码，结合响应式系统，能够智能推导需要重新渲染的组件，并尽量减少 DOM 操作。
如果你熟悉虚拟 DOM 并偏好使用 JavaScript，可以使用可选的 JSX 支持来手写渲染函数。但请注意，手写渲染函数将不会享受模板同等级别的编译时优化。
文本插值最基本的数据绑定形式是 文本插值，使用双大括号（Mustache 语法）
&amp;lt;span&amp;gt;Message: {{ msg }}&amp;lt;/span&amp;gt;双大括号会被替换为组件实例中 msg 属性的值。 每次 msg 改变时，会自动同步更新视图。 原始 HTML双大括号将数据作为纯文本处理，而不是 HTML。如果需要插入 HTML，请使用 v-html 指令：
&amp;lt;p&amp;gt;Using v-html directive: &amp;lt;span v-html=&amp;#34;rawHtml&amp;#34;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;v-html 指令会将元素的 innerHTML 与组件的 rawHtml 属性保持同步，插值为纯 HTML，数据绑定将会被忽略。 你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。 请谨慎使用 v-html，因为它容易导致 XSS 漏洞，仅在内容安全可信时使用，并且 永远不要使用用户提供的 HTML 内容。 Attribute 绑定双大括号不能在 HTML attributes 中使用。响应式绑定一个 attribute，应使用v-bind 指令。v-bind 也有简写语法：
&amp;lt;div v-bind:id=&amp;#34;dynamicId&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :id=&amp;#34;dynamicId&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :id&amp;gt;&amp;lt;/div&amp;gt;如果绑定的值是 null 或 undefined，该 attribute 将被从渲染的元素中移 …  ]]></content></entry><entry><title>2.3 响应式基础</title><url>/post/vue3/0203-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  声明响应式状态ref()在 Vue 的组合式 API 中，推荐使用 ref() 函数来声明响应式状态。
ref() 接收一个初始值，并将其包裹在一个具有 .value 属性的 ref 对象中返回
import { ref } from &amp;#34;vue&amp;#34;; const count = ref(0); console.log(count); // { value: 0 } console.log(count.value); // 0 要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们
在组件模板中访问 ref 时，不需要附加 .value，Vue 会自动解包。 你可以在事件监听器中修改 ref 的值。 对于更复杂的逻辑，可以在同一作用域内声明修改 ref 的函数，并将它们作为方法公开给模板。这样可以在事件监听器中使用这些方法。
&amp;lt;script setup&amp;gt;使用 &amp;lt;script setup&amp;gt; 可以大幅简化代码，避免手动暴露大量状态和方法。
&amp;lt;script setup&amp;gt; 中的顶层导入、变量和函数在同一组件的模板中可以直接使用。
为什么要使用 ref？ref 允许 Vue 自动检测变化并更新 DOM。这是通过 Vue 的响应式系统实现的。
Vue 使用 getter 和 setter 方法来拦截对 ref 的访问和修改，进而进行依赖追踪和触发更新。
ref 作为一个对象，具有 .value 属性：
// 伪代码，不是真正的实现 const myRef = { _value: 0, get value() { track(); return this._value; }, set value(newValue) { this._value = newValue; trigger(); }, };通过 ref，你可以将值传递给函数并保持响应式连接。当逻辑重构为可重用代码时，ref 是非常有用的。
深层响应性ref 可以持有任何类型的值，包括嵌套的对象、数组等。
ref 会使它的值具有深层响应性，即使对象内部发生变化也会被检测到。
非原始值将通过 reactive() 转换为响应式代理。
使用 shallowRef 可以避免深层响应性，适用于优化性能或外部库管理其内部状态的情况。
DOM 更新时机 …  ]]></content></entry><entry><title>2.4 计算属性</title><url>/post/vue3/0204-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  计算属性在模板中直接使用表达式虽然方便，但处理复杂逻辑时会使模板臃肿，难以维护。为了避免重复计算和提高代码可维护性，推荐使用 计算属性 来描述依赖响应式状态的复杂逻辑。
computed() 方法computed() 接受一个 getter 函数，该函数会根据响应式状态返回计算结果。 返回值为一个 计算属性 ref，你可以通过 .value 来访问其值。在模板中引用时，无需加 .value，它会自动解包。 计算属性会自动追踪响应式依赖，当依赖的响应式状态变化时，计算属性会自动重新计算。
计算属性缓存 vs 方法计算属性值会缓存，仅在其响应式依赖更新时重新计算。
如果你将相同的计算逻辑放入方法中，方法每次渲染时都会重新执行，即使计算逻辑没有变化。
因此，计算属性的效率较高，尤其在涉及重复计算时。
可写计算属性计算属性默认是只读的。当尝试修改一个计算属性时，会收到一个运行时警告。你可以通过提供 getter 和 setter 来创建一个 可写计算属性，允许计算属性具有读写能力。
get 用于返回计算属性的值，set 用于修改源状态。
获取上一个值如果需要获取计算属性返回的 上一个值，可以通过访问计算属性 getter 函数的第一个参数来实现。
最佳实践Getter 不应有副作用计算属性的 getter 只应做计算，没有副作用。 不要在 getter 中改变其他状态、发起异步请求或更改 DOM。 计算属性的职责是根据其他状态计算出一个派生值，getter 应仅计算并返回该值。 避免直接修改计算属性值计算属性返回的值是派生状态，应该视为 只读。 更改计算属性的返回值没有意义，应该更新其依赖的源状态来触发新的计算。   </content></entry><entry><title>2.5 class与style绑定</title><url>/post/vue3/0205-class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/</url><categories><category>Vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-bind: 用于将 HTML 元素的属性（包括 class 和 style）与动态数据绑定。
特殊增强: Vue 为 class 和 style 的 v-bind 提供了特殊功能，除了字符串，表达式的值也可以是对象或数组。
绑定 HTML class绑定对象使用 :class（v-bind:class 的缩写）可以绑定一个对象，根据对象的键值对动态地控制 class。
&lt;div :class=&#34;{ active: isActive }&#34;&gt;&lt;/div&gt;上面的语法表示 isActive 为 true 时，active 类会被添加；如果为 false，则移除该类。
可以在对象中定义多个类，按需控制多个类的添加或移除。
:class 指令可以与常规的 class attribute 共存。
绑定的对象不一定需要是内联的，可以直接绑定一个数据对象或计算属性。
绑定数组:class 可以绑定一个数组来渲染多个 CSS class。
可以在数组中使用三元表达式来实现有条件地渲染某个 class。为了避免冗长，可以在数组中嵌套对象来处理有多个依赖条件的 class。
在组件上使用当在组件上使用 class attribute 时，这些 class 会被添加到根元素上，并与该元素已有的 class 合并。
如果组件有多个根元素，可以通过组件的 $attrs 属性指定接收 class 的元素
绑定内联样式绑定对象:style 支持绑定 JavaScript 对象值，对应 HTML 元素的 style 属性。
推荐使用 camelCase 来命名样式属性，但 :style 也支持 kebab-case 形式的属性名。
绑定一个样式对象通常是好主意，可以使模板更简洁。
如果样式对象需要更复杂的逻辑，可以使用返回样式对象的计算属性。
:style 指令可以和常规的 style attribute 共存。
绑定数组:style 可以绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上。
自动前缀如果你在 :style 中使用需要浏览器特殊前缀的 CSS 属性，Vue 会自动为这些属性添加相应的前缀。
Vue 会在运行时检测浏览器支持的属性，并为不支持的属性自动加上浏览器前缀。
样式多值你可以为某个样式属性提供多个值，Vue 会渲染出当前浏览器支持的值。
&lt;div :style=&#34;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&#34;&gt;&lt;/div&gt;  ]]></content></entry><entry><title>4.1 原始值与引用值</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0401-%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  原始值与引用值ES 变量可包含两种数据类型：原始值和引用值，二者在存储、访问、复制等行为上存在本质差异。
基本定义与访问方式原始值：最简单的数据，对应 ES 六大基本数据类型（Undefined、Null、Boolean、Number、String、Symbol）。
保存原始值的变量按值访问，操作的是变量中存储的实际值。 引用值：由多个值构成的对象（如 Object、Array、Function 等）。
引用值保存在内存中，JS 无法直接操作内存空间，实际操作的是对象的引用（地址），保存引用值的变量按引用访问。 动态属性引用值：可随时添加、修改、删除其属性和方法，示例： let obj = {}; obj.name = &amp;#34;Alice&amp;#34;; // 新增属性 obj.age = 20; // 修改属性 delete obj.age; // 删除属性 原始值：不能有属性，尝试添加属性不会报错，但属性无法生效，示例： let str = &amp;#34;hello&amp;#34;; str.length = 10; // 无报错，但属性不生效 console.log(str.length); // 仍为 5（字符串原始值的内置 length 属性不受此影响） 特殊初始化：原始类型可通过原始字面量（如 let num = 10）初始化；若用 new 关键字（如 let num = new Number(10)），JS 会创建 Object 实例，但行为类似原始值。 复制值原始值复制：将原始值从一个变量赋给另一个变量时，原始值会被完整复制到新变量，两个变量独立（修改一个不影响另一个），示例： let a = 10; let b = a; // b 复制 a 的值（10） b = 20; console.log(a); // 10（a 不受 b 修改影响） 引用值复制：将引用值从一个变量赋给另一个变量时，复制的是指向堆内存对象的指针，两个变量指向同一个对象（修改一个会影响另一个），示例： let obj1 = { name: &amp;#34;Bob&amp;#34; }; let obj2 = obj1; // obj2 复制 obj1 的引用（指向同一对象） obj2.name = &amp;#34;Charlie&amp;#34;; console.log(obj1.name); // …  ]]></content></entry><entry><title>4.3 垃圾回收</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0402-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag><tag>性能优化</tag></tags><content type="html">  垃圾回收基础JS 是自动垃圾回收语言，执行环境负责代码运行时的内存管理（自动分配内存、回收闲置资源）。核心逻辑是：周期性判断“不再使用的变量”，释放其占用的内存（垃圾回收程序每隔一定时间自动运行）。
常见垃圾回收算法标记清理当前 JS 引擎最主流的垃圾回收算法，核心步骤如下：
标记阶段： 变量进入上下文（如函数内声明变量）时，标记为“存在于上下文”； 变量离开上下文（如函数执行完毕）时，标记为“离开上下文”； 垃圾回收程序运行时，先标记内存中所有变量。 清理阶段： 移除“存在于上下文的变量”及“被其引用的变量”的标记； 剩余带标记的变量=“无法被上下文访问的变量”，视为待回收； 销毁待回收变量，释放其内存。 引用计数早期算法，因缺陷已较少使用，核心逻辑是“通过引用次数判断变量是否可回收”：
计数规则： 声明变量并赋值引用值时，该值的引用数=1； 同一值被赋给其他变量，引用数+1； 保存该值引用的变量被覆盖（如赋值其他值），引用数-1。 回收时机：当值的引用数=0 时，下次垃圾回收程序运行时释放其内存。 核心缺陷：循环引用
若对象 A 引用对象 B，对象 B 同时引用对象 A，二者引用数永远不会变为 0，导致内存无法回收（如早期 COM 对象场景）。 解决方案：不再使用时，主动切断引用（如用 null 覆盖变量，示例：objA = null; objB = null）。 主动内存管理优化内存占用的核心是“只保留必要数据”，关键手段如下：
解除引用
数据不再必要时，将其赋值为 null，释放引用（让垃圾回收程序可识别为待回收）。 适用场景：全局变量/全局对象属性（局部变量超出作用域后会自动解除引用）。 注意：解除引用不代表立即回收内存，仅确保值“脱离上下文”，等待下次垃圾回收。 通过 const 和 let 提升性能 const/let 是块级作用域，变量在块执行完毕后更快脱离上下文，垃圾回收程序可更早回收内存； 对比 var（函数/全局作用域），减少内存占用时长。 隐藏类与性能优化（以 V8 引擎为例）V8 引擎通过“隐藏类”跟踪对象属性特征，共享相同隐藏类的对象性能更优（减少属性查找开销）。
隐藏类的共享条件对象需满足“相同构造函数+相同原型”，示例：
function Article() { this.title = &amp;amp;#34;Ingauration …  </content></entry><entry><title>3.4 操作符</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0304-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  ECMA-262 描述了一组可用于操作数据值的操作符，ES 中的操作符可用于各种值，在应用给对象时，操作符通常会调用 valueOf() 或 toString() 方法来取得可以计算的值
一元操作符只操作一个值的操作符叫一元操作符
递增递减操作符前缀递增操作符：给数值加 1，语法为 ++变量；前缀递减操作符：从数值减 1，语法为 --变量；无论使用前缀递增还是前缀递减，变量的值都会在语句被求值之前改变。 递增和递减的后缀版：语法分别是 变量++ 和 变量--，与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。 适用范围：这四个操作符可用于任何值（字符串、布尔值、浮点值、对象等），遵循如下规则： 字符串：若为有效的数值形式，转换为数值再应用改变，变量类型由字符串变为数值；若不是有效的数值形式，变量值设为 NaN，类型由字符串变为数值。 布尔值：若为 false，转换为 0 再应用改变；若为 true，转换为 1 再应用改变，变量类型均由布尔值变为数值。 浮点值：直接加 1 或减 1。 对象：调用其 valueOf() 方法取得可操作的值，对该值应用上述规则；若结果为 NaN，则调用 toString() 并再次应用其他规则，变量类型由对象变为数值。 一元加和减一元加：由一个加号 + 表示（语法：+变量），对数值无影响；若应用到非数值，会执行与 Number() 转型函数相同的类型转换。 一元减：由一个减号 - 表示（语法：-变量），主要用于把数值变为负值；若应用到非数值，会先执行与 Number() 转型函数相同的类型转换，再取负值。 位操作符有符号整数存储规则：使用 32 位，前 31 位表示整数值，第 32 位为符号位（0 表示正，1 表示负）；正值以二进制格式存储（31 位中每一位代表 2 的幂，空位以 0 填充）；负值以二补数（补码）存储，计算步骤为：
确定绝对值的二进制表示；
求一补数（反码，0 变 1、1 变 0）；
给结果加 1。
处理有符号整数：无法直接访问第 31 位，ES 会记录相关信息；将负值输出为二进制字符串时，会得到前面加了减号的绝对值（转换过程先求二补数，再以逻辑形式表示）。
后台转换逻辑：对 ES 中的数值应用位操作符时，64 位数值先转换为 32 位数值，执行位操作后，再将结果从 32 位转换为 64 位存储（过程如 …  </content></entry><entry><title>3.1 语法</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0301-%E8%AF%AD%E6%B3%95/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  ES 基础语法规则大小写敏感性ES 中所有内容（变量名、函数名、操作符等）均区分大小写（如num与Num是两个不同变量）。
标识符规则标识符是变量、函数、属性或参数的名称，需满足：
首字符：必须是字母（a-z/A-Z）、下划线（_）或美元符号（$）； 后续字符：可增加数字（0-9）； 字符范围：支持扩展 ASCII 字母和 Unicode 字母（如中文变量名，但不推荐，惯例用英文）； 命名惯例：采用小驼峰式（如userName、calculateTotal）； 禁用情况：不能使用关键字、未来保留字，也不能用true、false、null作为标识符。 注释方式采用 C 语言风格注释，分两种：
单行注释：以//开头，注释范围仅限当前行（如// 这是单行注释）； 块注释：以/*开头、*/结尾，可跨多行（如/* 这是跨多行的块注释 */）。 严格模式定义：一种严格的 JS 解析/执行模型，禁用 ES3 不规范写法，对不安全操作抛错； 启用方式： 全局启用：在脚本开头加&amp;quot;use strict&amp;quot;;（预处理指令）； 函数内启用：在函数体开头加&amp;quot;use strict&amp;quot;;； 核心目的：避免语法歧义，提升代码安全性和规范性。 语句规则分号结尾：语句需以分号（;）结束，省略时由解析器自动补全（但不推荐，可能导致语法错误）； 代码块：多条语句可包裹在花括号（{}）中形成代码块； 最佳实践：即使控制语句（如if、for）仅执行一条语句，也建议用代码块（{}）包裹，避免逻辑歧义。 关键词与保留字关键词定义：ECMA-262 保留的有特殊用途的词汇（如if、for、function、return等），用于控制语句、声明变量等； 限制：不能用作标识符或属性名（如不能定义let if = 1;）。 未来保留字定义：当前无特殊用途，但预留为未来版本关键字的词汇（如class、enum、export等，早期 ES 版本中部分已成为关键字）； 限制：不能用作标识符，虽部分可暂作属性名，但不推荐使用（避免兼容未来版本）。 ES 函数基础函数声明用function关键字声明，结构为：function 函数名(参数列表) { 函数体 }，示例：
// 声明一个计算两数和的函数 function add(num1, num2) { return …  ]]></content></entry><entry><title>3.2 变量</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0302-%E5%8F%98%E9%87%8F/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  变量声明：var、let、const 的核心差异变量是 JS 中保存数据的命名占位符，ES 提供 var、let、const 三种声明方式，核心差异体现在作用域、提升行为、可修改性上。
var 关键字（ES5 及之前）作用域：函数作用域（若在函数外声明则为全局作用域），无块级作用域（如 if/for 块内声明的 var 变量可在块外访问）。 初始化与类型： 可单独声明（var a;）或声明时赋值（var a = 1;）； 松散类型，可后续修改值的类型（如 a = &amp;amp;quot;hello&amp;amp;quot;）。 变量提升：var 声明的变量会自动提升到函数作用域顶部（仅声明提升，赋值不提升），示例： console.log(a); // undefined（声明提升，赋值未提升） var a = 1;全局变量特性：在全局作用域声明的 var 变量，会成为 window 对象的属性（如 var a = 1; console.log(window.a); // 1）。 重复声明：允许同一作用域内重复声明（如 var a = 1; var a = 2; 不报错，后者覆盖前者）。 函数内声明： 函数内用 var 声明的变量为局部变量（函数退出时销毁）； 省略 var 则为全局变量（不推荐，易污染全局作用域）。 严格模式限制：不可声明名为 arguments 或 eval 的变量。 let 声明（ES6+）作用域：块级作用域（{} 包裹的区域，如 if、for、函数块），块外无法访问。 重复声明：同一作用域内不允许重复声明（如 let a = 1; let a = 2; 报错），且与 var 混用时也报错（var a = 1; let a = 2; 报错）。 暂时性死区（TDZ）：let 声明的变量无变量提升，在声明语句之前的区域称为“暂时性死区”，引用变量会报错： console.log(a); // 报错（暂时性死区） let a = 1;全局变量特性：全局作用域声明的 let 变量，不会成为 window 对象的属性（如 let a = 1; console.log(window.a); // undefined），但仍在全局作用域存续。 for 循环特殊行为：let 声明的迭代变量（如 for (let i = 0; i &amp;amp;lt; 3; i++)），JS 引擎会为每个 …  </content></entry><entry><title>3.3 数据类型</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0303-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  数据类型分类简单数据类型（原始类型）：undefined、null、Boolean、number、string、symbol 复杂数据类型：object（一种无序名值对） ES 数据类型特性：灵活，一种数据类型可当作多种数据类型使用 typeof 操作符返回值：返回下列字符串之一——undefined、Boolean、string、number、object、function、symbol 语法示例： typeof message typeof(message) typeof 96 特性： 是操作符而非函数，无需参数，但可使用参数 调用 typeof null 返回 object（因 null 被视为空对象引用） 函数在 ES 中属对象，非独立数据类型，但因有特殊属性，typeof 可区分函数与其他对象 undefined 类型取值：仅一个值——undefined 赋值场景：用 var 或 let 声明变量但未初始化，变量默认赋予 undefined 值 使用建议： 无需显式给变量设 undefined 值，字面量 undefined 主要用于比较 ES3 前无 undefined，新增目的是明确空对象指针与未初始化变量的区别 变量区别： 包含 undefined 值的变量 ≠ 未定义变量 对未声明变量，仅有用操作是调用 typeof；调用 delete 不报错（无实际作用，严格模式下报错） 未初始化与未声明变量，typeof 均返回 &amp;amp;ldquo;undefined&amp;amp;rdquo; 初始化建议：声明变量时同时初始化，以便通过 typeof 返回 undefined 判断变量未声明（非未初始化） 布尔特性：undefined 是假值，可简洁检测 null 类型取值：仅一个值——null，表空对象指针 typeof 结果：调用 typeof null 返回 object 使用建议：定义将来存对象值的变量时，用 null 初始化（非其他值），便于后续检查变量是否重新赋予对象引用 与 undefined 关系： undefined 由 null 派生，== 比较二者始终返回 true（操作符会转换操作数） 用途不同：无需显式设变量为 undefined，但存对象的变量无对象可存时需设为 null 布尔特性：null 是假值，可简洁检测 Boolean 类型字面 …  </content></entry><entry><title>第二章 HTML中的JS</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0201-html%E4%B8%AD%E7%9A%84js/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>HTML</tag><tag>性能优化</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  script 元素将 JavaScript 插入 HTML 的主要方法是使用 script 元素。使用方式有两种：
在网页中嵌入行内 JavaScript 代码
在网页中包含外部 JavaScript 文件
行内脚本行内脚本：直接将代码放在 &amp;lt;script&amp;gt; 元素中。
执行顺序：代码会从上到下依次执行。
阻塞特性：在 &amp;lt;script&amp;gt; 元素中的代码被计算完成之前，页面的其余内容不会被加载或显示。
行内代码中不能出现字符串 &amp;lt;/script&amp;gt;。如果必须出现，需使用转义字符 \，即 \&amp;lt;\/script&amp;gt;。
外部脚本外部脚本：使用 src 属性指定外部文件的 URL。
文件只需包含要放在 &amp;lt;script&amp;gt; 起始和结束标签之间的 JavaScript 代码。
阻塞特性：解释外部脚本文件时，页面同样会阻塞。
扩展名：外部文件的扩展名（如 .js）不是必须的。
行内与外部互斥：使用了 src 属性的 &amp;lt;script&amp;gt; 元素中不应再包含行内代码。浏览器只会下载并执行外部脚本，忽略行内部分。
跨域加载： &amp;lt;script&amp;gt; 的 src 可为完整 URL，指向不同域的资源。请求不受同源策略限制，但返回内容的执行受限。请求仍受页面 HTTP/HTTPS 协议 限制。 外部域代码被当作加载页面的一部分来执行。
执行顺序：不论代码来源，浏览器都会按 &amp;lt;script&amp;gt; 在页面中出现的顺序依次解释。前提是 未使用 defer 和 async 属性。
标签位置现代 Web 应用程序通常将所有 &amp;lt;script&amp;gt; 引用放在 &amp;lt;body&amp;gt; 元素中内容的末尾。这样页面会在处理 JavaScript 代码之前完成渲染。
推迟执行脚本作用：脚本执行时不会改变页面结构。即脚本会被延迟到整个页面解析完毕后再运行。
机制：浏览器会立即下载脚本，但延迟执行，在 DOMContentLoaded 事件之前执行。
defer 属性仅对 外部脚本文件 有效。
异步执行脚本作用：浏览器无需等待脚本下载和执行即可继续加载页面。
特性：
脚本间执行顺序不确定，不保证按照出现顺序执行。 脚本会在 load 事件前执行，但可能在 DOMContentLoaded 之前或之后。 启用 async 后表示 …  ]]></content></entry><entry><title>第一章 什么是JS</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0101-%E4%BB%80%E4%B9%88%E6%98%AFjs/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>DOM</tag><tag>BOM</tag><tag>前端开发</tag></tags><content type="html">  完整的 JavaScript 实现包含三部分：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）
ECMAScriptECMAScript 没有输入和输出的方法。ECMA-262 将这门语言定义为一个基准标准，便于在其之上构建更完善的脚本语言。
Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境。宿主环境提供 ECMAScript 的基准实现与环境交互的扩展，这些扩展使用 ECMAScript 的核心类型和语法，提供环境特定的功能。
在基本层面上，ECMAScript 描述了语言的语法、类型、语句、关键字、保留字、操作符和全局对象。
ECMAScript 是语言规范的名称，JavaScript 实现了 ECMAScript。
ES 符合性要成为 ECMAScript 实现，必须满足以下条件：
支持 ECMA-262 所描述的所有类型、值、对象、属性、函数以及程序语法与语义。 支持 Unicode 字符标准。 此外，符合性实现还可以满足以下要求：
增加 ECMA-262 中未提及的额外类型、值、对象、属性和函数。 支持 ECMA-262 中未定义的程序和正则表达式语法。 ES 版本第一版：基本与网景 JavaScript 1.1 相同；删除浏览器特定代码；要求支持 Unicode 字符标准；对象需与平台无关。
第二版：仅为符合 ISO/IEC-16262 标准进行编校；无特性增减或变化。
第三版：更新字符串处理、错误定义、数值输出；增加正则表达式、新控制语句、try...catch 异常处理；进行了国际化修改。
第四版：在发布前被放弃。
第五版：解决第三版歧义；增加新功能：原生 JSON 解析与序列化；继承与高级属性定义方法；严格模式。
第六版：正式支持：类、模块；迭代器、生成器；箭头函数；期约（Promise）；反射与代理；新的数据类型。
第七版：少量语法增强：Array.prototype.includes；指数操作符。
第八版：新增：异步函数；SharedArrayBuffer 与 Atomics API；Object.values()、Object.entries()、Object.getOwnPropertyDescriptors()；字符串填充方法；支持对象字面量最后的逗号。
第九版：新增：异步迭代；剩余 …  </content></entry></search>