<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>2.13 - 2.14 复杂语句符号化</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0205-%E5%A4%8D%E6%9D%82%E8%AF%AD%E5%8F%A5%E7%AC%A6%E5%8F%B7%E5%8C%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html"><![CDATA[  日常语句符号化的核心原则：语法结构与逻辑结构的对应日常语句的语法结构（如联结词、标点）往往直接反映其逻辑结构，符号化的核心是将语法联结词替换为逻辑符号，同时确保逻辑含义与原语句完全一致。
复杂语句符号化的四步实操方法第一步：定位主联结词——符号化的“突破口”主联结词是决定整个语句逻辑类型的核心联结词（如“并且”“如果&amp;hellip;那么&amp;hellip;”“或”），找到它就能将复杂语句拆分为更小的支语句。
关键技巧： 关注语句开头：很多语句的主联结词直接出现在句首（如“如果明天晴天，我们就去公园”，主联结词是开头的“如果&amp;hellip;就&amp;hellip;”，对应逻辑符号“⊃”）。 区分“转折词的位置”： 转折词（如“但是”“然而”“不过”）出现在句首时，通常无真值函数意义（仅表语气转折），符号化时直接忽略（如“不过，小明今天没迟到”，实际逻辑是“小明今天没迟到”，符号化为“~A”，“不过”可忽略）； 转折词出现在语句中间时，等价于真值函数的“并且（·）”（如“小明很努力，但是没考好”，逻辑是“小明很努力且没考好”，符号化为“A·~B”）。 第二步：利用标点符号——确定支语句的边界逗号（,）、分号（;）是划分支语句的重要标志，通常对应逻辑符号中的“括号”，需将标点分隔的两部分分别置于主联结词两侧。
示例： 语句：“小明喜欢数学，小红喜欢英语”——逗号分隔两个支语句，主联结词是隐含的“并且”，符号化为“A·B”（A：小明喜欢数学，B：小红喜欢英语）； 语句：“如果明天不加班，我们去看电影；否则，我们在家做饭”——分号将语句分为“如果不加班则看电影”和“如果加班则在家做饭”，主联结词是“并且”，整体符号化为“(~A⊃B)·(A⊃C)”（A：明天加班，B：去看电影，C：在家做饭）。 第三步：分而治之——拆解支语句（递归应用符号化技巧）找到主联结词并拆分出支语句后，对每个支语句重复第一步和第二步：定位支语句的主联结词、利用标点划分更小的支语句，直到拆解为不可再分的原子语句。
示例（复杂语句）：“如果小明参加比赛并且小红当裁判，那么小李会来加油或小张会帮忙” 找主联结词：句首的“如果&amp;hellip;那么&amp;hellip;”（⊃），将语句拆为前件“小明参加比赛并且小红当裁判”和后件“小李会来加油或小张会帮忙”； 拆解前件：主联结词是“并且（·）”，拆为原子语句 A（小明参加 …  ]]></content></entry><entry><title>2.10 - 2.12 条件句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0204-%E6%9D%A1%E4%BB%B6%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>条件句</tag><tag>逻辑符号化</tag></tags><content type="html"><![CDATA[  实质条件句（“如果&amp;hellip;那么&amp;hellip;”）核心定义与结构定义：用联结词“如果&amp;hellip;那么&amp;hellip;”联结两个原子语句构成的复合语句，逻辑中用符号“⊃”（马蹄符）表示，形式为“前件 ⊃ 后件”（如“如果 A，那么 B”符号化为“A⊃B”）。 结构：“如果”后的语句为前件（如 A），“那么”后的语句为后件（如 B）。 真值规则（实质蕴含的核心）实质条件句“A⊃B”是真值函数联结词，仅当“前件真且后件假”时，整体为假；其余三种情况（前真后真、前假后真、前假后假）均为真。具体可概括为：
若前件真而后件假，则实质条件句为假；否则为真
前件（A） 后件（B） A⊃B（实质条件句） T T T T F F F T T F F T 与日常条件句的差异日常条件句常隐含“前件与后件的关联”（如因果、逻辑推导），而实质条件句仅关注真值组合，不要求前后件有实际关联（如“如果 2+2=5，那么太阳从西边升起”，虽前后无关联，但因前件假，实质条件句仍为真）。 实质条件句是“最弱的条件句”，仅捕捉日常条件句中“并非前真后假”的核心真值属性，其余隐含意义（如关联关系）会被忽略。 实质双条件句（“当且仅当”）核心定义与结构定义：表示“两个语句真值相同”的复合语句，逻辑中用符号“≡”表示，形式为“前件 ≡ 后件”（如“A 当且仅当 B”符号化为“A≡B”），也称为“实质等值句”。 等价形式：实质双条件句等价于“双向的实质条件句”，即“A≡B” = “(A⊃B)·(B⊃A)”（“如果 A 则 B，并且如果 B 则 A”）。 真值规则实质双条件句“A≡B”为真，当且仅当“前件与后件真值完全相同”（同真或同假）；若真值不同（一真一假），则整体为假。可概括为：
若前后件真值相同，则实质双条件句为真；否则为假
前件（A） 后件（B） A≡B（实质双条件句） T T T T F F F T F F F T 与日常等值句的差异日常语言中“等值”常隐含“前后件有内在关联”（如“三角形是等边的，当且仅当它是等角的”），而实质双条件句仅关注真值是否一致，不要求关联（如“2+2=5≡ 太阳从西边升起”，因前后均假，实质双条件句为真）。 五大联结词真值规则总结通过以下 5 句话可完整掌握所有基础联结词的真值条件：
否定（~）：颠倒原语句真值（真变假，假变真）； 合取（·）：仅当 …  ]]></content></entry><entry><title>2.8 - 2.9 析取</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0203-%E6%9E%90%E5%8F%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>析取句</tag><tag>算子辖域</tag><tag>逻辑符号化</tag></tags><content type="html">  析取句与“或”的两种含义析取句的定义由联结词“或”联结两个语句构成的复合语句，称为析取句；被联结的两个语句，称为“析取支”（如“小明吃苹果或小红吃香蕉”，“小明吃苹果”“小红吃香蕉”均为析取支）。
“或”的两种核心含义可兼含义（非互斥）：断言“至少一个析取支为真”，允许两个析取支同时为真（如“他学数学或学英语”，可同时为真）。日常中“和/或”是其明确表达（常见于法律文件），逻辑中用符号“∨”（v 字符）表示，是真值函数联结词。 不可兼含义（互斥）：断言“恰好一个析取支为真”，排除两个析取支同时为真的情况（如“比赛赢或输”，不可同时为真）。其含义比可兼或更丰富，除“至少一个真”外，还包含“至少一个假”。 可兼析取（∨）的真值规则“∨”的真值完全由析取支的真值决定，仅当两个析取支均为假时，析取句“p∨q”为假；其余情况（一个真、一个假，或两个均真）均为真。具体真值表如下：
p（析取支 1） q（析取支 2） p∨q（可兼析取句） T T T T F T F T T F F F 不可兼析取的符号化问题不可兼或的完整含义：需同时满足“至少一个真”和“至少一个假”，完整符号化为“(p∨q)·~(p·q)”（可兼或 + 否定合取）。 用“∨”符号化的局限性：若直接用“∨”表示不可兼或，会丢失“至少一个假”的含义（仅保留“至少一个真”），导致符号式与原语句真值可能不一致（如两个析取支均真时，原不可兼或语句为假，但“p∨q”为真）。 论证中的处理原则： 部分论证中，仅需“至少一个真”的核心含义，用“∨”符号化不影响有效性； 若论证依赖“互斥”属性（如“比赛赢或输，赢了，所以没输”），则需完整符号化为“(p∨q)·~(p·q)”。 日常语句的符号化规则：若“或”的含义不明确（无法判断是否互斥），遵循“如有疑义，按可兼含义符号化”（用“∨”），避免过度添加未明确的“互斥”假设。 多算子语句的符号化与辖域核心原则含两个及以上逻辑算子（如~、·、∨）的语句，需通过括号明确算子辖域，避免歧义（辖域即算子管辖的支语句范围）。
常见句式的符号化“并非既&amp;amp;hellip;又&amp;amp;hellip;”：否定“两个语句同时为真”，等价于“至少一个为假”，符号化为“~(Q·G)”或“~Q∨~G”（如“并非既下雨又刮风”，即“不下雨或不刮风”）。 逻辑依据：否定合取等价于析取否定（德摩根定律），两者 …  </content></entry><entry><title>2.4 - 2.7 否定</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0202-%E5%90%A6%E5%AE%9A/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>否定算子</tag><tag>算子辖域</tag><tag>逻辑符号化</tag></tags><content type="html">  非真值函数联结词与真值函数联结词的区别真值函数联结词（如“并且”）：复合语句的真值由支语句的真值唯一决定（只要支语句真值确定，复合语句真值就固定，如“ A 并且 B ”仅当 A、B 均真时为真）。 非真值函数联结词：复合语句的真值不能仅由支语句真值决定，还需依赖支语句内容、时态、语境等额外信息。 常见示例“在&amp;amp;hellip;之前”（时态联结词）：如“小明吃饭在小红看书之前”，即使“小明吃饭”和“小红看书”均为真，复合语句的真值仍需看两者的时间顺序（若小红先看书，则复合语句为假），无法仅通过支语句真值判断。 “众所周知”：如“众所周知地球是圆的”（真）和“众所周知小明今天吃了饭”（假），两者支语句均为真，但复合语句真值不同，因“众所周知”依赖“语句是否被广泛知晓”的额外信息。 “因为”：如“他感冒了因为他淋了雨”，即使“他感冒了”和“他淋了雨”均为真，复合语句真值还需看两者是否存在因果关系（若感冒是因着凉，而非淋雨，则复合语句为假），不取决于支语句真值。 变项与常项定义与作用语句变项：用小写字母（如 p、q）表示，是“位置所有者”，不指代特定语句，仅用于表示“任意语句的占位符”（如真值表中 p、q 可代表任何原子语句）。 语句常项：用大写字母（如 A、B）表示，是特定语句的缩写（如 A 代表“今天下雨”，B 代表“我带了伞”），有确定的真值（真或假）。 示例：真值表中的变项与常项合取句的真值表用 p、q（变项）表示任意合取支，描述“所有合取句的真值规则”： p q p·q T T T T F F 若用 A（“今天下雨”，真）、B（“我带了伞”，真）（常项）替换变项，得到具体合取句“A·B”（“今天下雨并且我带了伞”），其真值为 T，符合真值表规则。 否定（一元逻辑算子）核心性质一元算子：仅作用于单个语句（无需联结两个语句），就能生成新的复合语句（否定句），是标准语句逻辑中唯一的一元真值函数算子。 符号表示：用波浪符“~”表示（如“并非今天下雨”记为“~A”，A 代表“今天下雨”）。 真值规则否定句的真值与原语句（被否定的语句）真值完全相反：
若原语句为真（T），则否定句为假（F）（如 A 为真，~A 为假）； 若原语句为假（F），则否定句为真（T）（如 A 为假，~A 为真）。 真值表： A ~A T F F T 括号：消除歧义与明确算子辖域核心作 …  </content></entry><entry><title>2.1 - 2.3 合取</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0201%E5%90%88%E5%8F%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>合取句</tag><tag>逻辑符号化</tag></tags><content type="html">  核心概念：原子语句与复合语句原子语句（简单语句）：不包含“并且”“或者”等语句联结词的语句，是构成复合语句的基础单位（如“今天下雨”“我吃了饭”）。 复合语句：用“并且”“或者”等联结词联结原子语句构成的语句（如“今天下雨并且我带了伞”“他看书或者他写字”）。 语句逻辑与真值函数语句逻辑：逻辑学中“无需考虑原子语句内部结构”即可分析的部分，属于符号逻辑的分支（另一分支是谓词逻辑）。 真值函数核心： 输入与输出仅含“真（T）”和“假（F）”两个真值； 复合语句的真值由其包含的原子语句的真值唯一决定（复合语句是原子语句的“真值函数”），因此语句逻辑也叫“真值函数逻辑”。 合取句：“并且”联结的复合语句定义：用联结词“并且”（逻辑中常用小圆点“·”作为缩写）联结两个原子语句（称为“合取支”）构成的复合语句（如“A·B”，A、B 为合取支）。 真值表（合取句的真值规则）：
合取句“ A·B ”仅当两个合取支均为真时，整体才为真；只要有一个合取支为假，整体即为假，具体如下： A（合取支 1） B（合取支 2） A·B（合取句） T T T T F F F T F F F F 日常语句与逻辑符号化的注意事项并非所有“并且”都能符号化为“·”：
逻辑中的 “・” 要求联结的是两个独立的原子语句（即 “合取支需能单独判断真假”），但日常语言中部分含 “和” 的语句，“和” 仅用于连接名词（而非独立语句），无法拆分为两个原子语句，因此不能符号化为合取句 “・”。例如 “小明和小红在恋爱”，句中 “和” 连接的是 “小明”“小红” 两个主体，整个语句是一个不可拆分的原子语句（无法拆成 “小明在恋爱”“小红在恋爱” 两个独立真 / 假判断，因为 “恋爱” 是两人之间的关系，单独判断 “小明在恋爱” 不完整），因此不能符号化为 “A・B”。 符号化恰当性的判断标准：
若逻辑符号式的真值与原日常语句的真值一致（符号式真则原句真，符号式假则原句假），则符号化恰当；反之则不恰当。 等效联结词：
日常中“但是”“然而”等词，虽表达转折语气，但从真值函数角度，与“并且”功能一致（均需前后两部分均为真，整体才为真），可符号化为“·”（如“他很努力但是没考好”，符号化为“A·B”）。   </content></entry><entry><title>1.5 - 1.9 论证的本质</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0103-%E8%AE%BA%E8%AF%81%E7%9A%84%E6%80%A7%E8%B4%A8/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  有效论证、可靠论证与坏论证的关系核心概念辨析有效论证：仅保证“若前提全为真，则结论必为真”（逻辑形式有效），不要求前提实际为真。 可靠论证：需同时满足两个条件：
a. 论证有效（逻辑形式无问题）；
b. 所有前提实际为真。 坏论证：有效论证也可能是坏论证——若其存在一个或多个假前提（满足“有效”但不满足“所有前提真”，即不满足“可靠”）。 逻辑学的关注点逻辑学不直接判定论证的“可靠性”，仅关注“有效性”：
除“逻辑上为真/假的前提”（如“2+2=4”“三角形有 4 条边”）外，前提的实际真假需依赖具体领域知识（如数学、物理、事实），无法仅靠逻辑学判定。 陈述集的相容性与不相容性定义相容陈述集：所有陈述同时为真是可能的（不要求实际为真，仅需无逻辑矛盾）； 不相容陈述集：所有陈述同时为真是不可能的（存在逻辑矛盾，如“今天下雨”与“今天不下雨”组成的集合）。 关键特征相容性与陈述的“实际真假”无关： 所有陈述为真时，集合必相容； 所有陈述为假时，集合仍可能相容（如“地球是方的”与“太阳绕地球转”，虽均假，但无逻辑矛盾，可同时为假）； 唯一不可能的情况：集合不相容，但所有陈述均为真（矛盾陈述无法同时为真）。 有效性与相容性的关联核心等价关系一个论证是有效的，当且仅当“前提全为真且结论为假”的断言是不相容的：
有效论证的本质：“前提真而结论假”存在逻辑矛盾（不相容），故不可能发生； 无效论证的本质：“前提真而结论假”无逻辑矛盾（相容），故可能发生。 利用相容性检测有效性的方法通过以下步骤可借助“相容性”判断论证是否有效：
假设原论证的结论为假，得到“结论的否定”； 将“原前提”与“结论的否定”组成一个新的陈述集； 若该新集合相容（可同时为真）→ 原论证无效（“前提真而结论假”可能）； 若该新集合不相容（不可同时为真）→ 原论证有效（“前提真而结论假”不可能）。 发现语境与辩护语境两个核心问题当某人断言“某结论为真”时，存在两个维度的问题：
发现语境：引导其得出该结论的心理因素（如直觉、经验、情绪、灵感）； 辩护语境：支持该结论为真的客观理由（如前提、逻辑推导、证据）。 逻辑学的关注范围逻辑学仅关心“辩护语境”：
不探究结论的“产生过程”（心理因素具有主观性、偶然性），仅评估“结论是否有合理的理由支撑”（即论证的有效性与前提的相关性）。   </content></entry><entry><title>1.2 - 1.4 演绎与归纳</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0102-%E6%BC%94%E7%BB%8E%E4%B8%8E%E5%BD%92%E7%BA%B3/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>演绎论证</tag><tag>归纳论证</tag><tag>论证</tag></tags><content type="html">  演绎上有效的论证核心定义与逻辑性质基本性质：若所有前提为真，则结论必定为真（不可能出现“前提全真而结论假”的情况），前提之真完全保证结论之真。 判定标准：追问是否存在“前提全真、结论假”的可能——不存在则有效，存在则无效（无效论证即“非有效论证”）。 内容与形式的关系：演绎有效性由论证形式决定，而非内容。只要形式有效，无论内容如何，均为有效论证。例如以下两种固定有效形式： 形式 1： AAA，或者 BBB 并非 AAA BBB 形式 2： 如果 AAA，那么 BBB AAA BBB 有效性与“真/假”的关系关键区分：
有效性/无效性是论证的性质，仅判断“结论能否从前提推出”； 真/假是陈述（前提/结论）的性质，仅判断陈述是否符合事实。 （误区：不可说“论证是真的/假的”，也不可说“陈述是有效的/无效的”） 真假组合的可能性： 有效论证可出现 3 种组合（仅排除“前提全真+结论假”）：
前提真 + 结论真； 前提假 + 结论真； 前提假 + 结论假。 无效论证无限制：可出现“前提全真+结论真”“前提全假+结论假”等任意组合（只需构造无逻辑关联的陈述即可）。 核心特征结论信息已暗含在前提中，并非“真正的新信息”（仅可能是心理层面的新信念）； 演绎有效性是“绝对的”：论证要么有效，要么无效，不存在“更有效”或“较无效”的程度差异。 归纳论证核心定义与逻辑性质基本性质：结论内容超出前提包含的信息（并非从前提中暗含推导）；“好的归纳论证”称为“归纳上强的论证”。 与演绎有效性的核心区别： 强归纳论证的前提全真，仅能使结论或然/盖然（仍有可能前提真而结论假）； 有效演绎论证的前提全真，能保证结论真。 归纳强度的特征逻辑基础：基于“经验学习”——从经验中观察模式、规律性，再投射到其他场合。 强度的程度差异： 归纳强度是“相对的”：可描述“一个论证比另一个论证归纳更强”（如更多证据支持的论证强度更高）； 演绎有效性无程度差异（要么有效，要么无效）。 优缺点： 优点：提供“真正的新信念”（结论超出前提，非暗含信息）； 缺点：错误风险更高——即使是最强的归纳，也可能因“经验规律在新场合失效”而得出假结论。 演绎论证与归纳论证的核心对比维度 演绎论证 归纳论证 结论与前提的关系 结论信息暗含在前提中，不超出前提 结论信息超出前提 前提真对结论的作用 保证结论真（无例外）  …  </content></entry><entry><title>1.1 论证的要素</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0101-%E8%AE%BA%E8%AF%81%E7%9A%84%E8%A6%81%E7%B4%A0/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  论证的要素论证的核心定义论证是一套以 “为结论辩护、提供理由” 为目的的陈述系列，核心是通过前提推导结论。
论证的核心要素前提：论证中支持结论的陈述，数量可任意，需为 “可判断真假” 的内容，是结论成立的依据。 结论：论证中被前提辩护的陈述，是论证的核心目标，需从前提中合理推导得出。 论证的关键特征陈述属性：论证中的语句必须表达 “陈述”（即有真假属性），疑问句、祈使句、感叹句等无真假属性的语句无法构成论证。 逻辑关联：即使所有语句均为陈述，若彼此无 “支持与被支持” 的关联（无辩护对象、无接受结论的理由），也不构成论证。 结构灵活性：一个论证可被其他论证包围或嵌入（如子论证的结论作为核心论证的前提）。 区分 “论证” 与 “非论证” 的意义区分二者并非单纯的逻辑理论知识，其核心价值在于为普通人日常生活提供 “理性决策、有效沟通、清醒认知” 的实用工具，具体可总结为 4 点：
规避认知陷阱，不被误导：识别 “无理由支撑的伪观点”，通过追问 “是否有前提为结论辩护”，避免因盲目相信错误信息造成损失。 提升表达说服力，减少沟通矛盾：家庭协商、职场协作等场景中，用 “论证思维”（结论 + 支撑理由）替代单纯的 “我觉得”“我认为”（非论证的情绪 / 观点表达），让观点更清晰、有依据，减少 “各说各话” 的无效沟通，提升他人接受度。 助力理性决策，降低后悔风险：面对 “买哪款产品”“要不要换工作” 等选择时，用 “论证” 梳理 “选择结论 + 自身需求 / 客观理由”，替代 “凭直觉”“随大流”（非论证式决策），让选择贴合实际需求，减少冲动或外界压力导致的决策失误。 促进建设性讨论，避免情绪内耗：遇到争议话题时，聚焦 “对方观点是否有理由支撑”，而非陷入 “情绪攻击”，让讨论围绕 “理由合理性” 展开，减少 “为吵架而吵架” 的内耗，让争议更具建设性。   </content></entry><entry><title>附录 JS库</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E9%99%84%E5%BD%95-js%E5%BA%93/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>CDN</tag><tag>JavaScript</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 库的核心概念与优缺点什么是 JS 库？JS 库是封装好的可重用代码包，旨在简化常见开发任务（如 DOM 操作、动画、AJAX），避免重复编写繁琐代码，同时解决跨浏览器兼容问题。
库的核心优势可靠性高：代码经过大量用户测试和验证，bug 更少，稳定性优于自定义代码。 集成性强：可轻松与现有开发框架（如 Vue、React）或项目集成，无需重构底层逻辑。 效率提升：为 DOM 操作、表单验证、网络请求等日常任务提供简洁 API，一行代码可替代数十行原生 JS（如 jQuery 的 $(&amp;amp;quot;.class&amp;amp;quot;).hide() 隐藏元素）。 跨浏览器兼容：库内部已处理不同浏览器的差异（如早期 IE 与现代浏览器的 DOM 接口差异），开发者无需手动适配。 库的潜在问题黑箱风险：代码由第三方编写，内部逻辑不透明，出现 bug 时难以调试（如库的方法返回异常，需查阅文档或源码定位问题）。 性能负担：库文件需额外加载，会增加页面 HTTP 请求次数和带宽消耗（尤其大型库，可能导致首屏加载变慢）。 冲突与冗余： 多库混用可能引发命名冲突（如两个库都定义 $ 变量）； 库的功能可能超出需求（如仅需 DOM 操作，却引入包含动画、AJAX 的全量库），造成代码冗余。 如何选择合适的 JS 库？需从功能、体积、维护性等维度综合评估，核心考量以下 6 个问题：
考量维度 关键问题与说明 功能匹配度 1. 库是否包含项目所需的全部核心功能（如仅需表单验证，无需选择包含地图、图表的全能库）？
避免 “功能过剩”，减少冗余代码。 模块化设计 库是否支持按需加载（如只引入 DOM 操作模块，而非全量引入）？
模块化设计可降低体积，提升性能。 支持与维护 1. 库的更新频率如何（是否长期维护，修复漏洞、适配新浏览器）？ 2. 是否有活跃的社区（如 GitHub Issues 响应及时、Stack Overflow 有大量解答）？ 文档质量 是否有完整、易懂的官方文档（含 API 说明、示例代码、常见问题）？
优质文档可降低学习和使用成本。 许可协议 库的开源协议（如 MIT、Apache）是否允许商业使用？
避免因协议限制导致法律风险（如部分协议要求开源衍生代码）。 体积与性能 库的压缩后体积多大？是否会显著影响页面加载速度？
优先选择轻量级库（如需求简 …  </content></entry><entry><title>第十章 用JS实现动画效果</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/10--%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JS 动画</tag><tag>JavaScript</tag><tag>CSS</tag><tag>前端开发</tag></tags><content type="html">  动画基础知识：核心原理JS 动画的本质是按预定时间间隔重复调用函数，动态修改元素样式（尤其是位置相关样式），从而实现 “随时间变化” 的视觉效果。核心依赖两个维度：元素位置控制和时间调度。
元素位置控制：position 属性通过 CSS position 属性定义元素的定位方式，是实现动画的基础。position 有 4 个合法值，核心差异在于元素是否脱离文档流及定位基准：
属性值 定位规则 static 默认值，元素按文档流顺序排列，无法通过 top/left 等属性调整位置。 relative 元素仍在文档流中，但可通过 top/left 等属性 “相对自身原位置” 偏移，不影响其他元素。 absolute 元素脱离文档流，定位基准为最近的已定位祖先元素（position 为 relative/fixed/absolute），若无则以文档为基准。位置由 top/left/right/bottom 决定。 fixed 元素脱离文档流，定位基准为浏览器窗口，滚动页面时位置固定不变。 位置属性使用注意：避免冲突：设置位置时建议只使用 top 或 bottom（垂直方向）、left 或 right（水平方向），同时设置可能导致定位混乱。
容器定位：若需让 absolute 元素在指定容器内定位，需将容器的 position 设为 relative（此时容器成为定位基准）
时间调度：setTimeout 与 clearTimeout通过 JS 时间函数控制动画的 “节奏”，实现 “延迟执行” 或 “定时重复”。
setTimeout：延迟执行函数语法：
const timerId = setTimeout(func, delay)func：延迟后执行的函数（可直接写函数体或函数名，推荐用函数体避免字符串解析问题）； delay：延迟时间（毫秒，1 秒 = 1000 毫秒）； 返回值：timerId（定时器唯一标识，用于取消定时器）。 clearTimeout：取消延迟执行语法：
clearTimeout(timerId)作用：取消已通过 setTimeout 排队的函数，避免其执行 数值处理：parseInt 与 parseFloat动画中常需从样式字符串（如 100px）中提取数值，需用到这两个函数：
函数 功能 parseInt 提取字符串中的整 …  </content></entry><entry><title>归档</title><url>/archives/custom_archieves/</url><categories/><tags/><content type="html">  {{ define "main" }}{{ T "archive" }}{{ range .Site.RegularPages.ByDate.Reverse.GroupByDate "2006-01" }}{{ .Key | time.Format "2006年1月" }}({{ len .Pages }}){{ range .Pages }}{{ .Date.Format "02日" }}{{ .Title }}{{ end }}{{ end }}{{ end }}  </content></entry><entry><title>第八章 充实的文档的内容</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/08--%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>HTML</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  &lt;abbr&gt; 与 &lt;acronym&gt; 标签&lt;abbr&gt;：表示缩略语（对单词或短语的缩写，如 &ldquo;Mr.&rdquo; 是 &ldquo;Mister&rdquo; 的缩写），通常建议通过 title
属性提供完整含义，例如：
&lt;abbr title=&#34;HyperText Markup Language&#34;&gt;HTML&lt;/abbr&gt;&lt;acronym&gt;：专门表示首字母缩写词（由多个单词首字母组成，且发音为一个单词，如 &ldquo;NASA&rdquo; 读作 &ldquo;nasa&rdquo;）。
注意：HTML5 中已废弃 &lt;acronym&gt;，推荐统一使用 &lt;abbr&gt; 替代，因其语义更通用。 DOCTYPE 与浏览器渲染模式DOCTYPE 的作用：告知浏览器文档使用的 HTML 版本，决定浏览器以标准模式还是兼容模式渲染页面。
标准模式：浏览器严格遵循 W3C 规范渲染页面，保证跨浏览器一致性。 兼容模式（怪异模式）：模仿早期浏览器（如 IE6）的非标准行为，允许不规范的代码正常运行（如忽略闭合标签、错误的盒模型计算）。 HTML5 的 DOCTYPE：
&lt;!DOCTYPE html&gt;此声明简洁且默认触发标准模式，无需指定具体版本，是现代网页的推荐写法。
换行符与 DOM 文本节点部分浏览器（如早期 IE、部分基于 WebKit 的浏览器）会将 HTML 中的换行符解析为文本节点（nodeType = 3），导致 childNodes 等集合中包含空文本节点。 影响：遍历子节点时需注意过滤空文本节点（可通过 nodeValue.trim() === &quot;&quot; 判断），避免逻辑错误。 accesskey 属性作用：为元素绑定键盘快捷键，提升可访问性（尤其适合键盘用户）。
用法：
&lt;a href=&#34;index.html&#34; accesskey=&#34;h&#34;&gt;首页&lt;/a&gt;触发方式：
Windows 系统：Alt + 快捷键（如 Alt + h）； macOS 系统：Ctrl + 快捷键（如 Ctrl + h）。 注意：避免与浏览器默认快捷键冲突（如 Alt + F 通常打开文件菜单），且需在页面中明确提示快捷键（如通过文字说明）。
JS 与文档内容的关系原则：JS 应作为内容的增强工具，而非创建核心内容的依赖。 核心内容（如标题、正文、导航链接）应直接通过 HTML 编写，确保在 JS 禁用时仍可访问。 JS 可动态添加交互元素（如弹窗、表单验证）、加载非核心内容（如评论、推荐），但需遵循 “平稳退化” 原则。   ]]></content></entry><entry><title>第九章 CSS DOM</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/09--css-dom/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>CSS</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  网页的三层结构网页的呈现和交互由结构层、表示层、行为层共同构成，三者各司其职又协同工作：
结构层： 由 HTML/XHTML 标记语言实现，通过标签（如 &amp;lt;p&amp;gt;、&amp;lt;div&amp;gt;）描述内容的语义和结构（如标题、段落、列表），不包含样式或行为信息。 示例：&amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt; 仅定义 “这是一个一级标题”，不规定其颜色、大小。 表示层： 由 CSS 负责，定义内容的视觉呈现（如颜色、字体、布局）。 即使未显式编写 CSS，浏览器也会应用默认样式（如 &amp;lt;h1&amp;gt; 默认加粗、字号较大）。 行为层： 由 JavaScript 和 DOM 控制，定义内容对事件的响应方式（如点击、鼠标悬停）。 浏览器默认也有基础行为（如链接点击跳转、表单提交），JS 可扩展或修改这些行为。 通过 DOM 操作样式：style 属性style 属性的特性每个元素节点的 style 属性是一个对象，包含该元素的内嵌样式（即通过 style 属性直接定义的样式，如 &amp;lt;div style=&amp;quot;color: red&amp;quot;&amp;gt;）。
命名规则：CSS 属性名中的减号（如 font-size）在 style 对象中需转换为驼峰命名法（如 style.fontSize），避免与 JS 语法冲突。
局限性：
仅能获取 / 修改内嵌样式，无法访问外部 CSS 文件或 &amp;lt;style&amp;gt; 标签中定义的样式。
示例：
&amp;lt;div id=&amp;#34;box&amp;#34; style=&amp;#34;width: 100px; color: blue;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const box = document.getElementById(&amp;#34;box&amp;#34;); console.log(box.style.width); // 输出 &amp;#34;100px&amp;#34;（获取内嵌样式） console.log(box.style.fontSize); // 输出 &amp;#34;&amp;#34;（非内嵌样式无法获取） &amp;lt;/script&amp;gt;通过 style 属性设置样式style 对象的属性是可读写的，可通过赋值修改样式，值需为字符串（需加引号）。
示例：
const box = …  ]]></content></entry><entry><title>第七章 动态创建标记</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/07--%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>AJAX</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  传统文档操作方法document.write()功能：将字符串直接插入到文档中，语法简单（如 document.write(&amp;quot;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;quot;)）。 缺点： 违背 “行为与表现分离” 原则，需在 HTML 中嵌入 &amp;lt;script&amp;gt; 调用，导致代码耦合。 可能引发文档验证错误，且与 application/xhtml+xml 类型文档不兼容（浏览器会忽略该方法）。 innerHTML功能：读写元素内的 HTML 内容（如 div.innerHTML = &amp;quot;&amp;lt;span&amp;gt;Hi&amp;lt;/span&amp;gt;&amp;quot; 可设置内容，const html = div.innerHTML 可读取内容）。 特点： 简洁高效，适合批量操作 HTML 片段，但无法精确控制单个节点（会整体替换元素内容）。 局限性：HTML 专有属性，不支持 XHTML 文档；安全性风险（可能引入 XSS 攻击，需谨慎处理用户输入）。 替代方案：标准 DOM 方法（如 createElement、appendChild）虽代码量增加，但可精确控制节点，兼容性更强。 标准 DOM 操作方法核心思想DOM 是文档的双向映射：既能读取文档结构（通过节点属性和方法），也能修改节点树（实时反映到浏览器渲染结果）。 浏览器显示的是 DOM 节点树，而非原始 HTML 代码，因此修改 DOM 会直接改变页面表现。 创建与插入节点创建元素节点：document.createElement(tagName)
示例：const newDiv = document.createElement(&amp;quot;div&amp;quot;);（创建 &amp;lt;div&amp;gt; 元素，初始为 “文档碎片”，未插入文档）。 创建文本节点：document.createTextNode(text)
示例：const textNode = document.createTextNode(&amp;quot;Hello DOM&amp;quot;);（创建包含文本的节点）。 插入节点到文档：
parent.appendChild(child)：将子节点添加到父节点的子节点列表末尾。
示例：
const parent = …  ]]></content></entry><entry><title>第六章 案例研究：图片库改进版</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/06--%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  JS 与网页结构的解耦原则核心思想：为网页添加行为时，JS 代码应尽量避免依赖特定的 HTML 结构（如固定的标签嵌套、类名顺序等）。 好处：当 HTML 结构调整时，JS 代码无需频繁修改，提高可维护性。 命名规范与注意事项命名原则可读性：使用有意义的单词命名变量、函数（如 calculateTotal 而非 fn1），通过命名体现用途。 风格统一：变量和函数名推荐使用驼峰命名法（如 userName、handleClick），常量常用全大写（如 MAX_SIZE）。 命名禁忌避免保留字：不能使用 JS 语言的保留字（如 if、function、class 等）作为变量名。 避免覆盖内置 API：不使用现有 JS 函数 / 方法名（如 alert、push）作为变量名，防止覆盖内置功能。 节点链表（NodeList）定义：由 DOM 方法（如 getElementsByTagName、querySelectorAll）返回的节点集合，类似数组但并非真正的数组（是类数组对象）。 特性： 每个节点都有自身的属性（如 nodeType、nodeName）和方法（如 appendChild）。 动态性：部分 NodeList（如 getElementsByTagName 返回的集合）会随 DOM 变化自动更新。 共享 onload 事件：addLoadEvent 函数问题：window.onload 只能绑定一个函数，多次赋值会覆盖之前的函数。 解决方案：addLoadEvent 函数用于将多个函数追加到 window.onload 事件中，确保所有函数在页面加载完成后执行。 实现逻辑：function addLoadEvent(func) { const oldOnload = window.onload; // 保存现有 onload 函数 if (typeof window.onload !== &#34;function&#34;) { // 若 onload 未绑定函数，直接赋值 window.onload = func; } else { // 若已绑定函数，追加新函数 window.onload = function () { oldOnload(); // 执行原有函数 func(); // 执行新函数 }; } }nodeName 属性特性：返回元素节点的标签名，始终为大写字母（即使 HTML 中标签是小写，如 &lt;div&gt; 的 nodeName 为 &quot;DIV&quot;）。 用途：判断元素类型（如 if (element.nodeName === &quot;LI&quot;) 检测是否为列表项）。 键盘事件与交互一致性onkeypress 事件触发时机：按下键盘上的任意按键（包括字母、数字、符号等）时触发。 用途：监听键盘输入（如表单验证、快捷键操作）。 键盘与鼠标事件的一致性用 Tab 键聚焦到链接后按 Enter 键，会触发该链接的 onclick 事件，与鼠标点击效果一致。 意义：确保键盘用户与鼠标用户获得相同的交互体验，提升可访问性。   ]]></content></entry><entry><title>第四章 案例研究：JS图片库</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/04-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  元素属性操作的两种方式直接属性赋值（传统方式）语法：element.属性名 = 值（如 input.value = &amp;quot;hello&amp;quot;）。 适用场景：大部分 HTML 元素的标准属性（如 value、src、href 等）。 特点：简单直接，但仅支持预定义的标准属性，不支持自定义属性。 setAttribute() 方法（DOM Level 1）语法：element.setAttribute(属性名, 属性值)（如 div.setAttribute(&amp;quot;data-id&amp;quot;, &amp;quot;123&amp;quot;)）。 优势： 可设置任意元素的任意属性（包括自定义属性），兼容性更强。 遵循 DOM 标准，可移植性好（适用于多种环境和编程语言）。 注意：修改后会实时反映在 DOM 中，但不会改变原始 HTML 源代码。 JS 文件优化：合并文件目的：减少 HTTP 请求次数，提高页面加载性能。 做法：将多个 .js 文件合并为一个文件，通过单次请求加载。 事件处理函数基本概念作用：在特定事件发生时执行指定 JS 代码（如点击、鼠标悬停等）。 语法：元素.事件处理函数 = &amp;quot;JS 语句&amp;quot; 或通过 DOM 方法绑定（如 element.onclick = function() {}）。 常用事件： onclick：用户点击元素时触发； onmouseover：鼠标指针悬停在元素上时触发； onmouseout：鼠标指针离开元素时触发； onload：页面或资源（如图片）加载完成时触发（常用于页面初始化）。 事件处理函数的返回值事件触发的 JS 代码可返回一个值，该值会传递给事件处理函数。 典型应用：阻止默认行为 例如，在&amp;lt;a&amp;gt;标签的 onclick 中返回 false，可阻止链接跳转： 子节点获取：childNodes作用：返回当前元素的所有子节点（包含元素节点、文本节点、空格 / 换行节点等），结果为类数组对象。
示例：
const parent = document.getElementById(&amp;#34;parent&amp;#34;); const children = parent.childNodes; // 所有子节点（含文本、空格等） 节点类型判断：nodeType作用：通过数值区分节点类 …  ]]></content></entry><entry><title>第五章 最佳实践</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/05--%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>前端开发</tag><tag>性能优化</tag><tag>平稳退化</tag></tags><content type="html"><![CDATA[  平稳退化定义：确保网站在浏览器不支持 JavaScript 或 JS 被禁用时，核心功能仍可正常使用（如链接可点击、内容可访问）。 关键原则： 为 JS 功能提供 “退路”，例如将链接的 href 属性设置为真实 URL，而非仅依赖 onclick 事件。 避免过度依赖 JS 实现基础功能（如导航、跳转）。 弹出窗口与平稳退化window.open() 方法：用于创建新窗口，语法为window.open(url, name, features)，参数分别为目标 URL、窗口名称、窗口属性（如尺寸、功能）。
示例函数：
function popUp(winUrl) { window.open(winUrl, &amp;#34;popup&amp;#34;, &amp;#34;width=320,height=480&amp;#34;); }调用方式的问题：
伪协议（javascript:）：如 &amp;lt;a href=&amp;quot;javascript:popUp(&#39;url&#39;)&amp;quot;&amp;gt;，在禁用 JS 时失效，不推荐。 空链接（#）：如 &amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;popUp(&#39;url&#39;);return false&amp;quot;&amp;gt;，禁用 JS 时点击会跳转至页面顶部，体验差。 正确做法：
让 href 指向真实 URL，onclick 中通过 return false 阻止默认跳转，确保 JS 禁用时仍能正常访问：
&amp;lt;a href=&amp;#34;http://www.baidu.com&amp;#34; onclick=&amp;#34;popUp(&amp;#39;http://www.baidu.com&amp;#39;);return false;&amp;#34; &amp;gt;baidu&amp;lt;/a &amp;gt;分离 JavaScript核心思想：将 JS 代码从 HTML 中剥离，通过外部脚本文件管理，避免 HTML 与 JS 耦合。
实现步骤：
HTML 保留基础功能：链接使用真实 href，通过 class 或 id 标识需要特殊处理的元素：
&amp;lt;a href=&amp;#34;http://www.baidu.com&amp;#34; class=&amp;#34;popup&amp;#34;&amp;gt;baidu&amp;lt;/a&amp;gt;外部 JS 绑定事件：在外部脚本中通过 DOM 方法找到 …  ]]></content></entry><entry><title>第二章 JS语法</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/02-js%E8%AF%AD%E6%B3%95/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  语法变量定义：变量是存储可变值的容器，将值存入变量的操作称为赋值。 声明与赋值： JS 中，未声明的变量赋值时会自动声明（不推荐，易导致全局污染）。 可一次性声明多个变量：var a, b, c;。 可在声明时赋值：var x = 10, y = &amp;quot;hello&amp;quot;;。 命名规则： 区分大小写（name 与 Name 是不同变量）。 允许包含字母、数字、$、_，但不能以数字开头，不能包含空格或标点符号（$ 除外）。 长变量名可读性优化： 下划线命名法：user_name； 驼峰命名法：userName（第二个单词起首字母大写）。 字面量：直接在代码中写出的数据（如 123、&amp;quot;abc&amp;quot;、true）。 数据类型弱类型特性：JS 是弱类型语言，无需声明变量类型，可随时修改变量的类型（与强类型语言需显式声明类型不同）。 字符串： 由零个或多个字符组成，需用单引号（&#39;）或双引号（&amp;quot;）包裹。 引号选择规则：字符串包含双引号时用单引号包裹（如 &#39;He said &amp;quot;Hi&amp;quot;&#39;），反之亦然。 转义字符：用反斜线（\）转义特殊字符，如 \&amp;quot; 表示双引号（&amp;quot;She said \&amp;quot;Hello\&amp;quot;&amp;quot;）。 数值： 支持整数（如 42）和浮点数（如 3.14），可带正负号（如 -5、-2.7）。 布尔值： 仅两个值：true（真）和 false（假），不可用引号包裹（否则为字符串）。 数组定义：用一个变量存储一组值（元素），元素可通过下标访问（下标从 0 开始）。 声明与初始化： 用 Array 关键字：var arr = new Array(); 或 var arr = new Array(3);（指定初始长度，可选）。 简洁语法（推荐）：var arr = [1, &amp;quot;a&amp;quot;, true];（直接用方括号包裹元素，元素类型可混合）。 元素操作： 赋值：arr[0] = 10;（通过下标赋值）。 嵌套数组：数组元素可是另一个数组（如 var nested = [1, [2, 3]];）。 关联数组： 用字符串作为下标（如 arr[&amp;quot;name&amp;quot;] = &amp;quot;Alice&amp;quot;），本质是为数组对象添加属性。 注意： …  ]]></content></entry><entry><title>第三章 DOM</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/03--dom/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  DOM 的核心概念DOM（Document Object Model，文档对象模型）是一套用于抽象和概念化文档内容的接口，它将网页文档转换为可通过 JavaScript 操作的对象树结构。
D：文档（Document）当网页加载到浏览器时，浏览器会自动将 HTML/XML 文档解析为一个 文档对象，即 DOM 的基础。 O：对象（Object）对象是包含数据和方法的集合： 属性：对象关联的变量（如 element.id）； 方法：对象可调用的函数（如 element.appendChild()）。 JS 中的对象类型： 用户定义对象：开发者创建的自定义对象； 内建对象：JS 自带的对象（如 Array、Date）； 宿主对象：浏览器环境提供的对象（如 window、document）。 关键宿主对象： window：对应浏览器窗口，属于 BOM（浏览器对象模型）； document：对应网页内容，是操作 DOM 的核心对象。 M：模型（Model）DOM 将文档表示为一棵节点树（类似家谱树），用 “父子”“兄弟” 等关系描述元素间的层次结构： 根元素是 &amp;lt;html&amp;gt;，所有其他元素都是其后代； 节点树清晰展示了元素的嵌套关系，便于通过 JS 遍历和操作。 节点（Node）DOM 文档由多种节点组成，核心类型包括：
元素节点（Element Node）文档的基本构成单位，对应 HTML 标签（如 &amp;lt;div&amp;gt;、&amp;lt;p&amp;gt;）。 特点：可包含其他元素节点或文本节点，是节点树的 “骨架”。 根元素：&amp;lt;html&amp;gt; 是唯一不被其他元素包含的元素节点。 文本节点（Text Node）包含文本内容（如文字、空格），总是被元素节点包含（如 &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; 中，“Hello” 是文本节点）。 注意：并非所有元素节点都包含文本节点（如空标签 &amp;lt;img&amp;gt;）。 属性节点（Attribute Node）描述元素的附加信息（如 class、id、src），仅存在于元素的起始标签中。 特点：依赖元素节点存在，无法独立于元素存在（如 &amp;lt;a href=&amp;quot;url&amp;quot;&amp;gt; 中，href 是属性节点）。 CSS 与 DOM 的关联CSS 通过节点树结构应用样式，子元素会继承父元 …  ]]></content></entry><entry><title>第一章 JS简史</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/01--js%E7%AE%80%E5%8F%B2/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>DHTML</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  DOM（文档对象模型）核心定义：DOM 是一套对文档内容进行抽象和概念化的方法，它将 HTML/XML 文档的结构转化为一个树形的对象模型，使得程序（如 JS）可以访问和操作文档的内容、结构和样式。 作用：作为 JS 与网页内容之间的桥梁，允许开发者通过代码动态修改文档的元素、属性、文本等（例如添加节点、修改样式、绑定事件等）。 DHTML（动态 HTML）本质：DHTML 并非一项独立技术，而是 HTML、CSS 和 JavaScript 三种技术的组合术语，用于描述 “动态操控网页内容和样式” 的技术方案。 核心组成与目标： HTML：负责标记网页的结构和内容（如 &lt;div&gt;、&lt;p&gt; 等元素）； CSS：负责定义元素的样式（颜色、布局、位置等）； JavaScript：负责实时操控页面元素和样式（如动态修改 CSS 属性、显示 / 隐藏元素、响应用户交互等）。 核心价值：通过三者协同，实现网页内容的动态更新，无需重新加载页面即可改变外观和行为（如表单验证、菜单切换、实时数据展示等）。 API（应用程序编程接口）定义：API 是一组得到各方共同认可的基本约定，规定了不同组件（如软件、库、服务）之间如何交互的规则（包括可调用的函数、参数格式、返回值类型等）。 举例： DOM API：如 document.getElementById()、element.appendChild() 等，规定了 JS 操作文档的方法； 浏览器 API：如 fetch()（网络请求）、localStorage（本地存储）等，提供了 JS 与浏览器功能交互的接口。 作用：简化开发，使不同模块或系统能够按照统一规则协作，无需关注内部实现细节。   ]]></content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0405--%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>Web Worker</tag><tag>性能优化</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Web Worker 基础定义与作用：
Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。 创建与类型：
专用 Worker（Dedicated Worker）：通过 new Worker(&#39;script.js&#39;) 创建，与主程序是一对一关系，仅能与创建它的程序通信。
示例：
// 主程序中创建专用 Worker const w1 = new Worker(&amp;#34;worker.js&amp;#34;);Worker 通信机制消息传递：
不共享作用域 / 资源，通过 message 事件双向通信，数据传递基于结构化克隆或所有权转移。
主程序与 Worker 内部均通过 postMessage(data)发送消息，通过 onmessage 监听消息：
// 主程序 w1.postMessage(&amp;#34;hello&amp;#34;); // 发送消息到 Worker w1.onmessage = (e) =&amp;gt; console.log(&amp;#34;收到 Worker 消息：&amp;#34;, e.data); // worker.js 内部 self.onmessage = (e) =&amp;gt; { console.log(&amp;#34;收到主程序消息：&amp;#34;, e.data); self.postMessage(&amp;#34;hi&amp;#34;); // 发送消息到主程序 };终止 Worker：
主程序中调用 w1.terminate() 可立即终止 Worker（无清理机会）； Worker 内部可调用 self.close() 主动终止自身。 Worker 运行环境限制与可用资源： 不可访问 DOM、主程序全局变量，但可使用 navigator、location、JSON、setTimeout 等，支持网络请求（如 fetch）。 可通过 importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;) 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。 典型应用场景： 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。 数据传递方式结构化克 …  ]]></content></entry><entry><title>4.4节 生成器</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0404--%E7%94%9F%E6%88%90%E5%99%A8/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>生成器</tag><tag>迭代器</tag><tag>异步模式</tag><tag>前端开发</tag></tags><content type="html">  生成器的基本概念与特性定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 生成器产生值：生产者与迭代器迭代器接口作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 for..of循环自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 Iterable（可迭代对象）定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 生成器迭代器的特性生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 异步迭代生成器生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&amp;amp;#34;http://...&amp;amp;#34;, (err, data) =&amp;amp;gt; { if (err) it.throw(err); // 向生成器抛 …  </content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0403--promise/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>异步模式</tag><tag>Promise</tag><tag>前端开发</tag></tags><content type="html">  什么是 Promise未来值核心特性：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。 状态与不可变性： 封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。 一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。 then 方法的双回调：调用then(onFulfilled, onRejected)时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。 完成事件（流程控制）本质：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。 反控制反转： 传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过then注册回调，等待 Promise 决议后触发，将控制返还给调用代码。 信号特性：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。 具有 then 方法的鸭子类型thenable 定义：任何具有then方法的对象或函数，被视为与 Promise 一致的 “thenable”。 鸭子类型：通过值的形态（是否有then方法）假定其类型，这是识别 Promise 的核心逻辑。 Promise 信任问题（可靠性保障）异步回调：对 Promise 调用then时，即使 Promise 已决议，回调也始终异步执行（下一个事件循环 tick），确保行为一致。 决议的唯一性： Promise 只能被决议一次（首次调用resolve或reject生效，后续调用被忽略），因此then注册的回调仅执行一次。 若同一回调多次注册，会按注册次数执行。 决议值的单一性： 至多有一个决议值（未显式决议时为undefined），传给所有注册的回调。 调用resolve/reject时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。 异常处理：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。 Promise.resolve 的作用： 传入非 Promise / 非 thenable 值：返 …  </content></entry><entry><title>4.1节 异步：现在与将来</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0401--%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>异步模式</tag><tag>事件循环</tag><tag>前端开发</tag></tags><content type="html">  分块的程序与异步机制分块程序的本质： 将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。 console.log 的异步特性： 部分浏览器的console.log并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。 事件循环核心机制： 事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个tick：
若队列中有等待事件（即回调函数），则从队列中取出一个执行； 无事件时，循环等待新事件加入。 核心流程，循环周期（tick）：检查 “宏任务队列”（如setTimeout、DOM事件），若有等待任务，取出第一个执行； 执行完当前任务后，检查 “微任务队列”（如Promise.then），清空所有微任务； 更新 UI（浏览器环境）； 重复步骤 1-3。 setTimeout 的作用： 并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。
并行执行异步与并行的区别： 异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）； 并行：关注 “同时发生”（多个操作在物理上同时进行）。 进程与线程： 进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存； JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。 JS 的单线程特性： 函数代码具有原子性（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）； 若函数执行顺序不确定，可能导致竞态条件（因共享状态的修改顺序不可控引发的逻辑错误）。 并发定义： 两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。
JS 的并发形式： 单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。
并发交互的协调方式：
门（Gate）：等待多个条件都满足后再执行下一步。例如： …  </content></entry><entry><title>4.2节 回调</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0402--%E5%9B%9E%E8%B0%83/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>异步模式</tag><tag>回调</tag><tag>前端开发</tag></tags><content type="html">  回调函数的本质回调函数的核心作用是包裹或封装程序的延续逻辑—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。
回调地狱（Callback Hell）的成因回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：
思维与代码的不匹配：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。
控制反转导致的信任问题： 回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：
无法确保回调被调用的次数（可能被多次调用或不调用）； 无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）； 无法确保回调的参数符合预期。 回调模式的优化设计为缓解回调地狱和信任问题，常见的回调模式设计：
分离回调（Split Callbacks）： 为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。
错误优先回调（Error-First Callbacks，Node 风格）： 回调函数的第一个参数固定为错误对象，后续参数为成功结果：
若操作成功，错误参数为null或undefined； 若操作失败，错误参数为非空值（通常是Error对象）。 回调调用的最佳实践：永远异步执行即使回调逻辑可以同步完成，也应强制异步调用（如通过setTimeout或队列机制），确保回调行为的一致性：
避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）； 保证所有回调都遵循相同的异步逻辑，减少不可预测性。   </content></entry><entry><title>3.5节 语法</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0305--%E8%AF%AD%E6%B3%95/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>ASI</tag><tag>前端开发</tag></tags><content type="html">  语句与表达式的基本概念表达式：能返回一个结果值的代码片段（如1 + 2返回3，obj.prop返回属性值）。 语句：执行某种操作的代码（如if、for、return），所有语句都有结果值，但语法默认不允许直接获取。 语句的结果值常见语句的结果值： 赋值语句a = b：结果值为被赋予的值（即b的值）。 变量声明var a：结果值为undefined（let/const同理）。 代码块{...}：结果值为块内最后一个语句 / 表达式的结果（如{1; 2; 3}结果为3）。 获取语句结果值的方式：语法不直接支持，但可通过eval()获取（如eval(&amp;#39;{a=1; b=2}&amp;#39;)返回2）。 表达式的副作用副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。
常见有副作用的表达式函数调用：最常见（如console.log(1)会输出内容，改变控制台状态）。 自增 / 自减运算符： a++：先返回a的当前值，再将a加 1（副作用在后）。 ++a：先将a加 1，再返回新值（副作用在前）。 注意：++a++会报错（ReferenceError），因运算符需要可赋值的变量作为操作数。 逗号运算符：将多个表达式串联为一个语句，返回最后一个表达式的结果（如a=1, b=2, a+b结果为3），副作用是执行所有表达式。 delete 操作符： 作用：删除对象属性或数组单元。 结果值：成功删除（属性不存在或可配置）返回true；失败（不可配置属性）返回false或报错。 副作用：实际移除属性 / 单元（如delete obj.prop后obj.prop为undefined）。 赋值语句：a = 42结果为42，副作用是a被赋值为42；链式赋值（如a = b = 42）利用赋值表达式的结果值实现。 上下文规则大括号{}的用法对象常量：定义对象字面量（如{a: 1, b: 2}）。
标签（label）：用于标记代码块，配合break/ continue跳转：
break 标签：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。 continue 标签：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。 注意：标签不能用双引号；非循环代码块可使用break 标签，但不能用continue 标签。 JSON 与 JSON-P：
JSON …  </content></entry><entry><title>附录 混合环境JS</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>宿主环境</tag><tag>Annex B 规范</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Annex B（ES 规范的兼容性补充）背景： ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。
主要兼容性差异：
非严格模式允许八进制数值常量（如012，严格模式下为语法错误）；
浏览器提供window.escape()和window.unescape()，用于转义 / 还原带%分隔符的十六进制字符串（非标准方法，建议避免使用）；
String.prototype.substr与String.prototype.substring
的区别：
substring(start, end)：第二个参数为结束位置索引（不包含该位置）； substr(start, length)：第二个参数为截取长度。 Web ES 规范的额外差异：
&amp;lt;!--和--&amp;gt;被视为合法单行注释分隔符； String.prototype包含返回 HTML 格式字符串的附加方法（如anchor()、bold()）； 正则表达式（RegExp）扩展及Function.prototype附加方法（非标准，依赖浏览器实现）。 宿主对象定义：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如window、document、console），包括内建对象和工具函数。 特殊行为差异： 部分宿主对象强制转换为布尔值时可能为假值（如document.all，不符合 JS 标准假值规则）； 其他特性： 可能无法访问普通Object的内建方法（如toString()）； 部分属性为只读，无法覆盖； 方法的this无法重绑定到其他对象。 console 对象： 宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。 全局 DOM 对象全局变量与 global 对象：声明全局变量会同时在全局对象（如浏览器的window）中创建同名属性。 DOM 元素 ID 的副作用：因浏览器历史遗留问题，带id属性的 DOM 元素会自动创建同名全局变量（如&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;会生成window.app）。 原生原型扩展的注意事项不建议扩展原生原型：除非确保无代码冲突（如第三方库 …  ]]></content></entry><entry><title>第十章 远程共同协作</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/10--%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 远端操作</tag><tag>GitHub</tag><tag>版本控制工具</tag><tag>团队协作</tag><tag>Git</tag></tags><content type="html"><![CDATA[  将内容推送到 GitHub前置准备
在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。 关联远端仓库
git remote add origin &amp;lt;GitHub仓库地址&amp;gt;remote add：添加远端节点。
origin：远端 节点的默认名称（可自定义或修改）。
远端仓库管理（补充操作）- **查看远端配置**：`git remote -v`（显示远端名称、地址及操作类型，确认是否关联正确）。- **修改远端地址**：`git remote set-url origin &amp;lt;新地址&amp;gt;`（如仓库迁移后更新地址）。- **删除远端关联**：`git remote remove origin`（解除与远端的绑定）。推送内容到远端
git push -u origin master作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。 后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。 upstream 作用 本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。 推送时重命名分支
git push origin master:cat # 将本地master推送到远端并命名为cat从 GitHub 拉取更新（pull/fetch）命令 本质 适用场景 git fetch 仅获取远端更新（更新origin/xxx分支），不合并 需先查看远端修改再决定是否合并（安全） git pull git fetch + git merge 快速同步远端修改（可能产生合并 commit） git pull --rebase git fetch + git rebase 保持历史线性（无合并 commit，推荐协作场景） fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。 pull …  ]]></content></entry><entry><title>09- 类</title><url>/post/ts/09--%E7%B1%BB/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>对象</tag><tag>前端开发</tag></tags><content type="html">  类的字段字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。
基本特性 字段声明默认创建公共可写属性，类型可显式声明（如x: number）或通过初始化值推断（如x = 0 → 推断为number）。 未指定类型且无初始化值时，隐式为any（可通过noImplicitAny禁用，强制显式声明）。 初始化相关 初始化器：字段可直接赋值（如x = 0），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。 strictPropertyInitialization 配置： 开启时，字段必须在构造函数内或初始化器中初始化，否则报错（防止访问未初始化的属性）。 例外：用!（明确赋值断言）标记 “后续会初始化” 的字段（如name!: string，常用于依赖注入场景）。 注意：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。 readonly 修饰符 标记字段为只读，仅可在初始化器或构造函数中赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。 构造函数类的初始化函数，用于实例化时设置初始状态。
与函数的异同 相似性：支持类型注释、默认值、重载（如多构造函数签名）。 区别： 不能有类型参数（类型参数属于外部类声明）； 不能有返回类型注释（默认返回类实例类型）。 super () 调用要求 派生类构造函数中，使用this前必须调用super()（调用基类构造函数），否则 TypeScript 报错。 方法与访问器类的函数属性，用于定义行为和属性访问逻辑。
方法 本质是类的函数属性，支持类型注释（参数和返回值）。 方法体内访问字段 / 其他方法必须通过this.，否则引用外部变量。 访问器 包括get（读取）和set（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。 TypeScript 推断规则： 仅有get时，属性自动为readonly； 未指定set参数类型时，从get返回类型推断； 4.3+ 版本支持get和set使用不同类型。 注意：无额外逻辑的get/set对意义不大，建议直接用公共字段。 索引签名类可声明索引签名，与对象类型索引签名规则一致。
示例：class MyClass { [s: string]: …  </content></entry><entry><title>06- 泛型</title><url>/post/ts/06--%E6%B3%9B%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>泛型</tag><tag>类型系统</tag><tag>方差</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  类型变量类型变量是泛型的 “灵魂”，用于在类型层面建立关联（而非值层面），解决 “同一份逻辑适配多种类型” 的问题。
基本用法// 定义泛型函数：类型变量&amp;lt;Type&amp;gt;关联输入与输出类型 function identity&amp;lt;Type&amp;gt;(arg: Type): Type { return arg; } // 两种调用方式 let output1 = identity&amp;lt;string&amp;gt;(&amp;#34;myString&amp;#34;); // 显式指定类型参数 let output2 = identity(42); // 类型推断（推荐）：编译器自动推断Type为number 核心价值：避免重复编写不同类型的同名函数（如identityString、identityNumber），同时保持类型安全（对比any：any会丢失类型关联，泛型则保留输入与输出的类型一致性）。 类型推断：编译器可通过传入的值自动推断类型参数，简化代码。复杂场景下若推断失败，需显式指定类型。 类型约束：函数体内必须正确使用泛型参数（视为 “任意类型” 处理）。 泛型函数的类型定义泛型函数的类型与非泛型函数类似，需先声明类型参数，有多种表达方式：
直接作为函数类型
let myIdentity: &amp;lt;Type&amp;gt;(arg: Type) =&amp;gt; Type = identity;使用不同名称的类型变量（只要数量和使用方式一致）
let myIdentity: &amp;lt;Input&amp;gt;(arg: Input) =&amp;gt; Input = identity; // 合法：Input与Type作用相同 对象字面量的调用签名
let myIdentity: { &amp;lt;Type&amp;gt;(arg: Type): Type } = identity;泛型接口
// 接口内声明泛型调用签名 interface GenericIdentityFn { &amp;lt;Type&amp;gt;(arg: Type): Type; } let myIdentity: GenericIdentityFn = identity; // 接口本身泛型化（更常用） interface GenericIdentityFn&amp;lt;Type&amp;gt; { (arg: Type): Type; } let …  ]]></content></entry><entry><title>07- 类型运算符</title><url>/post/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>类型系统</tag><tag>类型运算符</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  keyof 运算符keyof 用于将对象类型的所有键名转换为字面量联合类型，是实现 “类型安全的键访问” 的基础。
基础用法type Point = { x: number; y: number }; type P = keyof Point; // 等价于 type P = &amp;#34;x&amp;#34; | &amp;#34;y&amp;#34; 作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。 与索引签名结合当对象类型包含 string 或 number 索引签名时，keyof 会返回对应的索引类型：
// number 索引签名 type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; // type A = number（仅允许 number 类型索引） // string 索引签名 type Mapish = { [k: string]: boolean }; type M = keyof Mapish; // type M = string | number 因为 JavaScript 会将数字索引自动转换为字符串（如 obj[0] 等价于 obj[&amp;quot;0&amp;quot;]），因此 string 索引签名隐含支持 number 索引。 keyof与Object.keys的区别： keyof：在类型层面工作，返回键的字面量联合类型（编译时）。 Object.keys：在值层面工作，返回键的字符串数组（运行时）。 typeof 运算符（类型上下文）typeof 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。
基本用法let s = &amp;#34;hello&amp;#34;; let n: typeof s; // 类型为 string（n 的类型与 s 一致） 与函数结合获取函数的类型（而非调用结果的类型），配合 ReturnType 可提取返回值类型：
function f() { return { x: 10, y: 3 }; } type FType = typeof f; // () =&amp;gt; { x: number; y: number } …  ]]></content></entry><entry><title>08- 条件类型</title><url>/post/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>类型系统</tag><tag>条件类型</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  条件类型条件类型通过判断类型关系返回不同类型，基本形式为 SomeType extends OtherType ? TrueType : FalseType，核心价值在于与泛型结合实现灵活的类型逻辑。
基本用法当 SomeType 可赋值给 OtherType 时，返回 TrueType；否则返回 FalseType
type Example1 = Dog extends Animal ? number : string; // 若Dog是Animal的子类型，返回number 与泛型结合条件类型与泛型结合可简化重载，实现类型与值的动态关联：
// 需求：输入number返回IdLabel，输入string返回NameLabel type IdLabel = { id: number }; type NameLabel = { name: string }; // 条件类型关联输入与输出类型 type Label&amp;lt;T extends number | string&amp;gt; = T extends number ? IdLabel : NameLabel; // 单个函数替代重载 function createLabel&amp;lt;T extends number | string&amp;gt;(value: T): Label&amp;lt;T&amp;gt; { return typeof value === &amp;#34;number&amp;#34; ? { id: value } : ({ name: value } as Label&amp;lt;T&amp;gt;); } const label1 = createLabel(10); // 类型：IdLabel（{ id: number }） const label2 = createLabel(&amp;#34;Alice&amp;#34;); // 类型：NameLabel（{ name: string }） 类型推断与 infer通过 infer 关键字在条件类型中声明性推断类型，无需显式指定提取逻辑：
示例 1：提取数组元素类型
type Flatten&amp;lt;Type&amp;gt; = Type extends Array&amp;lt;infer Item&amp;gt; ? Item : Type; type Str = …  ]]></content></entry><entry><title>第九章 其他常见的情况及冷知识</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/09--%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%8A%E5%86%B7%E7%9F%A5%E8%AF%86/</url><categories><category>Git从入门到精通</category></categories><tags><tag>版本控制工具</tag><tag>Git</tag></tags><content type="html"><![CDATA[  工作中途切换任务的处理（git stash）git stash用于临时保存工作区和暂存区的修改（未提交的内容），以便切换分支处理其他任务，后续可恢复继续工作。
保存当前修改： git stash # 保存已跟踪文件的修改（默认不包含untracked文件） git stash -u # 同时保存untracked文件（新文件） git stash -a # 保存所有修改（包括untracked和ignored文件，谨慎使用） git stash -m &amp;#34;描述信息&amp;#34; # 给stash添加描述，便于区分（推荐）查看保存的 stash： git stash list # 列出所有stash，格式：stash@{n}: WIP on &amp;lt;分支名&amp;gt;: &amp;lt;描述&amp;gt; # 示例：stash@{0}: WIP on feature/login: 完善表单验证恢复 stash：
git stash pop &amp;lt;stash@{n}&amp;gt;：恢复指定 stash 并从列表中删除（默认恢复最新的 stash@{0}）。 git stash apply &amp;lt;stash@{n}&amp;gt;：恢复指定 stash 但不删除（可多次应用，适合多分支复用）。 删除 stash：
git stash drop &amp;lt;stash@{n}&amp;gt; # 删除指定stash git stash clear # 清空所有stash（谨慎！）移除 Git 历史中的敏感信息（如账号密码）当不慎提交敏感文件后，需彻底从历史中删除。
推荐方法：git filter-repo（现代替代filter-branch） git filter-branch因性能差、易出错已被官方推荐git filter-repo替代（需先安装：pip install git-filter-repo）。
移除历史中的敏感文件：
# 彻底删除历史中所有&amp;#34;敏感文件路径&amp;#34;的痕迹 git filter-repo --path &amp;#34;敏感文件路径&amp;#34; --invert-paths--path：指定要删除的文件路径； --invert-paths：保留除指定路径外的所有内容（即删除目标文件）。 简单但粗暴的方法 删除 .git 目录（丢失所有历史）→ 删除敏感文件 → 重新初始化仓 …  ]]></content></entry><entry><title>05- 对象类型</title><url>/post/ts/05--%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>对象</tag><tag>泛型</tag><tag>元组</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  对象类型的基本定义对象类型是 TS 中描述数据结构的核心方式，主要有三种定义形式：
匿名对象类型 直接在参数或变量声明中定义，无需命名：
function greet(person: { name: string; age: number }) { return &amp;#34;Hello &amp;#34; + person.name; }接口（interface） 通过interface关键字命名对象类型，支持声明合并（多次定义同一接口会自动合并），可复用：
interface Person { name: string; age: number; } function greet(person: Person) { /* ... */ }类型别名（type alias） 通过type关键字为对象类型命名：
type Person = { name: string; age: number; }; function greet(person: Person) { /* ... */ }面试高频对比：
场景 interface type 声明合并 支持 不支持（重复声明报错） 扩展方式 extends继承 交叉类型（&amp;amp;）合并 适用类型 仅对象 / 类形状 任意类型（对象、联合、基础类型等） 对象属性的特性对象类型的属性可通过修饰符指定特性：
可选属性
标记为?的属性可省略，类型为T | undefined（在strictNullChecks开启时需显式处理undefined）。
示例：
interface User { name: string; age?: number; // 可选属性 } const user: User = { name: &amp;#34;Alice&amp;#34; }; // 合法，age可省略 只读属性（readonly）
标记为readonly的属性在类型检查期间不可被重写，但不影响其内部内容的可变性（如对象属性仍可修改）。
TypeScript 检查类型兼容性时不考虑readonly，因此可通过别名修改只读属性。
示例：
interface Point { readonly x: number; readonly y: number; } const p: Point = { x: 1, y: 2 }; p.x = 3; // 错误：只读属 …  ]]></content></entry><entry><title>第八章和第十一章 标签和gitflow</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/0811--%E6%A0%87%E7%AD%BE%E5%92%8Cgitflow/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 标签</tag><tag>Git Flow</tag><tag>Git</tag><tag>团队协作</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  Git 标签相关知识标签的概念与作用标签是 Git 中指向某个 commit 的指示标，常用于标记软件开发的特定里程碑（如版本发布）。 标签本质类似 “贴纸”，标签一旦创建，默认不会随新提交移动，删除标签不会影响对应的 commit 或文件。 标签的类型及使用轻量标签
特点：仅作为指向某个 commit 的指示标，不含额外信息。
创建方式：直接指定 commit（若不指定则默认当前 commit）
git tag &amp;lt;标签名&amp;gt; [commit的SHA-1值]示例：
git tag big_cats 51d54ff存储：指向某个 commit 的 SHA-1 值，存于 .git/refs/tags 目录。
有附注的标签
特点：包含更多信息（如标签创建者、时间、描述等），推荐使用。
创建方式：通过-a 参数创建，-m 可添加描述（若无-m则弹出 vim 编辑器）
```bashgit tag &amp;lt;标签名&amp;gt; [commit 的 SHA-1 值] -a -m &amp;ldquo;描述信息&amp;rdquo;
示例： ``` git tag big_cats 51d64ff -a -m &amp;#34;big cats are comming&amp;#34;存储：指向某个 Tag 对象的 SHA-1 值，该 Tag 对象再指向对应的 commit，存于 .git/refs/tags 目录。
标签的查看与删除
查看标签信息：git show &amp;lt;标签名&amp;gt;（如 git show big_cats） 删除标签：git tag -d &amp;lt;标签名&amp;gt;（如 git tag -d big_cats） 标签与分支的区别对比项 标签 分支 存储位置 .git/refs/tags 目录 .git/refs/heads 目录 内容格式 40 字节的 SHA-1 值 40 字节的 SHA-1 值 动态性 固定不变，不会随新 commit 移动 会随新 commit 推进而移动 本质类比 固定的 “贴纸” 可移动的 “标签” 删除影响 不影响被指向的对象 不影响被指向的对象 Git Flow 分支模型Git Flow 是一种规范化的分支管理流程，适用于中大型项目的协同开发，核心是通过不同类型分支的分工保证代码质量。
Git Flow 建议的分支类型及功能如下， …  ]]></content></entry><entry><title>03- 类型缩小</title><url>/post/ts/03--%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>类型系统</tag><tag>类型保护</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  类型缩小与控制流分析基础TS 会跟踪代码执行路径（如if/else、switch、循环等），分析变量在不同分支中的具体类型。
类型保护：特殊表达式（如typeof x === &#39;string&#39;），TS 可通过它判断变量类型，从而缩小类型范围。
类型缩小：通过类型保护或赋值操作，将变量类型从 “宽泛”（如联合类型）收缩为 “具体”（如单一类型）的过程。
基于 typeof 运算符的类型缩小TS 可识别typeof的 8 种返回值：&amp;quot;string&amp;quot;、&amp;quot;number&amp;quot;、&amp;quot;bigint&amp;quot;、&amp;quot;boolean&amp;quot;、&amp;quot;symbol&amp;quot;、&amp;quot;undefined&amp;quot;、&amp;quot;object&amp;quot;、&amp;quot;function&amp;quot;。
typeof 检查是一种类型保护，TypeScript 编码了 typeof 对不同值的操作逻辑，包括其在 JavaScript 中的一些特性。
基于真值检查的类型缩小JavaScript 中，if 等构造会将条件强制为布尔值，0、NaN、&amp;quot;&amp;quot;（空字符串）、0n（bigint 版本零）、null、undefined 强制为 false，其他值强制为 true。
可通过 Boolean 函数或双布尔否定（!!）将值强制为布尔值，后者的优势是 TypeScript 会推断出缩小的字面布尔类型 true，而前者推断为 boolean 类型。
利用这种行为防范 null 或 undefined 很常见，带有!的布尔否定会从否定分支中过滤掉这些值。
基于相等性检查的类型缩小TypeScript 使用 switch 语句和===、!==、==、!=等相等性检查来缩小类型。
== null 不仅检查值是否为 null，还检查是否为 undefined；== undefined 同样检查值是 null 还是 undefined。
基于 in 运算符的类型缩小JavaScript 的 in 运算符用于确定对象或其原型链是否具有指定名称的属性。
TypeScript 将 in 运算符视为缩小潜在类型的方式：对于&amp;quot;value&amp;quot; in x（&amp;ldquo;value&amp;quot;为字符串字面，x 为联合类 …  ]]></content></entry><entry><title>04- 更多关于函数</title><url>/post/ts/04--%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>函数</tag><tag>泛型</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  函数类型表达式基本语法：用箭头函数形式描述函数类型，如(a: string) =&amp;gt; void（参数a为string类型，无返回值）。
特点：参数名必须存在（仅用于标识，不影响类型匹配），未指定类型时隐式为any（可通过noImplicitAny禁用）。 示例：
function greeter(fn: (a: string) =&amp;gt; void) { fn(&amp;#34;Hello, World&amp;#34;); } function printToConsole(s: string) { console.log(s); } greeter(printToConsole); // 符合函数类型要求 类型别名命名：通过type给函数类型命名，提升可读性和复用性： type GreetFunction = (a: string) =&amp;gt; void; function greeter(fn: GreetFunction) { /* ... */ }类型兼容性（面试高频）：函数类型兼容遵循 “参数少的可赋值给参数多的”（逆变原则简化版）： type F1 = (a: string) =&amp;gt; void; type F2 = (a: string, b: number) =&amp;gt; void; const f1: F1 = (a) =&amp;gt; {}; const f2: F2 = f1; // 合法：F1参数更少，可兼容F2 带属性的函数与调用签名函数类型表达式的局限：仅能描述函数的调用方式，无法声明函数自身的属性（如fn.prop）。
调用签名：若需描述可调用且带属性的对象，可在对象类型中编写调用签名，参数列表与返回类型间用:分隔（而非=&amp;gt;）：
type DescribableFunction = { description: string; (someArg: number): boolean; // 调用签名 }; function doSomething(fn: DescribableFunction) { console.log(fn.description + &amp;#34; returned &amp;#34; + fn(6)); } function myFunc(someArg: number) { return someArg &amp;gt; 3; } …  ]]></content></entry><entry><title>02- 日常类型</title><url>/post/ts/02--%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>类型系统</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  基础类型与数组类型JavaScript 基础类型：string、number 、 boolean（对应 JS 原始类型），TypeScript 中可直接作为类型注解使用。
特点：使用typeof运算符对这些类型的值操作时，返回值与类型名一致（如typeof &#39;abc&#39; === &#39;string&#39;）。 数组类型：
两种声明方式：T[]（如number[]表示数字数组）或Array&amp;lt;T&amp;gt;（泛型形式，如Array&amp;lt;number&amp;gt;），两者完全等价。 特殊类型 any核心特性：关闭类型检查，允许值被任意操作（访问任意属性、作为函数调用、赋值给任何类型等）。
适用场景：
处理动态内容（如来自 API 的未知数据）。 迁移 JS 项目时临时兼容无类型代码。 隐式any：未指定类型且 TS 无法推断时，编译器默认视为any（可通过noImplicitAny配置项禁用，强制显式声明类型，面试高频考点）。
风险与替代：
滥用any会失去 TS 类型检查的意义，建议优先使用unknown（更安全，需显式类型断言后使用）。 变量与函数的类型注解变量注解： let 变量名: 类型 = 值（如 let age: number = 20）。
多数情况可省略：TS 会自动推断类型（如let name = &#39;ts&#39; → 推断为string）。 函数参数类型注解：在每个参数名称后添加，用于声明函数接受的参数类型，即使参数无类型注释，TypeScript 仍会检查参数数量是否正确。
函数返回类型注解：出现在参数列表之后。（如function add(a: number, b: number): number { return a + b }）。
函数参数类型自动推断：当函数出现在 TypeScript 可确定调用方式的地方时，其参数会自动被赋予类型。
对象类型基础定义：通过属性列表描述对象形状，如{ name: string; age: number }（属性间可用,或;分隔，最后一个可选）。
可选属性：属性名后加?（如{ name: string; age?: number }），表示该属性可不存在。
注意：访问可选属性前需检查是否为undefined（如if (obj.age !== undefined) { ... }）。 联合类型含义：由两种或多种其他类型组成，表 …  ]]></content></entry><entry><title>01-ts</title><url>/post/ts/01--ts/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript</tag><tag>静态类型</tag><tag>类型系统</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  静态检查与静态类型检查静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。
静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。
TypeScript 与 JavaScript 的关系TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。
关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。
重要特性：
TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。 TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。 注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = &#39;str&#39;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。
TypeScript 的核心优势（面试高频）提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。
增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。
提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。
更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。
TypeScript 的类型推断与扩展类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。 例：let x = 10 → TS 推断x为number；const y = { name: &#39;ts&#39; } → 推断y为{ name: string }。
类型注解：当推断结果不符合预期时，可显式指定类型（:后接类型）。 例：let z: string = &#39;hello&#39;；function add(a: number, b: number): number { return a + b }。
TypeScript 的类型系统基础类型（ …  ]]></content></entry><entry><title>第七章 修改历史记录</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/07--%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 历史管理</tag><tag>Git</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  修改历史信息命令：git rebase -i &lt;基准 commit&gt; -i：进入互动模式，可编辑历史提交。 &lt;基准commit&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。 操作过程： 执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与 git log的 “从新到旧” 相反）。 每行开头为操作指令，将 pick 改成 reword（或简写 r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。 影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。 取消 rebase：git reset ORIG_HEAD &ndash;hard 把多个 commit 合并成一个 commit执行 git rebase -i &lt;最早要合并的commit的前一个哈希&gt;（如合并最近 3 个 commit，基准为 HEAD~4）。 在编辑器中，将目标 commit 的 pick改为 squash（或 fixup） 保存退出后，若用 squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。 完成后，多个 commit 被合并为一个，历史更简洁。 把一个 commit 拆解成多个 commit在 rebase 的互动模式下使用 edit 指令，继续执行 rebase，rebase 会在 edit 位置停下来。 执行 git reset HEAD^指令。 重新 commit 拆出来的文件，再执行 git rebase &ndash;continue 让 rebase 继续即可。 在某些 commit 之间加新的 commit在 rebase 互动模式下，将目标 commit 改成 edit，继续执行 rebase，让 rebase 停在该 commit 上。 注意：处于 rebase 状态的 commit 列表与平常记录相反，需确认停下来的点正确。 增加新的 commit，完成后执行 git rebase &ndash;continue，即可在指定位置中间增加新 commit。 删除某几个 commit 或调整 commit 顺序调整顺序：在 rebase 交互模式下调整 commit 的位置，存档离开即可。 删除 commit：在 rebase 交互模式下，把对应 commit 的 pick 改成 drop，或直接删掉该记录即可。 reset、revert 和 rebase 指令的区别指令 特点 适用场景 reset 将 HEAD 指针移动到指定 commit，可重置工作区 / 暂存区（--hard/--mixed/--soft） 通常适用于尚未推出去的 commit revert 生成新 commit 抵消目标 commit 的修改，原 commit 保留 适用于已经推出去的 commit，或不允许使用 reset 和 rebase 修改历史记录的情景。例如取消最后的 commit：git revert HEAD &ndash;no-edit（&ndash;no-edit 表示不编辑 commit 信息） rebase 重建 commit 历史（修改、合并、拆分、插入 commit） 通常只适用于尚未推出去的 commit   ]]></content></entry><entry><title>第六章 使用分支</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/06--%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 分支</tag><tag>Git</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  分支的基本操作查看分支 执行 git branch 命令，不带任何参数时，会输出当前项目中的所有分支，前面带有星号的分支表示当前所在分支（即 HEAD 指向的分支）。 扩展命令（面试高频）： git branch -r：查看远程分支（如origin/main）。 git branch -a：查看本地 + 远程所有分支（远程分支以remotes/前缀显示）。 git branch -v：显示各分支最后一次提交信息（哈希 + 说明）。 创建分支 在 git branch 命令后加上想要创建的分支名称，即可基于当前分支为基准创建新分支（仅创建，不切换），例如 git branch cat。 修改分支名称 使用-m 参数可以修改分支名称，即使是 master 分支也能修改，且不会影响文件或目录（当前分支可省略旧名，直接git branch -m &amp;lt;新名&amp;gt;），如 git branch -m cat tiger。 删除分支 使用-d 参数可以删除不需要的分支，如 git branch -d dog。
若要删除的分支未被完全合并，-d 参数无法删除，此时可使用-D 参数强制删除，如 git branch -D dog。
当前所在的分支不能删除，需先切换到其他分支再进行删除操作。
切换分支 使用 git checkout 命令切换分支，如 git checkout dog，切换的分支必须已存在，否则会出错（Git 2.23 + 推荐用git switch &amp;lt;分支名&amp;gt;，更直观）。
若要切换的分支不存在，可在 git checkout 后加上-b 参数，若分支不存在则创建并切换过去，若已存在则直接切换，如 git checkout -b new_branch。
注意：切换分支前，需 commit 或 stash 工作区的修改（否则未提交的修改会被带到新分支）。
对分支的理解可以将分支想象成一张贴纸，贴在某个 commit 上。当进行新的 commit 后，新的 commit 会指向其前一个 commit，当前分支（HEAD 所指分支）会贴到新的 commit 上，HEAD 也会随之前进。
Git 中的分支并非通过复制目录或文件夹形成，它只是一个指向 commit 的指标。
切换分支的原理切换分支时，Git 会用该分支指向的 commit 内容更新暂存区及工 …  ]]></content></entry><entry><title>3.4节 强制类型转换</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0304--%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>类型系统</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  值类型转换的基本概念定义与区分： 显式类型转换：主动将值从一种类型转换为另一种（如String(123)）。 隐式强制类型转换：操作中自动发生的类型转换（如1 + &amp;quot;2&amp;quot;）。 特性：JS 强制类型转换始终返回标量基本类型值，对象封装（如new Number(1)）不算严格意义上的强制转换。 与其他语言的差异： 静态类型语言的 “类型转换” 发生在编译阶段； 动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。 抽象值操作（内部使用的转换规则）抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括ToString、ToNumber、ToBoolean。
ToString（非字符串 → 字符串）基本类型转换规则：
null → &amp;quot;null&amp;quot;；undefined → &amp;quot;undefined&amp;quot;；true → &amp;quot;true&amp;quot;；false → &amp;quot;false&amp;quot;。 数字：常规数字直接转换（如123→&amp;quot;123&amp;quot;），极小 / 极大数字用指数形式（如1e-20、1e+20）。 对象 / 数组转换：
普通对象：默认返回内部属性[[Class]]值（如&amp;quot;[object Object]&amp;quot;）；若自定义toString()方法，则调用该方法并使用其返回值。 数组：toString()将所有元素字符串化后用,连接（如[1, 2, 3].toString() → &amp;quot;1,2,3&amp;quot;）。 JSON.stringify () 的特殊处理：
作用：将 JSON 对象序列化为字符串，遵循ToString规则但结果必为字符串。
安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ undefined、function 、symbol、循环引用对象）的处理：
对象中遇到非安全值：自动忽略。 数组中遇到非安全值：返回null（保持数组长度）。 循环引用对象：直接报错。 toJSON()方法：若对象定义了toJSON()，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：toJSON()应返回安全值，而非字符串）。
可选参数：
replacer（数组 / 函 …  ]]></content></entry><entry><title>第五章 开始使用git</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/05--%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  新增、初始 Repository命令：git init
作用：在目录中创建一个.git 目录，该目录是 Git 进行版本控制的核心。若移除.git 目录，Git 将失去对该目录的控制权，可用于提供不含版控记录的内容给客户。
把文件交给 Git 管控查看目录状态：git status
显示文件状态：Untracked（未跟踪，新文件）、Modified（已修改未暂存）、Staged（已暂存待提交）。 添加文件到暂存区：
单个文件：git add &amp;lt;文件名&amp;gt;，将指定文件安置到暂存区。
特定类型文件：git add *.html，把所有后缀为.html 的文件加到暂存区。
全部文件：
git add &amp;ndash;all（或git add -A），添加项目中所有异动文件到暂存区；
git add .，添加当前目录及子目录中的异动文件到暂存区，对目录外文件无效。
注意事项：git add 后若再次改动文件，改动内容不会自动加入暂存区，暂存区仍为之前的版本，此时git status会显示文件同时处于Modified（工作区）和Staged（暂存区）状态。
提交到存储库：git commit -m &amp;lsquo;init commit&amp;rsquo;，-m 后为提交说明，将暂存区内容永久保存到存储库。每次 commit 仅处理暂存区内容，未加入暂存区的文件不会被提交。
空提交：git commit &amp;ndash;allow-empty -m &amp;ldquo;&amp;quot;，加上&amp;ndash;allow-empty 参数，无文件变动时强制提交（常用于触发 CI/CD 流程或标记重要节点）。
工作区、暂存区与存储库关系：git add 将文件从工作目录移至暂存区，git commit 将暂存区内容移至存储库，完成 commit 才算整个流程结束。
简化提交：git commit -a -m &amp;ldquo;update content&amp;rdquo;，-a 参数可缩短流程，跳过git add，直接将已跟踪文件的修改提交（新文件Untracked不生效，仍需手动add）。
查看记录基本查看：git log，越新的信息越靠上，显示作者、提交时间、提交说明等。 精简查看： git log --oneline：每行显示一条记录（哈希前缀 + 说明）。 git log …  ]]></content></entry><entry><title>3.1节 类型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0301--%E7%B1%BB%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>类型系统</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内置类型概述定义：类型是值的内部特征，决定值的行为，以区分于其他值。 分类： 基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。 对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。 typeof 运算符作用：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。 特殊情况： null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理） 检测 null 值类型的复合条件：!a &amp;&amp; typeof a === 'object'（因 null 是假值，且是唯一用 typeof 检测返回 &lsquo;object&rsquo; 的基本类型值）。 对象子类型函数（function）： 是 object 的子类型，属于可调用对象。 具有内部属性 [[Call]]，使其可被调用。 可拥有属性，如 length 属性表示其声明的参数个数。 typeof function返回&quot;function&quot;，是历史遗留的特殊处理 数组： 是 object 的子类型。 元素按数字顺序索引，length 属性表示元素个数。 值和类型的特性变量与类型的关系： JS 中变量无类型，只有值有类型。 变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。 对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。 undefined 与 undeclared 的区别： undefined：变量已在作用域中声明但未赋值。 undeclared：变量未在作用域中声明过。 typeof 的安全防范机制： 对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。 应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。 其他安全检查方法： 检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。 依赖注入设计模式：将依赖通过参数显式传递到函数中。   ]]></content></entry><entry><title>3.2节 值</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0302--%E5%80%BC/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag><tag>数组</tag><tag>字符串</tag></tags><content type="html"><![CDATA[  数组特性： 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。 使用delete运算符删除单元后，位置变为空白单元，数组length属性不变。 稀疏数组： 指含有空白 / 空缺单元的数组，空白单元值为undefined，但与显式赋值为undefined的单元有区别（如[,,]与[undefined, undefined]行为不同）。 索引与属性： 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在length内，length只计算数字索引的最大整数 + 1）。 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。 类数组转换： 类数组特征：有length和数字索引，但无数组方法（如arguments、DOM 集合NodeList） 可转换为真正的数组，常用方法： Array.prototype.slice.call(类数组) ES6 的Array.from(类数组) 扩展运算符（需类数组为可迭代对象） 字符串与数组的区别： 是类数组（有length、indexOf()、concat()等），但并非字符数组。 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。 数组方法的借用： 可借用数组的非变更方法（如Array.prototype.indexOf.call(str, &#39;a&#39;)）处理字符串。 不可借用数组的变更方法（因字符串不可变），需先通过split(&#39;&#39;)转为数组，处理后再用join(&#39;&#39;)转回字符串。 数字类型与格式：
JS 只有一种数值类型number（双精度浮点数），包含整数（如42.0）和带小数的十进制数。 字面量表示： 十进制：可省略小数点前的 0（.42）或后多余的 0（42.）。 特殊格式：指数形式（1e3）、二进制（0b1010）、八进制（0o12）、十六进制（0xa）。 显示规则：
大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同toExponential()）。 Number 对象方法：
toFixed(n)：指定小数部分显示位数，不足用 0 补齐（返回字符串）。 toPrecision(n)：指定有效数位的显示位数。 注意：数字字面量调用方法时，需避免.被误判为数字一部分（如42..toFixed(2)或42 …  ]]></content></entry><entry><title>3.3节 原生函数</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0303--%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag><tag>对象</tag></tags><content type="html"><![CDATA[  内部属性 [[Class]]基本概念： 内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。 属性特征： 所有typeof返回值为object的对象都包含内部属性[[Class]]，该属性无法直接访问。 通常通过Object.prototype.toString()方法查看[[Class]]的值。 对应关系： 多数情况下，对象的[[Class]]属性值与创建该对象的内建原生构造函数相对应。 特殊情况：虽然不存在Null()和undefined()原生构造函数，但null和undefined的[[Class]]属性值分别为&#39;Null&#39;和&#39;Undefined&#39;。 封装对象包装自动包装机制： 基本类型值（如string、number等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。 手动封装与拆封： 手动封装：使用Object()函数（不带new关键字）可将基本类型值封装为对象。 拆封：通过valueOf()方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。 使用建议：除非必要，应避免使用构造函数创建封装对象。 原生函数作为构造函数Array()：
不带new关键字时会被自动补全（等效于new Array()）。 仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。 替代方案：ES6 的Array.of()（无歧义，始终将参数作为元素） 稀疏数组：包含至少一个空单元的数组，可通过以下方式创建： 设置length属性值超过实际单元数； 使用delete删除数组单元。 可通过Array.apply(null, {length: 3})创建包含undefined单元（非空单元）的数组。 不建议使用的构造函数： 除非特殊需求，尽量避免使用Object()、Function()、RegExp()作为构造函数。
Date()：
必须使用new Date()创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。 时间戳获取：getTime()方法或Date.now()（ES5+）可获取 Unix 时间戳。 特殊情况：不带new关键字调用Date()时，返回当前日期的字符串值（格式无统一规范）。 Error()： 带或不带new关键字均可使用。  …  ]]></content></entry><entry><title>第一 ~ 四章 初步使用git</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/01-04--%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8git/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>命令行</tag><tag>vim</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  Git 概述Git 是一种分布式版本控制系统，具有以下优点：
免费开源，降低使用成本，支持二次开发和定制化需求。 操作速度快、存储效率高，通过快照式存储而非差异对比，高效处理大型项目的版本控制。 分布式架构：无需依赖中央服务器，每个开发者可拥有完整版本库，断网时仍能提交代码，多人协作更灵活。 常用命令（跨系统对比）Windows macOS/Linux 说明 cd cd 切换目录 cd pwd 获取当前所在的位置 dir ls 列出当前目录的文件和目录 mkdir mkdir 创建新的目录 无 touch 创建文件 copy cp 复制文件 move mv 移动文件 del rm 删除文件 cls clear 清除终端显示内容 命令示例# 切换到上一层目录 cd .. # ~表示home目录，切换到home目录下的project目录 cd ~/project/ # 显示当前所在目录 pwd # 列出当前目录下所有文件及目录，包括以小数点开头的文件，并显示完整信息（权限、所有者、创建及修改时间等） ls -al # 删除目录中所有的.html文档 rm *.html # 创建文件，若文件不存在则创建空白文件，若已存在则仅修改最后修改时间 touch index.htmlls 命令说明ls 命令用于列出当前目录下的所有文件及目录，-al 参数中：
a：表示显示以小数点开头的文件。 l：表示显示文件的完整权限、所有者以及创建、修改的时间等信息。 vim 操作vim 主要通过模式切换进行输入、光标移动、选取、复制及粘贴等操作，常用模式有两种：
Normal 模式（命令模式）：默认进入的模式，无法输入文本，仅能进行复制、粘贴、存储或离开等操作。 Insert 模式（插入模式）：输入文本前需进入该模式，可通过按下 i（当前位置插入）、a（当前位置后插入）、o（新行插入）进入进入。在 Insert 模式下，按下 &amp;lsquo;Esc&amp;rsquo; 键或 &amp;lsquo;Ctrl+[&amp;rsquo; 组合键可退回 Normal 模式。 Normal 模式常用命令按下 “:w”：对文件进行存储。 按下 “:q”：关闭文件（若未存储会提示先存储再离开）。 按下 “:wq”：存储完成后直接关闭文件。 :q!：强制退出（不保存修改，放弃当前编辑）。 Git 配置基本配置（用户信 …  ]]></content></entry><entry><title>2.4节 原型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0204--%E5%8E%9F%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>对象</tag><tag>原型链</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  一、[[Prototype]] 基础定义：对象的特殊内置属性，本质是对其他对象的引用 默认值：几乎所有对象创建时，[[Prototype]] 都会被赋予非空值 [[Get]] 操作逻辑（属性查找）： 优先检查对象本身是否有目标属性，有则使用； 若无，沿 [[Prototype]] 链向上查找； 直至找到属性或遍历完整条原型链，未找到则返回 undefined 二、原型链终点：Object.prototype地位：所有普通对象的 [[Prototype]] 链最终都会指向 Object.prototype 作用：包含 JS 通用功能（如 toString()、hasOwnProperty() 等），供所有普通对象继承 核心通用方法方法 作用 示例 toString() 返回对象的字符串表示（默认&amp;quot;[object Object]&amp;quot;） ({}).toString() → &amp;quot;[object Object]&amp;quot; hasOwnProperty(key) 检查属性是否为对象自身所有（不含原型链） cat.hasOwnProperty(&amp;quot;eat&amp;quot;) → false（eat 在原型上） isPrototypeOf(obj) 检查当前对象是否在obj的原型链上 animal.isPrototypeOf(cat) → true valueOf() 返回对象的原始值（默认返回对象本身） (new Number(123)).valueOf() → 123 三、属性设置与屏蔽（myObject.foo = &#39;bar&#39;）1. 基础逻辑若 myObject 本身有 foo 普通数据属性：仅修改属性值； 若 foo 不在 myObject 中：沿 [[Prototype]] 链查找，未找到则直接在 myObject 上添加 foo； 若 foo 既在 myObject 中，也在原型链上层：myObject 的 foo 屏蔽原型链上层的 foo（优先取最底层属性）。 2. 特殊场景（foo 在原型链上层）原型链上层 foo 特性 结果 普通数据属性（非只读） 在 myObject 上添加 foo 屏蔽属性 只读数据属性（writable: false） 非严格模式：忽略赋值；严格模式：报错（无法添加屏蔽属性或修改原属性） 访问描述 …  ]]></content></entry><entry><title>2.5节 行为委托和class</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0205--%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>对象</tag><tag>类</tag><tag>原型链</tag><tag>前端开发</tag></tags><content type="html">  一、对象关联风格的核心特性与设计原则1. 状态存储原则核心规则：状态（数据属性）应保存在委托者对象上，而非委托目标（原型链上层对象）。 避免委托目标状态被多个委托者共享，导致数据污染或不可预期的修改。 2. 方法命名原则核心规则：尽量避免在 [[Prototype]] 链不同级别使用相同命名的方法（与类风格的“重写”逻辑相反）。 设计建议：使用描述性方法名（需体现对象行为类型），降低命名冲突风险，提升代码可理解性与可维护性。 3. 委托本质委托行为的核心：当对象自身找不到属性/方法时，会将请求委托给 [[Prototype]] 关联的对象（沿原型链向上查找）。 4. 委托限制禁止循环委托：无法在两个及以上对象间创建互相委托（如 A 关联 B、B 关联 A），会触发错误。 5. 思维模型与灵活性维度 特点 思维模型 仅关注对象之间的关联关系，不强调实体及实体间的层级（如父类-子类） 创建与初始化分离 支持“创建对象”与“初始化状态”分步执行，更符合关注分离原则，灵活性更高 对比类风格 类风格通常强制“构造+初始化”合并为一步（如 new 调用构造函数时同步初始化） 二、class 语法特点（ES6+）1. 多态实现支持通过 super() 实现相对多态：子类方法可通过 super 引用原型链上层的同名方法（模拟类继承中的“调用父类方法”）。 2. 声明限制仅能声明方法：class 字面量语法中，无法直接声明数据属性（需在构造函数 constructor 中通过 this.属性名 定义）。 示例：class A { foo() {}; // 允许；bar = 1; // 类字段语法（ESNext，非标准字面量声明） } 3. 扩展能力支持通过 extends 关键字自然扩展对象类型，包括内置对象类型（如 class MyArray extends Array {}），模拟类继承的“子类扩展父类”逻辑。 4. 本质与局限性维度 特点 本质 是 [[Prototype]] 机制的语法糖，并非真正实现面向类语言的“类”（无类实例化复制、无类级别的类型约束） super 绑定方式 静态绑定：super 指向的原型链上层对象在 class 定义时确定，无法动态修改（与类风格的动态关联不同） 动态修改难度 class 定义后，难以对其原型链、方法等进行动态调整（如修改 prototype 指向、新增/删除方法），灵活性低于原生对象关联   </content></entry><entry><title>2.3节 混合对象类</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0203--%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>对象</tag><tag>类</tag><tag>原型链</tag><tag>前端开发</tag></tags><content type="html">  类理论与 JavaScript 实现解析一、类理论核心概念本质：一种代码组织结构形式，用于对真实世界问题领域建模 核心思想：数据与操作数据的行为紧密关联（数据结构的封装） 分类：通过类对数据结构分类，将特定数据结构视为更广泛定义的特例 多态：父类通用行为可被子类重写，子类可通过相对引用访问父类基础行为 设计建议：父类与子类使用相同方法名表示特定行为，便于子类重写 二、类的机制类的本质：蓝图或模板，定义对象的结构和行为 实例：根据类创建的具体对象，包含类中描述的所有特性的副本 交互方式：可在实例上直接调用方法和访问共有属性 类与实例关系：可判断实例所属的类，但通常不通过实例直接操作类 实例化机制：通过复制类的定义创建实例对象 构造函数作用：初始化实例所需的所有信息 特性：属于类，通常与类同名 调用方式：大多需要用 new 关键字调用，指示引擎创建新的类实例 三、类的继承定义：子类继承父类的行为，是独立于父类的全新类 继承内容：包含父类行为的原始副本 扩展能力：可重写继承的行为或定义新行为 多态特性相对多态：
方法可引用继承层次中高层的方法 通过 super 等相对引用访问父类（超类）方法 子类构造函数中可通过 super 调用父类构造函数 方法重写：
同一方法名可在继承链不同层次多次定义 调用方法时自动选择对应实例所属类的定义 子类重写方法不影响父类中的原方法，两者相互独立 实现基础：类的继承本质是行为的复制
四、JavaScript 中的特殊性无类机制：JS 中只有对象，没有可被实例化的类 无自动复制：对象不会被复制到其他对象 关联关系：对象之间通过原型链建立关联，而非类继承的复制关系 继承模拟：通过原型链实现类似类继承的功能，但本质不同   </content></entry><entry><title>2.2节 对象</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0202--%E5%AF%B9%E8%B1%A1/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>对象</tag><tag>类型系统</tag><tag>数组</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  一、对象定义形式声明文字形式：{ key1: value1, key2: value2 } 可一次性定义多个键值对，简洁高效 构造形式：new Object() 需逐个添加属性（obj.key = value） 与文字形式生成的对象功能一致 二、JS 主要类型与对象子类型1. 六种主要类型基本类型：string、number、boolean、null、undefined 复杂类型：object（所有对象的基类） 2. 特殊对象子类型函数：可调用的对象，一等公民（可像普通对象操作） 数组：有序数值下标存储的对象，含额外数组方法 内置对象（构造函数）：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error 可构造对应子类型对象（如 new Array()） 语言会自动将字面量转换为内置对象（无需显式创建） 3. 特殊说明null/undefined：无构造形式，仅字面量 Date：仅有构造形式（new Date()），无字面量 Object/Array/Function/RegExp：文字形式与构造形式均为对象，构造形式仅在需要额外选项时使用 Error：通常在抛出异常时自动创建，也可显式构造（new Error()） 三、对象内容与属性访问1. 属性本质对象内容由属性（键值对）组成，存储的是属性名（指向值的指针） 属性名永远是字符串，非字符串类型会自动转换为字符串 2. 属性访问方式. 语法（属性访问）：obj.key，要求属性名符合标识符规范 [&amp;quot;&amp;quot;] 语法（键访问）：obj[&amp;quot;key&amp;quot;]，支持任意 UTF-8/Unicode 字符串作为属性名，可动态构造键名 3. 可计算属性名文字形式中用 [] 包裹表达式作为属性名：{ [expr]: value } 4. 符号（Symbol）新基础类型，值不透明且唯一，通常作为属性名避免冲突 实际值在不同引擎中可能不同，一般使用其名称 5. 属性与方法函数不属于对象，属性访问返回的函数与普通函数无区别（非“方法”） 本质是对函数对象的引用 四、数组特性支持 [] 访问，期望数值下标（非负整数） 是特殊对象，可添加命名属性（不影响 length） 建议：对象存键值对，数组存下标值对 若属性名类似数 …  ]]></content></entry><entry><title>2.1节 this</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0201--this/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>this 绑定规则</tag><tag>函数</tag><tag>前端开发</tag></tags><content type="html">  关于 thisthis 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件
this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
当一个函数被调用时，会创建一个活动记录（也称为执行上下文），这个记录会包含函数在哪里被调用，函数的调用方式，传入的参数等信息，this 就是这个记录的一个属性，会在函数执行的过程中用到
调用位置调用位置就是函数在代码中被调用的位置，在当前正在执行的函数的前一个调用中
调用栈：为了到达当前执行位置所调用的所有函数
绑定规则默认绑定：函数直接使用不带任何修饰的函数引用进行调用（独立函数调用），只能使用默认绑定，无法应用其他规则，非严格模式下，默认绑定绑定到全局对象，在严格模式下绑定到 undefined。
严格模式只在自执行函数内部生效。也就是说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。
隐式绑定：当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象，对象属性引用链中只有上一层或者说最后一层在调用位置中起作用
被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或 undefined 上，因为此时的函数可能是一个不带任何修饰的函数调用或者被当做参数传入函数形成了隐式赋值（间接引用）
显示绑定：所有函数都可以使用 call()和 apply()方法，它们的第一个参数是一个对象，接着在调用函数时将其绑定到 this
如果传入一个原始值来当做 this 的绑定对象，这个原始值会被转换成它的对象形式，这通常被称为装箱
硬绑定：一种显式的强制绑定
function foo() { console.log(this.a); } var obj = { a: 2, }; var bar = function () { foo.call(obj); };可以创建一个包裹函数，负责接收参数并返回值
var bar = function () { return foo.apply(obj, arguments); };另一种是创建一个可以重复使用的辅助函数
function bind(fn, obj) { return function () { return fn.apply(obj, …  </content></entry><entry><title>附录 作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/%E9%99%84%E5%BD%95-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>作用域</tag><tag>this绑定</tag><tag>函数</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  动态作用域核心逻辑：不关心函数“在哪里声明”，只关心函数“从哪里调用”——作用域链基于调用栈（运行时确定），而非代码的嵌套结构（定义时确定）。 与 JS 的关系：JS 本身没有动态作用域，只有词法作用域；但this机制的行为类似动态作用域（this指向依赖调用位置，而非定义位置）。 关键区别： 词法作用域：定义时确定（关注“函数在哪写的”）； 动态作用域：运行时确定（关注“函数在哪调用的”）。 块作用域的替代方案（ES6 前）ES6 前无原生块作用域（var声明为函数/全局作用域），可利用**catch分句**实现块作用域——catch的参数仅在catch块内有效，外部无法访问：
{ try { throw undefined; // 主动抛出错误，进入catch块 } catch (a) { // a的作用域仅在catch块内 a = 2; console.log(a); // 输出 2（块内可访问） } } console.log(a); // 报错：a is not defined（块外不可访问） this词法：箭头函数的this绑定核心特性：箭头函数不遵循普通函数的this绑定规则（如调用位置、bind/call/apply、对象方法绑定等），而是将this绑定为当前词法作用域的this（定义时确定，与外层函数的this一致）。 示例解析：
原代码中，setTimeout的箭头函数this继承自外层coolFn的this（即obj对象）： var obj = { count: 0, cool: function coolFn() { if (this.count &lt; 1) { // 箭头函数this = 外层coolFn的this（obj） setTimeout(() =&gt; { this.count++; // 相当于 obj.count++ }); } }, };等价写法（模拟箭头函数的this绑定效果）： 方式 1：用self保存外层this（ES6 前常用）： var obj = { count: 0, cool: function coolFn() { var self = this; // 保存coolFn的this（obj） if (self.count &lt; 1) { setTimeout(function timer() { self.count++; // 用self访问obj }); } }, };方式 2：用bind(this)绑定普通函数this： var obj = { count: 0, cool: function coolFn() { if (this.count &lt; 1) { setTimeout( function timer() { this.count++; }.bind(this), 100 ); // 绑定this为coolFn的this（obj） } }, };  ]]></content></entry><entry><title>1.4节 提升</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0104--%E6%8F%90%E5%8D%87/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>声明提升</tag><tag>前端开发</tag><tag>函数</tag></tags><content type="html">  变量和函数声明的提升机制提升的本质： 引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。
本质：并非字面意义的 “代码移动”，而是引擎在编译时将声明信息存入作用域的 “标识符表”，执行时优先从表中查找，而非按代码顺序。
作用域范围：每个作用域（全局、函数、块作用域）都会独立进行提升操作。
let/const并非 “不提升”，而是提升后进入 “暂时性死区”（从作用域顶部到声明语句之间的区域），禁止访问，避免var的 “声明前使用为undefined” 的反直觉行为。
函数声明与变量声明的提升优先级函数声明优先： 规则 1：函数声明先提升（完整提升：声明 + 函数体），变量声明后提升（仅声明，重复声明会被忽略）； 规则 2：若变量后续有赋值操作，赋值会覆盖函数声明（执行阶段生效）。 函数表达式不提升： 函数表达式（如var fn = function() {}）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到undefined。 具名函数表达式（如var fn = function named() {}）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。 特殊情况与注意事项重复声明的覆盖：变量重复声明（如var a = 1; var a = 2）会被忽略前序，保留最后一次赋值； 函数重复声明（如function a() {}; function a() {}）后序声明会覆盖前序。 变量赋值（执行阶段）会覆盖函数声明（编译阶段提升），但函数声明不会覆盖变量赋值； 块级函数声明的问题：ES6 前无块级作用域，函数在块内（如if/for）声明时，不同 JS 环境（浏览器 / Node.js）处理差异极大，易导致逻辑混乱：
非严格模式：部分浏览器（如 Chrome）会将块内函数声明提升到所在函数 / 全局作用域顶部（而非块级）； 严格模式：块内函数声明被限制在块级作用域内（类似let），但仍不推荐使用； 最佳实践：避免在块内声明函数，如需在块内定义函数，用函数表达式（如if (true) { const fn = function() {}; }），行为更可控。   </content></entry><entry><title>1.5节 作用域闭包</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0105--%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>闭包</tag><tag>模块模式</tag><tag>前端开发</tag><tag>函数</tag></tags><content type="html">  闭包的核心定义与本质定义：即使函数在词法作用域之外执行，仍能通过闭包访问原作用域的变量，且原作用域不会被垃圾回收机制销毁。 底层逻辑：函数创建时会记录其词法作用域（作用域链），当函数被传递到词法作用域之外执行时，引擎会通过函数的 “[[Scope]]” 内部属性，持续引用原作用域，阻止其被回收； 常见场景：只要使用回调函数（如定时器、事件监听器、Ajax 请求、异步任务等），本质都是在利用闭包。 循环与闭包：解决变量共享问题循环变量共享的痛点（var 声明）用 var 声明循环变量时，变量作用域为全局 / 函数级（非块级），所有迭代的回调函数共享同一个变量，导致执行时获取的是变量最终值（而非迭代时的值）：
// 问题代码：输出 5、5、5、5（而非 1、2、3、4） for (var i = 1; i &amp;amp;lt; 5; i++) { setTimeout(function () { console.log(i); }, i * 1000); }解决方案IIFE（立即执行函数表达式） 通过 IIFE 为每个迭代创建独立的词法作用域，将当前迭代的 i 作为参数传入，使回调函数闭包捕获该作用域的变量：
// 正确输出 1、2、3、4 for (var i = 1; i &amp;amp;lt; 5; i++) { (function (j) { // j 是每个迭代的独立变量 setTimeout(function () { console.log(j); }, j * 1000); })(i); // 立即执行，传入当前 i 的值 }let 声明的特殊行为 let 支持块级作用域，且在 for 循环头部声明时，会为每个迭代单独创建变量实例（每次迭代用前一次迭代的变量值初始化），无需额外闭包即可解决共享问题：
// 正确输出 1、2、3、4 for (let i = 1; i &amp;amp;lt; 5; i++) { setTimeout(function () { console.log(i); }, i * 1000); }let 解决该问题的本质是 “块作用域 + 迭代变量独立实例”，而非闭包，但底层仍依赖作用域机制（可理解为引擎自动为每个迭代创建了闭包）。
模块模式：基于闭包的封装模块模式的核心条件需满足两个必要条件，本质是利用闭包实现 “私有状态 + 公共 API” 的封 …  </content></entry><entry><title>1.2节 词法作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0102--%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>作用域</tag><tag>前端开发</tag></tags><content type="html">  词法作用域的核心特性定义与本质： 词法作用域是 JS 作用域的核心机制，由代码书写时的声明位置决定，与执行时的调用位置无关，是 “静态作用域” 的一种。 查找规则： 作用域查找从最内部作用域开始，逐级向外（向上）进行，直到找到第一个匹配的标识符后停止（即 “就近匹配”）。 仅查找一级标识符（如a，不会自动查找对象属性链如obj.a）。 遮蔽效应： 在多层嵌套作用域中，内层作用域的标识符可遮蔽外层同名标识符（如内层var a = 1会遮蔽外层的var a = 2）。 全局变量的特殊访问： 全局变量会成为全局对象（如浏览器中的window）的属性，可通过window.a访问被内层同名变量遮蔽的全局变量。 函数的词法作用域： 函数的词法作用域仅由其声明时所处的位置决定，与调用位置、调用方式无关。 欺骗词法作用域的方式eval 函数功能：接收字符串参数，将其视为代码片段插入到当前位置执行，仿佛该代码在书写时就存在于此。 对作用域的影响： 默认情况下，若eval中的代码包含变量 / 函数声明，会修改其所处的词法作用域（新增或覆盖标识符）。 严格模式下，eval有独立的词法作用域，内部声明不会影响外部作用域。 常见用途：执行动态生成的代码（如拼接字符串形成的逻辑）。 with 语句功能：作为访问对象多个属性的快捷方式，避免重复书写对象名（如with(obj) { a = 1; b = 2 }等效于obj.a = 1; obj.b = 2）。 对作用域的影响： 将传入的对象视为一个临时的词法作用域，对象的属性被当作该作用域中的标识符。 块内的var声明不会被限制在with块中，而是泄漏到外层函数作用域。 本质：根据传入对象 “凭空创建” 全新的词法作用域，与eval修改现有作用域的行为不同。 副作用与风险性能问题： eval和with会破坏 JS 引擎的词法作用域静态分析（无法提前确定变量查找规则），导致无法优化代码执行，显著降低运行效率。 代码可读性与维护性： 动态修改作用域会使变量的查找逻辑变得模糊，增加调试难度，不符合词法作用域的设计初衷。 严格模式限制： 严格模式下eval的作用域被隔离，with被完全禁止（直接抛出错误），进一步体现了对 “欺骗词法” 行为的不推荐。   </content></entry><entry><title>1.3节 函数作用域和块作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0103--%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>作用域</tag><tag>前端开发</tag><tag>函数</tag></tags><content type="html">  函数作用域的核心特性定义与复用：函数内部声明的变量，可在整个函数范围内（包括嵌套作用域）使用和复用。 隐藏内部实现： 通过函数作用域封装变量和函数，遵循最小特权原则（仅暴露必要内容，隐藏细节），减少命名冲突。 第三方库通常通过命名空间对象（将功能作为对象属性暴露）或模块管理器（避免全局作用域污染）防止冲突。 函数声明与表达式的区别区分方法： 若function是声明的第一个词，则为函数声明；否则为函数表达式。 关键差异： 函数声明的名称标识符绑定在所在作用域中； 函数表达式的名称标识符绑定在自身函数内部（外部不可直接访问）。 匿名函数表达式的缺点： 栈追踪无有意义名称，调试困难； 无法通过名称自引用（依赖arguments.callee，已过时）； 降低代码可读性。 最佳实践：始终为函数表达式命名（如const fn = function namedFn() {}）。 立即执行函数表达式（IIFE）定义：函数表达式被声明后立即执行（如(function() { ... })()）。
常见用途：
传递参数，隔离作用域（避免污染外部）； 确保undefined标识符的准确性（通过参数占位，如(function(undef) { ... })()）； 倒置代码执行顺序（将主逻辑作为参数传递给 IIFE）。 块作用域的特性与实现核心作用：将变量本地化，扩展最小授权原则，从函数级隐藏扩展到块级隐藏。 块作用域的优势：变量声明靠近使用位置，减少作用域污染，优化变量生命周期，避免提升带来的意外行为。 实现方式： with 语句：为对象创建临时块作用域（仅在with内部有效）； try/catch：catch分句创建块作用域，内部变量仅在catch中有效； let 关键字： 将变量绑定到所在块作用域（如if、for块）； 无提升特性（声明前访问会报错）； for循环中，let会将变量重新绑定到每个迭代（确保迭代值独立）。 const 关键字： 同let的块作用域特性，但值为常量（修改会报错），声明时必须赋值。 原书中 P34 最上方 “点击事件因闭包导致变量问题” 的描述有误：实际是var声明的变量属于函数 / 全局作用域，生命周期长，导致循环中共享同一变量；而let通过块作用域解决此问题。   </content></entry><entry><title>1.1节 作用域是什么</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0101--%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>作用域</tag><tag>编译原理</tag><tag>前端开发</tag></tags><content type="html">  程序状态与变量程序状态通过变量的存储与访问实现：变量是状态的载体，作用域则决定 “变量在何处可被访问”，两者共同支撑程序的动态执行。 作用域的本质作用域是一套管理变量的规则体系，核心解决两个问题： 变量声明的存储位置：编译器在编译阶段根据作用域规则，确定变量属于哪个作用域（全局 / 函数 / 块级）。 变量访问的查找逻辑：引擎在执行阶段根据作用域规则，从当前作用域向上逐级查找变量。 编译原理传统编译三阶段：分词 / 词法分析：将源代码字符串分解为有意义的词法单元（如关键字、变量名、运算符等）。 解析 / 语法分析：将词法单元流转换为抽象语法树（AST），AST 是体现程序语法结构的嵌套树状结构。 代码生成：将 AST 转换为可执行代码。 JavaScript 编译特点：JS 是 “即时编译（JIT）” 语言，编译不提前完成，而是在代码执行前的微秒级时间内完成，且编译与执行交替进行（如函数执行前先编译函数内部代码）。
作用域的核心角色引擎：统筹全局，负责代码的编译触发和执行，主导变量的查找与赋值。 编译器：负责语法校验、AST 生成、代码生成，在编译阶段处理变量声明，并告知作用域 “需存储该变量”。 作用域：相当于 “变量仓库”，按规则存储变量，响应引擎的查找请求 变量声明与赋值过程（以var a = 2为例）var a = 2 并非 “一次性操作”，而是编译器声明变量与引擎执行赋值两个独立步骤的结合，中间通过作用域衔接：
阶段 1：编译器处理变量声明（编译期）步骤 1：编译器在当前作用域中 “查询” 是否存在名为 a 的变量。 若存在：忽略当前声明（var 允许重复声明，后续声明会覆盖前序声明的变量，但不会重新初始化）； 若不存在：要求作用域在当前 “变量集合” 中新增一个名为 a 的变量（此时 a 仅声明，值为 undefined）。 阶段 2：引擎处理变量赋值（执行期）步骤 1：引擎向当前作用域发起LHS 查询（查找变量的 “容器本身”，用于赋值），询问 “是否存在名为 a 的变量”。 步骤 2：作用域查找结果： 找到 a：引擎将 2 赋值给 a； 未找到 a： 非严格模式：引擎自动在全局作用域创建名为 a 的变量，再赋值 2（变量泄露到全局）； 严格模式（&amp;amp;quot;use strict&amp;amp;quot;）：直接抛出 ReferenceError（ …  </content></entry><entry><title>3.1 语法</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0301-%E8%AF%AD%E6%B3%95/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag><tag>函数</tag></tags><content type="html"><![CDATA[  ES 基础语法规则大小写敏感性ES 中所有内容（变量名、函数名、操作符等）均区分大小写（如num与Num是两个不同变量）。
标识符规则标识符是变量、函数、属性或参数的名称，需满足：
首字符：必须是字母（a-z/A-Z）、下划线（_）或美元符号（$）； 后续字符：可增加数字（0-9）； 字符范围：支持扩展 ASCII 字母和 Unicode 字母（如中文变量名，但不推荐，惯例用英文）； 命名惯例：采用小驼峰式（如userName、calculateTotal）； 禁用情况：不能使用关键字、未来保留字，也不能用true、false、null作为标识符。 注释方式采用 C 语言风格注释，分两种：
单行注释：以//开头，注释范围仅限当前行（如// 这是单行注释）； 块注释：以/*开头、*/结尾，可跨多行（如/* 这是跨多行的块注释 */）。 严格模式定义：一种严格的 JS 解析/执行模型，禁用 ES3 不规范写法，对不安全操作抛错； 启用方式： 全局启用：在脚本开头加&amp;quot;use strict&amp;quot;;（预处理指令）； 函数内启用：在函数体开头加&amp;quot;use strict&amp;quot;;； 核心目的：避免语法歧义，提升代码安全性和规范性。 语句规则分号结尾：语句需以分号（;）结束，省略时由解析器自动补全（但不推荐，可能导致语法错误）； 代码块：多条语句可包裹在花括号（{}）中形成代码块； 最佳实践：即使控制语句（如if、for）仅执行一条语句，也建议用代码块（{}）包裹，避免逻辑歧义。 关键词与保留字关键词定义：ECMA-262 保留的有特殊用途的词汇（如if、for、function、return等），用于控制语句、声明变量等； 限制：不能用作标识符或属性名（如不能定义let if = 1;）。 未来保留字定义：当前无特殊用途，但预留为未来版本关键字的词汇（如class、enum、export等，早期 ES 版本中部分已成为关键字）； 限制：不能用作标识符，虽部分可暂作属性名，但不推荐使用（避免兼容未来版本）。 ES 函数基础函数声明用function关键字声明，结构为：function 函数名(参数列表) { 函数体 }，示例：
// 声明一个计算两数和的函数 function add(num1, num2) { return …  ]]></content></entry><entry><title>3.2 变量</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0302-%E5%8F%98%E9%87%8F/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  变量声明：var、let、const 的核心差异变量是 JS 中保存数据的命名占位符，ES 提供 var、let、const 三种声明方式，核心差异体现在作用域、提升行为、可修改性上。
var 关键字（ES5 及之前）作用域：函数作用域（若在函数外声明则为全局作用域），无块级作用域（如 if/for 块内声明的 var 变量可在块外访问）。 初始化与类型： 可单独声明（var a;）或声明时赋值（var a = 1;）； 松散类型，可后续修改值的类型（如 a = &amp;amp;quot;hello&amp;amp;quot;）。 变量提升：var 声明的变量会自动提升到函数作用域顶部（仅声明提升，赋值不提升），示例： console.log(a); // undefined（声明提升，赋值未提升） var a = 1;全局变量特性：在全局作用域声明的 var 变量，会成为 window 对象的属性（如 var a = 1; console.log(window.a); // 1）。 重复声明：允许同一作用域内重复声明（如 var a = 1; var a = 2; 不报错，后者覆盖前者）。 函数内声明： 函数内用 var 声明的变量为局部变量（函数退出时销毁）； 省略 var 则为全局变量（不推荐，易污染全局作用域）。 严格模式限制：不可声明名为 arguments 或 eval 的变量。 let 声明（ES6+）作用域：块级作用域（{} 包裹的区域，如 if、for、函数块），块外无法访问。 重复声明：同一作用域内不允许重复声明（如 let a = 1; let a = 2; 报错），且与 var 混用时也报错（var a = 1; let a = 2; 报错）。 暂时性死区（TDZ）：let 声明的变量无变量提升，在声明语句之前的区域称为“暂时性死区”，引用变量会报错： console.log(a); // 报错（暂时性死区） let a = 1;全局变量特性：全局作用域声明的 let 变量，不会成为 window 对象的属性（如 let a = 1; console.log(window.a); // undefined），但仍在全局作用域存续。 for 循环特殊行为：let 声明的迭代变量（如 for (let i = 0; i &amp;amp;lt; 3; i++)），JS 引擎会为每个 …  </content></entry><entry><title>3.3 数据类型</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0303-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag><tag>类型系统</tag><tag>对象</tag></tags><content type="html">  数据类型分类简单数据类型（原始类型）：undefined、null、Boolean、number、string、symbol 复杂数据类型：object（一种无序名值对） ES 数据类型特性：灵活，一种数据类型可当作多种数据类型使用 typeof 操作符返回值：返回下列字符串之一——undefined、Boolean、string、number、object、function、symbol 语法示例： typeof message typeof(message) typeof 96 特性： 是操作符而非函数，无需参数，但可使用参数 调用 typeof null 返回 object（因 null 被视为空对象引用） 函数在 ES 中属对象，非独立数据类型，但因有特殊属性，typeof 可区分函数与其他对象 undefined 类型取值：仅一个值——undefined 赋值场景：用 var 或 let 声明变量但未初始化，变量默认赋予 undefined 值 使用建议： 无需显式给变量设 undefined 值，字面量 undefined 主要用于比较 ES3 前无 undefined，新增目的是明确空对象指针与未初始化变量的区别 变量区别： 包含 undefined 值的变量 ≠ 未定义变量 对未声明变量，仅有用操作是调用 typeof；调用 delete 不报错（无实际作用，严格模式下报错） 未初始化与未声明变量，typeof 均返回 &amp;amp;ldquo;undefined&amp;amp;rdquo; 初始化建议：声明变量时同时初始化，以便通过 typeof 返回 undefined 判断变量未声明（非未初始化） 布尔特性：undefined 是假值，可简洁检测 null 类型取值：仅一个值——null，表空对象指针 typeof 结果：调用 typeof null 返回 object 使用建议：定义将来存对象值的变量时，用 null 初始化（非其他值），便于后续检查变量是否重新赋予对象引用 与 undefined 关系： undefined 由 null 派生，== 比较二者始终返回 true（操作符会转换操作数） 用途不同：无需显式设变量为 undefined，但存对象的变量无对象可存时需设为 null 布尔特性：null 是假值，可简洁检测 Boolean 类型字面 …  </content></entry><entry><title>第二章 HTML中的JS</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/02-html%E4%B8%AD%E7%9A%84js/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>script 元素</tag><tag>性能优化</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  script 元素：JS 插入 HTML 的核心方式script 元素是嵌入或引入 JS 代码的主要载体，分为“嵌入行内代码”和“引入外部文件”两种用法，且需遵循特定执行规则。
两种使用方式类型 实现方式 关键注意事项 嵌入行内代码 代码直接放在&amp;lt;script&amp;gt;与&amp;lt;/script&amp;gt;之间 - 代码从上到下解释，执行期间阻塞页面加载/显示；
- 代码中不可直接出现&amp;lt;/script&amp;gt;，需用转义（如\&amp;lt;\/script&amp;gt;）；
- 示例：&amp;lt;script&amp;gt;console.log(&amp;quot;hi&amp;quot;);&amp;lt;/script&amp;gt; 引入外部文件 通过src属性指定外部 JS 文件 URL（如src=&amp;quot;example.js&amp;quot;） - 外部文件仅需包含 JS 代码（无需&amp;lt;script&amp;gt;标签）；
- 执行期间阻塞页面，阻塞时间含文件下载时间；
- 浏览器不检查.js扩展名（非必需，但为惯例）；
- 若同时写src和行内代码，仅执行外部文件，忽略行内代码；
- src可指向外部域资源（如&amp;lt;script src=&amp;quot;https://xxx.com/xxx.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;） 执行顺序浏览器按&amp;lt;script&amp;gt;在页面中出现的顺序依次解释执行（无论嵌入还是引入外部文件）。
script 标签位置：影响页面渲染传统位置：早期放在&amp;lt;head&amp;gt;中，会导致 JS 执行时页面未渲染（因 JS 阻塞加载），出现“空白页”； 现代推荐位置：放在&amp;lt;body&amp;gt;元素内页面内容之后（如&amp;lt;/body&amp;gt;闭合前），确保页面完全渲染后再执行 JS，避免阻塞视觉呈现。 脚本执行控制：defer 与 async 属性两者均用于优化脚本执行（减少页面阻塞），仅对外部脚本文件有效，核心差异在“执行时机”和“顺序性”。
属性 下载行为 执行时机 执行顺序 关键说明 defer 立即下载（不阻塞页面） 页面完全解析完毕后、DOMContentLoaded事件前执行 按脚本出现顺序 脚本不修改页面结构（否则可能导致 DOM 操作异常）；多个 defer 脚本按顺序执行 async 立即下载（不阻塞页面） 下载完成后立即执行，可能 …  ]]></content></entry><entry><title>第一章 什么是JS</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/01-%E4%BB%80%E4%B9%88%E6%98%AFjs/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>DOM</tag><tag>BOM</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 的核心构成JS 的完整实现由三部分组成，三者协同支撑前端交互功能：
核心（ECMAScript，ES）：定义语言的基础语法、类型、语句等核心规则，是跨环境（浏览器、Node.js 等）的通用标准，无输入输出能力，需依赖宿主环境扩展。 文档对象模型（DOM）：提供操作 HTML/XML 文档结构的 API，将页面抽象为分层节点树，支持增删改查节点，实现“网页内容与结构的动态控制”。 浏览器对象模型（BOM）：用于操作浏览器窗口（如弹窗、地址栏、历史记录），控制“页面之外的浏览器功能”，早期无标准，HTML5 后逐步统一。 ECMAScript（ES）详解ES 的核心定义与规范内容本质：ECMA-262 标准定义的语言基准，宿主环境（如浏览器）在此基础上添加扩展功能（如 DOM/BOM）。 ECMA-262 规定的核心部分： 语法、数据类型（如 String、Number、Object）、语句（if/for）、关键字（var/function）、保留字； 操作符（+、=== 等）、全局对象（如 Math、Date）。 关键 ES 版本迭代（核心特性）版本（俗称） 发布时间 核心新增特性 ES3 1999 年 正则表达式、try/catch 异常处理、新控制语句 ES5（ES3.1） 2009 年 JSON 原生解析/序列化、严格模式、Object 扩展方法（如 Object.keys） ES6（ES2015） 2015 年 类（class）、模块（import/export）、箭头函数、Promise、let/const、迭代器/生成器 ES7（ES2016） 2016 年 Array.prototype.includes、指数操作符（**） ES8（ES2017） 2017 年 async/await 异步函数、Object.values/entries、字符串填充（padStart/padEnd） ES9（ES2018） 2018 年 异步迭代（for await&amp;amp;hellip;of）、正则表达式扩展、剩余/扩展属性 ES10（ES2019） 2019 年 Array.prototype.flat/flatMap、String.trimStart/trimEnd、Object.fromEntries ES 符合性要求必选条件： …  </content></entry></search>