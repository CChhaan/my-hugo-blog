<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>3.5 简化真值表</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0305-%E7%AE%80%E5%8C%96%E7%9C%9F%E5%80%BC%E8%A1%A8/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  简化真值表方法：检验论证无效性与语句集相容性在语句逻辑中，完整真值表虽能精准判定论证有效性和语句集相容性，但当支语句数量较多时（如 4 个支语句需 16 行真值组合），会显得繁琐低效。简化真值表方法通过“目标导向”的真值指派，直接定位关键解释（反例或相容解释），大幅简化推理过程，尤其适用于检验论证无效性和语句集相容性。
简化真值表方法：检验论证无效性论证无效的核心标志是“存在反例”——即存在一种支语句真值组合，使得所有前提为真（T）且结论为假（F）。简化真值表方法的本质的是“逆向推导”：先预设“前提皆真、结论假”的目标，再反向推导支语句的真值，若能找到无矛盾的真值组合，则论证无效（反例存在）；若推导过程中出现矛盾，则论证有效（反例不存在）。
核心原理与步骤简化真值表检验论证无效性的核心逻辑是：先定目标（前提 T、结论 F），再推支语句真值，验证是否无矛盾。具体步骤如下：
步骤 1：明确论证结构，列出前提与结论首先提取论证的所有前提和结论，用符号化形式表示（如前提：p⊃q、q∨r；结论：p⊃r），明确所有支语句（如 p、q、r）。
步骤 2：预设目标真值——前提皆为 T，结论为 F直接给每个前提指派“真（T）”，给结论指派“假（F）”，这是寻找反例的起点（反例的定义就是“前提真且结论假”）。
步骤 3：逆向推导支语句的真值根据复合语句（前提、结论）的真值规则，反向推导支语句的真值，需遵循“优先处理真值唯一确定的语句”原则：
优先处理否定句：若否定句为 T，则原句为 F；若否定句为 F，则原句为 T（如 ¬p=T → p=F）。 优先处理真值唯一的复合句：部分复合语句的真值仅对应唯一的支语句组合，需优先推导（如条件句 A⊃B=F 仅当 A=T 且 B=F；合取句 A∧B=T 仅当 A=T 且 B=T）。 步骤 4：验证真值指派是否无矛盾若推导过程中，所有支语句的真值始终一致（无“同一支语句既为 T 又为 F”的矛盾），则找到反例，论证无效；若推导必然出现矛盾（如某支语句被迫同时为 T 和 F），则不存在反例，论证有效。
实例演示：检验论证无效性以论证“前提 1：p⊃q；前提 2：q∨r；结论：p⊃r”为例，演示简化真值表的应用：
步骤 1：明确结构支语句：p、q、r 前提 1：p⊃q（T），前提 2：q∨r（T），结论：p⊃r（F） 步骤 2：预设目标 …  </content></entry><entry><title>3.3 逻辑等价与条件句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0303-%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  核心概念界定与区分在逻辑研究中，“等值”与“蕴含”是两类关键关系，但需严格区分“实质”与“逻辑”两个层面——前者依赖语句的实际真值，后者依赖语句的逻辑结构，二者的核心差异在于“真值是否仅由逻辑形式决定”。
实质等值与逻辑等值实质等值：基于实际真值的等同定义：若两个语句（如 p 和 q）在实际情况中具有相同的真值（即同真或同假），则称二者“实质等值”。
例如：“今天下雨”（p）和“地面潮湿”（q），若今天确实下雨且地面潮湿（同真），或今天没下雨且地面干燥（同假），则 p 与 q 实质等值。 表达式：用双条件句 p ≡ q（读作“p 当且仅当 q”）表示实质等值关系。
当 p 与 q 实质等值时，p ≡ q 为真；若二者真值不同（一真一假），则 p ≡ q 为假。 关键特性：实质等值依赖语句的“实际真值”，而非逻辑结构。即使两个语句的逻辑形式无关，只要实际真值相同，就满足实质等值。 逻辑等值：基于逻辑结构的必然等同定义：若两个语句（如 p 和 q）不可能具有不同的真值（即无论支语句的真值如何变化，二者始终同真同假），则称二者“逻辑等值”。
例如：“并非（p 且 q）”（¬(p ∧ q)）和“非 p 或非 q”（¬p ∨ ¬q），无论 p 和 q 本身是真还是假，这两个语句的真值始终一致（这是逻辑中的“德摩根定律”）。 表达式：仍用双条件句 p ≡ q 表示，但此时 p ≡ q 是逻辑等价句（属于重言句的一种）。
逻辑等价句的核心特征是：其真值独立于支语句的真值，仅由逻辑结构决定——无论支语句取何值，p ≡ q 始终为真。 判定标准：两个语句逻辑等值，当且仅当它们的真值表中没有任何一行出现不同的真值。
以 ¬(p ∧ q) 与 ¬p ∨ ¬q 为例，真值表如下（T 为真，F 为假）： p q p ∧ q ¬(p ∧ q) ¬p ¬q ¬p ∨ ¬q T T T F F F F T F F T F T T F T F T T F T F F F T T T T 可见，¬(p ∧ q) 与 ¬p ∨ ¬q 在所有行的真值完全一致，因此二者逻辑等值。
实质蕴含与逻辑蕴含实质蕴含：基于实际真值的推导定义：若两个语句 p 和 q 满足“不可能 p 真而 q 假”的实际情况，则称 p 实质蕴含 q。
例如：“今天是周一”（p）和“今天是工作日”（q），若实际情况中“今天是 …  </content></entry><entry><title>3.4 有效性、相容性</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0304-%E6%9C%89%E6%95%88%E6%80%A7%E7%9B%B8%E5%AE%B9%E6%80%A7/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  语句逻辑中真值表的应用：有效性与相容性检验在语句逻辑（命题逻辑）中，真值表是分析论证有效性和语句集相容性的核心工具。它通过穷尽所有可能的“解释”（即支语句的真值组合），直观呈现论证或语句集的逻辑特征，帮助我们精准判定其逻辑属性。
用真值表检验论证有效性论证的“有效性”是语句逻辑的核心概念，其本质是前提与结论之间的必然逻辑联系——若前提为真，则结论不可能为假。真值表通过覆盖所有可能的真值组合，直接验证这一必然性。
有效性的核心定义一个论证是有效的，当且仅当：
不存在任何解释（支语句真值组合），使得“所有前提为真”且“结论为假”。 反之，若存在至少一种解释满足“前提皆真而结论假”，则论证是无效的，这种解释被称为论证的“反例”。 真值表检验有效性的步骤以简单论证“如果 p，那么 q（p⊃q）；p；因此 q”为例，演示检验流程：
步骤 1：确定支语句与真值组合论证中涉及的支语句为p和q，每个支语句有“真（T）”“假（F）”两种可能，因此总共有2²=4种真值组合（若有 n 个支语句，组合数为2ⁿ）。
步骤 2：构造真值表，计算前提与结论的真值支语句组合 前提 1：p⊃q 前提 2：p 结论：q 关键判定（前提皆真？结论假？） p=T, q=T T（T⊃T=T） T T 前提皆真，结论真 → 符合有效性 p=T, q=F F（T⊃F=F） T F 前提 1 假，不满足“前提皆真” → 无关 p=F, q=T T（F⊃T=T） F T 前提 2 假，不满足“前提皆真” → 无关 p=F, q=F T（F⊃F=T） F F 前提 2 假，不满足“前提皆真” → 无关 步骤 3：判定有效性观察真值表中是否存在“前提皆真且结论假”的行：上述表格中无此类行，因此该论证（假言推理肯定前件式）是有效的。
论证的对应条件句与有效性论证的“对应条件句”定义为：（前提 1 ∧ 前提 2 ∧ &amp;amp;hellip; ∧ 前提 n）⊃ 结论（即所有前提的合取作为前件，结论作为后件的条件句）。
一个论证是有效的，当且仅当其对应条件句是重言句（恒真句）。
原因：重言句的真值独立于支语句，始终为真，意味着“前提合取为真”时“结论必为真”，完全符合有效性定义。 示例：上述论证的对应条件句为((p⊃q) ∧ p) ⊃ q，其真值表中所有行均为真（重言句），进一步验证论证有效。 …  </content></entry><entry><title>3.1 真值的计算</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0301--%E7%9C%9F%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  核心前提对由真值函数联结词（如否定 ¬、合取 ∧、析取 ∨、蕴含 →、等值 ↔）联结的任意复合语句，若已知所有支语句（原子语句/子复合语句）的真值，可通过真值表相关方法判定整个复合语句的真值。
真值表分析法（含环线方法）核心逻辑从语句的最小单位（原子语句） 开始，按“由小到大、逐步演算”的顺序，结合真值函数联结词的真值表规则，最终通过“环线标注”确定整个语句的真值。
操作步骤拆分语句结构：将复合语句拆解为原子语句、子复合语句，明确各层级的联结词（如“¬(p∧q)∨r”拆分为原子语句 p/q/r、子复合语句 p∧q、外层复合语句 ¬(p∧q)∨r）； 赋值原子语句真值：根据已知条件，为每个原子语句赋予 T（真）或 F（假）； 逐步演算子复合语句真值： 先计算“最小辖域联结词”对应的子语句真值（如先算 p∧q，依据合取词真值表：p、q 均为 T 时 p∧q 为 T，否则为 F）； 再计算“更大辖域联结词”对应的子语句真值（如基于 p∧q 的真值算 ¬(p∧q)，依据否定词真值表：原语句为 T 则否定为 F，原语句为 F 则否定为 T）； 环线标注最终真值：每完成一个层级的演算，用环线标注该层级子语句的真值；重复步骤 3，直到演算至整个语句的“主联结词”，主联结词旁环线标注的真值即为整个复合语句的真值。 优势图解式标注（环线）清晰区分各层级真值，适合初学阶段理解真值演算的“分步逻辑”。 表列方法（无环线的真值表分析）核心逻辑不使用环线，直接将各层级语句的真值写在对应联结词下方，整个复合语句的真值最终体现在“主联结词下方”，通过“箭头符”标示主联结词，明确真值判定的最终依据。
操作步骤（含主联结词标示）符号化语句与原子赋值： 确保复合语句已完成符号化（如“如果 p 那么 q 且 r”符号化为 p→(q∧r)）； 在每个原子语句（p、q、r）下方，根据已知条件标注 T 或 F； 计算否定句真值：对原子语句的否定（如 ¬p），依据否定词真值表，在“否定号（¬）下方”标注真值（p 为 T 则 ¬p 下标 F，p 为 F 则 ¬p 下标 T）； 按辖域从小到大演算联结词真值： 先找“辖域最小的非否定联结词”（如 q∧r 中的 ∧），依据对应联结词真值表，在该联结词下方标注真值（q、r 均为 T 则 ∧ 下标 T，否则为 F）； 重复此步骤，逐步寻找“辖域更大的联结 …  </content></entry><entry><title>3.2 重言句、矛盾句和偶真句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0302--%E9%87%8D%E8%A8%80%E5%8F%A5%E7%9F%9B%E7%9B%BE%E5%8F%A5%E5%92%8C%E5%81%B6%E7%9C%9F%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>真值表</tag></tags><content type="html">  真值表的核心概念：解释与语句分类解释与真值表行的关系解释：对复合语句中所有原子语句的真值指派（即给每个原子语句赋 T 或 F）。 真值表行：每一行对应一个唯一的解释，完整真值表覆盖语句的所有可能解释（无遗漏）。 主联结词的作用：语句的最终真值由其主联结词下方的真值决定（某行主联结词为 T，代表该解释下语句为真；为 F 则为假）。 语句的三类分类（基于真值表判定）语句类型 定义（基于解释） 真值表判定标准（主联结词下方） 矛盾句 不存在任何解释使其为真（逻辑上必然假） 所有行均为 F 重言句 不存在任何解释使其为假（逻辑上必然真） 所有行均为 T 偶真句 存在部分解释使其为真，部分解释使其为假（真值依赖“世界偶然状态”，非逻辑必然） 既有 T 也有 F 特殊情况：单原子语句的解释若语句仅含 1 个不同原子语句（无论该原子语句出现多少次），仅存在2 种可能解释（原子语句为 T 或 F）。 真值表的构建步骤（机械流程）步骤 1：确定真值表的行数核心公式：若语句含 n 个不同原子语句，行数 = 2ⁿ（如 2 个原子语句：2²=4 行；3 个原子语句：2³=8 行）。 步骤 2：列出原子语句的所有真值组合规则：从最右侧原子语句开始，按“T、F 交替”赋值；左侧原子语句按“2 行同值、2 行交替”（n=2）、“4 行同值、4 行交替”（n=3）的规律扩展，确保覆盖所有组合。 示例（2 个原子语句 p、q）： p q T T T F F T F F 步骤 3：逐步演算支语句与主联结词的真值原子语句列赋值：直接在每个原子语句下方，按步骤 2 的真值组合填写 T 或 F； 优先演算否定句：对原子语句的否定（如 ¬p），依据否定词真值表（原句为 T 则 ¬ 为 F，原句为 F 则 ¬ 为 T），在否定号下方填写真值； 按辖域从小到大演算联结词： 先算“最小辖域联结词”（如 p∧q 中的 ∧），依据对应联结词真值表（合取 ∧：仅 p、q 均 T 时为 T；析取 ∨：仅 p、q 均 F 时为 F 等），在联结词下方填真值； 逐步扩大辖域，重复演算（如先算 p∧q，再算 ¬(p∧q)，最后算 ¬(p∧q)∨r）； 完成主联结词赋值：当演算至覆盖全句的“主联结词”，并填写其下方所有真值后，真值表构建完成。 真值表的延伸应用：论证有效性与哲学关联论证有效性的判定核心逻辑：有效 …  </content></entry><entry><title>2.13 - 2.14 复杂语句符号化</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0205-%E5%A4%8D%E6%9D%82%E8%AF%AD%E5%8F%A5%E7%AC%A6%E5%8F%B7%E5%8C%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html"><![CDATA[  日常语句符号化的核心原则：语法结构与逻辑结构的对应日常语句的语法结构（如联结词、标点）往往直接反映其逻辑结构，符号化的核心是将语法联结词替换为逻辑符号，同时确保逻辑含义与原语句完全一致。
复杂语句符号化的四步实操方法第一步：定位主联结词——符号化的“突破口”主联结词是决定整个语句逻辑类型的核心联结词（如“并且”“如果&amp;hellip;那么&amp;hellip;”“或”），找到它就能将复杂语句拆分为更小的支语句。
关键技巧： 关注语句开头：很多语句的主联结词直接出现在句首（如“如果明天晴天，我们就去公园”，主联结词是开头的“如果&amp;hellip;就&amp;hellip;”，对应逻辑符号“⊃”）。 区分“转折词的位置”： 转折词（如“但是”“然而”“不过”）出现在句首时，通常无真值函数意义（仅表语气转折），符号化时直接忽略（如“不过，小明今天没迟到”，实际逻辑是“小明今天没迟到”，符号化为“~A”，“不过”可忽略）； 转折词出现在语句中间时，等价于真值函数的“并且（·）”（如“小明很努力，但是没考好”，逻辑是“小明很努力且没考好”，符号化为“A·~B”）。 第二步：利用标点符号——确定支语句的边界逗号（,）、分号（;）是划分支语句的重要标志，通常对应逻辑符号中的“括号”，需将标点分隔的两部分分别置于主联结词两侧。
示例： 语句：“小明喜欢数学，小红喜欢英语”——逗号分隔两个支语句，主联结词是隐含的“并且”，符号化为“A·B”（A：小明喜欢数学，B：小红喜欢英语）； 语句：“如果明天不加班，我们去看电影；否则，我们在家做饭”——分号将语句分为“如果不加班则看电影”和“如果加班则在家做饭”，主联结词是“并且”，整体符号化为“(~A⊃B)·(A⊃C)”（A：明天加班，B：去看电影，C：在家做饭）。 第三步：分而治之——拆解支语句（递归应用符号化技巧）找到主联结词并拆分出支语句后，对每个支语句重复第一步和第二步：定位支语句的主联结词、利用标点划分更小的支语句，直到拆解为不可再分的原子语句。
示例（复杂语句）：“如果小明参加比赛并且小红当裁判，那么小李会来加油或小张会帮忙” 找主联结词：句首的“如果&amp;hellip;那么&amp;hellip;”（⊃），将语句拆为前件“小明参加比赛并且小红当裁判”和后件“小李会来加油或小张会帮忙”； 拆解前件：主联结词是“并且（·）”，拆为原子语句 A（小明参加 …  ]]></content></entry><entry><title>2.10 - 2.12 条件句</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0204-%E6%9D%A1%E4%BB%B6%E5%8F%A5/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html"><![CDATA[  实质条件句（“如果&amp;hellip;那么&amp;hellip;”）核心定义与结构定义：用联结词“如果&amp;hellip;那么&amp;hellip;”联结两个原子语句构成的复合语句，逻辑中用符号“⊃”（马蹄符）表示，形式为“前件 ⊃ 后件”（如“如果 A，那么 B”符号化为“A⊃B”）。 结构：“如果”后的语句为前件（如 A），“那么”后的语句为后件（如 B）。 真值规则（实质蕴含的核心）实质条件句“A⊃B”是真值函数联结词，仅当“前件真且后件假”时，整体为假；其余三种情况（前真后真、前假后真、前假后假）均为真。具体可概括为：
若前件真而后件假，则实质条件句为假；否则为真
前件（A） 后件（B） A⊃B（实质条件句） T T T T F F F T T F F T 与日常条件句的差异日常条件句常隐含“前件与后件的关联”（如因果、逻辑推导），而实质条件句仅关注真值组合，不要求前后件有实际关联（如“如果 2+2=5，那么太阳从西边升起”，虽前后无关联，但因前件假，实质条件句仍为真）。 实质条件句是“最弱的条件句”，仅捕捉日常条件句中“并非前真后假”的核心真值属性，其余隐含意义（如关联关系）会被忽略。 实质双条件句（“当且仅当”）核心定义与结构定义：表示“两个语句真值相同”的复合语句，逻辑中用符号“≡”表示，形式为“前件 ≡ 后件”（如“A 当且仅当 B”符号化为“A≡B”），也称为“实质等值句”。 等价形式：实质双条件句等价于“双向的实质条件句”，即“A≡B” = “(A⊃B)·(B⊃A)”（“如果 A 则 B，并且如果 B 则 A”）。 真值规则实质双条件句“A≡B”为真，当且仅当“前件与后件真值完全相同”（同真或同假）；若真值不同（一真一假），则整体为假。可概括为：
若前后件真值相同，则实质双条件句为真；否则为假
前件（A） 后件（B） A≡B（实质双条件句） T T T T F F F T F F F T 与日常等值句的差异日常语言中“等值”常隐含“前后件有内在关联”（如“三角形是等边的，当且仅当它是等角的”），而实质双条件句仅关注真值是否一致，不要求关联（如“2+2=5≡ 太阳从西边升起”，因前后均假，实质双条件句为真）。 五大联结词真值规则总结通过以下 5 句话可完整掌握所有基础联结词的真值条件：
否定（~）：颠倒原语句真值（真变假，假变真）； 合取（·）：仅当 …  ]]></content></entry><entry><title>2.8 - 2.9 析取</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0203-%E6%9E%90%E5%8F%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html">  析取句与“或”的两种含义析取句的定义由联结词“或”联结两个语句构成的复合语句，称为析取句；被联结的两个语句，称为“析取支”（如“小明吃苹果或小红吃香蕉”，“小明吃苹果”“小红吃香蕉”均为析取支）。
“或”的两种核心含义可兼含义（非互斥）：断言“至少一个析取支为真”，允许两个析取支同时为真（如“他学数学或学英语”，可同时为真）。日常中“和/或”是其明确表达（常见于法律文件），逻辑中用符号“∨”（v 字符）表示，是真值函数联结词。 不可兼含义（互斥）：断言“恰好一个析取支为真”，排除两个析取支同时为真的情况（如“比赛赢或输”，不可同时为真）。其含义比可兼或更丰富，除“至少一个真”外，还包含“至少一个假”。 可兼析取（∨）的真值规则“∨”的真值完全由析取支的真值决定，仅当两个析取支均为假时，析取句“p∨q”为假；其余情况（一个真、一个假，或两个均真）均为真。具体真值表如下：
p（析取支 1） q（析取支 2） p∨q（可兼析取句） T T T T F T F T T F F F 不可兼析取的符号化问题不可兼或的完整含义：需同时满足“至少一个真”和“至少一个假”，完整符号化为“(p∨q)·~(p·q)”（可兼或 + 否定合取）。 用“∨”符号化的局限性：若直接用“∨”表示不可兼或，会丢失“至少一个假”的含义（仅保留“至少一个真”），导致符号式与原语句真值可能不一致（如两个析取支均真时，原不可兼或语句为假，但“p∨q”为真）。 论证中的处理原则： 部分论证中，仅需“至少一个真”的核心含义，用“∨”符号化不影响有效性； 若论证依赖“互斥”属性（如“比赛赢或输，赢了，所以没输”），则需完整符号化为“(p∨q)·~(p·q)”。 日常语句的符号化规则：若“或”的含义不明确（无法判断是否互斥），遵循“如有疑义，按可兼含义符号化”（用“∨”），避免过度添加未明确的“互斥”假设。 多算子语句的符号化与辖域核心原则含两个及以上逻辑算子（如~、·、∨）的语句，需通过括号明确算子辖域，避免歧义（辖域即算子管辖的支语句范围）。
常见句式的符号化“并非既&amp;amp;hellip;又&amp;amp;hellip;”：否定“两个语句同时为真”，等价于“至少一个为假”，符号化为“~(Q·G)”或“~Q∨~G”（如“并非既下雨又刮风”，即“不下雨或不刮风”）。 逻辑依据：否定合取等价于析取否定（德摩根定律），两者 …  </content></entry><entry><title>2.4 - 2.7 否定</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0202-%E5%90%A6%E5%AE%9A/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html">  非真值函数联结词与真值函数联结词的区别真值函数联结词（如“并且”）：复合语句的真值由支语句的真值唯一决定（只要支语句真值确定，复合语句真值就固定，如“ A 并且 B ”仅当 A、B 均真时为真）。 非真值函数联结词：复合语句的真值不能仅由支语句真值决定，还需依赖支语句内容、时态、语境等额外信息。 常见示例“在&amp;amp;hellip;之前”（时态联结词）：如“小明吃饭在小红看书之前”，即使“小明吃饭”和“小红看书”均为真，复合语句的真值仍需看两者的时间顺序（若小红先看书，则复合语句为假），无法仅通过支语句真值判断。 “众所周知”：如“众所周知地球是圆的”（真）和“众所周知小明今天吃了饭”（假），两者支语句均为真，但复合语句真值不同，因“众所周知”依赖“语句是否被广泛知晓”的额外信息。 “因为”：如“他感冒了因为他淋了雨”，即使“他感冒了”和“他淋了雨”均为真，复合语句真值还需看两者是否存在因果关系（若感冒是因着凉，而非淋雨，则复合语句为假），不取决于支语句真值。 变项与常项定义与作用语句变项：用小写字母（如 p、q）表示，是“位置所有者”，不指代特定语句，仅用于表示“任意语句的占位符”（如真值表中 p、q 可代表任何原子语句）。 语句常项：用大写字母（如 A、B）表示，是特定语句的缩写（如 A 代表“今天下雨”，B 代表“我带了伞”），有确定的真值（真或假）。 示例：真值表中的变项与常项合取句的真值表用 p、q（变项）表示任意合取支，描述“所有合取句的真值规则”： p q p·q T T T T F F 若用 A（“今天下雨”，真）、B（“我带了伞”，真）（常项）替换变项，得到具体合取句“A·B”（“今天下雨并且我带了伞”），其真值为 T，符合真值表规则。 否定（一元逻辑算子）核心性质一元算子：仅作用于单个语句（无需联结两个语句），就能生成新的复合语句（否定句），是标准语句逻辑中唯一的一元真值函数算子。 符号表示：用波浪符“~”表示（如“并非今天下雨”记为“~A”，A 代表“今天下雨”）。 真值规则否定句的真值与原语句（被否定的语句）真值完全相反：
若原语句为真（T），则否定句为假（F）（如 A 为真，~A 为假）； 若原语句为假（F），则否定句为真（T）（如 A 为假，~A 为真）。 真值表： A ~A T F F T 括号：消除歧义与明确算子辖域核心作 …  </content></entry><entry><title>2.1 - 2.3 合取</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0201%E5%90%88%E5%8F%96/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>语句逻辑</tag><tag>逻辑符号化</tag></tags><content type="html">  核心概念：原子语句与复合语句原子语句（简单语句）：不包含“并且”“或者”等语句联结词的语句，是构成复合语句的基础单位（如“今天下雨”“我吃了饭”）。 复合语句：用“并且”“或者”等联结词联结原子语句构成的语句（如“今天下雨并且我带了伞”“他看书或者他写字”）。 语句逻辑与真值函数语句逻辑：逻辑学中“无需考虑原子语句内部结构”即可分析的部分，属于符号逻辑的分支（另一分支是谓词逻辑）。 真值函数核心： 输入与输出仅含“真（T）”和“假（F）”两个真值； 复合语句的真值由其包含的原子语句的真值唯一决定（复合语句是原子语句的“真值函数”），因此语句逻辑也叫“真值函数逻辑”。 合取句：“并且”联结的复合语句定义：用联结词“并且”（逻辑中常用小圆点“·”作为缩写）联结两个原子语句（称为“合取支”）构成的复合语句（如“A·B”，A、B 为合取支）。 真值表（合取句的真值规则）：
合取句“ A·B ”仅当两个合取支均为真时，整体才为真；只要有一个合取支为假，整体即为假，具体如下： A（合取支 1） B（合取支 2） A·B（合取句） T T T T F F F T F F F F 日常语句与逻辑符号化的注意事项并非所有“并且”都能符号化为“·”：
逻辑中的 “・” 要求联结的是两个独立的原子语句（即 “合取支需能单独判断真假”），但日常语言中部分含 “和” 的语句，“和” 仅用于连接名词（而非独立语句），无法拆分为两个原子语句，因此不能符号化为合取句 “・”。例如 “小明和小红在恋爱”，句中 “和” 连接的是 “小明”“小红” 两个主体，整个语句是一个不可拆分的原子语句（无法拆成 “小明在恋爱”“小红在恋爱” 两个独立真 / 假判断，因为 “恋爱” 是两人之间的关系，单独判断 “小明在恋爱” 不完整），因此不能符号化为 “A・B”。 符号化恰当性的判断标准：
若逻辑符号式的真值与原日常语句的真值一致（符号式真则原句真，符号式假则原句假），则符号化恰当；反之则不恰当。 等效联结词：
日常中“但是”“然而”等词，虽表达转折语气，但从真值函数角度，与“并且”功能一致（均需前后两部分均为真，整体才为真），可符号化为“·”（如“他很努力但是没考好”，符号化为“A·B”）。   </content></entry><entry><title>1.5 - 1.9 论证的本质</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0103-%E8%AE%BA%E8%AF%81%E7%9A%84%E6%80%A7%E8%B4%A8/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  有效论证、可靠论证与坏论证的关系核心概念辨析有效论证：仅保证“若前提全为真，则结论必为真”（逻辑形式有效），不要求前提实际为真。 可靠论证：需同时满足两个条件：
a. 论证有效（逻辑形式无问题）；
b. 所有前提实际为真。 坏论证：有效论证也可能是坏论证——若其存在一个或多个假前提（满足“有效”但不满足“所有前提真”，即不满足“可靠”）。 逻辑学的关注点逻辑学不直接判定论证的“可靠性”，仅关注“有效性”：
除“逻辑上为真/假的前提”（如“2+2=4”“三角形有 4 条边”）外，前提的实际真假需依赖具体领域知识（如数学、物理、事实），无法仅靠逻辑学判定。 陈述集的相容性与不相容性定义相容陈述集：所有陈述同时为真是可能的（不要求实际为真，仅需无逻辑矛盾）； 不相容陈述集：所有陈述同时为真是不可能的（存在逻辑矛盾，如“今天下雨”与“今天不下雨”组成的集合）。 关键特征相容性与陈述的“实际真假”无关： 所有陈述为真时，集合必相容； 所有陈述为假时，集合仍可能相容（如“地球是方的”与“太阳绕地球转”，虽均假，但无逻辑矛盾，可同时为假）； 唯一不可能的情况：集合不相容，但所有陈述均为真（矛盾陈述无法同时为真）。 有效性与相容性的关联核心等价关系一个论证是有效的，当且仅当“前提全为真且结论为假”的断言是不相容的：
有效论证的本质：“前提真而结论假”存在逻辑矛盾（不相容），故不可能发生； 无效论证的本质：“前提真而结论假”无逻辑矛盾（相容），故可能发生。 利用相容性检测有效性的方法通过以下步骤可借助“相容性”判断论证是否有效：
假设原论证的结论为假，得到“结论的否定”； 将“原前提”与“结论的否定”组成一个新的陈述集； 若该新集合相容（可同时为真）→ 原论证无效（“前提真而结论假”可能）； 若该新集合不相容（不可同时为真）→ 原论证有效（“前提真而结论假”不可能）。 发现语境与辩护语境两个核心问题当某人断言“某结论为真”时，存在两个维度的问题：
发现语境：引导其得出该结论的心理因素（如直觉、经验、情绪、灵感）； 辩护语境：支持该结论为真的客观理由（如前提、逻辑推导、证据）。 逻辑学的关注范围逻辑学仅关心“辩护语境”：
不探究结论的“产生过程”（心理因素具有主观性、偶然性），仅评估“结论是否有合理的理由支撑”（即论证的有效性与前提的相关性）。   </content></entry><entry><title>1.2 - 1.4 演绎与归纳</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0102-%E6%BC%94%E7%BB%8E%E4%B8%8E%E5%BD%92%E7%BA%B3/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  演绎上有效的论证核心定义与逻辑性质基本性质：若所有前提为真，则结论必定为真（不可能出现“前提全真而结论假”的情况），前提之真完全保证结论之真。 判定标准：追问是否存在“前提全真、结论假”的可能——不存在则有效，存在则无效（无效论证即“非有效论证”）。 内容与形式的关系：演绎有效性由论证形式决定，而非内容。只要形式有效，无论内容如何，均为有效论证。例如以下两种固定有效形式： 形式 1： AAA，或者 BBB 并非 AAA BBB 形式 2： 如果 AAA，那么 BBB AAA BBB 有效性与“真/假”的关系关键区分：
有效性/无效性是论证的性质，仅判断“结论能否从前提推出”； 真/假是陈述（前提/结论）的性质，仅判断陈述是否符合事实。 （误区：不可说“论证是真的/假的”，也不可说“陈述是有效的/无效的”） 真假组合的可能性： 有效论证可出现 3 种组合（仅排除“前提全真+结论假”）：
前提真 + 结论真； 前提假 + 结论真； 前提假 + 结论假。 无效论证无限制：可出现“前提全真+结论真”“前提全假+结论假”等任意组合（只需构造无逻辑关联的陈述即可）。 核心特征结论信息已暗含在前提中，并非“真正的新信息”（仅可能是心理层面的新信念）； 演绎有效性是“绝对的”：论证要么有效，要么无效，不存在“更有效”或“较无效”的程度差异。 归纳论证核心定义与逻辑性质基本性质：结论内容超出前提包含的信息（并非从前提中暗含推导）；“好的归纳论证”称为“归纳上强的论证”。 与演绎有效性的核心区别： 强归纳论证的前提全真，仅能使结论或然/盖然（仍有可能前提真而结论假）； 有效演绎论证的前提全真，能保证结论真。 归纳强度的特征逻辑基础：基于“经验学习”——从经验中观察模式、规律性，再投射到其他场合。 强度的程度差异： 归纳强度是“相对的”：可描述“一个论证比另一个论证归纳更强”（如更多证据支持的论证强度更高）； 演绎有效性无程度差异（要么有效，要么无效）。 优缺点： 优点：提供“真正的新信念”（结论超出前提，非暗含信息）； 缺点：错误风险更高——即使是最强的归纳，也可能因“经验规律在新场合失效”而得出假结论。 演绎论证与归纳论证的核心对比维度 演绎论证 归纳论证 结论与前提的关系 结论信息暗含在前提中，不超出前提 结论信息超出前提 前提真对结论的作用 保证结论真（无例外）  …  </content></entry><entry><title>1.1 论证的要素</title><url>/post/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%93%B2%E5%AD%A6/0101-%E8%AE%BA%E8%AF%81%E7%9A%84%E8%A6%81%E7%B4%A0/</url><categories><category>逻辑与哲学</category></categories><tags><tag>逻辑学</tag><tag>论证</tag></tags><content type="html">  论证的要素论证的核心定义论证是一套以 “为结论辩护、提供理由” 为目的的陈述系列，核心是通过前提推导结论。
论证的核心要素前提：论证中支持结论的陈述，数量可任意，需为 “可判断真假” 的内容，是结论成立的依据。 结论：论证中被前提辩护的陈述，是论证的核心目标，需从前提中合理推导得出。 论证的关键特征陈述属性：论证中的语句必须表达 “陈述”（即有真假属性），疑问句、祈使句、感叹句等无真假属性的语句无法构成论证。 逻辑关联：即使所有语句均为陈述，若彼此无 “支持与被支持” 的关联（无辩护对象、无接受结论的理由），也不构成论证。 结构灵活性：一个论证可被其他论证包围或嵌入（如子论证的结论作为核心论证的前提）。 区分 “论证” 与 “非论证” 的意义区分二者并非单纯的逻辑理论知识，其核心价值在于为普通人日常生活提供 “理性决策、有效沟通、清醒认知” 的实用工具，具体可总结为 4 点：
规避认知陷阱，不被误导：识别 “无理由支撑的伪观点”，通过追问 “是否有前提为结论辩护”，避免因盲目相信错误信息造成损失。 提升表达说服力，减少沟通矛盾：家庭协商、职场协作等场景中，用 “论证思维”（结论 + 支撑理由）替代单纯的 “我觉得”“我认为”（非论证的情绪 / 观点表达），让观点更清晰、有依据，减少 “各说各话” 的无效沟通，提升他人接受度。 助力理性决策，降低后悔风险：面对 “买哪款产品”“要不要换工作” 等选择时，用 “论证” 梳理 “选择结论 + 自身需求 / 客观理由”，替代 “凭直觉”“随大流”（非论证式决策），让选择贴合实际需求，减少冲动或外界压力导致的决策失误。 促进建设性讨论，避免情绪内耗：遇到争议话题时，聚焦 “对方观点是否有理由支撑”，而非陷入 “情绪攻击”，让讨论围绕 “理由合理性” 展开，减少 “为吵架而吵架” 的内耗，让争议更具建设性。   </content></entry><entry><title>附录 JS库</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E9%99%84%E5%BD%95-js%E5%BA%93/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>CDN</tag><tag>JavaScript</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 库的核心概念与优缺点什么是 JS 库？JS 库是封装好的可重用代码包，旨在简化常见开发任务（如 DOM 操作、动画、AJAX），避免重复编写繁琐代码，同时解决跨浏览器兼容问题。
库的核心优势可靠性高：代码经过大量用户测试和验证，bug 更少，稳定性优于自定义代码。 集成性强：可轻松与现有开发框架（如 Vue、React）或项目集成，无需重构底层逻辑。 效率提升：为 DOM 操作、表单验证、网络请求等日常任务提供简洁 API，一行代码可替代数十行原生 JS（如 jQuery 的 $(&amp;amp;quot;.class&amp;amp;quot;).hide() 隐藏元素）。 跨浏览器兼容：库内部已处理不同浏览器的差异（如早期 IE 与现代浏览器的 DOM 接口差异），开发者无需手动适配。 库的潜在问题黑箱风险：代码由第三方编写，内部逻辑不透明，出现 bug 时难以调试（如库的方法返回异常，需查阅文档或源码定位问题）。 性能负担：库文件需额外加载，会增加页面 HTTP 请求次数和带宽消耗（尤其大型库，可能导致首屏加载变慢）。 冲突与冗余： 多库混用可能引发命名冲突（如两个库都定义 $ 变量）； 库的功能可能超出需求（如仅需 DOM 操作，却引入包含动画、AJAX 的全量库），造成代码冗余。 如何选择合适的 JS 库？需从功能、体积、维护性等维度综合评估，核心考量以下 6 个问题：
考量维度 关键问题与说明 功能匹配度 1. 库是否包含项目所需的全部核心功能（如仅需表单验证，无需选择包含地图、图表的全能库）？
避免 “功能过剩”，减少冗余代码。 模块化设计 库是否支持按需加载（如只引入 DOM 操作模块，而非全量引入）？
模块化设计可降低体积，提升性能。 支持与维护 1. 库的更新频率如何（是否长期维护，修复漏洞、适配新浏览器）？ 2. 是否有活跃的社区（如 GitHub Issues 响应及时、Stack Overflow 有大量解答）？ 文档质量 是否有完整、易懂的官方文档（含 API 说明、示例代码、常见问题）？
优质文档可降低学习和使用成本。 许可协议 库的开源协议（如 MIT、Apache）是否允许商业使用？
避免因协议限制导致法律风险（如部分协议要求开源衍生代码）。 体积与性能 库的压缩后体积多大？是否会显著影响页面加载速度？
优先选择轻量级库（如需求简 …  </content></entry><entry><title>第十章 用JS实现动画效果</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/10--%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>CSS</tag><tag>前端开发</tag></tags><content type="html">  动画基础知识：核心原理JS 动画的本质是按预定时间间隔重复调用函数，动态修改元素样式（尤其是位置相关样式），从而实现 “随时间变化” 的视觉效果。核心依赖两个维度：元素位置控制和时间调度。
元素位置控制：position 属性通过 CSS position 属性定义元素的定位方式，是实现动画的基础。position 有 4 个合法值，核心差异在于元素是否脱离文档流及定位基准：
属性值 定位规则 static 默认值，元素按文档流顺序排列，无法通过 top/left 等属性调整位置。 relative 元素仍在文档流中，但可通过 top/left 等属性 “相对自身原位置” 偏移，不影响其他元素。 absolute 元素脱离文档流，定位基准为最近的已定位祖先元素（position 为 relative/fixed/absolute），若无则以文档为基准。位置由 top/left/right/bottom 决定。 fixed 元素脱离文档流，定位基准为浏览器窗口，滚动页面时位置固定不变。 位置属性使用注意：避免冲突：设置位置时建议只使用 top 或 bottom（垂直方向）、left 或 right（水平方向），同时设置可能导致定位混乱。
容器定位：若需让 absolute 元素在指定容器内定位，需将容器的 position 设为 relative（此时容器成为定位基准）
时间调度：setTimeout 与 clearTimeout通过 JS 时间函数控制动画的 “节奏”，实现 “延迟执行” 或 “定时重复”。
setTimeout：延迟执行函数语法：
const timerId = setTimeout(func, delay)func：延迟后执行的函数（可直接写函数体或函数名，推荐用函数体避免字符串解析问题）； delay：延迟时间（毫秒，1 秒 = 1000 毫秒）； 返回值：timerId（定时器唯一标识，用于取消定时器）。 clearTimeout：取消延迟执行语法：
clearTimeout(timerId)作用：取消已通过 setTimeout 排队的函数，避免其执行 数值处理：parseInt 与 parseFloat动画中常需从样式字符串（如 100px）中提取数值，需用到这两个函数：
函数 功能 parseInt 提取字符串中的整 …  </content></entry><entry><title>归档</title><url>/archives/custom_archieves/</url><categories/><tags/><content type="html">  {{ define "main" }}{{ T "archive" }}{{ range .Site.RegularPages.ByDate.Reverse.GroupByDate "2006-01" }}{{ .Key | time.Format "2006年1月" }}({{ len .Pages }}){{ range .Pages }}{{ .Date.Format "02日" }}{{ .Title }}{{ end }}{{ end }}{{ end }}  </content></entry><entry><title>第八章 充实的文档的内容</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/08--%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>HTML</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  &lt;abbr&gt; 与 &lt;acronym&gt; 标签&lt;abbr&gt;：表示缩略语（对单词或短语的缩写，如 &ldquo;Mr.&rdquo; 是 &ldquo;Mister&rdquo; 的缩写），通常建议通过 title
属性提供完整含义，例如：
&lt;abbr title=&#34;HyperText Markup Language&#34;&gt;HTML&lt;/abbr&gt;&lt;acronym&gt;：专门表示首字母缩写词（由多个单词首字母组成，且发音为一个单词，如 &ldquo;NASA&rdquo; 读作 &ldquo;nasa&rdquo;）。
注意：HTML5 中已废弃 &lt;acronym&gt;，推荐统一使用 &lt;abbr&gt; 替代，因其语义更通用。 DOCTYPE 与浏览器渲染模式DOCTYPE 的作用：告知浏览器文档使用的 HTML 版本，决定浏览器以标准模式还是兼容模式渲染页面。
标准模式：浏览器严格遵循 W3C 规范渲染页面，保证跨浏览器一致性。 兼容模式（怪异模式）：模仿早期浏览器（如 IE6）的非标准行为，允许不规范的代码正常运行（如忽略闭合标签、错误的盒模型计算）。 HTML5 的 DOCTYPE：
&lt;!DOCTYPE html&gt;此声明简洁且默认触发标准模式，无需指定具体版本，是现代网页的推荐写法。
换行符与 DOM 文本节点部分浏览器（如早期 IE、部分基于 WebKit 的浏览器）会将 HTML 中的换行符解析为文本节点（nodeType = 3），导致 childNodes 等集合中包含空文本节点。 影响：遍历子节点时需注意过滤空文本节点（可通过 nodeValue.trim() === &quot;&quot; 判断），避免逻辑错误。 accesskey 属性作用：为元素绑定键盘快捷键，提升可访问性（尤其适合键盘用户）。
用法：
&lt;a href=&#34;index.html&#34; accesskey=&#34;h&#34;&gt;首页&lt;/a&gt;触发方式：
Windows 系统：Alt + 快捷键（如 Alt + h）； macOS 系统：Ctrl + 快捷键（如 Ctrl + h）。 注意：避免与浏览器默认快捷键冲突（如 Alt + F 通常打开文件菜单），且需在页面中明确提示快捷键（如通过文字说明）。
JS 与文档内容的关系原则：JS 应作为内容的增强工具，而非创建核心内容的依赖。 核心内容（如标题、正文、导航链接）应直接通过 HTML 编写，确保在 JS 禁用时仍可访问。 JS 可动态添加交互元素（如弹窗、表单验证）、加载非核心内容（如评论、推荐），但需遵循 “平稳退化” 原则。   ]]></content></entry><entry><title>第九章 CSS DOM</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/09--css-dom/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>CSS</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  网页的三层结构网页的呈现和交互由结构层、表示层、行为层共同构成，三者各司其职又协同工作：
结构层： 由 HTML/XHTML 标记语言实现，通过标签（如 &amp;lt;p&amp;gt;、&amp;lt;div&amp;gt;）描述内容的语义和结构（如标题、段落、列表），不包含样式或行为信息。 示例：&amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt; 仅定义 “这是一个一级标题”，不规定其颜色、大小。 表示层： 由 CSS 负责，定义内容的视觉呈现（如颜色、字体、布局）。 即使未显式编写 CSS，浏览器也会应用默认样式（如 &amp;lt;h1&amp;gt; 默认加粗、字号较大）。 行为层： 由 JavaScript 和 DOM 控制，定义内容对事件的响应方式（如点击、鼠标悬停）。 浏览器默认也有基础行为（如链接点击跳转、表单提交），JS 可扩展或修改这些行为。 通过 DOM 操作样式：style 属性style 属性的特性每个元素节点的 style 属性是一个对象，包含该元素的内嵌样式（即通过 style 属性直接定义的样式，如 &amp;lt;div style=&amp;quot;color: red&amp;quot;&amp;gt;）。
命名规则：CSS 属性名中的减号（如 font-size）在 style 对象中需转换为驼峰命名法（如 style.fontSize），避免与 JS 语法冲突。
局限性：
仅能获取 / 修改内嵌样式，无法访问外部 CSS 文件或 &amp;lt;style&amp;gt; 标签中定义的样式。
示例：
&amp;lt;div id=&amp;#34;box&amp;#34; style=&amp;#34;width: 100px; color: blue;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const box = document.getElementById(&amp;#34;box&amp;#34;); console.log(box.style.width); // 输出 &amp;#34;100px&amp;#34;（获取内嵌样式） console.log(box.style.fontSize); // 输出 &amp;#34;&amp;#34;（非内嵌样式无法获取） &amp;lt;/script&amp;gt;通过 style 属性设置样式style 对象的属性是可读写的，可通过赋值修改样式，值需为字符串（需加引号）。
示例：
const box = …  ]]></content></entry><entry><title>第七章 动态创建标记</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/07--%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>AJAX</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  传统文档操作方法document.write()功能：将字符串直接插入到文档中，语法简单（如 document.write(&amp;quot;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;quot;)）。 缺点： 违背 “行为与表现分离” 原则，需在 HTML 中嵌入 &amp;lt;script&amp;gt; 调用，导致代码耦合。 可能引发文档验证错误，且与 application/xhtml+xml 类型文档不兼容（浏览器会忽略该方法）。 innerHTML功能：读写元素内的 HTML 内容（如 div.innerHTML = &amp;quot;&amp;lt;span&amp;gt;Hi&amp;lt;/span&amp;gt;&amp;quot; 可设置内容，const html = div.innerHTML 可读取内容）。 特点： 简洁高效，适合批量操作 HTML 片段，但无法精确控制单个节点（会整体替换元素内容）。 局限性：HTML 专有属性，不支持 XHTML 文档；安全性风险（可能引入 XSS 攻击，需谨慎处理用户输入）。 替代方案：标准 DOM 方法（如 createElement、appendChild）虽代码量增加，但可精确控制节点，兼容性更强。 标准 DOM 操作方法核心思想DOM 是文档的双向映射：既能读取文档结构（通过节点属性和方法），也能修改节点树（实时反映到浏览器渲染结果）。 浏览器显示的是 DOM 节点树，而非原始 HTML 代码，因此修改 DOM 会直接改变页面表现。 创建与插入节点创建元素节点：document.createElement(tagName)
示例：const newDiv = document.createElement(&amp;quot;div&amp;quot;);（创建 &amp;lt;div&amp;gt; 元素，初始为 “文档碎片”，未插入文档）。 创建文本节点：document.createTextNode(text)
示例：const textNode = document.createTextNode(&amp;quot;Hello DOM&amp;quot;);（创建包含文本的节点）。 插入节点到文档：
parent.appendChild(child)：将子节点添加到父节点的子节点列表末尾。
示例：
const parent = …  ]]></content></entry><entry><title>第六章 案例研究：图片库改进版</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/06--%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  JS 与网页结构的解耦原则核心思想：为网页添加行为时，JS 代码应尽量避免依赖特定的 HTML 结构（如固定的标签嵌套、类名顺序等）。 好处：当 HTML 结构调整时，JS 代码无需频繁修改，提高可维护性。 命名规范与注意事项命名原则可读性：使用有意义的单词命名变量、函数（如 calculateTotal 而非 fn1），通过命名体现用途。 风格统一：变量和函数名推荐使用驼峰命名法（如 userName、handleClick），常量常用全大写（如 MAX_SIZE）。 命名禁忌避免保留字：不能使用 JS 语言的保留字（如 if、function、class 等）作为变量名。 避免覆盖内置 API：不使用现有 JS 函数 / 方法名（如 alert、push）作为变量名，防止覆盖内置功能。 节点链表（NodeList）定义：由 DOM 方法（如 getElementsByTagName、querySelectorAll）返回的节点集合，类似数组但并非真正的数组（是类数组对象）。 特性： 每个节点都有自身的属性（如 nodeType、nodeName）和方法（如 appendChild）。 动态性：部分 NodeList（如 getElementsByTagName 返回的集合）会随 DOM 变化自动更新。 共享 onload 事件：addLoadEvent 函数问题：window.onload 只能绑定一个函数，多次赋值会覆盖之前的函数。 解决方案：addLoadEvent 函数用于将多个函数追加到 window.onload 事件中，确保所有函数在页面加载完成后执行。 实现逻辑：function addLoadEvent(func) { const oldOnload = window.onload; // 保存现有 onload 函数 if (typeof window.onload !== &#34;function&#34;) { // 若 onload 未绑定函数，直接赋值 window.onload = func; } else { // 若已绑定函数，追加新函数 window.onload = function () { oldOnload(); // 执行原有函数 func(); // 执行新函数 }; } }nodeName 属性特性：返回元素节点的标签名，始终为大写字母（即使 HTML 中标签是小写，如 &lt;div&gt; 的 nodeName 为 &quot;DIV&quot;）。 用途：判断元素类型（如 if (element.nodeName === &quot;LI&quot;) 检测是否为列表项）。 键盘事件与交互一致性onkeypress 事件触发时机：按下键盘上的任意按键（包括字母、数字、符号等）时触发。 用途：监听键盘输入（如表单验证、快捷键操作）。 键盘与鼠标事件的一致性用 Tab 键聚焦到链接后按 Enter 键，会触发该链接的 onclick 事件，与鼠标点击效果一致。 意义：确保键盘用户与鼠标用户获得相同的交互体验，提升可访问性。   ]]></content></entry><entry><title>第四章 案例研究：JS图片库</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/04-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  元素属性操作的两种方式直接属性赋值（传统方式）语法：element.属性名 = 值（如 input.value = &amp;quot;hello&amp;quot;）。 适用场景：大部分 HTML 元素的标准属性（如 value、src、href 等）。 特点：简单直接，但仅支持预定义的标准属性，不支持自定义属性。 setAttribute() 方法（DOM Level 1）语法：element.setAttribute(属性名, 属性值)（如 div.setAttribute(&amp;quot;data-id&amp;quot;, &amp;quot;123&amp;quot;)）。 优势： 可设置任意元素的任意属性（包括自定义属性），兼容性更强。 遵循 DOM 标准，可移植性好（适用于多种环境和编程语言）。 注意：修改后会实时反映在 DOM 中，但不会改变原始 HTML 源代码。 JS 文件优化：合并文件目的：减少 HTTP 请求次数，提高页面加载性能。 做法：将多个 .js 文件合并为一个文件，通过单次请求加载。 事件处理函数基本概念作用：在特定事件发生时执行指定 JS 代码（如点击、鼠标悬停等）。 语法：元素.事件处理函数 = &amp;quot;JS 语句&amp;quot; 或通过 DOM 方法绑定（如 element.onclick = function() {}）。 常用事件： onclick：用户点击元素时触发； onmouseover：鼠标指针悬停在元素上时触发； onmouseout：鼠标指针离开元素时触发； onload：页面或资源（如图片）加载完成时触发（常用于页面初始化）。 事件处理函数的返回值事件触发的 JS 代码可返回一个值，该值会传递给事件处理函数。 典型应用：阻止默认行为 例如，在&amp;lt;a&amp;gt;标签的 onclick 中返回 false，可阻止链接跳转： 子节点获取：childNodes作用：返回当前元素的所有子节点（包含元素节点、文本节点、空格 / 换行节点等），结果为类数组对象。
示例：
const parent = document.getElementById(&amp;#34;parent&amp;#34;); const children = parent.childNodes; // 所有子节点（含文本、空格等） 节点类型判断：nodeType作用：通过数值区分节点类 …  ]]></content></entry><entry><title>第五章 最佳实践</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/05--%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>前端开发</tag><tag>性能优化</tag><tag>平稳退化</tag></tags><content type="html"><![CDATA[  平稳退化定义：确保网站在浏览器不支持 JavaScript 或 JS 被禁用时，核心功能仍可正常使用（如链接可点击、内容可访问）。 关键原则： 为 JS 功能提供 “退路”，例如将链接的 href 属性设置为真实 URL，而非仅依赖 onclick 事件。 避免过度依赖 JS 实现基础功能（如导航、跳转）。 弹出窗口与平稳退化window.open() 方法：用于创建新窗口，语法为window.open(url, name, features)，参数分别为目标 URL、窗口名称、窗口属性（如尺寸、功能）。
示例函数：
function popUp(winUrl) { window.open(winUrl, &amp;#34;popup&amp;#34;, &amp;#34;width=320,height=480&amp;#34;); }调用方式的问题：
伪协议（javascript:）：如 &amp;lt;a href=&amp;quot;javascript:popUp(&#39;url&#39;)&amp;quot;&amp;gt;，在禁用 JS 时失效，不推荐。 空链接（#）：如 &amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;popUp(&#39;url&#39;);return false&amp;quot;&amp;gt;，禁用 JS 时点击会跳转至页面顶部，体验差。 正确做法：
让 href 指向真实 URL，onclick 中通过 return false 阻止默认跳转，确保 JS 禁用时仍能正常访问：
&amp;lt;a href=&amp;#34;http://www.baidu.com&amp;#34; onclick=&amp;#34;popUp(&amp;#39;http://www.baidu.com&amp;#39;);return false;&amp;#34; &amp;gt;baidu&amp;lt;/a &amp;gt;分离 JavaScript核心思想：将 JS 代码从 HTML 中剥离，通过外部脚本文件管理，避免 HTML 与 JS 耦合。
实现步骤：
HTML 保留基础功能：链接使用真实 href，通过 class 或 id 标识需要特殊处理的元素：
&amp;lt;a href=&amp;#34;http://www.baidu.com&amp;#34; class=&amp;#34;popup&amp;#34;&amp;gt;baidu&amp;lt;/a&amp;gt;外部 JS 绑定事件：在外部脚本中通过 DOM 方法找到 …  ]]></content></entry><entry><title>第二章 JS语法</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/02-js%E8%AF%AD%E6%B3%95/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  语法变量定义：变量是存储可变值的容器，将值存入变量的操作称为赋值。 声明与赋值： JS 中，未声明的变量赋值时会自动声明（不推荐，易导致全局污染）。 可一次性声明多个变量：var a, b, c;。 可在声明时赋值：var x = 10, y = &amp;quot;hello&amp;quot;;。 命名规则： 区分大小写（name 与 Name 是不同变量）。 允许包含字母、数字、$、_，但不能以数字开头，不能包含空格或标点符号（$ 除外）。 长变量名可读性优化： 下划线命名法：user_name； 驼峰命名法：userName（第二个单词起首字母大写）。 字面量：直接在代码中写出的数据（如 123、&amp;quot;abc&amp;quot;、true）。 数据类型弱类型特性：JS 是弱类型语言，无需声明变量类型，可随时修改变量的类型（与强类型语言需显式声明类型不同）。 字符串： 由零个或多个字符组成，需用单引号（&#39;）或双引号（&amp;quot;）包裹。 引号选择规则：字符串包含双引号时用单引号包裹（如 &#39;He said &amp;quot;Hi&amp;quot;&#39;），反之亦然。 转义字符：用反斜线（\）转义特殊字符，如 \&amp;quot; 表示双引号（&amp;quot;She said \&amp;quot;Hello\&amp;quot;&amp;quot;）。 数值： 支持整数（如 42）和浮点数（如 3.14），可带正负号（如 -5、-2.7）。 布尔值： 仅两个值：true（真）和 false（假），不可用引号包裹（否则为字符串）。 数组定义：用一个变量存储一组值（元素），元素可通过下标访问（下标从 0 开始）。 声明与初始化： 用 Array 关键字：var arr = new Array(); 或 var arr = new Array(3);（指定初始长度，可选）。 简洁语法（推荐）：var arr = [1, &amp;quot;a&amp;quot;, true];（直接用方括号包裹元素，元素类型可混合）。 元素操作： 赋值：arr[0] = 10;（通过下标赋值）。 嵌套数组：数组元素可是另一个数组（如 var nested = [1, [2, 3]];）。 关联数组： 用字符串作为下标（如 arr[&amp;quot;name&amp;quot;] = &amp;quot;Alice&amp;quot;），本质是为数组对象添加属性。 注意： …  ]]></content></entry><entry><title>第三章 DOM</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/03--dom/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  DOM 的核心概念DOM（Document Object Model，文档对象模型）是一套用于抽象和概念化文档内容的接口，它将网页文档转换为可通过 JavaScript 操作的对象树结构。
D：文档（Document）当网页加载到浏览器时，浏览器会自动将 HTML/XML 文档解析为一个 文档对象，即 DOM 的基础。 O：对象（Object）对象是包含数据和方法的集合： 属性：对象关联的变量（如 element.id）； 方法：对象可调用的函数（如 element.appendChild()）。 JS 中的对象类型： 用户定义对象：开发者创建的自定义对象； 内建对象：JS 自带的对象（如 Array、Date）； 宿主对象：浏览器环境提供的对象（如 window、document）。 关键宿主对象： window：对应浏览器窗口，属于 BOM（浏览器对象模型）； document：对应网页内容，是操作 DOM 的核心对象。 M：模型（Model）DOM 将文档表示为一棵节点树（类似家谱树），用 “父子”“兄弟” 等关系描述元素间的层次结构： 根元素是 &amp;lt;html&amp;gt;，所有其他元素都是其后代； 节点树清晰展示了元素的嵌套关系，便于通过 JS 遍历和操作。 节点（Node）DOM 文档由多种节点组成，核心类型包括：
元素节点（Element Node）文档的基本构成单位，对应 HTML 标签（如 &amp;lt;div&amp;gt;、&amp;lt;p&amp;gt;）。 特点：可包含其他元素节点或文本节点，是节点树的 “骨架”。 根元素：&amp;lt;html&amp;gt; 是唯一不被其他元素包含的元素节点。 文本节点（Text Node）包含文本内容（如文字、空格），总是被元素节点包含（如 &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; 中，“Hello” 是文本节点）。 注意：并非所有元素节点都包含文本节点（如空标签 &amp;lt;img&amp;gt;）。 属性节点（Attribute Node）描述元素的附加信息（如 class、id、src），仅存在于元素的起始标签中。 特点：依赖元素节点存在，无法独立于元素存在（如 &amp;lt;a href=&amp;quot;url&amp;quot;&amp;gt; 中，href 是属性节点）。 CSS 与 DOM 的关联CSS 通过节点树结构应用样式，子元素会继承父元 …  ]]></content></entry><entry><title>第一章 JS简史</title><url>/post/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/01--js%E7%AE%80%E5%8F%B2/</url><categories><category>JS DOM编程艺术</category></categories><tags><tag>JavaScript</tag><tag>DOM</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  DOM（文档对象模型）核心定义：DOM 是一套对文档内容进行抽象和概念化的方法，它将 HTML/XML 文档的结构转化为一个树形的对象模型，使得程序（如 JS）可以访问和操作文档的内容、结构和样式。 作用：作为 JS 与网页内容之间的桥梁，允许开发者通过代码动态修改文档的元素、属性、文本等（例如添加节点、修改样式、绑定事件等）。 DHTML（动态 HTML）本质：DHTML 并非一项独立技术，而是 HTML、CSS 和 JavaScript 三种技术的组合术语，用于描述 “动态操控网页内容和样式” 的技术方案。 核心组成与目标： HTML：负责标记网页的结构和内容（如 &lt;div&gt;、&lt;p&gt; 等元素）； CSS：负责定义元素的样式（颜色、布局、位置等）； JavaScript：负责实时操控页面元素和样式（如动态修改 CSS 属性、显示 / 隐藏元素、响应用户交互等）。 核心价值：通过三者协同，实现网页内容的动态更新，无需重新加载页面即可改变外观和行为（如表单验证、菜单切换、实时数据展示等）。 API（应用程序编程接口）定义：API 是一组得到各方共同认可的基本约定，规定了不同组件（如软件、库、服务）之间如何交互的规则（包括可调用的函数、参数格式、返回值类型等）。 举例： DOM API：如 document.getElementById()、element.appendChild() 等，规定了 JS 操作文档的方法； 浏览器 API：如 fetch()（网络请求）、localStorage（本地存储）等，提供了 JS 与浏览器功能交互的接口。 作用：简化开发，使不同模块或系统能够按照统一规则协作，无需关注内部实现细节。   ]]></content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0405--%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>Web Worker</tag><tag>性能优化</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Web Worker 基础定义与作用：
Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。 创建与类型：
专用 Worker（Dedicated Worker）：通过 new Worker(&#39;script.js&#39;) 创建，与主程序是一对一关系，仅能与创建它的程序通信。
示例：
// 主程序中创建专用 Worker const w1 = new Worker(&amp;#34;worker.js&amp;#34;);Worker 通信机制消息传递：
不共享作用域 / 资源，通过 message 事件双向通信，数据传递基于结构化克隆或所有权转移。
主程序与 Worker 内部均通过 postMessage(data)发送消息，通过 onmessage 监听消息：
// 主程序 w1.postMessage(&amp;#34;hello&amp;#34;); // 发送消息到 Worker w1.onmessage = (e) =&amp;gt; console.log(&amp;#34;收到 Worker 消息：&amp;#34;, e.data); // worker.js 内部 self.onmessage = (e) =&amp;gt; { console.log(&amp;#34;收到主程序消息：&amp;#34;, e.data); self.postMessage(&amp;#34;hi&amp;#34;); // 发送消息到主程序 };终止 Worker：
主程序中调用 w1.terminate() 可立即终止 Worker（无清理机会）； Worker 内部可调用 self.close() 主动终止自身。 Worker 运行环境限制与可用资源： 不可访问 DOM、主程序全局变量，但可使用 navigator、location、JSON、setTimeout 等，支持网络请求（如 fetch）。 可通过 importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;) 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。 典型应用场景： 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。 数据传递方式结构化克 …  ]]></content></entry><entry><title>4.4节 生成器</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0404--%E7%94%9F%E6%88%90%E5%99%A8/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  生成器的基本概念与特性定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 生成器产生值：生产者与迭代器迭代器接口作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 for..of循环自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 Iterable（可迭代对象）定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 生成器迭代器的特性生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 异步迭代生成器生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&amp;amp;#34;http://...&amp;amp;#34;, (err, data) =&amp;amp;gt; { if (err) it.throw(err); // 向生成器抛 …  </content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0403--promise/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  什么是 Promise未来值核心特性：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。 状态与不可变性： 封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。 一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。 then 方法的双回调：调用then(onFulfilled, onRejected)时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。 完成事件（流程控制）本质：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。 反控制反转： 传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过then注册回调，等待 Promise 决议后触发，将控制返还给调用代码。 信号特性：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。 具有 then 方法的鸭子类型thenable 定义：任何具有then方法的对象或函数，被视为与 Promise 一致的 “thenable”。 鸭子类型：通过值的形态（是否有then方法）假定其类型，这是识别 Promise 的核心逻辑。 Promise 信任问题（可靠性保障）异步回调：对 Promise 调用then时，即使 Promise 已决议，回调也始终异步执行（下一个事件循环 tick），确保行为一致。 决议的唯一性： Promise 只能被决议一次（首次调用resolve或reject生效，后续调用被忽略），因此then注册的回调仅执行一次。 若同一回调多次注册，会按注册次数执行。 决议值的单一性： 至多有一个决议值（未显式决议时为undefined），传给所有注册的回调。 调用resolve/reject时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。 异常处理：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。 Promise.resolve 的作用： 传入非 Promise / 非 thenable 值：返 …  </content></entry><entry><title>4.1节 异步：现在与将来</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0401--%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  分块的程序与异步机制分块程序的本质： 将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。 console.log 的异步特性： 部分浏览器的console.log并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。 事件循环核心机制： 事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个tick：
若队列中有等待事件（即回调函数），则从队列中取出一个执行； 无事件时，循环等待新事件加入。 核心流程，循环周期（tick）：检查 “宏任务队列”（如setTimeout、DOM事件），若有等待任务，取出第一个执行； 执行完当前任务后，检查 “微任务队列”（如Promise.then），清空所有微任务； 更新 UI（浏览器环境）； 重复步骤 1-3。 setTimeout 的作用： 并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。
并行执行异步与并行的区别： 异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）； 并行：关注 “同时发生”（多个操作在物理上同时进行）。 进程与线程： 进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存； JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。 JS 的单线程特性： 函数代码具有原子性（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）； 若函数执行顺序不确定，可能导致竞态条件（因共享状态的修改顺序不可控引发的逻辑错误）。 并发定义： 两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。
JS 的并发形式： 单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。
并发交互的协调方式：
门（Gate）：等待多个条件都满足后再执行下一步。例如： …  </content></entry><entry><title>4.2节 回调</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0402--%E5%9B%9E%E8%B0%83/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  回调函数的本质回调函数的核心作用是包裹或封装程序的延续逻辑—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。
回调地狱（Callback Hell）的成因回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：
思维与代码的不匹配：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。
控制反转导致的信任问题： 回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：
无法确保回调被调用的次数（可能被多次调用或不调用）； 无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）； 无法确保回调的参数符合预期。 回调模式的优化设计为缓解回调地狱和信任问题，常见的回调模式设计：
分离回调（Split Callbacks）： 为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。
错误优先回调（Error-First Callbacks，Node 风格）： 回调函数的第一个参数固定为错误对象，后续参数为成功结果：
若操作成功，错误参数为null或undefined； 若操作失败，错误参数为非空值（通常是Error对象）。 回调调用的最佳实践：永远异步执行即使回调逻辑可以同步完成，也应强制异步调用（如通过setTimeout或队列机制），确保回调行为的一致性：
避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）； 保证所有回调都遵循相同的异步逻辑，减少不可预测性。   </content></entry><entry><title>3.5节 语法</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0305--%E8%AF%AD%E6%B3%95/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>ASI</tag><tag>前端开发</tag></tags><content type="html">  语句与表达式的基本概念表达式：能返回一个结果值的代码片段（如1 + 2返回3，obj.prop返回属性值）。 语句：执行某种操作的代码（如if、for、return），所有语句都有结果值，但语法默认不允许直接获取。 语句的结果值常见语句的结果值： 赋值语句a = b：结果值为被赋予的值（即b的值）。 变量声明var a：结果值为undefined（let/const同理）。 代码块{...}：结果值为块内最后一个语句 / 表达式的结果（如{1; 2; 3}结果为3）。 获取语句结果值的方式：语法不直接支持，但可通过eval()获取（如eval(&amp;#39;{a=1; b=2}&amp;#39;)返回2）。 表达式的副作用副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。
常见有副作用的表达式函数调用：最常见（如console.log(1)会输出内容，改变控制台状态）。 自增 / 自减运算符： a++：先返回a的当前值，再将a加 1（副作用在后）。 ++a：先将a加 1，再返回新值（副作用在前）。 注意：++a++会报错（ReferenceError），因运算符需要可赋值的变量作为操作数。 逗号运算符：将多个表达式串联为一个语句，返回最后一个表达式的结果（如a=1, b=2, a+b结果为3），副作用是执行所有表达式。 delete 操作符： 作用：删除对象属性或数组单元。 结果值：成功删除（属性不存在或可配置）返回true；失败（不可配置属性）返回false或报错。 副作用：实际移除属性 / 单元（如delete obj.prop后obj.prop为undefined）。 赋值语句：a = 42结果为42，副作用是a被赋值为42；链式赋值（如a = b = 42）利用赋值表达式的结果值实现。 上下文规则大括号{}的用法对象常量：定义对象字面量（如{a: 1, b: 2}）。
标签（label）：用于标记代码块，配合break/ continue跳转：
break 标签：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。 continue 标签：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。 注意：标签不能用双引号；非循环代码块可使用break 标签，但不能用continue 标签。 JSON 与 JSON-P：
JSON …  </content></entry><entry><title>附录 混合环境JS</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>宿主环境</tag><tag>Annex B 规范</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Annex B（ES 规范的兼容性补充）背景： ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。
主要兼容性差异：
非严格模式允许八进制数值常量（如012，严格模式下为语法错误）；
浏览器提供window.escape()和window.unescape()，用于转义 / 还原带%分隔符的十六进制字符串（非标准方法，建议避免使用）；
String.prototype.substr与String.prototype.substring
的区别：
substring(start, end)：第二个参数为结束位置索引（不包含该位置）； substr(start, length)：第二个参数为截取长度。 Web ES 规范的额外差异：
&amp;lt;!--和--&amp;gt;被视为合法单行注释分隔符； String.prototype包含返回 HTML 格式字符串的附加方法（如anchor()、bold()）； 正则表达式（RegExp）扩展及Function.prototype附加方法（非标准，依赖浏览器实现）。 宿主对象定义：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如window、document、console），包括内建对象和工具函数。 特殊行为差异： 部分宿主对象强制转换为布尔值时可能为假值（如document.all，不符合 JS 标准假值规则）； 其他特性： 可能无法访问普通Object的内建方法（如toString()）； 部分属性为只读，无法覆盖； 方法的this无法重绑定到其他对象。 console 对象： 宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。 全局 DOM 对象全局变量与 global 对象：声明全局变量会同时在全局对象（如浏览器的window）中创建同名属性。 DOM 元素 ID 的副作用：因浏览器历史遗留问题，带id属性的 DOM 元素会自动创建同名全局变量（如&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;会生成window.app）。 原生原型扩展的注意事项不建议扩展原生原型：除非确保无代码冲突（如第三方库 …  ]]></content></entry><entry><title>09- 类</title><url>/post/ts/09--%E7%B1%BB/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html">  类的字段字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。
基本特性 字段声明默认创建公共可写属性，类型可显式声明（如x: number）或通过初始化值推断（如x = 0 → 推断为number）。 未指定类型且无初始化值时，隐式为any（可通过noImplicitAny禁用，强制显式声明）。 初始化相关 初始化器：字段可直接赋值（如x = 0），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。 strictPropertyInitialization 配置： 开启时，字段必须在构造函数内或初始化器中初始化，否则报错（防止访问未初始化的属性）。 例外：用!（明确赋值断言）标记 “后续会初始化” 的字段（如name!: string，常用于依赖注入场景）。 注意：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。 readonly 修饰符 标记字段为只读，仅可在初始化器或构造函数中赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。 构造函数类的初始化函数，用于实例化时设置初始状态。
与函数的异同 相似性：支持类型注释、默认值、重载（如多构造函数签名）。 区别： 不能有类型参数（类型参数属于外部类声明）； 不能有返回类型注释（默认返回类实例类型）。 super () 调用要求 派生类构造函数中，使用this前必须调用super()（调用基类构造函数），否则 TypeScript 报错。 方法与访问器类的函数属性，用于定义行为和属性访问逻辑。
方法 本质是类的函数属性，支持类型注释（参数和返回值）。 方法体内访问字段 / 其他方法必须通过this.，否则引用外部变量。 访问器 包括get（读取）和set（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。 TypeScript 推断规则： 仅有get时，属性自动为readonly； 未指定set参数类型时，从get返回类型推断； 4.3+ 版本支持get和set使用不同类型。 注意：无额外逻辑的get/set对意义不大，建议直接用公共字段。 索引签名类可声明索引签名，与对象类型索引签名规则一致。
示例：class MyClass { [s: string]: …  </content></entry><entry><title>06- 泛型</title><url>/post/ts/06--%E6%B3%9B%E5%9E%8B/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  类型变量类型变量是泛型的 “灵魂”，用于在类型层面建立关联（而非值层面），解决 “同一份逻辑适配多种类型” 的问题。
基本用法// 定义泛型函数：类型变量&amp;lt;Type&amp;gt;关联输入与输出类型 function identity&amp;lt;Type&amp;gt;(arg: Type): Type { return arg; } // 两种调用方式 let output1 = identity&amp;lt;string&amp;gt;(&amp;#34;myString&amp;#34;); // 显式指定类型参数 let output2 = identity(42); // 类型推断（推荐）：编译器自动推断Type为number 核心价值：避免重复编写不同类型的同名函数（如identityString、identityNumber），同时保持类型安全（对比any：any会丢失类型关联，泛型则保留输入与输出的类型一致性）。 类型推断：编译器可通过传入的值自动推断类型参数，简化代码。复杂场景下若推断失败，需显式指定类型。 类型约束：函数体内必须正确使用泛型参数（视为 “任意类型” 处理）。 泛型函数的类型定义泛型函数的类型与非泛型函数类似，需先声明类型参数，有多种表达方式：
直接作为函数类型
let myIdentity: &amp;lt;Type&amp;gt;(arg: Type) =&amp;gt; Type = identity;使用不同名称的类型变量（只要数量和使用方式一致）
let myIdentity: &amp;lt;Input&amp;gt;(arg: Input) =&amp;gt; Input = identity; // 合法：Input与Type作用相同 对象字面量的调用签名
let myIdentity: { &amp;lt;Type&amp;gt;(arg: Type): Type } = identity;泛型接口
// 接口内声明泛型调用签名 interface GenericIdentityFn { &amp;lt;Type&amp;gt;(arg: Type): Type; } let myIdentity: GenericIdentityFn = identity; // 接口本身泛型化（更常用） interface GenericIdentityFn&amp;lt;Type&amp;gt; { (arg: Type): Type; } let …  ]]></content></entry><entry><title>07- 类型运算符</title><url>/post/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  keyof 运算符keyof 用于将对象类型的所有键名转换为字面量联合类型，是实现 “类型安全的键访问” 的基础。
基础用法type Point = { x: number; y: number }; type P = keyof Point; // 等价于 type P = &amp;#34;x&amp;#34; | &amp;#34;y&amp;#34; 作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。 与索引签名结合当对象类型包含 string 或 number 索引签名时，keyof 会返回对应的索引类型：
// number 索引签名 type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; // type A = number（仅允许 number 类型索引） // string 索引签名 type Mapish = { [k: string]: boolean }; type M = keyof Mapish; // type M = string | number 因为 JavaScript 会将数字索引自动转换为字符串（如 obj[0] 等价于 obj[&amp;quot;0&amp;quot;]），因此 string 索引签名隐含支持 number 索引。 keyof与Object.keys的区别： keyof：在类型层面工作，返回键的字面量联合类型（编译时）。 Object.keys：在值层面工作，返回键的字符串数组（运行时）。 typeof 运算符（类型上下文）typeof 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。
基本用法let s = &amp;#34;hello&amp;#34;; let n: typeof s; // 类型为 string（n 的类型与 s 一致） 与函数结合获取函数的类型（而非调用结果的类型），配合 ReturnType 可提取返回值类型：
function f() { return { x: 10, y: 3 }; } type FType = typeof f; // () =&amp;gt; { x: number; y: number } …  ]]></content></entry><entry><title>08- 条件类型</title><url>/post/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  条件类型条件类型通过判断类型关系返回不同类型，基本形式为 SomeType extends OtherType ? TrueType : FalseType，核心价值在于与泛型结合实现灵活的类型逻辑。
基本用法当 SomeType 可赋值给 OtherType 时，返回 TrueType；否则返回 FalseType
type Example1 = Dog extends Animal ? number : string; // 若Dog是Animal的子类型，返回number 与泛型结合条件类型与泛型结合可简化重载，实现类型与值的动态关联：
// 需求：输入number返回IdLabel，输入string返回NameLabel type IdLabel = { id: number }; type NameLabel = { name: string }; // 条件类型关联输入与输出类型 type Label&amp;lt;T extends number | string&amp;gt; = T extends number ? IdLabel : NameLabel; // 单个函数替代重载 function createLabel&amp;lt;T extends number | string&amp;gt;(value: T): Label&amp;lt;T&amp;gt; { return typeof value === &amp;#34;number&amp;#34; ? { id: value } : ({ name: value } as Label&amp;lt;T&amp;gt;); } const label1 = createLabel(10); // 类型：IdLabel（{ id: number }） const label2 = createLabel(&amp;#34;Alice&amp;#34;); // 类型：NameLabel（{ name: string }） 类型推断与 infer通过 infer 关键字在条件类型中声明性推断类型，无需显式指定提取逻辑：
示例 1：提取数组元素类型
type Flatten&amp;lt;Type&amp;gt; = Type extends Array&amp;lt;infer Item&amp;gt; ? Item : Type; type Str = …  ]]></content></entry><entry><title>05- 对象类型</title><url>/post/ts/05--%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  对象类型的基本定义对象类型是 TS 中描述数据结构的核心方式，主要有三种定义形式：
匿名对象类型 直接在参数或变量声明中定义，无需命名：
function greet(person: { name: string; age: number }) { return &amp;#34;Hello &amp;#34; + person.name; }接口（interface） 通过interface关键字命名对象类型，支持声明合并（多次定义同一接口会自动合并），可复用：
interface Person { name: string; age: number; } function greet(person: Person) { /* ... */ }类型别名（type alias） 通过type关键字为对象类型命名：
type Person = { name: string; age: number; }; function greet(person: Person) { /* ... */ }面试高频对比：
场景 interface type 声明合并 支持 不支持（重复声明报错） 扩展方式 extends继承 交叉类型（&amp;amp;）合并 适用类型 仅对象 / 类形状 任意类型（对象、联合、基础类型等） 对象属性的特性对象类型的属性可通过修饰符指定特性：
可选属性
标记为?的属性可省略，类型为T | undefined（在strictNullChecks开启时需显式处理undefined）。
示例：
interface User { name: string; age?: number; // 可选属性 } const user: User = { name: &amp;#34;Alice&amp;#34; }; // 合法，age可省略 只读属性（readonly）
标记为readonly的属性在类型检查期间不可被重写，但不影响其内部内容的可变性（如对象属性仍可修改）。
TypeScript 检查类型兼容性时不考虑readonly，因此可通过别名修改只读属性。
示例：
interface Point { readonly x: number; readonly y: number; } const p: Point = { x: 1, y: 2 }; p.x = 3; // 错误：只读属 …  ]]></content></entry><entry><title>4. 更多关于函数</title><url>/post/ts/04-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  函数类型表达式描述函数最简单的方法是使用函数类型表达式。这些类型在语法上类似于箭头函数。
type GreetFunction = (a: string) =&amp;gt; void; function greeter(fn: GreetFunction) { // ... }(a: string) =&amp;gt; void 表示一个带有一个参数 a 的函数，该参数的类型为 string，没有返回值。
如果未指定参数类型，则隐式为 any。
参数名称是必需的。(string) =&amp;gt; void 表示“具有 any 类型名为 string 的参数的函数”。
调用签名函数类型表达式语法不允许声明属性。如果想描述可调用且带属性的函数，可以用对象类型编写调用签名。
type DescribableFunction = { description: string; (someArg: number): boolean; }; function doSomething(fn: DescribableFunction) { console.log(fn.description + &amp;#34; returned &amp;#34; + fn(6)); } function myFunc(someArg: number) { return someArg &amp;gt; 3; } myFunc.description = &amp;#34;default description&amp;#34;; doSomething(myFunc);与函数类型表达式不同，在参数列表和返回类型之间使用 : 而不是 =&amp;gt;。
构造函数签名JavaScript 函数可以通过 new 调用，TypeScript 称这些为构造函数。 通过在调用签名前添加 new 来编写构造函数签名。
type SomeConstructor = { new (s: string): SomeObject; }; function fn(ctor: SomeConstructor) { return new ctor(&amp;#34;hello&amp;#34;); }可组合调用与构造签名：
interface CallOrConstruct { (n?: number): string; new (s: string): Date; }泛型函数当输入 …  ]]></content></entry><entry><title>3. 缩小</title><url>/post/ts/03-%E7%BC%A9%E5%B0%8F/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  TypeScript 会将类型分析覆盖在 JavaScript 的运行时控制流结构上，例如 if/else、条件表达式、循环、真值检查等，这些结构都会影响类型判断。
当 TypeScript 看到如 typeof padding === &amp;quot;number&amp;quot; 的检查时，会将其识别为一种称为类型保护（Type Guard）的特殊代码形式。TypeScript 会跟踪程序可能的执行路径，分析各位置值的最具体类型，并通过这些检查和赋值将类型细化为更具体的类型，这一过程称为缩小（Narrowing）。
typeof 类型保护JavaScript 的 typeof 操作符能在运行时提供值的类型信息。
TypeScript 能理解 typeof 的结果，用以在不同分支中缩小类型范围。
TypeScript 内置了对 typeof 的行为规则，因此能正确处理 JavaScript 的一些特例。
真实性缩小在 JavaScript 中，if、&amp;amp;&amp;amp;、||、! 等条件语句可以接受任意类型的表达式。
条件判断时会先将表达式强制为 boolean，再根据结果选择分支。
可通过：Boolean(value)或 !!value将值强制为布尔类型。
这种方式常用于防范 null 或 undefined。但对原始值的真值检查容易出错，TypeScript 仅能在有限范围内帮助发现问题。
带有 ! 的布尔否定会从否定分支中过滤掉原值。
相等缩小TypeScript 会利用 switch、===、!==、==、!= 来缩小类型。
即使使用宽松等式（==、!=），TypeScript 也能正确缩小。
x == null 同时检查 x 是否为 null 或 undefined。 x == undefined 亦同理。 in 操作符缩小JavaScript 的 in 操作符可判断某对象或其原型链中是否存在指定属性。TypeScript 利用此信息缩小可能的类型范围。
可选属性在缩小时会同时存在于两侧分支。
instanceof 缩小instanceof 用于检查某值是否是另一构造函数的实例。
TypeScript 将其视为一种类型保护，可根据结果缩小分支类型。
x instanceof Foo 会检查 x 的原型链中是否包含 Foo.prototype。
赋值当变 …  ]]></content></entry><entry><title>2. 日常类型</title><url>/post/ts/02-%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  原始类型：字符串、数字和布尔值JavaScript 有三个常用的原始类型：string、number、boolean。
TypeScript 中对应的类型名称与 JavaScript 中 typeof 运算符的结果一致。
应始终使用 小写的 string、number、boolean 作为类型。
以大写开头的 String、Number、Boolean 是特殊内置类型，几乎不使用。
数组数组类型的写法：
number[]：数字数组 string[]：字符串数组 Array&amp;lt;number&amp;gt;：与 number[] 含义相同 注意：[number] 是不同的东西。
any特殊类型 any 用于在不希望引发类型检查错误时使用。
当值为 any 类型时：
可以访问任何属性； 可以像函数一样调用； 可以赋值给任意类型或从任意类型赋值； 可执行所有语法合法的操作。 当不想写出冗长类型以通过编译时，any 很有用。
noImplicitAny当未指定类型且 TypeScript 无法推断类型时，编译器默认将其设为 any。应避免这种情况。
使用编译器标志 noImplicitAny 可将隐式 any 标记为错误。
变量的类型注解使用 const、var 或 let 声明变量时，可选择添加类型注解。
let myName: string = &amp;#34;Alice&amp;#34;;TypeScript 不使用“左侧类型”声明（如 int x = 0;），类型注解总是写在变量之后。
多数情况下无需显式类型注解，TypeScript 会自动 推断类型。
函数参数类型注解在参数名后添加类型注释声明函数的参数类型。
TypeScript 会检查：
参数类型是否匹配； 参数数量是否正确。 function greet(name: string) { console.log(&amp;#34;Hello, &amp;#34; + name.toUpperCase() + &amp;#34;!!&amp;#34;); }返回类型注释返回类型注释位于参数列表之后。
TypeScript 通常能自动推断返回类型，但可显式指定以增强可读性。
function getFavoriteNumber(): number { return 26; }匿名函数当函数出现在 TypeScript 能确定其调用方式的位置 …  ]]></content></entry><entry><title>1. 基础知识</title><url>/post/ts/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>typescript文档阅读</category></categories><tags><tag>TypeScript</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 与类型系统每个值都有一组行为，可以通过运行不同的操作观察这些行为。JavaScript 运行时根据值的 类型 来决定执行的操作。
对于原始类型（如 string、number），可使用 typeof 运算符识别。对于函数等复杂类型，没有运行时机制可识别其类型。
在纯 JavaScript 中，了解函数如何处理特定值的唯一方法是 调用它并观察结果。这种特性导致在代码运行前 难以预测行为。
类型 是描述哪些值可以传递给函数、哪些值会导致崩溃的概念。
JavaScript 提供的是 动态类型系统 —— 运行代码才能看到结果。静态类型系统 则能在代码运行 之前 预测执行行为。
静态类型检查目的
帮助在运行代码 之前 发现错误。 TypeScript 通过描述运行时值的形状与行为，提前检测潜在异常。 问题背景
运行时错误被视为 bug。 测试不足或重构复杂时，错误难以发现或修复。 非异常失败JavaScript 遵循 ECMAScript 规范，在遇到意外情况时会定义特定行为。
静态类型系统需自行决定哪些代码应被视为错误，即使这些代码在 JavaScript 中是“合法”的。
TypeScript 的目标是捕获合法 bug，如：拼写错误，未调用的函数，基本逻辑错误
工具类型TypeScript 不仅能捕获错误，还能 防止错误的发生。
类型检查器可以：
检查属性访问是否正确； 提供属性建议； 提供代码补全与错误提示。 支持 TypeScript 的编辑器还提供：
快速修复 重构 跳转定义 查找引用 tsc，TypeScript 编译器安装
npm install -g typescript编译
tsc hello.ts若无类型错误，无输出（表示无问题）。 生成对应的 hello.js 文件，代码清晰且保留注释。 发出错误若存在类型检查错误，命令行会显示错误信息，但仍会生成 hello.js。
TypeScript 假设 开发者比编译器更了解代码意图。
可使用 noEmitOnError 参数让编译器在错误时不生成输出文件。
显式类型function greet(person: string, date: Date) { console.log(`Hello ${person}, today is …  </content></entry><entry><title>11. git flow</title><url>/post/git/11-git-flow/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  根据 Git Flow 的建议，分支主要分为以下几类：
master 分支 develop 分支 hotfix 分支 release 分支 feature 分支 其中：
master 和 develop 被称为 长期分支，因为它们会一直存在于整个 Git Flow 生命周期中。 其他分支（如 hotfix、release、feature）属于 临时分支，会在任务完成后被删除。 各分支职责master 分支
用于存放 稳定、可随时上线的项目版本。 来源：只能从其他分支合并，开发者不会直接在 master 上 commit。 特征：每个稳定版本的 commit 通常会打上 版本号标签（tag）。 develop 分支
是 所有开发分支的基础分支。 新增功能时，所有的 feature 分支 都从 develop 分支划出。 当 feature 分支的功能完成后，会被 合并回 develop 分支。 hotfix 分支
当 线上产品出现紧急问题 时，从 master 分支 划出一个 hotfix 分支进行修复。 修复完成后： 合并回 master 分支（发布修复版本）。 同时合并一份到 develop 分支。 合并到 develop 的原因
如果不这样做，当 develop 分支未来合并回 master 时，之前修复过的问题会再次出现。
不从 develop 分支划出的原因
因为 develop 分支的功能可能尚未完成，若从中直接切出修复分支再合并回 master，反而可能造成更大的问题。
release 分支
当 develop 分支 的代码足够成熟时，将其合并到 release 分支，进行上线前的 最终测试。 测试完成后： 合并到 master 分支（正式上线版本）。 同时合并回 develop 分支。 合并回 develop 的原因
在 release 阶段可能会发现并修正问题，需同步回 develop，避免未来版本再次出现同样的错误。
feature 分支
用于 新增功能的开发。 所有 feature 分支都从 develop 分支 划出。 功能开发完成后，合并回 develop 分支。 层级关系master ← release ← develop ← feature ↑ ↑ └── hotfix ┘  </content></entry><entry><title>10. 使用github</title><url>/post/git/10-%E4%BD%BF%E7%94%A8github/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  把内容推送到 GitHub 上GitHub 是全球最大的 git 服务器。
git 是工具，GitHub 是网站，其本质是一个 git 服务器。
设置远端节点git remote add origin xxx.gitgit remote：进行与远端有关的操作。
add：加入一个远端节点。
origin：指向远端 GitHub 服务器的位置，是 默认代名词。
从服务器 clone 下来的项目默认远端名就是 origin，但该名称可以修改。
推送内容到远端git push -u origin main该命令完成以下操作：
将 main 分支内容推送到 origin。 若远端不存在 main 分支，则 创建一个名为 main 的分支。 若存在，则 移动远端 main 分支到最新进度。 -u 参数：设置 upstream。 upstream（上游分支）upstream 翻译成中文意思是上游，其实就是另一个分支的名称
每个分支最多可设置一个上游（upstream）。
upstream 可追踪远端分支，也可指向本地分支。
若设置了 upstream，之后执行 git push 可 自动推送到默认目标。
若未设置，则需 每次明确指定分支与目标。
修改远端分支名称git push -u origin main:main与上方命令效果相同。
若希望远端分支名称不同，可修改为：
git push -u origin main:cat此时会在远端创建名为 cat 的分支。
拉取更新（pull）fetch 指令执行 fetch 指令
git fetch执行后：
Git 会拉取远端更新，并同步到本地的 origin/ 分支。 远端分支命名如：origin/HEAD、origin/main。 因使用过 -u 参数，origin/main 即为本地 main 的 upstream。 fetch 后若远端有新内容，会更新本地对应的 origin 分支。 接下来可执行 merge 合并更新。 pull 指令git pull = git fetch+git merge
git pull -rebasepull 会拉取远端内容并更新本地进度。
使用 -rebase 参数时，fetch 后采用 rebase 方式合并。
在多人协作时，rebase …  </content></entry><entry><title>9. git其他知识</title><url>/post/git/09-git%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  手边的工作做到一半，临时要切换到别的任务简单做法先保存当前所有修改。 切换到有问题的分支进行修复。 修复完成后切换回原分支。 执行 reset 命令，衔接上已完成的部分。 继续之前的工作。 使用 stash使用 git stash 将修改暂存。
注意：untracked 状态的文件默认无法被 stash，需要使用 -u 参数。 使用 git stash list 查看当前状态栈。
最前面的 stash@{0} 表示最新的 stash。 WIP 表示 “work in progress”（工作进行中）。 取回暂存内容
git stash pop stash@{0}pop 会将指定的 stash 应用到当前分支上，并 自动删除 它。
若未指定，默认取出 stash@{0}（最后保存的那次）。
删除指定的 stash。
git stash drop stash@{0}不删除地取回
git stash apply stash@{0}将指定的 stash 套用到当前分支上，但 不会被删除。
可理解为：pop = apply + drop。
不小心把账号密码放进 git，想删掉砍断重练法：删除 .git 目录。 删除密码文件。 重新 commit。 优点：简单直接。 缺点：所有历史记录都会消失，仅适合个人项目。
使用 filter-branch可一次性从每个 commit 中移除文件。
git filter-branch --tree-filter &amp;amp;#34;操作&amp;amp;#34;说明filter-branch 会逐个处理 commit。 --tree-filter 会在每个 commit 被 checkout 后执行指定操作，再重新 commit。 删除文件后，后续 commit 会重新计算，产生新的历史记录。 恢复到执行前状态执行 filter-branch 时，git 会将原状态备份到.git/refs/original/refs/heads 目录中，可以通过该目录找出 SHA-1，再执行：
git reset refs/original/refs/heads/master --hard即可回到执行前状态。
如果已经推出去了执行：
git push -f强制推送修改后的历史。
将其他分支的 commit 捡过来合并使用 cherry-pick： …  </content></entry><entry><title>8. 修改历史记录</title><url>/post/git/08-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  修改历史信息用 --amend 修改最后一次提交只能修改最后一次 commit 的信息。
git commit --amend使用互动模式修改更早的历史记录可使用 git rebase 的互动模式来改动过去的历史记录。
git rebase -i SHA-1-i：进入 rebase 的互动模式。SHA-1：表示从当前到该 commit 的范围。
进入后会弹出 vim 编辑器。
编辑器中的顺序与 git log 结果相反。
pick：保留这次 commit，不改动。
reword（或 r）：修改 commit 信息。
修改后保存并退出，会弹出另一个 vim 编辑器以修改 commit 信息。 保存并退出后，git 会自动完成剩下的操作。
修改 commit 信息后，SHA-1 值会改变。
被修改的 commit 会成为新的对象。
之后的所有 commit 都会重新生成新的 commit 对象。
如果要取消当前 rebase，可执行：
git reset ORIG_HEAD --hard即可回到 rebase 之前的状态。
把多个 commit 合并为一个使用互动模式的 rebase：
将 pick 改为 squash。 被标记为 squash 的 commit 会与前一行的 commit 合并。 保存并退出后，会进入编辑器重新编写合并后的 commit 信息。 把一个 commit 拆分为多个使用互动模式的 rebase，将 pick 改为 edit。当 rebase 执行到该 commit 时会暂停。
使用以下命令重置该 commit：
git reset HEAD^使用多次 add + commit 将内容分成多个 commit。
执行以下命令让 rebase 继续：
git rebase --continue在两个 commit 之间插入新的 commit使用互动模式的 rebase，将 pick 改为 edit。
当执行到该 commit 时会暂停。
添加新的 commit。继续执行 rebase
注意：rebase 状态下的 commit 列表顺序与正常日志相反，需确认停下的点是否正确。
删除或调整 commit 顺序使用互动模式的 rebase：
调整顺序：直接调整列表中 commit 的顺序。 删除 commit： 将 pick 改为 drop，或直接删除该行。 注意：删除或调整顺序时需考虑 commit 的相依性。
revert取消最后一次 commit：
git revert HEAD --no-edit--no-edit：不编辑 commit 信息。
该操作会新增一个 commit 来撤销目标 commit，原 commit 仍保留。
取消 revert再开一个 revert
对刚才的 revert 再执行一次 revert。 直接使用 reset
git reset HEAD^ --hard可回到 revert 之前的状态。
适用场景单人项目：通常直接使用 reset。
多人协作项目：若不允许使用 reset 或 rebase 修改历史，可使用 revert 生成一个反向操作的 commit。
三个指令的区别指令 作用 是否修改历史 适用场景 reset 修改当前状态到指定 commit ✅ 是 尚未推送的 commit rebase 编辑、删除或整理历史记录 ✅ 是 尚未推送的 commit revert 新增一个 commit 来反转之前的内容 ❌ 否（新增 commit） 已推送或禁止改历史的情形   </content></entry><entry><title>7. 标签</title><url>/post/git/07-%E6%A0%87%E7%AD%BE/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  使用标签在 Git 中，标签是一个指向某个 commit 的指示标。
通常在完成特定的里程碑时，使用标签来做标记。
标签分类标签分为两种：轻量标签和有附注的标签
不管哪种标签，都可以看作是一张贴纸贴在某个 commit 上。
轻量标签 使用方法简单，只需指定要贴上的 commit：
git tag 标签名 SHA-1若不加 SHA-1 值，则会贴在当前所在的 commit 上。
轻量标签仅是一个指向 commit 的指示标，不含其他信息。
Git 更推荐使用有附注的标签。
有附注的标签 创建方法：
git tag 标签名 SHA-1 -a -m &amp;#34;xxx&amp;#34;-a：创建有附注的标签。
-m：输入信息，类似于 commit 信息。
若省略 -m，会自动进入 Vim 编辑器输入说明。
区别 有附注的标签主要用作 软件版本号。轻量标签适合个人使用或临时标记。
有附注的标签包含更多信息：谁、何时贴上标签。
存储方式：
轻量标签 → 直接指向 commit。 有附注的标签 → 指向 tag 对象，再由 tag 对象指向 commit。 标签与分支一样，以文档形式存放在 .git/refs/tags 目录下。内容是一个 40 字节的 SHA-1 值，指向某个对象。
删除标签标签本质是一张贴纸，删除标签不会影响 commit 或文件。
删除方法：
git tag -d 标签名标签与分支的区别共同点
都是指示标。 都存放在 .git/refs 目录下：分支在 heads 目录。标签在 tags 目录。 都是 40 字节的 SHA-1 值。 删除不会影响被指向的对象。 区别
分支会随着 commit 前进而移动。 标签一旦贴上去就固定在该 commit 上，不随 commit 变化。   </content></entry><entry><title>6. 合并分支</title><url>/post/git/06-%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  使用 merge 合并分支如果想要用 master 分支来合并 cat 分支，需要先切换回 master 分支，再使用 git merge 命令。
git merge cat合并后，落后的 master 分支会和 cat 分支处于同一个 commit。
假设从 master 分支创建了 cat 和 dog 两个分支，并且当前在 cat 分支：
master 合并 cat 或 dog → 快转模式（fast-forward），master 直接收割成果。 cat 与 dog 互相合并 → Git 会生成一个 额外的 commit，该 commit 会指向两个父 commit。 谁合并谁，两个分支上的 commit 都是对等的。
差别在于：
谁合并谁，谁的分支就会往前移动。 额外生成的 commit 对象中会记录两个 parent，合并方向决定顺序。 使用 --no-ff 参数可避免快转模式，强制生成一个新的 commit 对象。
这样做出来的 commit 对象一样会指向前面的两个 commit。
合并过的分支是否保留可自行决定。删除分支只是移除一张贴纸，不影响原 commit。 所谓合并分支，其实是合并 分支指向的 commit，而不是分支本身。
恢复已被删除但未合并的分支分支只是一个指向某个 commit 的指标，删除分支不会使 commit 消失。
删除分支后，commit 仍存在，只是若未记下 SHA-1 值，不易再利用。
git branch new_branch SHA-1如果未记录 SHA-1 值，可用 git reflog 查找。reflog 默认保留 30 天，在此期间可找回。
使用 rebase 合并分支git rebase 的含义是 重新定义分支的参考基准，功能与 git merge 类似。
例如：cat 和 dog 两个分支的基准都是 master。使用 git rebase：
git rebase dog含义：cat 分支重新定义基准，dog 分支作为新的基准。
过程：
把 cat 分支的 commit 接到 dog 分支上。 重新计算 commit 的 SHA-1，生成新的 commit 对象。 cat 分支指向新的 commit，HEAD 继续指向 cat。 原本的 commit 依然存在，只是没有分支指向，最终可能被 Git …  </content></entry><entry><title>5. 使用分支</title><url>/post/git/05-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  使用分支在 Git 中使用分支很简单，只要使用 git branch 命令即可。
如果 git branch 后面没有接任何参数，它仅会输出当前在这个项目中有哪些分支。
Git 默认会设置一个名为 main 的分支，前面的 星号 表示现在正在这个分支上。
新增分支执行 git branch 命令时，在后面加上分支的名字即可新增一个分支。
更改分支名称使用 -m 参数更改分支名称。
git branch -m old new即使是 main 分支 也可以改。
更改分支名称不会影响文件或目录。
删除分支使用 -d 参数删除分支。
git branch -d 分支名如果要删除的分支还没有被完全合并，Git 会有提示。
此时改用 -D 参数即可强制删除。
任何分支都可以删除，包括 main 分支。
当前所在的分支不能删，必须先切换到其他分支再删除。
切换分支使用 git checkout 切换分支。
git checkout 分支名切换后，执行 add 和 commit 操作时，只有 当前所在的分支 会前进。
要切换到的分支必须先存在，否则会报错。
使用 -b 参数可在切换时直接创建新分支：
如果分支存在 → 直接切换 如果分支不存在 → 创建并切换过去 分支的原理分支就是一张贴纸，贴在某一个 commit 上。
新的 commit 会指向前一个 commit，而当前分支（HEAD 所指）会贴到新的 commit 上，HEAD 也会跟着前进。
Git 的分支不是通过复制目录或文件生成的，而只是一个指标。
分支其实就是一个 只有 40 个字节的文件，位于 .git/refs/heads 目录中。
切换分支时发生的事更新暂存区和工作目录
Git 会用目标分支指向的 commit 内容更新暂存区和工作目录。 切换前的改动会保留在工作目录中，不受影响。 每次 commit 都是一个对象，指向某个 tree 对象，而这些 tree 又指向其他 tree 或 blob 对象，类似葡萄串。 → 切换分支不会影响工作目录中已有的改动。
变更 HEAD 的位置
HEAD 会指向刚切换过去的分支。 .git/HEAD 文件内容会被改动。 git 如何知道现在是在哪个分支执行 git branch 可看到所有分支列表，星号表示当前分支。
.git 目录中的 HEAD 文件 记录了当前指向的分支。
切换分支时，HEAD 内容会变化。
使用 @ 可代替 HEAD。
ORIG_HEAD.git 目录中有一个 ORIG_HEAD 文件。
在执行危险操作时，Git 会把 HEAD 的状态存放在其中，方便随时回退到危险动作前的状态。
git reflog 也能查到相关信息，但数据较复杂。
ORIG_HEAD 可方便地找到最近一次危险动作之前的 SHA-1 值。
从过去的某个 commit 再创建一个新的分支回到目标 commit：
git checkout SHA-1从该 commit 开出新分支并切换：
git checkout -b 分支名也可以直接一行完成：
git branch -b 分支名 SHA-1  </content></entry><entry><title>4. git目录中有什么</title><url>/post/git/04-.git%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  head 是什么HEAD 是一个指标，指向某一个分支，通常可以当作当前所在分支。
在 .git 目录中有一个名为 head 的文件，其中记录的就是 HEAD 的内容。
HEAD 特点：
通常指向当前所在分支 不一定总是指向分支，当未指向分支时会出现 detached head 状态 在切换分支时，HEAD 内容会改变 当 HEAD 改变时，reflog 会留下记录 SHA-1 值SHA-1 值是一种杂凑算法，结果为 40 个十六进制数字。
特点：
相同输入 → 相同输出 不同输入 → 不同输出 Git 中所有对象的编号都是用 SHA-1 产生的。
SHA-1 值会重复吗相同输入：相同结果，不代表重复。
不同输入，相同结果：称为 碰撞。发生概率极低。
Git 计算时不仅使用文件内容，还会额外加内容，进一步降低碰撞概率。
对象 SHA-1 计算方式Blob 对象计算模式： blob 字样 一个空白字节 输入内容的长度 null 结束符 输入内容 Tree / Commit / Tag：第一项改成对应的对象名。 git 中的对象Git 有四种重要对象：Blob、Tree、Commit、Tag
Blob 对象当文件加入暂存区，Git 在 .git 中生成 blob 对象
存储规则：
前 2 个字节 → 目录名 后 38 个字节 → 文件名 文件内容经过压缩，一般编辑器无法直接查看
使用命令查看：
git cat-file -t SHA-1值 # 查看对象类型 git cat-file -p SHA-1值 # 查看对象内容关键点：
git add 时，计算 SHA-1 并存储 使用前两位作为目录，后 38 位作为文件名 内容存放于 .git/object 文件内容是压缩后的结果 空目录无法加入 Git，但空文件可以（内容为空） Tree 对象文件以 blob 存放
目录及文件名以 tree 存放
Tree 对象会指向：
一个或多个 blob 一个或多个其他 tree 这种关系称为 DAG（有向无环图）
commit 对象包含信息：
某个 tree（根目录的 tree） 提交时间 作者和提交者（一般相同） 提交信息 分支分支像一张“贴纸”，贴在某个 commit 上，并随 commit 移动
HEAD 指向某个分支，可理解为当前分支
特点： …  </content></entry><entry><title>3. commit相关</title><url>/post/git/03-commit%E7%9B%B8%E5%85%B3/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html">  修改 commit 记录修改方式删除整个 .git 目录 使用 git rebase 删除并整理后重新 commit 使用 git reset 删除并整理后重新 commit 使用 --amend 改动最后一次的 commit 使用 &amp;amp;ndash;amend 参数修改最后一次 commit在 commit 命令后加 --amend 即可
如果没有加 -m，会弹出 vim 编辑器编辑信息
虽然只是修改 commit 信息，但 git 会认为内容改变，重新生成新的 commit 对象（一次全新的 commit）
修改更早的 commit使用 git rebase
注意：不要在已经 push 的 commit 上改动，否则会造成困扰
追加文件到最近一次 commit采用下面两种方式：
使用 git reset 删除最近一次 commit，加入新文件后重新 commit 使用 --amend 操作流程git add 把文件加到暂存区 git commit --amend 可加 --no-edit 避免编辑信息 git commit --amend --no-edit注意：尽量不要在已 push 的 commit 上执行
新增目录Git 根据文件内容计算对象，空目录无法提交
解决方法：在空目录中放置一个文件（如 .keep 或 .gitkeep）
然后按正常流程 add 和 commit
忽略文件使用 .gitignore在项目目录新增 .gitignore 文件并设置规则
即使 .gitignore 未 commit/push 也有效，但建议提交共享
规则只对之后新增的文件有效，已存在的文件无效
若需让已存在的文件生效：
git rm --cached 文件名忽略忽略在 git add 时加 -f 参数可忽略 .gitignore 规则
git add -f 文件名称清除忽略的文件使用 git clean -fX
-f：强制删除 -X：删除被忽略的文件 查看特定文件的 commit 记录查看单一文件的历史
git log index.html查看改动内容
git log -p index.html+ 表示新增，- 表示删除
查看某行代码是谁写的使用 git blame
显示每行代码的提交者和提交信息
可加 -L 参数指定范围
git …  </content></entry><entry><title>2. 开始使用 Git</title><url>/post/git/02-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html"><![CDATA[  新增、初始 Repositorygit init：在当前目录中创建一个 .git 目录，整个 Git 的核心都集中在此目录中。
如果不想让当前目录被 Git 管控，或只想提供不含版控记录的内容，只需移除 .git 目录，Git 就会失去对该目录的控制权。
把文件交给 git 管控创建文件后交给 gitgit status：查看当前目录状态。
untracked files：文件尚未被加到 Git 版控系统中，只是新加入目录，尚未被追踪。 git add [文件名]：将文件交给 Git 管控。
状态从 untracked files → new files。 表示该文件已经进入 暂存区（index），稍后可与其他文件一起提交到存储库。 使用万用字元：
git add *.html把所有后缀名是.html 的文件全部加到暂存区。
加入所有文件：
git add --all--all 与 . 的区别git add .：将当前目录及其子目录中的修改加入暂存区，不包含该目录以外的内容。
git add --all：不论在哪一层目录执行，都会将整个项目的所有修改加入暂存区。
提交暂存区内容到存储库git commit -m &amp;quot;xxx&amp;quot;：将暂存区的内容永久保存到存储库。
-m &amp;quot;xxx&amp;quot; 用于说明此次提交的内容。可以使用中英文，只要简单、清晰即可。说明的重点是 让自己和别人都能快速理解本次改动。
完成 commit 才算完成整个流程。
git commit 只会处理暂存区的内容。尚未 git add 到暂存区的文件 不会被提交。
提交说明是必需的，否则提交不会完成。若未指定 -m 参数，Git 会打开默认编辑器（通常是 vim）以填写提交信息。
使用 --allow-empty 参数可以创建 没有内容变更 的提交：
git commit --allow-empty -m &amp;#34;&amp;#34;工作区、暂存区与存储库三个主要区域工作目录 → 暂存区：git add 暂存区 → 存储库：git commit 注意：执行 commit 才算完成整个流程。
是否一定要二段式使用 -a 参数可省略 git add
git commit -a -m &amp;#34;xxx&amp;#34;-a 参数只对 已存在于存储库的文件 有效， …  ]]></content></entry><entry><title>1. git概述</title><url>/post/git/01-git%E6%A6%82%E8%BF%B0/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>版本控制系统</tag></tags><content type="html"><![CDATA[  git 概述Git：一种 分布式版本控制系统。
git 的优点免费开源
速度快、文件体积小
其他版本控制系统：记录的是各版本之间的差异。 Git：记录的是 文本内容的快照，可快速切换版本。 分布式系统
即使没有服务器或网络，也可以使用 Git 进行版本控制。 待服务器恢复或网络可用时再进行同步，不受影响。 终端机/命令提示符常用命令Windows macOS/Linux 说明 cd cd 切换目录 cd pwd 获取当前位置 dir ls 列出文件列表 mkdir mkdir 创建目录 无 touch 创建文件 copy cp 复制文件 move mv 移动文件 del rm 删除文件 cls clear 清屏 目录切换及显示# 切换到 /tmp 目录（绝对路径） cd /tmp # 切换到 my_project 目录（相对路径） cd my_project # 切换到上一层目录 cd .. # 切换到 home/project/namecards 目录 cd ~/project/namecards/ # 显示当前所在目录 pwd文件列表ls：列出当前目录下文件及目录。
ls -al：显示包含以.开头的文件，及完整权限、所有者、时间信息。
ls -al创建文件、目录# 创建文件 touch index.html # 创建目录 mkdir demotouch：
不存在 → 创建空白文件。 已存在 → 修改最后修改时间，不改动内容。 mkdir：创建目录。
文件操作# 复制 cp index.html about.html # 重命名 / 移动 mv index.html info.html # 删除文件 rm index.html # 删除目录下所有 .html 文件 rm *.htmlvim 操作介绍模式切换：
Normal 模式：命令模式，无法输入文本。 Insert 模式：文本输入模式。 进入 Insert 模式：
i → insert a → append o → 新建一行并输入 切换模式：
Insert → Normal：Esc 或 Ctrl + [ 常用命令：
:w → 存储文件 :q → 关闭文件（未存储会提示先保存） :wq → 存储并关闭文件 设置 Git用户设置git config --global user.name &#34;Allay&#34; git config --global user.email &#34;allay@qq.com&#34;检查配置：
git config --list配置保存在 ~/.gitconfig 文件中，可手动修改。
每个项目设置不同的作者针对特定的项目设置不同的作者，可以用&ndash;local 参数
git config --local user.name &#34;Andy&#34; git config --local user.email &#34;andy@qq.com&#34;local 设置：仅对该项目生效。
其他项目仍使用 global 设置。
设置缩写git config --global alias.co checkout git config --global alias.l &#34;log --oneline --graph&#34;示例：
git co = git checkout git l = git log --oneline --graph 这些 alias 配置可在 ~/.gitconfig 中修改。
  ]]></content></entry><entry><title>3.4节 强制类型转换</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0304--%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  值类型转换的基本概念定义与区分： 显式类型转换：主动将值从一种类型转换为另一种（如String(123)）。 隐式强制类型转换：操作中自动发生的类型转换（如1 + &amp;quot;2&amp;quot;）。 特性：JS 强制类型转换始终返回标量基本类型值，对象封装（如new Number(1)）不算严格意义上的强制转换。 与其他语言的差异： 静态类型语言的 “类型转换” 发生在编译阶段； 动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。 抽象值操作（内部使用的转换规则）抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括ToString、ToNumber、ToBoolean。
ToString（非字符串 → 字符串）基本类型转换规则：
null → &amp;quot;null&amp;quot;；undefined → &amp;quot;undefined&amp;quot;；true → &amp;quot;true&amp;quot;；false → &amp;quot;false&amp;quot;。 数字：常规数字直接转换（如123→&amp;quot;123&amp;quot;），极小 / 极大数字用指数形式（如1e-20、1e+20）。 对象 / 数组转换：
普通对象：默认返回内部属性[[Class]]值（如&amp;quot;[object Object]&amp;quot;）；若自定义toString()方法，则调用该方法并使用其返回值。 数组：toString()将所有元素字符串化后用,连接（如[1, 2, 3].toString() → &amp;quot;1,2,3&amp;quot;）。 JSON.stringify () 的特殊处理：
作用：将 JSON 对象序列化为字符串，遵循ToString规则但结果必为字符串。
安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ undefined、function 、symbol、循环引用对象）的处理：
对象中遇到非安全值：自动忽略。 数组中遇到非安全值：返回null（保持数组长度）。 循环引用对象：直接报错。 toJSON()方法：若对象定义了toJSON()，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：toJSON()应返回安全值，而非字符串）。
可选参数：
replacer（数组 / 函 …  ]]></content></entry><entry><title>3.1节 类型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0301--%E7%B1%BB%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内置类型概述定义：类型是值的内部特征，决定值的行为，以区分于其他值。 分类： 基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。 对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。 typeof 运算符作用：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。 特殊情况： null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理） 检测 null 值类型的复合条件：!a &amp;&amp; typeof a === 'object'（因 null 是假值，且是唯一用 typeof 检测返回 &lsquo;object&rsquo; 的基本类型值）。 对象子类型函数（function）： 是 object 的子类型，属于可调用对象。 具有内部属性 [[Call]]，使其可被调用。 可拥有属性，如 length 属性表示其声明的参数个数。 typeof function返回&quot;function&quot;，是历史遗留的特殊处理 数组： 是 object 的子类型。 元素按数字顺序索引，length 属性表示元素个数。 值和类型的特性变量与类型的关系： JS 中变量无类型，只有值有类型。 变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。 对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。 undefined 与 undeclared 的区别： undefined：变量已在作用域中声明但未赋值。 undeclared：变量未在作用域中声明过。 typeof 的安全防范机制： 对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。 应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。 其他安全检查方法： 检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。 依赖注入设计模式：将依赖通过参数显式传递到函数中。   ]]></content></entry><entry><title>3.2节 值</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0302--%E5%80%BC/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  数组特性： 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。 使用delete运算符删除单元后，位置变为空白单元，数组length属性不变。 稀疏数组： 指含有空白 / 空缺单元的数组，空白单元值为undefined，但与显式赋值为undefined的单元有区别（如[,,]与[undefined, undefined]行为不同）。 索引与属性： 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在length内，length只计算数字索引的最大整数 + 1）。 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。 类数组转换： 类数组特征：有length和数字索引，但无数组方法（如arguments、DOM 集合NodeList） 可转换为真正的数组，常用方法： Array.prototype.slice.call(类数组) ES6 的Array.from(类数组) 扩展运算符（需类数组为可迭代对象） 字符串与数组的区别： 是类数组（有length、indexOf()、concat()等），但并非字符数组。 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。 数组方法的借用： 可借用数组的非变更方法（如Array.prototype.indexOf.call(str, &#39;a&#39;)）处理字符串。 不可借用数组的变更方法（因字符串不可变），需先通过split(&#39;&#39;)转为数组，处理后再用join(&#39;&#39;)转回字符串。 数字类型与格式：
JS 只有一种数值类型number（双精度浮点数），包含整数（如42.0）和带小数的十进制数。 字面量表示： 十进制：可省略小数点前的 0（.42）或后多余的 0（42.）。 特殊格式：指数形式（1e3）、二进制（0b1010）、八进制（0o12）、十六进制（0xa）。 显示规则：
大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同toExponential()）。 Number 对象方法：
toFixed(n)：指定小数部分显示位数，不足用 0 补齐（返回字符串）。 toPrecision(n)：指定有效数位的显示位数。 注意：数字字面量调用方法时，需避免.被误判为数字一部分（如42..toFixed(2)或42 …  ]]></content></entry><entry><title>3.3节 原生函数</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%AD%E5%8D%B7/0303--%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内部属性 [[Class]]基本概念： 内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。 属性特征： 所有typeof返回值为object的对象都包含内部属性[[Class]]，该属性无法直接访问。 通常通过Object.prototype.toString()方法查看[[Class]]的值。 对应关系： 多数情况下，对象的[[Class]]属性值与创建该对象的内建原生构造函数相对应。 特殊情况：虽然不存在Null()和undefined()原生构造函数，但null和undefined的[[Class]]属性值分别为&#39;Null&#39;和&#39;Undefined&#39;。 封装对象包装自动包装机制： 基本类型值（如string、number等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。 手动封装与拆封： 手动封装：使用Object()函数（不带new关键字）可将基本类型值封装为对象。 拆封：通过valueOf()方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。 使用建议：除非必要，应避免使用构造函数创建封装对象。 原生函数作为构造函数Array()：
不带new关键字时会被自动补全（等效于new Array()）。 仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。 替代方案：ES6 的Array.of()（无歧义，始终将参数作为元素） 稀疏数组：包含至少一个空单元的数组，可通过以下方式创建： 设置length属性值超过实际单元数； 使用delete删除数组单元。 可通过Array.apply(null, {length: 3})创建包含undefined单元（非空单元）的数组。 不建议使用的构造函数： 除非特殊需求，尽量避免使用Object()、Function()、RegExp()作为构造函数。
Date()：
必须使用new Date()创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。 时间戳获取：getTime()方法或Date.now()（ES5+）可获取 Unix 时间戳。 特殊情况：不带new关键字调用Date()时，返回当前日期的字符串值（格式无统一规范）。 Error()： 带或不带new关键字均可使用。  …  ]]></content></entry><entry><title>2.4节 原型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0204--%E5%8E%9F%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  [[Prototype]] 基础定义：对象的特殊内置属性，本质是对其他对象的引用 默认值：几乎所有对象创建时，[[Prototype]] 都会被赋予非空值 [[Get]] 操作逻辑（属性查找）： 优先检查对象本身是否有目标属性，有则使用； 若无，沿 [[Prototype]] 链向上查找； 直至找到属性或遍历完整条原型链，未找到则返回 undefined 原型链终点：Object.prototype地位：所有普通对象的 [[Prototype]] 链最终都会指向 Object.prototype 作用：包含 JS 通用功能（如 toString()、hasOwnProperty() 等），供所有普通对象继承 核心通用方法方法 作用 示例 toString() 返回对象的字符串表示（默认&amp;quot;[object Object]&amp;quot;） ({}).toString() → &amp;quot;[object Object]&amp;quot; hasOwnProperty(key) 检查属性是否为对象自身所有（不含原型链） cat.hasOwnProperty(&amp;quot;eat&amp;quot;) → false（eat 在原型上） isPrototypeOf(obj) 检查当前对象是否在obj的原型链上 animal.isPrototypeOf(cat) → true valueOf() 返回对象的原始值（默认返回对象本身） (new Number(123)).valueOf() → 123 属性设置与屏蔽（myObject.foo = &#39;bar&#39;）基础逻辑若 myObject 本身有 foo 普通数据属性：仅修改属性值； 若 foo 不在 myObject 中：沿 [[Prototype]] 链查找，未找到则直接在 myObject 上添加 foo； 若 foo 既在 myObject 中，也在原型链上层：myObject 的 foo 屏蔽原型链上层的 foo（优先取最底层属性）。 特殊场景（foo 在原型链上层）原型链上层 foo 特性 结果 普通数据属性（非只读） 在 myObject 上添加 foo 屏蔽属性 只读数据属性（writable: false） 非严格模式：忽略赋值；严格模式：报错（无法添加屏蔽属性或修改原属性） 访问描述符（含 setter） 调 …  ]]></content></entry><entry><title>2.5节 行为委托和class</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0205--%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98%E5%92%8Cclass/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  对象关联风格的核心特性与设计原则状态存储原则核心规则：状态（数据属性）应保存在委托者对象上，而非委托目标（原型链上层对象）。 避免委托目标状态被多个委托者共享，导致数据污染或不可预期的修改。 方法命名原则核心规则：尽量避免在 [[Prototype]] 链不同级别使用相同命名的方法（与类风格的“重写”逻辑相反）。 设计建议：使用描述性方法名（需体现对象行为类型），降低命名冲突风险，提升代码可理解性与可维护性。 委托本质委托行为的核心：当对象自身找不到属性/方法时，会将请求委托给 [[Prototype]] 关联的对象（沿原型链向上查找）。 委托限制禁止循环委托：无法在两个及以上对象间创建互相委托（如 A 关联 B、B 关联 A），会触发错误。 思维模型与灵活性维度 特点 思维模型 仅关注对象之间的关联关系，不强调实体及实体间的层级（如父类-子类） 创建与初始化分离 支持“创建对象”与“初始化状态”分步执行，更符合关注分离原则，灵活性更高 对比类风格 类风格通常强制“构造+初始化”合并为一步（如 new 调用构造函数时同步初始化） class 语法特点（ES6+）多态实现支持通过 super() 实现相对多态：子类方法可通过 super 引用原型链上层的同名方法（模拟类继承中的“调用父类方法”）。 声明限制仅能声明方法：class 字面量语法中，无法直接声明数据属性（需在构造函数 constructor 中通过 this.属性名 定义）。 示例：class A { foo() {}; // 允许；bar = 1; // 类字段语法（ESNext，非标准字面量声明） } 扩展能力支持通过 extends 关键字自然扩展对象类型，包括内置对象类型（如 class MyArray extends Array {}），模拟类继承的“子类扩展父类”逻辑。 本质与局限性维度 特点 本质 是 [[Prototype]] 机制的语法糖，并非真正实现面向类语言的“类”（无类实例化复制、无类级别的类型约束） super 绑定方式 静态绑定：super 指向的原型链上层对象在 class 定义时确定，无法动态修改（与类风格的动态关联不同） 动态修改难度 class 定义后，难以对其原型链、方法等进行动态调整（如修改 prototype 指向、新增/删除方法），灵活性低于原生对象关联   </content></entry><entry><title>2.3节 混合对象类</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0203--%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  类理论核心概念本质：一种代码组织结构形式，用于对真实世界问题领域建模 核心思想：数据与操作数据的行为紧密关联（数据结构的封装） 分类：通过类对数据结构分类，将特定数据结构视为更广泛定义的特例 多态：父类通用行为可被子类重写，子类可通过相对引用访问父类基础行为 设计建议：父类与子类使用相同方法名表示特定行为，便于子类重写 类的机制类的本质：蓝图或模板，定义对象的结构和行为 实例：根据类创建的具体对象，包含类中描述的所有特性的副本 交互方式：可在实例上直接调用方法和访问共有属性 类与实例关系：可判断实例所属的类，但通常不通过实例直接操作类 实例化机制：通过复制类的定义创建实例对象 构造函数作用：初始化实例所需的所有信息 特性：属于类，通常与类同名 调用方式：大多需要用 new 关键字调用，指示引擎创建新的类实例 类的继承定义：子类继承父类的行为，是独立于父类的全新类 继承内容：包含父类行为的原始副本 扩展能力：可重写继承的行为或定义新行为 多态特性相对多态：
方法可引用继承层次中高层的方法 通过 super 等相对引用访问父类（超类）方法 子类构造函数中可通过 super 调用父类构造函数 方法重写：
同一方法名可在继承链不同层次多次定义 调用方法时自动选择对应实例所属类的定义 子类重写方法不影响父类中的原方法，两者相互独立 实现基础：类的继承本质是行为的复制
JavaScript 中的特殊性无类机制：JS 中只有对象，没有可被实例化的类 无自动复制：对象不会被复制到其他对象 关联关系：对象之间通过原型链建立关联，而非类继承的复制关系 继承模拟：通过原型链实现类似类继承的功能，但本质不同   </content></entry><entry><title>2.2节 对象</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0202--%E5%AF%B9%E8%B1%A1/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  对象定义形式声明文字形式：{ key1: value1, key2: value2 } 可一次性定义多个键值对，简洁高效 构造形式：new Object() 需逐个添加属性（obj.key = value） 与文字形式生成的对象功能一致 JS 主要类型与对象子类型六种主要类型基本类型：string、number、boolean、null、undefined 复杂类型：object（所有对象的基类） 特殊对象子类型函数：可调用的对象，一等公民（可像普通对象操作） 数组：有序数值下标存储的对象，含额外数组方法 内置对象（构造函数）：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error 可构造对应子类型对象（如 new Array()） 语言会自动将字面量转换为内置对象（无需显式创建） 特殊说明null/undefined：无构造形式，仅字面量 Date：仅有构造形式（new Date()），无字面量 Object/Array/Function/RegExp：文字形式与构造形式均为对象，构造形式仅在需要额外选项时使用 Error：通常在抛出异常时自动创建，也可显式构造（new Error()） 对象内容与属性访问属性本质对象内容由属性（键值对）组成，存储的是属性名（指向值的指针） 属性名永远是字符串，非字符串类型会自动转换为字符串 属性访问方式. 语法（属性访问）：obj.key，要求属性名符合标识符规范 [&amp;quot;&amp;quot;] 语法（键访问）：obj[&amp;quot;key&amp;quot;]，支持任意 UTF-8/Unicode 字符串作为属性名，可动态构造键名 可计算属性名文字形式中用 [] 包裹表达式作为属性名：{ [expr]: value } 符号（Symbol）新基础类型，值不透明且唯一，通常作为属性名避免冲突 实际值在不同引擎中可能不同，一般使用其名称 属性与方法函数不属于对象，属性访问返回的函数与普通函数无区别（非“方法”） 本质是对函数对象的引用 数组特性支持 [] 访问，期望数值下标（非负整数） 是特殊对象，可添加命名属性（不影响 length） 建议：对象存键值对，数组存下标值对 若属性名类似数字，会自动转为数值下标 对象复制深拷贝（复制所有层级，嵌套对象独 …  ]]></content></entry><entry><title>2.1节 this</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0201--this/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  关于 thisthis 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件
this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
当一个函数被调用时，会创建一个活动记录（也称为执行上下文），这个记录会包含函数在哪里被调用，函数的调用方式，传入的参数等信息，this 就是这个记录的一个属性，会在函数执行的过程中用到
调用位置调用位置就是函数在代码中被调用的位置，在当前正在执行的函数的前一个调用中
调用栈：为了到达当前执行位置所调用的所有函数
绑定规则默认绑定：函数直接使用不带任何修饰的函数引用进行调用（独立函数调用），只能使用默认绑定，无法应用其他规则，非严格模式下，默认绑定绑定到全局对象，在严格模式下绑定到 undefined。
严格模式只在自执行函数内部生效。也就是说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。
隐式绑定：当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象，对象属性引用链中只有上一层或者说最后一层在调用位置中起作用
被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或 undefined 上，因为此时的函数可能是一个不带任何修饰的函数调用或者被当做参数传入函数形成了隐式赋值（间接引用）
显示绑定：所有函数都可以使用 call()和 apply()方法，它们的第一个参数是一个对象，接着在调用函数时将其绑定到 this
如果传入一个原始值来当做 this 的绑定对象，这个原始值会被转换成它的对象形式，这通常被称为装箱
硬绑定：一种显式的强制绑定
function foo() { console.log(this.a); } var obj = { a: 2, }; var bar = function () { foo.call(obj); };可以创建一个包裹函数，负责接收参数并返回值
var bar = function () { return foo.apply(obj, arguments); };另一种是创建一个可以重复使用的辅助函数
function bind(fn, obj) { return function () { return fn.apply(obj, …  </content></entry><entry><title>附录 作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/%E9%99%84%E5%BD%95-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  动态作用域核心逻辑：不关心函数“在哪里声明”，只关心函数“从哪里调用”——作用域链基于调用栈（运行时确定），而非代码的嵌套结构（定义时确定）。 与 JS 的关系：JS 本身没有动态作用域，只有词法作用域；但this机制的行为类似动态作用域（this指向依赖调用位置，而非定义位置）。 关键区别： 词法作用域：定义时确定（关注“函数在哪写的”）； 动态作用域：运行时确定（关注“函数在哪调用的”）。 块作用域的替代方案（ES6 前）ES6 前无原生块作用域（var声明为函数/全局作用域），可利用**catch分句**实现块作用域——catch的参数仅在catch块内有效，外部无法访问：
{ try { throw undefined; // 主动抛出错误，进入catch块 } catch (a) { // a的作用域仅在catch块内 a = 2; console.log(a); // 输出 2（块内可访问） } } console.log(a); // 报错：a is not defined（块外不可访问） this词法：箭头函数的this绑定核心特性：箭头函数不遵循普通函数的this绑定规则（如调用位置、bind/call/apply、对象方法绑定等），而是将this绑定为当前词法作用域的this（定义时确定，与外层函数的this一致）。 示例解析：
原代码中，setTimeout的箭头函数this继承自外层coolFn的this（即obj对象）： var obj = { count: 0, cool: function coolFn() { if (this.count &lt; 1) { // 箭头函数this = 外层coolFn的this（obj） setTimeout(() =&gt; { this.count++; // 相当于 obj.count++ }); } }, };等价写法（模拟箭头函数的this绑定效果）： 方式 1：用self保存外层this（ES6 前常用）： var obj = { count: 0, cool: function coolFn() { var self = this; // 保存coolFn的this（obj） if (self.count &lt; 1) { setTimeout(function timer() { self.count++; // 用self访问obj }); } }, };方式 2：用bind(this)绑定普通函数this： var obj = { count: 0, cool: function coolFn() { if (this.count &lt; 1) { setTimeout( function timer() { this.count++; }.bind(this), 100 ); // 绑定this为coolFn的this（obj） } }, };  ]]></content></entry><entry><title>1.4节 提升</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0104--%E6%8F%90%E5%8D%87/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  变量和函数声明的提升机制提升的本质： 引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。
本质：并非字面意义的 “代码移动”，而是引擎在编译时将声明信息存入作用域的 “标识符表”，执行时优先从表中查找，而非按代码顺序。
作用域范围：每个作用域（全局、函数、块作用域）都会独立进行提升操作。
let/const并非 “不提升”，而是提升后进入 “暂时性死区”（从作用域顶部到声明语句之间的区域），禁止访问，避免var的 “声明前使用为undefined” 的反直觉行为。
函数声明与变量声明的提升优先级函数声明优先： 规则 1：函数声明先提升（完整提升：声明 + 函数体），变量声明后提升（仅声明，重复声明会被忽略）； 规则 2：若变量后续有赋值操作，赋值会覆盖函数声明（执行阶段生效）。 函数表达式不提升： 函数表达式（如var fn = function() {}）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到undefined。 具名函数表达式（如var fn = function named() {}）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。 特殊情况与注意事项重复声明的覆盖：变量重复声明（如var a = 1; var a = 2）会被忽略前序，保留最后一次赋值； 函数重复声明（如function a() {}; function a() {}）后序声明会覆盖前序。 变量赋值（执行阶段）会覆盖函数声明（编译阶段提升），但函数声明不会覆盖变量赋值； 块级函数声明的问题：ES6 前无块级作用域，函数在块内（如if/for）声明时，不同 JS 环境（浏览器 / Node.js）处理差异极大，易导致逻辑混乱：
非严格模式：部分浏览器（如 Chrome）会将块内函数声明提升到所在函数 / 全局作用域顶部（而非块级）； 严格模式：块内函数声明被限制在块级作用域内（类似let），但仍不推荐使用； 最佳实践：避免在块内声明函数，如需在块内定义函数，用函数表达式（如if (true) { const fn = function() {}; }），行为更可控。   </content></entry><entry><title>1.5节 作用域闭包</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0105--%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  闭包的核心定义与本质定义：即使函数在词法作用域之外执行，仍能通过闭包访问原作用域的变量，且原作用域不会被垃圾回收机制销毁。 底层逻辑：函数创建时会记录其词法作用域（作用域链），当函数被传递到词法作用域之外执行时，引擎会通过函数的 “[[Scope]]” 内部属性，持续引用原作用域，阻止其被回收； 常见场景：只要使用回调函数（如定时器、事件监听器、Ajax 请求、异步任务等），本质都是在利用闭包。 循环与闭包：解决变量共享问题循环变量共享的痛点（var 声明）用 var 声明循环变量时，变量作用域为全局 / 函数级（非块级），所有迭代的回调函数共享同一个变量，导致执行时获取的是变量最终值（而非迭代时的值）：
// 问题代码：输出 5、5、5、5（而非 1、2、3、4） for (var i = 1; i &amp;amp;lt; 5; i++) { setTimeout(function () { console.log(i); }, i * 1000); }解决方案IIFE（立即执行函数表达式） 通过 IIFE 为每个迭代创建独立的词法作用域，将当前迭代的 i 作为参数传入，使回调函数闭包捕获该作用域的变量：
// 正确输出 1、2、3、4 for (var i = 1; i &amp;amp;lt; 5; i++) { (function (j) { // j 是每个迭代的独立变量 setTimeout(function () { console.log(j); }, j * 1000); })(i); // 立即执行，传入当前 i 的值 }let 声明的特殊行为 let 支持块级作用域，且在 for 循环头部声明时，会为每个迭代单独创建变量实例（每次迭代用前一次迭代的变量值初始化），无需额外闭包即可解决共享问题：
// 正确输出 1、2、3、4 for (let i = 1; i &amp;amp;lt; 5; i++) { setTimeout(function () { console.log(i); }, i * 1000); }let 解决该问题的本质是 “块作用域 + 迭代变量独立实例”，而非闭包，但底层仍依赖作用域机制（可理解为引擎自动为每个迭代创建了闭包）。
模块模式：基于闭包的封装模块模式的核心条件需满足两个必要条件，本质是利用闭包实现 “私有状态 + 公共 API” 的封 …  </content></entry><entry><title>1.2节 词法作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0102--%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  词法作用域的核心特性定义与本质： 词法作用域是 JS 作用域的核心机制，由代码书写时的声明位置决定，与执行时的调用位置无关，是 “静态作用域” 的一种。 查找规则： 作用域查找从最内部作用域开始，逐级向外（向上）进行，直到找到第一个匹配的标识符后停止（即 “就近匹配”）。 仅查找一级标识符（如a，不会自动查找对象属性链如obj.a）。 遮蔽效应： 在多层嵌套作用域中，内层作用域的标识符可遮蔽外层同名标识符（如内层var a = 1会遮蔽外层的var a = 2）。 全局变量的特殊访问： 全局变量会成为全局对象（如浏览器中的window）的属性，可通过window.a访问被内层同名变量遮蔽的全局变量。 函数的词法作用域： 函数的词法作用域仅由其声明时所处的位置决定，与调用位置、调用方式无关。 欺骗词法作用域的方式eval 函数功能：接收字符串参数，将其视为代码片段插入到当前位置执行，仿佛该代码在书写时就存在于此。 对作用域的影响： 默认情况下，若eval中的代码包含变量 / 函数声明，会修改其所处的词法作用域（新增或覆盖标识符）。 严格模式下，eval有独立的词法作用域，内部声明不会影响外部作用域。 常见用途：执行动态生成的代码（如拼接字符串形成的逻辑）。 with 语句功能：作为访问对象多个属性的快捷方式，避免重复书写对象名（如with(obj) { a = 1; b = 2 }等效于obj.a = 1; obj.b = 2）。 对作用域的影响： 将传入的对象视为一个临时的词法作用域，对象的属性被当作该作用域中的标识符。 块内的var声明不会被限制在with块中，而是泄漏到外层函数作用域。 本质：根据传入对象 “凭空创建” 全新的词法作用域，与eval修改现有作用域的行为不同。 副作用与风险性能问题： eval和with会破坏 JS 引擎的词法作用域静态分析（无法提前确定变量查找规则），导致无法优化代码执行，显著降低运行效率。 代码可读性与维护性： 动态修改作用域会使变量的查找逻辑变得模糊，增加调试难度，不符合词法作用域的设计初衷。 严格模式限制： 严格模式下eval的作用域被隔离，with被完全禁止（直接抛出错误），进一步体现了对 “欺骗词法” 行为的不推荐。   </content></entry><entry><title>1.3节 函数作用域和块作用域</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0103--%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  函数作用域的核心特性定义与复用：函数内部声明的变量，可在整个函数范围内（包括嵌套作用域）使用和复用。 隐藏内部实现： 通过函数作用域封装变量和函数，遵循最小特权原则（仅暴露必要内容，隐藏细节），减少命名冲突。 第三方库通常通过命名空间对象（将功能作为对象属性暴露）或模块管理器（避免全局作用域污染）防止冲突。 函数声明与表达式的区别区分方法： 若function是声明的第一个词，则为函数声明；否则为函数表达式。 关键差异： 函数声明的名称标识符绑定在所在作用域中； 函数表达式的名称标识符绑定在自身函数内部（外部不可直接访问）。 匿名函数表达式的缺点： 栈追踪无有意义名称，调试困难； 无法通过名称自引用（依赖arguments.callee，已过时）； 降低代码可读性。 最佳实践：始终为函数表达式命名（如const fn = function namedFn() {}）。 立即执行函数表达式（IIFE）定义：函数表达式被声明后立即执行（如(function() { ... })()）。
常见用途：
传递参数，隔离作用域（避免污染外部）； 确保undefined标识符的准确性（通过参数占位，如(function(undef) { ... })()）； 倒置代码执行顺序（将主逻辑作为参数传递给 IIFE）。 块作用域的特性与实现核心作用：将变量本地化，扩展最小授权原则，从函数级隐藏扩展到块级隐藏。 块作用域的优势：变量声明靠近使用位置，减少作用域污染，优化变量生命周期，避免提升带来的意外行为。 实现方式： with 语句：为对象创建临时块作用域（仅在with内部有效）； try/catch：catch分句创建块作用域，内部变量仅在catch中有效； let 关键字： 将变量绑定到所在块作用域（如if、for块）； 无提升特性（声明前访问会报错）； for循环中，let会将变量重新绑定到每个迭代（确保迭代值独立）。 const 关键字： 同let的块作用域特性，但值为常量（修改会报错），声明时必须赋值。 原书中 P34 最上方 “点击事件因闭包导致变量问题” 的描述有误：实际是var声明的变量属于函数 / 全局作用域，生命周期长，导致循环中共享同一变量；而let通过块作用域解决此问题。   </content></entry><entry><title>1.1节 作用域是什么</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js-%E4%B8%8A%E5%8D%B7/0101--%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  程序状态与变量程序状态通过变量的存储与访问实现：变量是状态的载体，作用域则决定 “变量在何处可被访问”，两者共同支撑程序的动态执行。 作用域的本质作用域是一套管理变量的规则体系，核心解决两个问题： 变量声明的存储位置：编译器在编译阶段根据作用域规则，确定变量属于哪个作用域（全局 / 函数 / 块级）。 变量访问的查找逻辑：引擎在执行阶段根据作用域规则，从当前作用域向上逐级查找变量。 编译原理传统编译三阶段：分词 / 词法分析：将源代码字符串分解为有意义的词法单元（如关键字、变量名、运算符等）。 解析 / 语法分析：将词法单元流转换为抽象语法树（AST），AST 是体现程序语法结构的嵌套树状结构。 代码生成：将 AST 转换为可执行代码。 JavaScript 编译特点：JS 是 “即时编译（JIT）” 语言，编译不提前完成，而是在代码执行前的微秒级时间内完成，且编译与执行交替进行（如函数执行前先编译函数内部代码）。
作用域的核心角色引擎：统筹全局，负责代码的编译触发和执行，主导变量的查找与赋值。 编译器：负责语法校验、AST 生成、代码生成，在编译阶段处理变量声明，并告知作用域 “需存储该变量”。 作用域：相当于 “变量仓库”，按规则存储变量，响应引擎的查找请求 变量声明与赋值过程（以var a = 2为例）var a = 2 并非 “一次性操作”，而是编译器声明变量与引擎执行赋值两个独立步骤的结合，中间通过作用域衔接：
阶段 1：编译器处理变量声明（编译期）步骤 1：编译器在当前作用域中 “查询” 是否存在名为 a 的变量。 若存在：忽略当前声明（var 允许重复声明，后续声明会覆盖前序声明的变量，但不会重新初始化）； 若不存在：要求作用域在当前 “变量集合” 中新增一个名为 a 的变量（此时 a 仅声明，值为 undefined）。 阶段 2：引擎处理变量赋值（执行期）步骤 1：引擎向当前作用域发起LHS 查询（查找变量的 “容器本身”，用于赋值），询问 “是否存在名为 a 的变量”。 步骤 2：作用域查找结果： 找到 a：引擎将 2 赋值给 a； 未找到 a： 非严格模式：引擎自动在全局作用域创建名为 a 的变量，再赋值 2（变量泄露到全局）； 严格模式（&amp;amp;quot;use strict&amp;amp;quot;）：直接抛出 ReferenceError（ …  </content></entry><entry><title>8.4 渲染机制</title><url>/post/vue3/0804-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  虚拟 DOM虚拟 DOM (Virtual DOM, VDOM)：一种编程概念，将目标 UI 用数据结构“虚拟”表示，保存在内存中，并与真实 DOM 保持同步。
虚拟 DOM 不是具体技术，而是一种模式，没有标准实现。
挂载 (mount)：运行时渲染器遍历虚拟 DOM 树，构建真实 DOM 树。
更新 (patch / diffing / reconciliation)：比较两份虚拟 DOM 树的差异，并将变化应用到真实 DOM。
主要收益：
声明式、灵活地创建、检查和组合 UI 结构。 具体 DOM 操作交由渲染器处理。 渲染管线Vue 组件挂载时的步骤：
编译 Vue 模板被编译为渲染函数（返回虚拟 DOM 树的函数）。 可通过构建步骤提前完成，也可使用运行时编译器即时完成。 挂载 渲染器调用渲染函数，遍历虚拟 DOM 树并创建真实 DOM 节点。 作为响应式副作用执行，追踪所有响应式依赖。 更新 当依赖变化时，副作用重新运行，创建新的虚拟 DOM 树。 渲染器比较新旧树，应用必要更新到真实 DOM。 模板 vs. 渲染函数模板：预编译为虚拟 DOM 渲染函数。
渲染函数：直接使用 JavaScript 手写 vnode。
渲染函数的灵活性：更适合处理高度动态逻辑。
模板的优势：
贴近 HTML
更易重用 HTML 片段。 提供更好的可访问性。 更方便使用 CSS。 设计师更容易理解和修改。 确定语法
模板可被静态分析。 编译器可进行编译时优化，提升虚拟 DOM 性能。 模板对大多数场景够用且高效；渲染函数主要用于可重用组件的动态渲染逻辑。
带编译时信息的虚拟 DOMReact 等纯运行时实现的问题
更新算法无法预知新树结构。 每次都需遍历整棵树并比较 props。 即使未变部分，每次也会创建新 vnode。 带来 性能开销 和 内存压力。 Vue 的优化
框架同时控制 编译器 和 运行时。 编译器静态分析模板，在生成代码中添加标记。 运行时可基于标记走捷径。 保留使用渲染函数的能力。 称为 带编译时信息的虚拟 DOM。 缓存静态内容模板中无动态绑定的部分：
首次渲染后缓存 vnode。 后续渲染直接使用缓存，跳过比对。 多个连续静态元素：
压缩为 静态 vnode（纯 HTML 字符串）。 挂载时通过 innerHTML 渲染。 更新类型标记编译 …  </content></entry><entry><title>8.5 渲染函数和 JSX</title><url>/post/vue3/0805-%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E5%92%8Cjsx/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  在绝大多数情况下，Vue 推荐使用模板语法来创建应用。 然而在某些需要完整 JavaScript 编程能力的场景下，渲染函数就派上用场了。
基本用法创建 VnodesVue 提供了 h() 函数用于创建 vnodes。
h 是 hyperscript 的简称，意为“能生成 HTML 的 JavaScript”。更准确的名称是 createVNode()，但 h() 更简洁。
h() 的使用方式：
// 类型必填，其他参数可选 h(&amp;#39;div&amp;#39;) h(&amp;#39;div&amp;#39;, { id: &amp;#39;foo&amp;#39; }) // attribute 和 property 都能在 prop 中书写 // Vue 会自动将它们分配到正确的位置 h(&amp;#39;div&amp;#39;, { class: &amp;#39;bar&amp;#39;, innerHTML: &amp;#39;hello&amp;#39; }) // 像 `.prop` 和 `.attr` 这样的的属性修饰符 // 可以分别通过 `.` 和 `^` 前缀来添加 h(&amp;#39;div&amp;#39;, { &amp;#39;.name&amp;#39;: &amp;#39;some-name&amp;#39;, &amp;#39;^width&amp;#39;: &amp;#39;100&amp;#39; }) // 类与样式可以用数组或对象 h(&amp;#39;div&amp;#39;, { class: [foo, { bar }], style: { color: &amp;#39;red&amp;#39; } }) // 事件监听器应以 onXxx 的形式书写 h(&amp;#39;div&amp;#39;, { onClick: () =&amp;gt; {} }) // children 可以是字符串 h(&amp;#39;div&amp;#39;, { id: &amp;#39;foo&amp;#39; }, &amp;#39;hello&amp;#39;) // 没有 props 可省略 h(&amp;#39;div&amp;#39;, &amp;#39;hello&amp;#39;) h(&amp;#39;div&amp;#39;, [h(&amp;#39;span&amp;#39;, &amp;#39;hello&amp;#39;)]) // children 数组可包含 vnode 与字符串 h(&amp;#39;div&amp;#39;, [&amp;#39;hello&amp;#39;, h(&amp;#39;span&amp;#39;, &amp;#39;hello&amp;#39;)]) …  ]]></content></entry><entry><title>8.3 深入响应式系统</title><url>/post/vue3/0803-%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  什么是响应性响应性是一种可以使我们声明式地处理变化的编程范式。
let A2; function update() { A2 = A0 + A1; } whenDepsChange(update);核心术语作用 (effect)：update() 函数会更改程序状态，因此称为副作用或作用。 依赖 (dependency)：A0 和 A1 被用来执行作用，因此它们是依赖。 订阅者 (subscriber)：依赖的订阅者即作用。 我们需要一个魔法函数，能够在 A0 或 A1 (这两个依赖) 变化时调用 update() (产生作用)。
魔法函数 whenDepsChange()任务如下：
当变量被读取时进行追踪。 如果变量在当前副作用中被读取，则将副作用设为该变量的订阅者。 当变量变化时，通知所有订阅副作用重新执行。 Vue 中的响应性是如何工作的无法追踪局部变量的读写。可以追踪对象属性的读写。
两种方式Vue 2：getter / setter（为支持旧浏览器）。 Vue 3：Proxy（主要），仅在 ref 中使用 getter / setter。 function reactive(obj) { return new Proxy(obj, { get(target, key) { track(target, key); return target[key]; }, set(target, key, value) { target[key] = value; trigger(target, key); }, }); } function ref(value) { const refObject = { get value() { track(refObject, &amp;#34;value&amp;#34;); return value; }, set value(newValue) { value = newValue; trigger(refObject, &amp;#34;value&amp;#34;); }, }; return refObject; }reactive() 的局限性属性赋值/解构到本地变量后，访问不再响应式。 从 reactive() 返回的代理与原对象不同，可通过 === 区分。 依赖追踪与触发track()：
检查是否有活跃副作用。 若有，将副作用 …  ]]></content></entry><entry><title>8.1 使用 Vue 的多种方式</title><url>/post/vue3/0801-%E4%BD%BF%E7%94%A8vue%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  独立脚本Vue 可以以一个单独 JS 文件的形式使用，无需构建步骤。
适用场景：
后端框架已渲染大部分 HTML 前端逻辑不复杂 在这些场景中，Vue 可以看作一个更声明式的 jQuery 替代品。
另一个适用版本：petite-vue
为渐进式增强已有 HTML 优化 功能更精简 十分轻量 作为 Web Component 嵌入Vue 可用于构建标准的 Web Component。
这些组件能嵌入到任何 HTML 页面中，不论其如何渲染。
优点：
无需顾虑最终使用场景 可嵌入旧应用、静态 HTML，或其他框架构建的应用 单页面应用 (SPA)应用特征：
需要丰富交互性 较深会话 复杂状态逻辑 架构：
Vue 控制整个页面 处理数据抓取 页面切换无需重新加载 这种应用称为 单页应用 (SPA)。
Vue 提供核心库和工具链支持，包括：
客户端路由 极快的构建工具 IDE 支持 浏览器开发工具 TypeScript 支持 测试工具 与后端的关系
SPA 一般要求后端提供 API 数据接口。 也可结合 Inertia.js 使用 → 保留服务端开发模型同时获得 SPA 益处。 全栈 / SSR纯客户端 SPA 在首屏加载和 SEO 上存在显著问题。浏览器先收到空 HTML，需等待 JavaScript 才渲染内容。
解决方案：
Vue 提供 API，将应用在服务端渲染为 HTML 字符串。 服务器直接返回渲染好的 HTML。 用户可在 JavaScript 下载前看到内容。 客户端随后对应用进行激活 (hydrate) → 重获交互性。 服务端渲染 (SSR) 的优势：极大改善 Web 核心指标性能，如 最大内容绘制 (LCP)。
相关框架：NuxtJS → 基于 Vue 的全栈框架。
JAMStack / SSG若数据是静态的，可提前完成服务端渲染。整个应用预渲染为 HTML → 部署为静态文件。
优点：
性能提升 部署更容易（无需请求时动态渲染） Vue 仍可通过激活在客户端提供交互。这种技术称为 静态站点生成 (SSG)，也称 JAMStack。
SSG 有两种风格：
单页 SSG 初始加载后激活为 SPA 成本：更多前期 JS 加载和激活 好处：后续导航更快（部分更新页面内容） 适用场景：重交互、深会话，或需要持久化状态/元素 多页 SSG 每次导航加载新页面 优点：JS 最少，甚至可不需要 JS 一些框架（如 Astro）支持“部分激活” → 静态 HTML 中通过 Vue 组件创建交互孤岛 相关工具：
VitePress（Vue 官方维护的 SSG） NuxtJS → 同时支持 SSR 与 SSG Web 之外&amp;hellip;Vue 不局限于浏览器，还可用于：
Electron / Wails → 桌面应用 Ionic Vue → 移动端应用 Quasar / Tauri → 同一代码同时开发桌面和移动应用 TresJS → 构建 3D WebGL 体验 Vue 的自定义渲染 API → 构建自定义渲染器（如 终端命令行）   </content></entry><entry><title>8.2 组合式 API 常见问答</title><url>/post/vue3/0802-%E7%BB%84%E5%90%88%E5%BC%8F-api-%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  什么是组合式 API组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。
它涵盖以下方面：
响应式 API：如 ref()、reactive()，用于创建响应式状态、计算属性和侦听器。 生命周期钩子：如 onMounted()、onUnmounted()，用于在组件生命周期阶段添加逻辑。 依赖注入：如 provide()、inject()，结合响应式 API 使用 Vue 的依赖注入系统。 在 Vue 3 中，组合式 API 通常配合 &amp;lt;script setup&amp;gt; 语法使用。
组合式 API 并不是函数式编程：
组合式 API 基于 Vue 的响应性系统（数据可变、细粒度）。 函数式编程通常强调数据不可变。 为什么要有组合式 API更好的逻辑复用通过 组合函数 实现简洁高效的逻辑复用。
解决了 mixins 的缺陷。
更灵活的代码组织选项式 API 的限制：
多个逻辑关注点被拆分到不同选项中，阅读和重构成本高。 抽取逻辑时需在多个位置寻找代码片段。 组合式 API 的改进：
相同逻辑关注点的代码被组织到一起。 方便移动到外部文件，降低重构成本。 更适合大型项目的长期维护。 更好的类型推导使用变量和函数，天然类型友好。
代码可享受完整的类型推导，减少类型标注需求。
TypeScript 和 JavaScript 用户都能受益。
更小的生产包体积&amp;lt;script setup&amp;gt; 与组合式 API 更高效，代码压缩更友好。
模板被编译为内联函数，与 &amp;lt;script setup&amp;gt; 代码同作用域。
不依赖 this，可直接访问变量。
优势：本地变量名可压缩，对象属性名不能。
与选项式 API 的关系组合式 API：
不限制代码放置位置，可运用 JavaScript 最佳实践。 提供更好的长期可维护性。 选项式 API：
允许“少思考”，但被锁定在固定模式中。 在大型项目中难以重构或提高质量。 组合式 API 是否覆盖了所有场景组合式 API 能覆盖所有状态逻辑需求。
仅需保留少量选项：props、emits、name、inheritAttrs。
可配置编译时标记移除选项式 API 代码，减小包体积。
可以在同一个组件中使用两种 API 吗可以在 …  ]]></content></entry><entry><title>7.3 无障碍访问</title><url>/post/vue3/0703-%E6%97%A0%E9%9A%9C%E7%A2%8D%E8%AE%BF%E9%97%AE/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Web 无障碍访问 (a11y) 指创建可供任何人使用的网站的做法——无论是：
身患某种障碍 通过慢速的网络连接访问 使用老旧或损坏的硬件 处于某种不方便的环境 示例：
视频添加字幕 → 帮助失聪、有听力障碍或身处嘈杂环境的用户 确保文字对比度足够 → 帮助低视力用户或在强光下使用手机的用户 跳过链接在每个页面顶部添加一个直接指向主内容区域的链接，用户可跳过重复内容。
通常放在 App.vue 顶部 → 成为所有页面的第一个可聚焦元素。
当路由改变时，应将焦点置回页面最开始（跳过链接之前）。
可通过调用 backToTop 模板引用的 focus 实现（假设使用 vue-router）。 内容结构目标：设计支持易于访问的实现。
包括：颜色对比度、字体选择、文本大小、语言、内容组织。
标题用户可通过标题在应用中导航。
实践建议：
按级别顺序嵌套标题：&lt;h1&gt; - &lt;h6&gt; 不要在章节内跳跃标题级别 使用实际标题标签，而不是仅用样式模拟标题 LandmarksLandmark 提供访问规划，辅助技术用户可直接导航至应用的各个部分，可使用 ARIA role 实现
语义化表单表单常用元素：&lt;form&gt;、&lt;label&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;button&gt;。
标签通常位于表格字段的顶部或左侧。
标签提供标签来描述所有表单控件用途，使用 for 与 id 关联
如果在 Chrome 开发者工具中检查这个元素，并打开 Elements 选项卡中的 Accessibility 选项卡，将看到输入是如何从标签中获取其名称的
aria-label：为 input 框配置无障碍访问名
aria-labelledby：
类似于 aria-label，但标签文本在屏幕上可见 通过 id 与其他元素配对，可链接多个 id aria-describedby：用法与 aria-labelledby 相同，提供用户可能需要的附加描述信息。可用于描述输入标准
占位符避免使用占位符：容易让用户困惑
缺陷：默认不符合 颜色对比度标准
解决：修改颜色，让其看起来像预填数据
建议：在表单外提供所有必要输入说明
用法说明确保用法说明正确链接到目标 input 框
方法：
在 aria-labelledby 内绑定多个 id 或通过 aria-describedby 将说明附加到 input 隐藏内容一般不建议隐藏标签，即使 input 有无障碍名称
特例：如果上下文足以说明输入功能，可隐藏视觉标签
aria-hidden=&quot;true&quot;对无障碍访问隐藏，但对视觉用户可见
注意：不要在可聚焦元素上使用
仅用于装饰性、重复或屏幕外内容
按钮在表单中使用按钮时，必须设置 type，防止误提交表单
也可以使用 &lt;input&gt; 元素创建按钮
  ]]></content></entry><entry><title>7.4 安全</title><url>/post/vue3/0704-%E5%AE%89%E5%85%A8/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  首要规则：不要使用无法信赖的模板使用 Vue 时最基本的安全规则就是：不要将无法信赖的内容作为组件模板。
使用无法信赖的模板 = 允许任意 JavaScript 在应用中执行。
在服务端渲染时执行这些代码 → 可能导致服务器被攻击。
原因：
Vue 模板会被编译成 JavaScript，模板内的表达式将作为渲染过程的一部分被执行。 由于全局执行环境的复杂性，Vue 无法在性能开销合理的前提下完全避免潜在的恶意代码执行。 直接方法：确保 Vue 模板始终可信，并完全由自己控制。
Vue 自身的安全机制HTML 内容无论使用模板还是渲染函数，内容都会自动转义。
转义通过 textContent 等浏览器原生 API 完成。
只有浏览器本身存在漏洞时，才会出现漏洞。
Attribute 绑定动态 attribute 的绑定也会自动转义。
转义通过 setAttribute 等浏览器原生 API 完成。
同样，只有浏览器存在漏洞时才会受影响。
潜在的危险在任何 Web 应用中，允许执行未经无害化处理的用户提供内容（HTML、CSS、JavaScript）都存在安全隐患，应尽可能避免。
注入 HTMLVue 会自动转义 HTML，避免可执行 HTML 注入。
例外：当确定 HTML 安全时，可以显式渲染 HTML。
结论：用户提供的 HTML 永远不安全，除非：
在 iframe 沙盒环境中，或 该 HTML 仅被该用户看到。 允许用户编写自己的 Vue 模板也存在类似危险。
URL 注入如果 URL 允许通过 javascript: 执行 JavaScript → 存在潜在问题。
结论：
任何用户提供的 URL 必须在后端先做无害化处理，然后再保存到数据库。 即使是经过无害化处理的 URL，Vue 也不能保证其目标安全。 样式注入恶意用户能利用 CSS 进行“点击劫持”。
若允许在 &lt;style&gt; 中插入用户提供内容 → 更大漏洞（控制整个页面样式）。
Vue 阻止在模板中渲染 &lt;style&gt; 标签。
建议：
仅在沙盒 iframe 中允许用户控制 CSS。 当允许样式绑定时，应使用 对象值形式，并限制为可安全控制的特定属性。 JavaScript 注入禁止在 Vue 中渲染 &lt;script&gt;。
HTML 元素的事件属性（如 onclick、onfocus、onmouseenter）也可能接受 JavaScript 字符串，存在风险。
结论：用户提供的 JavaScript 永远不安全，除非：
在 iframe 沙盒环境中，或 仅在该用户登录页面上执行。 常见问题场景开发者显式渲染了未经无害化处理的用户内容 → 本身不安全。 开发者将 Vue 挂载到包含服务端渲染或用户提供内容的 DOM 节点上 → 与 #1 类似的风险。 最佳实践：
不要将 Vue 挂载到可能包含服务端渲染或用户提供内容的 DOM 节点上。 最佳实践核心规则：只要执行了未经无害化处理的用户内容（HTML、JavaScript、CSS），就可能遭受攻击。
使用 Vue、其他框架，或不使用框架，结论都相同。
  ]]></content></entry><entry><title>7.1 生产部署</title><url>/post/vue3/0701-%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  开发环境 vs. 生产环境在开发过程中，Vue 提供了许多功能来提升开发体验：
对常见错误和隐患的警告 对组件 props / 自定义事件 的校验 响应性调试钩子 开发工具集成 这些功能在生产环境中不会被使用。 一些警告检查会带来少量性能开销。
在部署到生产环境时，应移除所有 仅用于开发环境 的代码分支，以获得 更小的包体积 和 更好的性能。
不使用构建工具如果没有使用构建工具，而是通过 CDN 或其他源 加载 Vue：
必须确保部署时使用 生产环境版本（文件名以 .prod.js 结尾）。 生产环境版本特点： 经过最小化处理 移除了所有仅用于开发环境的代码分支 选择版本全局变量版本（通过 Vue 全局变量访问）：使用 vue.global.prod.js ESM 版本（通过原生 ESM 导入访问）：使用 vue.esm-browser.prod.js 使用构建工具通过以下工具搭建的项目已经预先配置好生产环境：
create-vue (基于 Vite) Vue CLI (基于 webpack) 自定义构建时的注意事项
vue 被解析为 vue.runtime.esm-bundler.js。 编译时功能标记已正确配置。 process.env.NODE_ENV 在构建时被替换为 &quot;production&quot;。 追踪运行时错误可以使用 应用级错误处理来向追踪服务报告错误：
import { createApp } from &#39;vue&#39; const app = createApp(...) app.config.errorHandler = (err, instance, info) =&gt; { // 向追踪服务报告错误 }  ]]></content></entry><entry><title>7.2 性能优化</title><url>/post/vue3/0702-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>性能优化</tag></tags><content type="html">  概述Web 应用性能的两个主要方面：
页面加载性能：首次访问时，应用展示出内容与达到可交互状态的速度。 更新性能：应用响应用户输入更新的速度。 结论：优化性能的第一步是为应用类型确定合适的架构。
页面加载优化选用正确的架构如果应用对 页面加载性能 敏感：
避免纯客户端的 SPA 使用 SSR 或 SSG 来缓解首屏加载缓慢的问题 如果应用对 交互性要求不高：
使用传统后端渲染 HTML 在客户端用 Vue 进行增强 如果主应用必须是 SPA，但有营销相关页面（如落地页、关于页、博客等）：
将这些页面单独部署 理想情况：使用 静态 HTML，尽量少 JS，用 SSG 部署 包体积与 Tree-shaking 优化减少打包产物体积的方法：
尽可能地采用构建步骤 模板预编译 → 避免在浏览器中加载 Vue 编译器 体积缩小 14kb（最小化 + gzip） 避免运行时编译开销 谨慎引入依赖 包体积膨胀常因无意识引入过重依赖 优先选择 提供 ES 模块格式 的依赖（对 tree-shaking 友好） 实际体积大小取决于导入的 API 渐进式增强场景 如果不使用构建步骤，可考虑使用 petite-vue 代码分割定义：构建工具将 JS 包拆分为多个较小文件，可按需或并行加载。
优点：
初次加载只下载必要功能 额外功能仅在需要时加载 在 Vue 应用中：
结合 异步组件使用 Vue Router 应用强烈建议：路由组件使用 异步组件 更新优化Props 稳定性子组件只在至少一个 props 改变时 才会更新。应保持传给子组件的 props 稳定
v-once内置指令。用于渲染依赖运行时数据但无需再更新的内容。整个子树会在未来更新中被跳过
v-memo内置指令。有条件地跳过某些大型子树或 v-for 列表的更新
计算属性稳定性Vue 3.4+：计算属性仅在值变更时触发副作用
问题：若每次计算都创建新对象 → Vue 认为始终不同
优化方法：
手动比较新旧值 若无变化则返回旧值 必须先完整计算，确保依赖收集一致 通用优化大型虚拟列表渲染大型列表 → 性能瓶颈
浏览器需处理大量 DOM 节点
解决方法：列表虚拟化
仅渲染用户视口中可见部分 减少大型不可变数据的响应性开销Vue 响应性系统默认是 深度的
在数据量巨大时 → 性能负担明显
解决方法：
使用 shallowRef() 使用 shallowReactive() 浅层式 API → 仅顶层响应式，深层对象不可变 更新方式：替换整个根状态 避免不必要的组件抽象创建无渲染组件或高阶组件会增加组件实例数量
组件实例比 DOM 节点更昂贵
过多抽象 → 性能损失
注意：减少少量组件实例对性能改善不明显
  </content></entry><entry><title>5.3 KeepAlive 组件</title><url>/post/vue3/0503-keepalive/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  &lt;KeepAlive&gt; 组件&lt;KeepAlive&gt; 是一个内置组件，用于在多个组件间动态切换时 缓存被移除的组件实例。
动态组件的实现：通过 &lt;component&gt; 元素。
默认行为：
组件实例在被替换后会被销毁。 组件销毁后，其内部所有已变化的状态都会丢失。 当组件再次显示时，会创建一个带有 初始状态 的新实例。 解决方案：使用 &lt;KeepAlive&gt; 包装动态组件以缓存实例。
DOM 内模板写法：需写为 &lt;keep-alive&gt;。
包含/排除默认行为：缓存内部所有组件实例。
定制方式：通过 include 和 exclude prop。
可选值： 英文逗号分隔的字符串 正则表达式 包含上述类型的数组 匹配依据：根据组件的 name选项。
要求：若组件需要条件性缓存，必须显式声明 name 选项。
Vue 3.2.34+ 特性：
使用 &lt;script setup&gt; 的单文件组件会自动根据文件名生成对应的 name 选项，无需手动声明。 最大缓存实例数通过 max prop 限制缓存的最大组件实例数。
行为特点：
在指定 max 时，&lt;KeepAlive&gt; 的行为类似 LRU 缓存。 当缓存数量即将超过最大值时，最久未被访问的实例将被销毁，以便为新的实例腾出空间。 缓存实例的生命周期状态变化：
当组件实例从 DOM 移除但被 &lt;KeepAlive&gt; 缓存时 → 变为 不活跃，而不是被卸载。 当组件实例再次插入 DOM 时 → 被重新 激活。 生命周期钩子：
onActivated() onDeactivated() 注意事项：
onActivated 在组件挂载时也会调用。onDeactivated 在组件卸载时也会调用。 这两个钩子适用于 &lt;KeepAlive&gt; 缓存的 根组件和后代组件。   ]]></content></entry><entry><title>5.4 Teleport</title><url>/post/vue3/0504-teleport/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  &lt;Teleport&gt; 组件&lt;Teleport&gt; 是一个内置组件，它可以将组件内部的一部分模板 “传送”到该组件 DOM 结构外层的位置。
使用场景：模板的一部分逻辑上属于该组件，但在 DOM 中需要渲染到其他位置，甚至 Vue 应用外部。
常见例子：全屏模态框。
触发按钮和模态框属于同一个组件，逻辑紧密相关。 若不使用 &lt;Teleport&gt;，模态框会深嵌在 DOM 结构中，导致 CSS 布局困难。 解决方案：使用 &lt;Teleport&gt; 将模板片段传送到 DOM 中的其他位置，避免 DOM 结构的限制。
to prop：
用于指定传送的目标。 值类型： CSS 选择器字符串 DOM 元素对象 含义：将以下模板片段 传送到 to 指定的标签下。 结合使用：
&lt;Teleport&gt; 可以与 Transition搭配，创建带动画的模态框。 挂载要求：
&lt;Teleport&gt; 挂载时，目标 to 必须已存在于 DOM 中。 理想情况下，目标元素应位于 Vue 应用 DOM 树外部。 若目标元素由 Vue 渲染，则必须在 &lt;Teleport&gt; 挂载前挂载该元素。 搭配组件使用&lt;Teleport&gt; 只改变 渲染的 DOM 结构，不会影响组件的逻辑关系。
逻辑保持：
如果 &lt;Teleport&gt; 包含组件，该组件仍与使用 &lt;Teleport&gt; 的组件保持 父子关系。 props 传递和事件触发依然照常工作。 开发工具表现：
父组件的注入正常生效。 子组件在 Vue Devtools 中依然嵌套在父组件下，而不是出现在实际渲染的位置。 禁用 Teleport通过动态传入 disabled prop，可以按需禁用 &lt;Teleport&gt;。
多个 Teleport 共享目标在多个实例共存的场景下（如 &lt;Modal&gt; 可复用组件）：
多个 &lt;Teleport&gt; 可将内容挂载到同一个目标元素。 顺序规则：后挂载的内容会排在目标元素下更后的位置，但都属于该目标元素。 延迟解析的 Teleport版本要求：Vue 3.5+
使用 defer prop 可以 推迟目标解析，直到应用的其他部分挂载完成。
适用场景：目标容器由 Vue 渲染，且位于组件树之后部分。
注意事项：
目标元素必须与 &lt;Teleport&gt; 在 同一个挂载/更新周期 内渲染。 若目标元素延迟过久（如 1 秒后才挂载），Teleport 仍会报错。 延迟原理与 mounted 生命周期钩子类似。   ]]></content></entry><entry><title>6.1 单文件组件</title><url>/post/vue3/0601-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  介绍定义：Vue 的单文件组件（Single-File Component，简称 SFC，即 *.vue 文件）是一种特殊的文件格式。 它允许我们将一个 Vue 组件的 模板、逻辑与样式 封装在单个文件中。
特点：
是 HTML、CSS 和 JavaScript 经典组合的自然延伸。 使用 &lt;template&gt;、&lt;script&gt; 和 &lt;style&gt; 三个块在同一文件中封装和组合视图、逻辑、样式。 为什么要使用单文件组件前提：使用单文件组件必须依赖构建工具。
优点：
使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件。 让强相关的关注点自然内聚。 预编译模板，避免运行时编译开销。 支持 组件作用域的 CSS。 组合式 API 下语法更简单。 可通过交叉分析模板和逻辑进行更多编译时优化。 更好的 IDE 支持，包括自动补全和类型检查。 开箱即用的模块热更新 (HMR) 支持。 推荐使用场景：
单页面应用 (SPA) 静态站点生成 (SSG) 需要构建步骤以获得更好开发体验 (DX) 的项目 非推荐场景：
在轻量级场景下，SFC 可能显得过于复杂。 Vue 也支持无构建步骤的纯 JavaScript 使用方式。 如果只需在静态 HTML 中添加简单交互，可以使用 petite-vue（约 6 kB，预优化的 Vue 子集）。 单文件组件是如何工作的编译：
SFC 是框架指定的文件格式。 必须由 @vue/compiler-sfc 编译为标准 JavaScript 和 CSS。 编译后的 SFC 是标准的 JavaScript (ES) 模块，可以像其他 ES 模块一样导入。 样式处理：
开发环境：&lt;style&gt; 标签会注入为原生 &lt;style&gt;，支持热更新。 生产环境：样式会被抽取、合并为独立 CSS 文件。 如何看待关注点分离？关键观点：
前端开发的关注点不是完全基于文件类型分离的。 关注点分离的目标是提高可维护性，而不仅仅是文件类型上的分离。 现代实践：
与其将代码库拆为三个庞大的层（HTML、CSS、JavaScript 相互交织），不如划分为松散耦合的组件，再按需组合。 在一个组件中：模板、逻辑、样式本就是耦合的。将它们放在一起，使组件 更内聚、更可维护。   ]]></content></entry><entry><title>5.1 Transition</title><url>/post/vue3/0501-transition/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Vue 内置过渡与动画Vue 提供了两个内置组件，用于基于状态变化的过渡和动画：
&amp;lt;Transition&amp;gt;：在一个元素或组件进入和离开 DOM 时应用动画。 &amp;lt;TransitionGroup&amp;gt;：在 v-for 列表中的元素或组件被插入、移动、或移除时应用动画。 其他动画方式：
切换 CSS class 用状态绑定样式来驱动动画 &amp;lt;Transition&amp;gt; 组件内置组件：无需注册，任意组件中均可使用。
作用：将进入和离开动画应用到通过默认插槽传递的元素或组件上。
触发条件：
由 v-if 触发的切换 由 v-show 触发的切换 &amp;lt;component&amp;gt; 动态组件切换 改变特殊的 key 属性 限制：
仅支持单个元素或组件作为插槽内容。 如果内容是组件，该组件必须仅有一个根元素。 当 &amp;lt;Transition&amp;gt; 内元素被插入或移除时：
Vue 自动检测目标元素是否应用了 CSS 过渡或动画，添加/移除相应的 CSS class。 如果提供了 JavaScript 钩子，在适当时机被调用。 如果无 CSS 动画或 JS 钩子，DOM 插入/删除操作将在浏览器的下一个动画帧执行。 基于 CSS 的过渡效果CSS 过渡 class一共 6 个 class：
v-enter-from：进入起始状态。插入前添加，插入后下一帧移除。 v-enter-active：进入生效状态。插入前添加，过渡完成后移除。可定义进入动画的持续时间、延迟和速度曲线。 v-enter-to：进入结束状态。插入后下一帧添加，同时移除 v-enter-from，过渡完成后移除。 v-leave-from：离开起始状态。离开触发时立即添加，一帧后移除。 v-leave-active：离开生效状态。离开触发时立即添加，过渡完成后移除。可定义离开动画的持续时间、延迟和速度曲线。 v-leave-to：离开结束状态。离开触发后下一帧添加，同时移除 v-leave-from，过渡完成后移除。 v-enter-active 和 v-leave-active 可以为进入和离开动画指定不同速度曲线。
为过渡效果命名使用 name prop 声明过渡效果名。
命名过渡的 class 前缀使用该名字而不是 v。
CSS 过渡与动画CSS transition： …  ]]></content></entry><entry><title>5.2 TransitionGroup</title><url>/post/vue3/0502-transitiongroup/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  &lt;TransitionGroup&gt; 组件&lt;TransitionGroup&gt; 是一个内置组件，用于对 v-for 列表中的元素或组件的 插入、移除和顺序改变 添加动画效果。
和 &lt;Transition&gt; 的区别支持与 &lt;Transition&gt; 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器。
区别：
默认情况下不会渲染容器元素，可通过 tag prop 指定容器元素。 过渡模式不可用，因为不是在互斥元素之间切换。 列表中的每个元素都 必须 有独一无二的 key attribute。 CSS 过渡 class 作用在列表内元素上，而不是容器元素上。 当在 DOM 内模板中使用时，组件名需要写为 &lt;transition-group&gt;。
自定义过渡组 class通过 moveClass prop 可以为 移动元素 指定自定义过渡 class。类似于 自定义过渡 class。
渐进延迟列表动画实现方法：
将每个元素的 索引 渲染为该元素的 data attribute。 在 JavaScript 钩子中，基于元素的 data attribute，给该元素的 进场动画添加延迟。   ]]></content></entry><entry><title>4.1 组合式函数</title><url>/post/vue3/0401-%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  组合式函数组合式函数 (Composables)：利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。
无状态逻辑：接收输入并立即返回输出，例如格式化时间函数。
有状态逻辑：负责管理随时间变化的状态。
特点：
核心逻辑与组件中一致，只是移到外部函数并返回需要暴露的状态。 在组合式函数中可以使用所有的 组合式 API。 组合式函数可以嵌套调用，像组件一样组合成更复杂的逻辑。 接收响应式状态toValue()（Vue 3.3+）：将 ref 或 getter 规范化为值。
参数是 ref → 返回 ref 的值。 参数是函数 → 调用并返回函数结果。 否则 → 原样返回参数。 类似 unref()，但对函数有特殊处理。
约定和最佳实践命名使用驼峰命名法。以 use 开头。
输入参数组合式函数可以接收 ref 或 getter 作为参数。
最佳实践：
使用 toValue() 处理参数。 如果函数内创建了响应式 effect：使用 watch() 监视 ref 或 getter，或在 watchEffect() 中调用 toValue()。 返回值推荐返回一个包含多个 ref 的普通非响应式对象。
**原因：**保持解构后的响应性。若直接返回响应式对象，解构时会丢失响应性。
如果需要以对象属性形式使用状态，可以用 reactive() 包装返回对象。
副作用可以执行副作用（DOM 事件监听、请求数据），但需遵守：
SSR 应用中，必须在组件挂载后生命周期钩子中执行 DOM 相关副作用。 在 onUnmounted() 时清理副作用。 使用限制只能在 &amp;lt;script setup&amp;gt; 或 setup() 中调用。
必须同步调用（可在生命周期钩子如 onMounted() 中调用）。
限制原因：需要访问活跃的组件实例上下文，以便：
注册生命周期钩子。 注册计算属性和监听器并在卸载时清理。 特殊情况：&amp;lt;script setup&amp;gt; 支持在 await 之后调用组合式函数，编译器会恢复组件实例。
抽取组合式函数改善代码结构目的：不仅是复用，还能改善代码组织。
随着组件复杂度增加，组合式函数可以将逻辑拆分成更小的函数。
可以视作组件范围内的服务，相互之间可通信。
在选项式 API 中使用组合式函数组合式函数必须在 setup() 中调 …  ]]></content></entry><entry><title>4.2 自定义指令</title><url>/post/vue3/0402-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  自定义指令Vue 内置指令：如 v-model、v-show。
自定义指令：用于复用涉及普通元素的底层 DOM 访问逻辑。
与其他复用方式的比较：
组件：主要构建模块。 组合式函数：侧重有状态逻辑。 自定义指令：专注底层 DOM 操作逻辑。 自定义指令由一个包含类似组件生命周期钩子的对象来定义。
钩子函数接收指令绑定元素作为参数。
在 &lt;script setup&gt; 中：任何以 v 开头的驼峰命名变量都可作为自定义指令。
不使用 &lt;script setup&gt;：通过 directives 选项注册。
可在应用层级全局注册。
自定义指令的使用时机推荐：尽可能使用 v-bind 等内置指令。
自定义指令的使用场景：只有当功能只能通过直接 DOM 操作实现时才使用。
原因：内置指令更高效，对服务端渲染更友好。
指令钩子一个指令的定义对象可以提供以下钩子函数（均为可选）
const myDirective = { // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode) { // 下面会介绍各个参数的细节 }, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode) {}, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode) {}, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode) {}, };钩子参数el：指令绑定的元素，用于直接操作 DOM。
binding：对象，包含：
value：传递给指令的值。例如 v-my-directive=&quot;1 + 1&quot; → 值为 2。 oldValue：之前的值，仅 beforeUpdate 和 updated 可用。无论是否更改都存在。 arg：指令参数。例如 v-my-directive:foo → 参数为 &quot;foo&quot;。 modifiers：修饰符对象。例如 v-my-directive.foo.bar → { foo: true, bar: true }。 instance：使用该指令的组件实例。 dir：指令的定义对象。 vnode：绑定元素的 VNode。
prevVnode：之前渲染中的 VNode，仅 beforeUpdate 和 updated 可用。
注意事项：
除 el 外，其他参数只读，不可更改。 需在不同钩子间共享信息时，推荐通过元素的 dataset 实现。 自定义指令的参数也可为动态值。 简化形式若仅在 mounted 和 updated 中实现相同行为，可直接用函数定义指令。
对象字面量自定义指令可以接收多个值。
可以向指令传递 JavaScript 对象字面量。
指令可接收任意合法的 JavaScript 表达式。
在组件上使用不推荐：在组件上使用自定义指令。
行为：
当组件有单个根节点时，自定义指令会应用到根节点（类似透传 attributes）。 当组件有多个根节点时，指令会被忽略并抛出警告。 限制：指令不能像 attribute 一样通过 v-bind=&quot;$attrs&quot; 传递到其他元素。
  ]]></content></entry><entry><title>4.3 插件</title><url>/post/vue3/0403-%E6%8F%92%E4%BB%B6/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html">  插件插件 (Plugins)：一种能为 Vue 添加全局功能的工具代码。
插件形式：
一个拥有 install() 方法的对象 直接是一个安装函数本身 安装函数参数：
安装它的 应用实例 传递给 app.use() 的额外选项 插件的常见使用场景通过 app.component()和 app.directive() 注册一到多个全局组件或自定义指令。
通过 app.provide()使一个资源 可被注入进整个应用。
向 app.config.globalProperties 中添加一些全局实例属性或方法。
功能库（可能包含上述三种）：例如 vue-router。
注意事项：
谨慎使用全局属性。 如果在整个应用中由不同插件注入过多全局属性，会让应用难以理解和维护。 插件中的 Provide / Inject在插件中，可以通过 provide 为插件用户提供访问某个函数或属性的能力。
  </content></entry><entry><title>2.12 组件基础</title><url>/post/vue3/0212-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  组件概念组件：允许将 UI 划分为独立、可重用的部分，每个部分可单独思考。
结构：组件常常组织成层层嵌套的树状结构，类似于 HTML 元素的嵌套方式。
封装：Vue 提供组件模型，可在每个组件内封装自定义内容与逻辑。
兼容性：Vue 也能很好地配合原生 Web Component。
定义组件单文件组件 (SFC)：使用构建步骤时，将 Vue 组件定义在单独的 .vue 文件中。
对象定义：不使用构建步骤时，以包含 Vue 特定选项的 JavaScript 对象来定义组件。
模板方式：
使用内联 JavaScript 字符串，在运行时编译。 使用 ID 选择器指向一个元素（通常是 &amp;lt;template&amp;gt;），以其内容作为模板来源。 使用组件导入使用：
在父组件中导入子组件。 使用 &amp;lt;script setup&amp;gt; 时，导入的组件在模板中直接可用。 可全局注册组件，使其在应用中任意位置可用。 特点：
组件可被重复使用任意多次。 每次使用组件都会创建一个新的 实例，各自维护独立状态。 命名规范：
在 SFC 中，推荐使用 PascalCase 标签名以区分原生 HTML 元素。 模板编译可区分大小写。 可使用 /&amp;gt; 关闭标签。 DOM 内模板注意 ：必须使用 kebab-case 并显式关闭标签。
传递 propsProps 定义
是一种特殊的 attributes，需要在组件上声明注册。 使用defineProps 宏（仅 &amp;lt;script setup&amp;gt; 中可用，不需要导入）。 返回对象包含所有可传递的 props，自动暴露给模板。 不使用 &amp;lt;script setup&amp;gt; 时，需通过 props 选项声明，作为 setup() 第一个参数传入。 特点
组件可拥有任意数量的 props。 默认所有 props 接受任意类型值。 注册后的 prop 可通过自定义 attribute 传递数据。 监听事件父组件监听：通过 v-on 或 @ 监听子组件抛出的事件。
子组件抛出：
使用内置 $emit 方法传入事件名称抛出事件。 使用 defineEmits宏声明可能抛出的事件，可对事件参数进行验证。 使用说明
defineEmits： 仅 &amp;lt;script setup&amp;gt; 可用，无需导入。 返回等同于 $emit …  ]]></content></entry><entry><title>3.1 组件注册</title><url>/post/vue3/0301-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  一个 Vue 组件 在使用前需要先被 注册，这样 Vue 才能在渲染模板时找到对应的实现。
注册方式：
全局注册 局部注册 全局注册使用 Vue 应用实例的 .component() 方法，让组件在当前 Vue 应用中全局可用。
特点：
可以注册被导入的 .vue 文件。 .component() 方法支持链式调用。 全局注册的组件可在该应用的任意组件模板中使用。 所有子组件也能使用全局注册的组件，即这些子组件可以在 彼此内部使用。 局部注册全局注册的不足
Tree-shaking 无效：全局注册但未使用的组件不会被自动移除，即使未使用仍会出现在打包后的 JS 文件中。 依赖关系不明确：在大型项目中，父组件使用子组件时，不易定位子组件的实现，影响长期可维护性。 局部注册的特性
局部注册的组件必须在父组件中 显式导入，并且只能在该父组件中使用。 依赖关系更加明确。 对 tree-shaking 更加友好。 使用方式
在 &lt;script setup&gt; 的单文件组件中：导入的组件可以直接在模板中使用，无需注册。 未使用 &lt;script setup&gt; 时： 需要在 components 选项中显式注册。 每个 components 对象的 key 是组件名，value 是组件实现。 ⚠️ 注意：局部注册的组件在 后代组件中不可用。
组件名格式推荐使用 PascalCase 作为组件名注册格式。
原因：
PascalCase 是合法的 JavaScript 标识符，便于导入和注册，并且 IDE 能提供更好的自动补全。 &lt;PascalCase /&gt; 在模板中更明显地区分 Vue 组件与原生 HTML 元素或自定义元素 (Web Components)。 适用范围：
单文件组件 内联字符串模板 限制：PascalCase 标签名在 DOM 内模板 中不可用。
Vue 的支持：
模板中使用 kebab-case 标签时，可以解析为 PascalCase 注册的组件。 例如：注册名为 MyComponent 的组件，可以通过 &lt;MyComponent&gt; 或 &lt;my-component&gt; 使用。   ]]></content></entry><entry><title>3.2 Props</title><url>/post/vue3/0302-props/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Props 声明组件需要显式声明 props，Vue 才能区分外部传入的是 props 还是透传 attribute。
声明方式：
&amp;lt;script setup&amp;gt; 中使用 defineProps() 宏。 非 &amp;lt;script setup&amp;gt; 中使用 props 选项。 传递给 defineProps() 的参数与 props 选项的值相同，本质上使用的都是 props 选项。
声明形式：
字符串数组。 对象形式： key：prop 名称。 value：预期类型的构造函数。 优点： 一定程度上充当文档。 类型错误时会在浏览器控制台抛出警告。 TypeScript：在 &amp;lt;script setup&amp;gt; 中可使用 类型标注声明 props。
响应式 Props 解构Vue 响应系统基于属性访问跟踪状态。
在 &amp;lt;script setup&amp;gt; 中，解构的变量会自动加上 props. 前缀。
可使用 JavaScript 默认值语法声明 props 默认值。
Vue VSCode 插件可为解构 props 提供内联提示。
将解构的 props 传递到函数中解构的 prop 传入函数时，传递的是值而非响应式数据源。
Vue 会捕捉并警告此情况。
推荐：将其包装在 getter 中，以保持响应性。
外部函数可调用 getter（或使用 toValue）来追踪 prop 变更。
传递 prop 的细节Prop 名字格式长 prop 名：推荐使用 camelCase（合法的 JS 标识符，可直接在模板表达式中使用）。
实际传递时：通常写为 kebab-case，与 HTML attribute 对齐。
组件名推荐使用 PascalCase，提升可读性。
使用对象绑定多个 prop使用无参数的 v-bind 可将对象所有属性作为 props 传入。
单向数据流所有 props 遵循 单向绑定：
父组件更新 → 子组件接收新值。 子组件不能修改 prop，否则 Vue 会警告。 导致你想要更改一个 prop 的常见需求场景：
作为初始值：子组件需定义新的本地数据属性，并以 prop 初始化。
对传入值做转换：基于该 prop 定义计算属性。
对象 / 数组类型的 props子组件可以修改对象或数组内部的值（按引用传递）。
缺陷：可能导致 …  ]]></content></entry><entry><title>3.3 组件事件</title><url>/post/vue3/0303-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  触发与监听事件在组件模板表达式中，可以直接使用 $emit 方法触发自定义事件。
父组件通过 v-on（缩写为 @）监听事件。
事件监听器支持 .once 修饰符。
事件名提供了 自动格式转换。
触发时可用 camelCase。 父组件监听时可用 kebab-case。 推荐：在模板中使用 kebab-case 形式。
与原生 DOM 事件不同，组件触发的事件没有冒泡机制。只能监听直接子组件触发的事件。
平级或跨层组件通信：应使用 事件总线或全局状态管理方案。
事件参数触发事件时可以附带参数：
在 $emit 中传入额外参数。 父组件监听：
可用内联箭头函数接收参数。 可用组件方法作为事件处理函数接收参数。 结论：所有传入 $emit() 的参数都会直接传给监听器。
声明触发的事件组件可显式通过 defineEmits() 声明要触发的事件。
在 &lt;template&gt; 使用的 $emit，不能在 &lt;script setup&gt; 中使用；
defineEmits() 会返回一个同作用的函数供使用。
限制：只能在 &lt;script setup&gt; 顶级作用域中使用，不能放在子函数内。
使用 setup() 时：
需通过 emits 选项定义事件。 emit 函数在 setup() 上下文对象中被暴露，可安全解构。 emits 选项和 defineEmits() 支持 对象语法。可通过 TypeScript 为参数指定类型，进行参数验证。
在 &lt;script setup&gt; 搭配 TypeScript 时，可使用 纯类型标注声明事件。
虽然声明事件是可选的，但推荐完整声明所有触发的事件：
作为组件文档记录。 帮助 Vue 区分事件和透传 attribute。 避免第三方代码触发的自定义 DOM 事件导致边界问题。 若原生事件名（如 click）被定义在 emits 选项中，监听器只会监听组件触发的事件，不会再响应原生事件。
事件校验与 props 类型校验类似，事件也可使用对象语法进行描述。
校验方式：
将事件赋值为一个函数。 函数接收 emit 传入的参数。 返回布尔值：表示事件是否合法。 &lt;script setup&gt; const emit = defineEmits({ // 没有校验 click: null, // 校验 submit 事件 submit: ({ email, password }) =&gt; { if (email &amp;&amp; password) { return true; } else { console.warn(&#34;Invalid submit event payload!&#34;); return false; } }, }); function submitForm(email, password) { emit(&#34;submit&#34;, { email, password }); } &lt;/script&gt;  ]]></content></entry><entry><title>3.4 组件 v-model</title><url>/post/vue3/0304-%E7%BB%84%E4%BB%B6v-model/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  基本用法v-model 可以在组件上使用以实现双向绑定。
从 Vue 3.4 开始，推荐的实现方式是使用 defineModel() 宏。
defineModel() 返回的值是一个 ref：
.value 与父组件的 v-model 值同步； 子组件变更 .value 时，父组件绑定的值也会更新。 可以用 v-model 把这个 ref 绑定到原生 input 元素，实现包装。
&lt;script setup&gt; const model = defineModel(); function update() { model.value++; } &lt;/script&gt; &lt;template&gt; &lt;div&gt;Parent bound v-model is: {{ model }}&lt;/div&gt; &lt;button @click=&#34;update&#34;&gt;Increment&lt;/button&gt; &lt;/template&gt;底层机制defineModel 是一个便利宏，编译器会将其展开为：
一个名为 modelValue 的 prop，与本地 ref 的值同步； 一个名为 update:modelValue 的事件，在本地 ref 的值变更时触发。 Vue 3.4 之前的实现方式
&lt;script setup&gt; const props = defineProps([&#34;modelValue&#34;]); const emit = defineEmits([&#34;update:modelValue&#34;]); &lt;/script&gt; &lt;template&gt; &lt;input :value=&#34;props.modelValue&#34; @input=&#34;emit(&#39;update:modelValue&#39;, $event.target.value)&#34; /&gt; &lt;/template&gt;父组件中的 v-model=&quot;foo&quot; 将被编译为：
&lt;Child :modelValue=&#34;foo&#34; @update:modelValue=&#34;($event) =&gt; (foo = $event)&#34; /&gt;注意事项defineModel 声明了一个 prop。 可以通过传递选项给 defineModel 来声明底层 prop 的选项。 如果设置了 default 值且父组件没有提供该值，会导致父子组件不同步。 v-model 的参数组件上的 v-model 可以接受参数。
在子组件中，通过将字符串作为 第一个参数传递给 defineModel() 来支持相应的参数。
如果需要额外的 prop 选项，应在 model 名称之后传递。
多个 v-model 绑定利用参数和事件名，可以在单个组件实例上创建多个 v-model 双向绑定。
每个 v-model 会同步不同的 prop，且无需额外选项。
处理 v-model 修饰符获取修饰符通过解构 defineModel() 的返回值，可以在子组件中访问 v-model 的修饰符 &lt;script setup&gt; const [model, modifiers] = defineModel(); &lt;/script&gt; &lt;template&gt; &lt;input type=&#34;text&#34; v-model=&#34;model&#34; /&gt; &lt;/template&gt;基于修饰符调节可以给 defineModel() 传入 get 和 set 选项： get 在读取值时接收当前值，并返回处理后的新值。 set 在设置值时接收当前值，并返回处理后的新值。   ]]></content></entry><entry><title>3.5 透传 Attributes</title><url>/post/vue3/0305-%E9%80%8F%E4%BC%A0-attributes/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Attributes 继承透传 attribute：传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或 v-on 事件监听器。
常见例子：class、style、id。
当一个组件以单个元素为根渲染时，透传的 attribute 会自动添加到根元素上。
对 class 和 style 的合并如果子组件根元素已有 class 或 style，会与继承的值合并。
v-on 监听器继承同样规则适用于 v-on 事件监听器。
根元素自身的监听器与继承的监听器都会被触发。
深层组件继承透传的 attribute 不会包含父组件已声明的 props 或 emits 的 v-on 侦听函数，这些被父组件消费。 符合声明的透传 attribute，可以作为 props 传入子组件。 禁用 Attributes 继承设置 inheritAttrs: false 可禁用自动继承。
在 &lt;script setup&gt; 中可使用 defineOptions 设置。
使用场景：当 attribute 需要应用到根节点以外的其他元素时。设置 inheritAttrs: false 后，可完全控制透传 attribute 的使用。
模板中可用 $attrs 访问透传 attribute。
$attrs 包含除已声明的 props 和 emits 外的所有 attribute：包括 class、style、v-on 监听器等。
注意事项透传 attributes 在 JavaScript 中保留原始大小写。 v-on 事件监听器会暴露为函数，例如：$attrs.onClick。 使用没有参数的 v-bind，可将对象的所有属性作为 attribute 应用到目标元素上。 多根节点的 Attributes 继承多根节点组件没有自动 attribute 透传。
如果 $attrs 没有显式绑定，会抛出运行时警告。
显式绑定 $attrs 时，则不会有警告。
在 JavaScript 中访问透传 Attributes在 &lt;script setup&gt; 中可用 useAttrs() API 访问透传 attribute。
未使用 &lt;script setup&gt; 时，attrs 会作为 setup() 上下文对象的一个属性暴露。
注意事项attrs 对象总是反映最新的透传 attribute，但它不是响应式。 不能通过侦听器监听 attrs 的变化。 如果需要响应性： 使用 prop； 或使用 onUpdated() 在每次更新时结合最新的 attrs 执行副作用。   ]]></content></entry><entry><title>3.6 插槽 Slots</title><url>/post/vue3/0306-%E6%8F%92%E6%A7%BD-slots/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  插槽内容与出口&lt;slot&gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。
插槽内容可以是任意合法的模板内容，不局限于文本。可以传入多个元素，甚至是组件。
渲染作用域插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。
插槽内容无法访问子组件的数据。
Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则一致。
**换言之：**父组件模板中的表达式只能访问父组件的作用域。子组件模板中的表达式只能访问子组件的作用域。
默认内容在外部没有提供任何内容的情况下，可以为插槽指定默认内容。
如果我们提供了插槽内容，被显式提供的内容会取代默认内容。
具名插在一个组件中包含多个插槽出口时，可以为 &lt;slot&gt; 元素添加 name attribute，用来分配唯一 ID。
带 name 的插槽称为具名插槽 (named slots)。
没有提供 name 的 &lt;slot&gt; 出口会隐式地命名为 default。
使用方式：
为具名插槽传入内容时，需要使用带 v-slot 指令的 &lt;template&gt; 元素。 将目标插槽的名字传给该指令。 v-slot 有简写形式：#。 **注意：**当组件同时接收默认插槽和具名插槽时：所有位于顶级的非 &lt;template&gt; 节点都被隐式地视为默认插槽内容。
条件插槽可以通过 $slots 属性与 v-if 结合，来根据插槽是否被传入内容进行渲染。
动态插槽名v-slot 支持动态指令参数。表达式与动态指令参数遵循相同语法限制。
作用域插槽插槽内容可能需要同时使用 父组件域内 和 子组件域内 的数据，子组件在渲染时，可以将一部分数据提供给插槽。
实现方式：
可以像组件传递 props 那样，向插槽出口传递 attributes。 接收插槽 props 时： 默认插槽和具名插槽略有区别。 子组件标签上的 v-slot 指令会接收到一个插槽 props 对象。 插槽 props 可作为 v-slot 的值在插槽表达式中访问。 类比：
作用域插槽类似于传入子组件的函数。 子组件将 props 作为参数传入。 具名作用域插槽工作方式与默认作用域插槽类似。 插槽 props 可通过 v-slot:name=&quot;slotProps&quot; 访问。
如果同时使用具名插槽与默认插槽：
需要为默认插槽使用显式的 &lt;template&gt; 标签。 直接为组件添加 v-slot 指令会导致编译错误。 这是为了避免默认插槽 props 的作用域混淆。 无渲染组件一些组件只包含逻辑，不需要渲染内容，视图输出完全通过作用域插槽交给消费者组件，这种组件称为 无渲染组件。
注意：
大部分无渲染组件的功能可以通过 组合式 API 实现。 使用组合式 API 更高效，并且避免额外的组件嵌套开销。   ]]></content></entry><entry><title>3.7 依赖注入</title><url>/post/vue3/0307-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  Prop 逐级透传问题当需要从父组件向子组件传递数据时，会使用 props。
如果组件层级很深，某个深层子组件需要祖先组件的数据，则必须逐级透传 props。这种情况被称为 “prop 逐级透传”，是我们希望避免的。
**解决方式：**使用 provide / inject：
父组件作为依赖提供者。 任意后代组件（无论层级多深）都可以注入该依赖。 Provide (提供)使用 provide()为组件后代提供数据。
如果不使用 &lt;script setup&gt;，必须在 setup() 中同步调用。
参数说明：
第一个参数：注入名
类型：字符串或 Symbol 作用：供后代组件查找依赖 一个组件可多次调用 provide()，使用不同注入名。 第二个参数：提供的值
类型：任意，包括响应式状态（如 ref） 作用：提供响应式状态时，后代组件可与提供者保持响应式联系。 应用层 Provide可以在整个应用层面提供依赖。
应用级提供的数据可被该应用内的所有组件注入。
特别适用于插件，因为插件通常不会使用组件形式提供值。
Inject (注入)使用 inject()注入上层组件提供的数据。
如果多个父组件提供了相同键，就近原则：解析为最近父组件的值。
注意：
如果提供的值是 ref：
注入的是 ref 对象本身，不会自动解包。 注入方组件可通过 ref 保持响应性链接。 如果不使用 &lt;script setup&gt;，必须在 setup() 内同步调用。
注入默认值默认情况下，如果注入名未被提供，会抛出运行时警告。
可以声明一个默认值，类似 props。
默认值可能需要通过函数或类初始化 → 可使用 工厂函数避免不必要的计算。
第三个参数：标识默认值应作为工厂函数使用。
和响应式数据配合使用建议：将响应式状态的变更保持在供给方组件中。状态声明与变更内聚在供给方 → 更易维护。
在注入方更改数据时：推荐由供给方提供更改数据的方法函数。
如果需要确保数据不可更改：使用 readonly() 包装提供的值。
使用 Symbol 作注入名在大型应用或组件库中，建议使用 Symbol 作为注入名，避免冲突。
推荐在单独文件中导出这些注入名 Symbol。
  ]]></content></entry><entry><title>3.8 异步组件</title><url>/post/vue3/0308-%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag><tag>组件化开发</tag></tags><content type="html"><![CDATA[  基本用法在大型项目中，我们可能需要将应用拆分为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能。
defineAsyncComponent 接收一个返回 Promise 的加载函数：
resolve：在从服务器获得组件定义时调用。 reject(reason)：加载失败时调用。 ES 模块动态导入会返回 Promise，通常与 defineAsyncComponent 搭配使用。
构建工具（如 Vite、Webpack）支持动态导入，并会将其作为打包时的代码分割点，因此可用来导入 Vue 单文件组件。
**结果：**得到的组件是一个包装组件，仅在需要时才加载内部实际组件。
Props 和插槽会传递给内部组件，可以无缝替换原始组件。
异步组件与普通组件一样：
可以用 app.component() 全局注册。 也可以在父组件中直接定义。 加载与错误状态defineAsyncComponent() 支持高级选项来处理加载和错误状态：
const AsyncComp = defineAsyncComponent({ // 加载函数 loader: () =&gt; import(&#34;./Foo.vue&#34;), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000, });加载组件：在内部组件加载时显示。默认延迟 200ms 才展示，避免网络良好时闪烁。
报错组件：在加载器函数的 Promise 抛错时渲染。超时后（如超过 timeout 设置）也会渲染。
惰性激活 (Vue 3.5+)异步组件可以通过提供 激活策略 来控制何时进行激活。
Vue 提供了内置激活策略，需要单独导入（便于 tree-shake）。 保持在底层设计，未来可在框架或上层解决方案中提供语法糖。 在空闲时进行激活使用 requestIdleCallback
import { defineAsyncComponent, hydrateOnIdle } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnIdle(/* 传递可选的最大超时 */), });在可见时激活使用 IntersectionObserver
import { defineAsyncComponent, hydrateOnVisible } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnVisible(), });可传递侦听器的选项对象。
在媒体查询匹配时进行激活通过 媒体查询 控制
import { defineAsyncComponent, hydrateOnMediaQuery } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnMediaQuery(&#34;(max-width:500px)&#34;), });交互时激活在指定事件触发时激活
import { defineAsyncComponent, hydrateOnInteraction } from &#34;vue&#34;; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: hydrateOnInteraction(&#34;click&#34;), });可以是多个事件类型的列表。
激活完成后，触发的事件会被重放。
自定义策略通过自定义函数控制激活
import { defineAsyncComponent, type HydrationStrategy } from &#34;vue&#34;; const myStrategy: HydrationStrategy = (hydrate, forEachElement) =&gt; { // forEachElement 是一个遍历组件未激活的 DOM 中所有根元素的辅助函数， // 因为根元素可能是一个片段而非单个元素 forEachElement((el) =&gt; { // ... }); // 准备好时调用 `hydrate` hydrate(); return () =&gt; { // 如必要，返回一个销毁函数 }; }; const AsyncComp = defineAsyncComponent({ loader: () =&gt; import(&#34;./Comp.vue&#34;), hydrate: myStrategy, });  ]]></content></entry><entry><title>2.10 侦听器</title><url>/post/vue3/0210-%E4%BE%A6%E5%90%AC%E5%99%A8/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  计算属性与副作用计算属性用于声明性地计算衍生值。但在某些情况下，需要在状态变化时执行副作用，例如：
更改 DOM 根据异步操作结果修改状态 在组合式 API 中，可以使用 watch 函数 在响应式状态发生变化时触发回调函数。
侦听数据源类型watch 的第一个参数可以是：
一个 ref（包括计算属性） 一个响应式对象 一个 getter 函数 多个数据源组成的数组 注意：不能直接侦听响应式对象的属性值，需要用返回该属性的 getter 函数。
深层侦听器直接传入响应式对象 → 隐式深层侦听器（所有嵌套变更都会触发）。
返回响应式对象的 getter → 仅在返回不同对象时触发。
可显式加上 deep: true 选项，强制为深层侦听器。
watch( () =&amp;amp;gt; state.someObject, (newValue, oldValue) =&amp;amp;gt; { // newValue 和 oldValue 相等 // 除非 state.someObject 被整个替换 }, { deep: true } );deep 可设为数字，表示最大遍历深度。
深度侦听会遍历所有嵌套属性，对大型数据结构开销大。只在必要时使用，并注意性能。
即时回调的侦听器watch 默认懒执行，仅在数据源变化时回调。
使用 immediate: true 可在创建侦听器时立即执行回调。
一次性侦听器默认：每次源变化时都会执行回调。
使用 once: true 可让回调仅执行一次。
watchEffect()用于简化依赖于相同响应式状态的侦听器。
自动跟踪回调中的响应式依赖，无需手动维护依赖列表。
对于嵌套数据结构，仅追踪被访问的属性，比深层侦听更高效。
依赖追踪限制：仅在同步执行期间生效。异步回调中，只有在第一个 await 之前访问到的属性会被追踪。
watch vs. watchEffectwatch：
只追踪明确指定的数据源。 不追踪回调中访问的其他内容。 仅在数据源确实改变时触发回调。 可精确控制回调触发时机。 watchEffect：
在副作用执行期间追踪依赖。 自动追踪所有访问到的响应式属性。 更方便简洁，但依赖关系可能不够明确。 副作用清理使用 onWatcherCleanup()注册清理函数，在侦听器失效并重新运行前调用。
调用限制： …  </content></entry><entry><title>2.11 模板引用</title><url>/post/vue3/0211-%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  模板引用 (ref)Vue 的声明性渲染模型抽象了大部分 DOM 操作，但有时仍需要直接访问底层 DOM 元素。 ref 是一个特殊的 attribute，允许在 DOM 元素或子组件实例被挂载后，获得对它的直接引用。 常见用途：
在组件挂载时将焦点设置到 input 元素 在元素上初始化第三方库 访问模板引用在组合式 API 中，可使用 useTemplateRef()获取引用。
使用 TypeScript 时，Vue 会根据模板中 ref attribute 的元素或组件，自动推断 input.value 的类型。
在 3.5 之前的版本，需要手动声明与模板中 ref 匹配的引用。
如果不使用 &lt;script setup&gt;，需从 setup() 返回 ref。
注意：
只能在组件挂载后访问模板引用。 如果侦听模板引用的变化，需要考虑其值可能为 null。 组件上的 ref模板引用也可以用在子组件上，此时引用的值是组件实例。
如果子组件：
使用 选项式 API 或
未使用 &lt;script setup&gt;
→ 那么被引用的组件实例与子组件的 this 一致，父组件可访问子组件的所有属性和方法。
⚠️ 这会导致父子组件之间的紧密耦合，应只在绝对需要时使用组件引用。常规情况下，应优先使用 props 和 emit 实现父子交互。
例外：
使用 &lt;script setup&gt; 的组件是默认私有的。 父组件无法访问其中任何内容，除非子组件通过 defineExpose 显式暴露。 defineExpose 必须在任何 await 操作之前调用，否则暴露的属性和方法无法访问。 v-for 中的模板引用在 v-for 中使用模板引用时，ref 的值是一个数组。
挂载后，数组包含整个列表对应的所有元素。
注意：ref 数组的顺序 不保证与源数组一致。
函数模板引用ref attribute 也可以绑定为一个函数。
在每次组件更新时，该函数都会被调用，并接收元素引用作为第一个参数。
需要使用 动态绑定 :ref 才能传入函数。
当绑定的元素被卸载时，函数也会被调用一次，此时参数 el 为 null。
可以绑定组件方法而不是内联函数。
  ]]></content></entry><entry><title>2.6 条件渲染</title><url>/post/vue3/0206-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-if用于条件性地渲染一块内容。内容只会在指令的表达式返回真值时才被渲染。
v-else为 v-if 添加一个“else 区块”。
必须紧跟在一个 v-if 或者 v-else-if 元素后面。否则不会被识别。
v-else-if作用：提供 v-if 的“else if 区块”。
特点：
可以连续多次使用。 必须紧跟在一个 v-if 或 v-else-if 元素后面。 &lt;template&gt; 上的 v-ifv-if 必须依附于某个元素。
如果需要切换多个元素，可以在 &lt;template&gt; 元素上使用 v-if。
&lt;template&gt; 是不可见的包装器，渲染结果中不会包含它本身。
v-else 和 v-else-if 也可以在 &lt;template&gt; 上使用。
v-show作用：按条件显示一个元素。
特点：
用法与 v-if 类似。 在 DOM 渲染中始终保留元素，仅通过切换 display CSS 属性控制显示。 限制：
不能在 &lt;template&gt; 元素上使用。 不能与 v-else 搭配使用。 v-if vs. v-showv-if：
是真实的条件渲染。 切换时，条件区块内的事件监听器和子组件会被销毁与重建。 惰性渲染：初次渲染时条件为 false，则不会渲染，只有首次为 true 时才渲染。 v-show：
元素无论初始条件如何，始终会被渲染。 仅切换 CSS display 属性。 结论：
v-if 切换开销更高。 v-show 初始渲染开销更高。 频繁切换时使用 v-show 更好；条件很少改变时用 v-if 更合适。 v-if 和 v-for优先级：当同时存在于一个元素时，v-if 会先执行。
结论：同时使用 不推荐，因为优先级不明显。
  ]]></content></entry><entry><title>2.7 列表渲染</title><url>/post/vue3/0207-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-for基于数组渲染列表。
语法：item in items
items：源数据数组 item：迭代项的别名 特点：
可以访问父作用域内的属性和变量。 可选的第二个参数表示当前项的索引。 支持在定义别名时使用解构。 多层嵌套时，作用域类似函数作用域，每个作用域可访问父级作用域。 of 可以替代 in，更接近 JavaScript 迭代器语法。 v-for 与对象可遍历对象的所有属性。
顺序：基于 Object.values() 的返回顺序。
参数：
第二个参数：属性名 第三个参数：索引 在 v-for 里使用范围值可以直接接受一个整数值。
效果：模板会基于 1...n 的取值范围重复渲染多次。
&lt;template&gt; 上的 v-for可在 &lt;template&gt; 标签上使用 v-for 来渲染包含多个元素的块。
v-for 与 v-if优先级：v-if 比 v-for 更高。 结果：v-if 的条件无法访问 v-for 的别名。 解决方法：在外层包装 &lt;template&gt; 并在其上使用 v-for。 结论：同时使用 不推荐，因优先级不明显。 常见情况： 过滤列表项： 示例：v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; 替代方案：使用新的计算属性（如 activeUsers）。 避免渲染隐藏的列表： 示例：v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; 替代方案：将 v-if 移至容器元素（如 ul、ol）。 通过 key 管理状态默认策略：Vue 按“就地更新”方式更新 v-for 渲染的元素，不移动 DOM 元素顺序。
适用场景：仅当渲染结果不依赖子组件状态或临时 DOM 状态（如表单值）。
提示机制：为每个元素提供唯一的 key 属性。
规则：
使用 &lt;template v-for&gt; 时，key 应放在 &lt;template&gt; 上。 推荐在可行时总是提供 key。 key 的值应为基础类型（字符串或 number），不要使用对象。 组件上使用 v-for用法：可以直接在组件上使用 v-for，需提供 key。
注意：
不会自动传递数据给组件，组件有自己独立作用域。 需通过 props 传递数据。 不自动注入 item 是为了避免组件与 v-for 耦合。 数组变化侦测变更方法Vue 能侦听以下数组方法，并触发更新：
push() pop() shift() unshift() splice() sort() reverse() 替换一个数组变更方法：直接修改原数组。
不可变方法：如 filter()、concat()、slice()，返回新数组，不修改原数组。
做法：使用新数组替换旧数组。
效率：Vue 会最大化 DOM 元素重用，即使新数组部分重叠，也高效。
展示过滤或排序后的结果需求：显示经过过滤或排序的数组，但不修改原始数据。
做法：使用计算属性返回过滤或排序后的数组。
注意：
reverse() 和 sort() 会修改原数组。 计算属性中不应直接修改原数组，应先创建副本再调用这些方法。   ]]></content></entry><entry><title>2.8 事件处理</title><url>/post/vue3/0208-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  监听事件可以使用 v-on 指令 (简写为 @) 监听 DOM 事件，并在事件触发时执行 JavaScript。
事件处理器的形式：
内联事件处理器：执行内联 JavaScript 语句（类似 onclick）。 方法事件处理器：指向组件上定义的方法的属性名或路径。 内联事件处理器通常用于简单场景
方法事件处理器适用场景：逻辑复杂时，使用方法代替内联代码。
特点：自动接收原生 DOM 事件并触发执行。
判断方式：模板编译器会检查 v-on 的值是否是合法的标识符或属性访问路径，以判断使用哪种形式。
在内联处理器中调用方法可以直接在内联事件处理器中调用方法。
作用：可传入自定义参数以替代原生事件。
在内联事件处理器中访问事件参数可通过特殊变量 $event 传入事件对象，或使用内联箭头函数。
事件修饰符目的：避免在方法中编写 event.preventDefault() 或 event.stopPropagation()，让方法更专注于数据逻辑。
修饰符：
.stop .prevent .self .capture .once .passive &amp;lt;!-- 单击事件将停止传递 --&amp;gt; &amp;lt;a @click.stop=&amp;#34;doThis&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 提交事件将不再重新加载页面 --&amp;gt; &amp;lt;form @submit.prevent=&amp;#34;onSubmit&amp;#34;&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;!-- 修饰语可以使用链式书写 --&amp;gt; &amp;lt;a @click.stop.prevent=&amp;#34;doThat&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 也可以只有修饰符 --&amp;gt; &amp;lt;form @submit.prevent&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&amp;gt; &amp;lt;!-- 例如：事件处理器不来自子元素 --&amp;gt; &amp;lt;div @click.self=&amp;#34;doThat&amp;#34;&amp;gt;...&amp;lt;/div&amp;gt;调用顺序：修饰符按声明顺序执行。
@click.prevent.self：阻止元素及其子元素所有点击的默认行为。 …  ]]></content></entry><entry><title>2.9 表单输入绑定</title><url>/post/vue3/0209-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-model定义：用于将表单输入框内容同步到 JavaScript 中的变量，避免手动绑定值和监听事件。
适用元素：可用于 &lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;。
绑定方式：
文本 &lt;input&gt; 和 &lt;textarea&gt;：绑定 value，侦听 input。 &lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt;：绑定 checked，侦听 change。 &lt;select&gt;：绑定 value，侦听 change。 注意：
v-model 会忽略元素上的初始 value、checked、selected 属性。 当前 JavaScript 状态始终是唯一数据来源。 初始值应通过响应式 API 在 JavaScript 中声明。 基本用法&lt;textarea&gt; 中不支持插值表达式，请使用 v-model。
单一复选框：绑定布尔值。
多个复选框：可以绑定到一个数组或 Set。
&lt;select&gt;：
如果初始值不匹配任何选项，则渲染为“未选择”状态。 在 iOS 上此情况可能导致用户无法选择第一项，因此建议提供一个空值的禁用选项。 选项可通过 v-for 动态渲染。 值绑定默认情况：
单选按钮、复选框、选择器的绑定值为静态字符串（复选框为布尔值）。 动态绑定：
使用 v-bind 可绑定组件实例上的动态数据。 支持绑定为非字符串的数据类型。 复选框true-value / false-value：
Vue 特有属性，仅能与 v-model 一起使用。 不影响 value 属性。 因为未选中复选框不会被提交，若需保证一定提交值，请使用单选按钮。 支持非字符串值绑定。
修饰符.lazy默认：每次 input 事件后更新数据（IME 拼字阶段除外）。
使用 .lazy：改为每次 change 事件后更新数据。
.number自动将输入转换为数字。
转换逻辑：
使用 parseFloat()，无法转换时返回原始值。 输入为空时，返回空字符串。 注意：当输入框 type=&quot;number&quot; 时，.number 修饰符会自动启用。
.trim自动去除用户输入内容两端的空格。
  ]]></content></entry><entry><title>1. 简介</title><url>/post/vue3/01-%E7%AE%80%E4%BB%8B/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  什么是 VueVue 是一个用于构建用户界面的 JavaScript 框架，基于标准的 HTML、CSS 和 JavaScript。它提供了一种声明式的、组件化的编程模型，旨在帮助开发高效的用户界面。
核心功能声明式渲染：Vue 通过模板语法，允许你声明式地描述 HTML 与 JavaScript 状态之间的关系。 响应性：Vue 会自动追踪 JavaScript 状态的变化，并且在其发生变化时，自动更新 DOM。 渐进式框架Vue 的设计注重灵活性，可以根据不同需求逐步集成。以下是几种使用 Vue 的方式：
增强静态 HTML，无需构建步骤。 作为 Web Components 嵌入任何页面。 构建单页应用（SPA）。 全栈开发/服务端渲染（SSR）。 Jamstack 和静态站点生成（SSG）。 开发桌面端、移动端、WebGL 或命令行终端界面。 单文件组件在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。
API 风格Vue 的组件有两种主要风格：选项式 API 和 组合式 API。
选项式 API (Options API)使用选项对象描述组件逻辑，如 data、methods 和 mounted。 所有选项定义的属性会暴露在组件的 this 上，this 会指向当前组件实例。 组合式 API (Composition API)通过导入 API 函数来描述组件逻辑。 在单文件组件中，通常与 &lt;script setup&gt; 搭配使用，setup 标记指示 Vue 在编译时处理组件逻辑。 &lt;script setup&gt; 中的导入和顶层变量/函数能在模板中直接使用。 API 风格对比与选择两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。
选项式 API 是在组合式 API 的基础上实现的，Vue 的基础概念和知识在两者间通用。
选项式 API：以“组件实例”为中心，更适合有面向对象语言背景的开发者，且抽象了响应性相关的细节。对初学者更友好。
组合式 API ：核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式灵活性更强，但需要对 Vue 的响应式系统有深入理解。适合处理复杂逻辑和组织/重用代码。
在生产项目中：
选项式 API：适用于不需要构建工具或在低复杂度场景下使用 Vue（如渐进增强的应用场景）。 组合式 API + 单文件组件：推荐用于构建完整的单页应用。   ]]></content></entry><entry><title>2.1 创建一个应用</title><url>/post/vue3/0201-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  应用实例每个 Vue 应用都是通过 createApp函数创建一个新的 应用实例。
传入 createApp 的对象实际上是一个 组件，每个应用都需要一个 根组件，其他组件将作为其子组件。
如果使用单文件组件，可以直接从另一个文件中导入根组件。
挂载应用应用实例必须调用 .mount() 方法后才会渲染。
.mount() 方法接收一个容器参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串。 根组件的内容将会渲染在容器元素内部，但容器元素本身 不会 被视为应用的一部分。 .mount() 方法应在整个应用配置和资源注册完成后调用。
不同于其他资源注册方法，.mount() 返回的是 根组件实例，而非应用实例。 DOM 中的根组件模板根组件的模板：通常是组件本身的一部分，也可以单独提供。
如果根组件没有设置 template 选项，Vue 会自动使用容器的 innerHTML 作为模板。 DOM 内模板：
通常用于 无构建步骤 的 Vue 应用程序。 也可以与 服务器端框架 一起使用，其中根模板可能由服务器动态生成。 应用配置应用实例暴露 .config 对象，用于配置应用级选项。
提供了一些方法，用于注册 应用范围内可用的资源。
确保在挂载应用实例之前完成所有应用配置！
多个应用实例Vue 允许创建多个应用实例，每个应用实例拥有自己的配置和全局资源作用域。
如果使用 Vue 增强服务端渲染 HTML，避免将一个 Vue 应用实例挂载到整个页面上。推荐创建多个小的应用实例，将它们分别挂载到所需的元素上。
  </content></entry><entry><title>2.2 模板语法</title><url>/post/vue3/0202-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  Vue 使用基于 HTML 的模板语法，使我们能够声明式地将组件实例的数据绑定到 DOM 上。所有 Vue 模板都是语法层面合法的 HTML，可以被标准浏览器和 HTML 解析器解析。
Vue 会将模板编译为高度优化的 JavaScript 代码，结合响应式系统，能够智能推导需要重新渲染的组件，并尽量减少 DOM 操作。
如果你熟悉虚拟 DOM 并偏好使用 JavaScript，可以使用可选的 JSX 支持来手写渲染函数。但请注意，手写渲染函数将不会享受模板同等级别的编译时优化。
文本插值最基本的数据绑定形式是 文本插值，使用双大括号（Mustache 语法）
&amp;lt;span&amp;gt;Message: {{ msg }}&amp;lt;/span&amp;gt;双大括号会被替换为组件实例中 msg 属性的值。 每次 msg 改变时，会自动同步更新视图。 原始 HTML双大括号将数据作为纯文本处理，而不是 HTML。如果需要插入 HTML，请使用 v-html 指令：
&amp;lt;p&amp;gt;Using v-html directive: &amp;lt;span v-html=&amp;#34;rawHtml&amp;#34;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;v-html 指令会将元素的 innerHTML 与组件的 rawHtml 属性保持同步，插值为纯 HTML，数据绑定将会被忽略。 你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。 请谨慎使用 v-html，因为它容易导致 XSS 漏洞，仅在内容安全可信时使用，并且 永远不要使用用户提供的 HTML 内容。 Attribute 绑定双大括号不能在 HTML attributes 中使用。响应式绑定一个 attribute，应使用v-bind 指令。v-bind 也有简写语法：
&amp;lt;div v-bind:id=&amp;#34;dynamicId&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :id=&amp;#34;dynamicId&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :id&amp;gt;&amp;lt;/div&amp;gt;如果绑定的值是 null 或 undefined，该 attribute 将被从渲染的元素中移 …  ]]></content></entry><entry><title>2.3 响应式基础</title><url>/post/vue3/0203-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  声明响应式状态ref()在 Vue 的组合式 API 中，推荐使用 ref() 函数来声明响应式状态。
ref() 接收一个初始值，并将其包裹在一个具有 .value 属性的 ref 对象中返回
import { ref } from &amp;#34;vue&amp;#34;; const count = ref(0); console.log(count); // { value: 0 } console.log(count.value); // 0 要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们
在组件模板中访问 ref 时，不需要附加 .value，Vue 会自动解包。 你可以在事件监听器中修改 ref 的值。 对于更复杂的逻辑，可以在同一作用域内声明修改 ref 的函数，并将它们作为方法公开给模板。这样可以在事件监听器中使用这些方法。
&amp;lt;script setup&amp;gt;使用 &amp;lt;script setup&amp;gt; 可以大幅简化代码，避免手动暴露大量状态和方法。
&amp;lt;script setup&amp;gt; 中的顶层导入、变量和函数在同一组件的模板中可以直接使用。
为什么要使用 ref？ref 允许 Vue 自动检测变化并更新 DOM。这是通过 Vue 的响应式系统实现的。
Vue 使用 getter 和 setter 方法来拦截对 ref 的访问和修改，进而进行依赖追踪和触发更新。
ref 作为一个对象，具有 .value 属性：
// 伪代码，不是真正的实现 const myRef = { _value: 0, get value() { track(); return this._value; }, set value(newValue) { this._value = newValue; trigger(); }, };通过 ref，你可以将值传递给函数并保持响应式连接。当逻辑重构为可重用代码时，ref 是非常有用的。
深层响应性ref 可以持有任何类型的值，包括嵌套的对象、数组等。
ref 会使它的值具有深层响应性，即使对象内部发生变化也会被检测到。
非原始值将通过 reactive() 转换为响应式代理。
使用 shallowRef 可以避免深层响应性，适用于优化性能或外部库管理其内部状态的情况。
DOM 更新时机 …  ]]></content></entry><entry><title>2.4 计算属性</title><url>/post/vue3/0204-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html">  计算属性在模板中直接使用表达式虽然方便，但处理复杂逻辑时会使模板臃肿，难以维护。为了避免重复计算和提高代码可维护性，推荐使用 计算属性 来描述依赖响应式状态的复杂逻辑。
computed() 方法computed() 接受一个 getter 函数，该函数会根据响应式状态返回计算结果。 返回值为一个 计算属性 ref，你可以通过 .value 来访问其值。在模板中引用时，无需加 .value，它会自动解包。 计算属性会自动追踪响应式依赖，当依赖的响应式状态变化时，计算属性会自动重新计算。
计算属性缓存 vs 方法计算属性值会缓存，仅在其响应式依赖更新时重新计算。
如果你将相同的计算逻辑放入方法中，方法每次渲染时都会重新执行，即使计算逻辑没有变化。
因此，计算属性的效率较高，尤其在涉及重复计算时。
可写计算属性计算属性默认是只读的。当尝试修改一个计算属性时，会收到一个运行时警告。你可以通过提供 getter 和 setter 来创建一个 可写计算属性，允许计算属性具有读写能力。
get 用于返回计算属性的值，set 用于修改源状态。
获取上一个值如果需要获取计算属性返回的 上一个值，可以通过访问计算属性 getter 函数的第一个参数来实现。
最佳实践Getter 不应有副作用计算属性的 getter 只应做计算，没有副作用。 不要在 getter 中改变其他状态、发起异步请求或更改 DOM。 计算属性的职责是根据其他状态计算出一个派生值，getter 应仅计算并返回该值。 避免直接修改计算属性值计算属性返回的值是派生状态，应该视为 只读。 更改计算属性的返回值没有意义，应该更新其依赖的源状态来触发新的计算。   </content></entry><entry><title>2.5 class与style绑定</title><url>/post/vue3/0205-class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/</url><categories><category>vue3文档阅读</category></categories><tags><tag>vue</tag><tag>vue3</tag><tag>前端框架</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  v-bind: 用于将 HTML 元素的属性（包括 class 和 style）与动态数据绑定。
特殊增强: Vue 为 class 和 style 的 v-bind 提供了特殊功能，除了字符串，表达式的值也可以是对象或数组。
绑定 HTML class绑定对象使用 :class（v-bind:class 的缩写）可以绑定一个对象，根据对象的键值对动态地控制 class。
&lt;div :class=&#34;{ active: isActive }&#34;&gt;&lt;/div&gt;上面的语法表示 isActive 为 true 时，active 类会被添加；如果为 false，则移除该类。
可以在对象中定义多个类，按需控制多个类的添加或移除。
:class 指令可以与常规的 class attribute 共存。
绑定的对象不一定需要是内联的，可以直接绑定一个数据对象或计算属性。
绑定数组:class 可以绑定一个数组来渲染多个 CSS class。
可以在数组中使用三元表达式来实现有条件地渲染某个 class。为了避免冗长，可以在数组中嵌套对象来处理有多个依赖条件的 class。
在组件上使用当在组件上使用 class attribute 时，这些 class 会被添加到根元素上，并与该元素已有的 class 合并。
如果组件有多个根元素，可以通过组件的 $attrs 属性指定接收 class 的元素
绑定内联样式绑定对象:style 支持绑定 JavaScript 对象值，对应 HTML 元素的 style 属性。
推荐使用 camelCase 来命名样式属性，但 :style 也支持 kebab-case 形式的属性名。
绑定一个样式对象通常是好主意，可以使模板更简洁。
如果样式对象需要更复杂的逻辑，可以使用返回样式对象的计算属性。
:style 指令可以和常规的 style attribute 共存。
绑定数组:style 可以绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上。
自动前缀如果你在 :style 中使用需要浏览器特殊前缀的 CSS 属性，Vue 会自动为这些属性添加相应的前缀。
Vue 会在运行时检测浏览器支持的属性，并为不支持的属性自动加上浏览器前缀。
样式多值你可以为某个样式属性提供多个值，Vue 会渲染出当前浏览器支持的值。
&lt;div :style=&#34;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&#34;&gt;&lt;/div&gt;  ]]></content></entry><entry><title>4.1 原始值与引用值</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0401-%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  原始值与引用值ES 变量可包含两种数据类型：原始值和引用值，二者在存储、访问、复制等行为上存在本质差异。
基本定义与访问方式原始值：最简单的数据，对应 ES 六大基本数据类型（Undefined、Null、Boolean、Number、String、Symbol）。
保存原始值的变量按值访问，操作的是变量中存储的实际值。 引用值：由多个值构成的对象（如 Object、Array、Function 等）。
引用值保存在内存中，JS 无法直接操作内存空间，实际操作的是对象的引用（地址），保存引用值的变量按引用访问。 动态属性引用值：可随时添加、修改、删除其属性和方法，示例： let obj = {}; obj.name = &amp;#34;Alice&amp;#34;; // 新增属性 obj.age = 20; // 修改属性 delete obj.age; // 删除属性 原始值：不能有属性，尝试添加属性不会报错，但属性无法生效，示例： let str = &amp;#34;hello&amp;#34;; str.length = 10; // 无报错，但属性不生效 console.log(str.length); // 仍为 5（字符串原始值的内置 length 属性不受此影响） 特殊初始化：原始类型可通过原始字面量（如 let num = 10）初始化；若用 new 关键字（如 let num = new Number(10)），JS 会创建 Object 实例，但行为类似原始值。 复制值原始值复制：将原始值从一个变量赋给另一个变量时，原始值会被完整复制到新变量，两个变量独立（修改一个不影响另一个），示例： let a = 10; let b = a; // b 复制 a 的值（10） b = 20; console.log(a); // 10（a 不受 b 修改影响） 引用值复制：将引用值从一个变量赋给另一个变量时，复制的是指向堆内存对象的指针，两个变量指向同一个对象（修改一个会影响另一个），示例： let obj1 = { name: &amp;#34;Bob&amp;#34; }; let obj2 = obj1; // obj2 复制 obj1 的引用（指向同一对象） obj2.name = &amp;#34;Charlie&amp;#34;; console.log(obj1.name); // …  ]]></content></entry><entry><title>4.3 垃圾回收</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0402-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag><tag>性能优化</tag></tags><content type="html">  垃圾回收基础JS 是自动垃圾回收语言，执行环境负责代码运行时的内存管理（自动分配内存、回收闲置资源）。核心逻辑是：周期性判断“不再使用的变量”，释放其占用的内存（垃圾回收程序每隔一定时间自动运行）。
常见垃圾回收算法标记清理当前 JS 引擎最主流的垃圾回收算法，核心步骤如下：
标记阶段： 变量进入上下文（如函数内声明变量）时，标记为“存在于上下文”； 变量离开上下文（如函数执行完毕）时，标记为“离开上下文”； 垃圾回收程序运行时，先标记内存中所有变量。 清理阶段： 移除“存在于上下文的变量”及“被其引用的变量”的标记； 剩余带标记的变量=“无法被上下文访问的变量”，视为待回收； 销毁待回收变量，释放其内存。 引用计数早期算法，因缺陷已较少使用，核心逻辑是“通过引用次数判断变量是否可回收”：
计数规则： 声明变量并赋值引用值时，该值的引用数=1； 同一值被赋给其他变量，引用数+1； 保存该值引用的变量被覆盖（如赋值其他值），引用数-1。 回收时机：当值的引用数=0 时，下次垃圾回收程序运行时释放其内存。 核心缺陷：循环引用
若对象 A 引用对象 B，对象 B 同时引用对象 A，二者引用数永远不会变为 0，导致内存无法回收（如早期 COM 对象场景）。 解决方案：不再使用时，主动切断引用（如用 null 覆盖变量，示例：objA = null; objB = null）。 主动内存管理优化内存占用的核心是“只保留必要数据”，关键手段如下：
解除引用
数据不再必要时，将其赋值为 null，释放引用（让垃圾回收程序可识别为待回收）。 适用场景：全局变量/全局对象属性（局部变量超出作用域后会自动解除引用）。 注意：解除引用不代表立即回收内存，仅确保值“脱离上下文”，等待下次垃圾回收。 通过 const 和 let 提升性能 const/let 是块级作用域，变量在块执行完毕后更快脱离上下文，垃圾回收程序可更早回收内存； 对比 var（函数/全局作用域），减少内存占用时长。 隐藏类与性能优化（以 V8 引擎为例）V8 引擎通过“隐藏类”跟踪对象属性特征，共享相同隐藏类的对象性能更优（减少属性查找开销）。
隐藏类的共享条件对象需满足“相同构造函数+相同原型”，示例：
function Article() { this.title = &amp;amp;#34;Ingauration …  </content></entry><entry><title>3.4 操作符</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0304-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  ECMA-262 描述了一组可用于操作数据值的操作符，ES 中的操作符可用于各种值，在应用给对象时，操作符通常会调用 valueOf() 或 toString() 方法来取得可以计算的值
一元操作符只操作一个值的操作符叫一元操作符
递增递减操作符前缀递增操作符：给数值加 1，语法为 ++变量；前缀递减操作符：从数值减 1，语法为 --变量；无论使用前缀递增还是前缀递减，变量的值都会在语句被求值之前改变。 递增和递减的后缀版：语法分别是 变量++ 和 变量--，与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。 适用范围：这四个操作符可用于任何值（字符串、布尔值、浮点值、对象等），遵循如下规则： 字符串：若为有效的数值形式，转换为数值再应用改变，变量类型由字符串变为数值；若不是有效的数值形式，变量值设为 NaN，类型由字符串变为数值。 布尔值：若为 false，转换为 0 再应用改变；若为 true，转换为 1 再应用改变，变量类型均由布尔值变为数值。 浮点值：直接加 1 或减 1。 对象：调用其 valueOf() 方法取得可操作的值，对该值应用上述规则；若结果为 NaN，则调用 toString() 并再次应用其他规则，变量类型由对象变为数值。 一元加和减一元加：由一个加号 + 表示（语法：+变量），对数值无影响；若应用到非数值，会执行与 Number() 转型函数相同的类型转换。 一元减：由一个减号 - 表示（语法：-变量），主要用于把数值变为负值；若应用到非数值，会先执行与 Number() 转型函数相同的类型转换，再取负值。 位操作符有符号整数存储规则：使用 32 位，前 31 位表示整数值，第 32 位为符号位（0 表示正，1 表示负）；正值以二进制格式存储（31 位中每一位代表 2 的幂，空位以 0 填充）；负值以二补数（补码）存储，计算步骤为：
确定绝对值的二进制表示；
求一补数（反码，0 变 1、1 变 0）；
给结果加 1。
处理有符号整数：无法直接访问第 31 位，ES 会记录相关信息；将负值输出为二进制字符串时，会得到前面加了减号的绝对值（转换过程先求二补数，再以逻辑形式表示）。
后台转换逻辑：对 ES 中的数值应用位操作符时，64 位数值先转换为 32 位数值，执行位操作后，再将结果从 32 位转换为 64 位存储（过程如 …  </content></entry><entry><title>3.1 语法</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0301-%E8%AF%AD%E6%B3%95/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  ES 基础语法规则大小写敏感性ES 中所有内容（变量名、函数名、操作符等）均区分大小写（如num与Num是两个不同变量）。
标识符规则标识符是变量、函数、属性或参数的名称，需满足：
首字符：必须是字母（a-z/A-Z）、下划线（_）或美元符号（$）； 后续字符：可增加数字（0-9）； 字符范围：支持扩展 ASCII 字母和 Unicode 字母（如中文变量名，但不推荐，惯例用英文）； 命名惯例：采用小驼峰式（如userName、calculateTotal）； 禁用情况：不能使用关键字、未来保留字，也不能用true、false、null作为标识符。 注释方式采用 C 语言风格注释，分两种：
单行注释：以//开头，注释范围仅限当前行（如// 这是单行注释）； 块注释：以/*开头、*/结尾，可跨多行（如/* 这是跨多行的块注释 */）。 严格模式定义：一种严格的 JS 解析/执行模型，禁用 ES3 不规范写法，对不安全操作抛错； 启用方式： 全局启用：在脚本开头加&amp;quot;use strict&amp;quot;;（预处理指令）； 函数内启用：在函数体开头加&amp;quot;use strict&amp;quot;;； 核心目的：避免语法歧义，提升代码安全性和规范性。 语句规则分号结尾：语句需以分号（;）结束，省略时由解析器自动补全（但不推荐，可能导致语法错误）； 代码块：多条语句可包裹在花括号（{}）中形成代码块； 最佳实践：即使控制语句（如if、for）仅执行一条语句，也建议用代码块（{}）包裹，避免逻辑歧义。 关键词与保留字关键词定义：ECMA-262 保留的有特殊用途的词汇（如if、for、function、return等），用于控制语句、声明变量等； 限制：不能用作标识符或属性名（如不能定义let if = 1;）。 未来保留字定义：当前无特殊用途，但预留为未来版本关键字的词汇（如class、enum、export等，早期 ES 版本中部分已成为关键字）； 限制：不能用作标识符，虽部分可暂作属性名，但不推荐使用（避免兼容未来版本）。 ES 函数基础函数声明用function关键字声明，结构为：function 函数名(参数列表) { 函数体 }，示例：
// 声明一个计算两数和的函数 function add(num1, num2) { return …  ]]></content></entry><entry><title>3.2 变量</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0302-%E5%8F%98%E9%87%8F/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  变量声明：var、let、const 的核心差异变量是 JS 中保存数据的命名占位符，ES 提供 var、let、const 三种声明方式，核心差异体现在作用域、提升行为、可修改性上。
var 关键字（ES5 及之前）作用域：函数作用域（若在函数外声明则为全局作用域），无块级作用域（如 if/for 块内声明的 var 变量可在块外访问）。 初始化与类型： 可单独声明（var a;）或声明时赋值（var a = 1;）； 松散类型，可后续修改值的类型（如 a = &amp;amp;quot;hello&amp;amp;quot;）。 变量提升：var 声明的变量会自动提升到函数作用域顶部（仅声明提升，赋值不提升），示例： console.log(a); // undefined（声明提升，赋值未提升） var a = 1;全局变量特性：在全局作用域声明的 var 变量，会成为 window 对象的属性（如 var a = 1; console.log(window.a); // 1）。 重复声明：允许同一作用域内重复声明（如 var a = 1; var a = 2; 不报错，后者覆盖前者）。 函数内声明： 函数内用 var 声明的变量为局部变量（函数退出时销毁）； 省略 var 则为全局变量（不推荐，易污染全局作用域）。 严格模式限制：不可声明名为 arguments 或 eval 的变量。 let 声明（ES6+）作用域：块级作用域（{} 包裹的区域，如 if、for、函数块），块外无法访问。 重复声明：同一作用域内不允许重复声明（如 let a = 1; let a = 2; 报错），且与 var 混用时也报错（var a = 1; let a = 2; 报错）。 暂时性死区（TDZ）：let 声明的变量无变量提升，在声明语句之前的区域称为“暂时性死区”，引用变量会报错： console.log(a); // 报错（暂时性死区） let a = 1;全局变量特性：全局作用域声明的 let 变量，不会成为 window 对象的属性（如 let a = 1; console.log(window.a); // undefined），但仍在全局作用域存续。 for 循环特殊行为：let 声明的迭代变量（如 for (let i = 0; i &amp;amp;lt; 3; i++)），JS 引擎会为每个 …  </content></entry><entry><title>3.3 数据类型</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/0303-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>前端开发</tag></tags><content type="html">  数据类型分类简单数据类型（原始类型）：undefined、null、Boolean、number、string、symbol 复杂数据类型：object（一种无序名值对） ES 数据类型特性：灵活，一种数据类型可当作多种数据类型使用 typeof 操作符返回值：返回下列字符串之一——undefined、Boolean、string、number、object、function、symbol 语法示例： typeof message typeof(message) typeof 96 特性： 是操作符而非函数，无需参数，但可使用参数 调用 typeof null 返回 object（因 null 被视为空对象引用） 函数在 ES 中属对象，非独立数据类型，但因有特殊属性，typeof 可区分函数与其他对象 undefined 类型取值：仅一个值——undefined 赋值场景：用 var 或 let 声明变量但未初始化，变量默认赋予 undefined 值 使用建议： 无需显式给变量设 undefined 值，字面量 undefined 主要用于比较 ES3 前无 undefined，新增目的是明确空对象指针与未初始化变量的区别 变量区别： 包含 undefined 值的变量 ≠ 未定义变量 对未声明变量，仅有用操作是调用 typeof；调用 delete 不报错（无实际作用，严格模式下报错） 未初始化与未声明变量，typeof 均返回 &amp;amp;ldquo;undefined&amp;amp;rdquo; 初始化建议：声明变量时同时初始化，以便通过 typeof 返回 undefined 判断变量未声明（非未初始化） 布尔特性：undefined 是假值，可简洁检测 null 类型取值：仅一个值——null，表空对象指针 typeof 结果：调用 typeof null 返回 object 使用建议：定义将来存对象值的变量时，用 null 初始化（非其他值），便于后续检查变量是否重新赋予对象引用 与 undefined 关系： undefined 由 null 派生，== 比较二者始终返回 true（操作符会转换操作数） 用途不同：无需显式设变量为 undefined，但存对象的变量无对象可存时需设为 null 布尔特性：null 是假值，可简洁检测 Boolean 类型字面 …  </content></entry><entry><title>第二章 HTML中的JS</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/02-html%E4%B8%AD%E7%9A%84js/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>HTML</tag><tag>性能优化</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  script 元素：JS 插入 HTML 的核心方式script 元素是嵌入或引入 JS 代码的主要载体，分为“嵌入行内代码”和“引入外部文件”两种用法，且需遵循特定执行规则。
两种使用方式类型 实现方式 关键注意事项 嵌入行内代码 代码直接放在&amp;lt;script&amp;gt;与&amp;lt;/script&amp;gt;之间 - 代码从上到下解释，执行期间阻塞页面加载/显示；
- 代码中不可直接出现&amp;lt;/script&amp;gt;，需用转义（如\&amp;lt;\/script&amp;gt;）；
- 示例：&amp;lt;script&amp;gt;console.log(&amp;quot;hi&amp;quot;);&amp;lt;/script&amp;gt; 引入外部文件 通过src属性指定外部 JS 文件 URL（如src=&amp;quot;example.js&amp;quot;） - 外部文件仅需包含 JS 代码（无需&amp;lt;script&amp;gt;标签）；
- 执行期间阻塞页面，阻塞时间含文件下载时间；
- 浏览器不检查.js扩展名（非必需，但为惯例）；
- 若同时写src和行内代码，仅执行外部文件，忽略行内代码；
- src可指向外部域资源（如&amp;lt;script src=&amp;quot;https://xxx.com/xxx.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;） 执行顺序浏览器按&amp;lt;script&amp;gt;在页面中出现的顺序依次解释执行（无论嵌入还是引入外部文件）。
script 标签位置：影响页面渲染传统位置：早期放在&amp;lt;head&amp;gt;中，会导致 JS 执行时页面未渲染（因 JS 阻塞加载），出现“空白页”； 现代推荐位置：放在&amp;lt;body&amp;gt;元素内页面内容之后（如&amp;lt;/body&amp;gt;闭合前），确保页面完全渲染后再执行 JS，避免阻塞视觉呈现。 脚本执行控制：defer 与 async 属性两者均用于优化脚本执行（减少页面阻塞），仅对外部脚本文件有效，核心差异在“执行时机”和“顺序性”。
属性 下载行为 执行时机 执行顺序 关键说明 defer 立即下载（不阻塞页面） 页面完全解析完毕后、DOMContentLoaded事件前执行 按脚本出现顺序 脚本不修改页面结构（否则可能导致 DOM 操作异常）；多个 defer 脚本按顺序执行 async 立即下载（不阻塞页面） 下载完成后立即执行，可能 …  ]]></content></entry><entry><title>第一章 什么是JS</title><url>/post/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/01-%E4%BB%80%E4%B9%88%E6%98%AFjs/</url><categories><category>JS红宝书</category></categories><tags><tag>JavaScript</tag><tag>ECMAScript</tag><tag>DOM</tag><tag>BOM</tag><tag>前端开发</tag></tags><content type="html">  JavaScript 的核心构成JS 的完整实现由三部分组成，三者协同支撑前端交互功能：
核心（ECMAScript，ES）：定义语言的基础语法、类型、语句等核心规则，是跨环境（浏览器、Node.js 等）的通用标准，无输入输出能力，需依赖宿主环境扩展。 文档对象模型（DOM）：提供操作 HTML/XML 文档结构的 API，将页面抽象为分层节点树，支持增删改查节点，实现“网页内容与结构的动态控制”。 浏览器对象模型（BOM）：用于操作浏览器窗口（如弹窗、地址栏、历史记录），控制“页面之外的浏览器功能”，早期无标准，HTML5 后逐步统一。 ECMAScript（ES）详解ES 的核心定义与规范内容本质：ECMA-262 标准定义的语言基准，宿主环境（如浏览器）在此基础上添加扩展功能（如 DOM/BOM）。 ECMA-262 规定的核心部分： 语法、数据类型（如 String、Number、Object）、语句（if/for）、关键字（var/function）、保留字； 操作符（+、=== 等）、全局对象（如 Math、Date）。 关键 ES 版本迭代（核心特性）版本（俗称） 发布时间 核心新增特性 ES3 1999 年 正则表达式、try/catch 异常处理、新控制语句 ES5（ES3.1） 2009 年 JSON 原生解析/序列化、严格模式、Object 扩展方法（如 Object.keys） ES6（ES2015） 2015 年 类（class）、模块（import/export）、箭头函数、Promise、let/const、迭代器/生成器 ES7（ES2016） 2016 年 Array.prototype.includes、指数操作符（**） ES8（ES2017） 2017 年 async/await 异步函数、Object.values/entries、字符串填充（padStart/padEnd） ES9（ES2018） 2018 年 异步迭代（for await&amp;amp;hellip;of）、正则表达式扩展、剩余/扩展属性 ES10（ES2019） 2019 年 Array.prototype.flat/flatMap、String.trimStart/trimEnd、Object.fromEntries ES 符合性要求必选条件： …  </content></entry></search>