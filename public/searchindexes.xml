<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>归档</title><url>/archives/custom_archieves/</url><categories/><tags/><content type="html">  {{ define "main" }}{{ T "archive" }}{{ range .Site.RegularPages.ByDate.Reverse.GroupByDate "2006-01" }}{{ .Key | time.Format "2006年1月" }}({{ len .Pages }}){{ range .Pages }}{{ .Date.Format "02日" }}{{ .Title }}{{ end }}{{ end }}{{ end }}  </content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0405--%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 多线程</tag><tag>Web Worker 通信</tag><tag>性能优化</tag><tag>结构化克隆</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  一、Web Worker 基础定义与作用：
Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。 创建与类型：
专用 Worker（Dedicated Worker）：通过 new Worker(&#39;script.js&#39;) 创建，与主程序是一对一关系，仅能与创建它的程序通信。
示例：
// 主程序中创建专用 Worker const w1 = new Worker(&amp;#34;worker.js&amp;#34;);二、Worker 通信机制消息传递：
不共享作用域 / 资源，通过 message 事件双向通信，数据传递基于结构化克隆或所有权转移。
主程序与 Worker 内部均通过 postMessage(data)发送消息，通过 onmessage 监听消息：
// 主程序 w1.postMessage(&amp;#34;hello&amp;#34;); // 发送消息到 Worker w1.onmessage = (e) =&amp;gt; console.log(&amp;#34;收到 Worker 消息：&amp;#34;, e.data); // worker.js 内部 self.onmessage = (e) =&amp;gt; { console.log(&amp;#34;收到主程序消息：&amp;#34;, e.data); self.postMessage(&amp;#34;hi&amp;#34;); // 发送消息到主程序 };终止 Worker：
主程序中调用 w1.terminate() 可立即终止 Worker（无清理机会）； Worker 内部可调用 self.close() 主动终止自身。 三、Worker 运行环境限制与可用资源： 不可访问 DOM、主程序全局变量，但可使用 navigator、location、JSON、setTimeout 等，支持网络请求（如 fetch）。 可通过 importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;) 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。 典型应用场景： 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。 四、数据传 …  ]]></content></entry><entry><title>4.4节 生成器</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0404--%E7%94%9F%E6%88%90%E5%99%A8/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 异步</tag><tag>生成器函数</tag><tag>迭代器接口</tag><tag>异步协作</tag><tag>前端开发</tag></tags><content type="html">  一、生成器的基本概念与特性定义与控制方式： 生成器是一类特殊函数，声明方式为function*（函数名前加*），可暂停、恢复执行，不一定需要完成。 通过迭代器控制生成器：调用生成器函数（如*foo()）会返回一个迭代器对象（如it），通过it.next()启动或恢复生成器执行，直至下一个yield或结束。 next()与yield的交互： next()返回一个对象{ value, done }：value是yield产出的值，done为布尔值（true表示生成器执行完毕）。 yield作为表达式可双向传递消息：yield向外发送值，next()可向暂停的yield传入值（第一个next()的参数会被忽略，因此时无暂停的yield）。 生成器实例与并发： 每次通过生成器函数创建迭代器，均对应生成器的一个独立实例，实例间可独立运行甚至交互。 二、生成器产生值：生产者与迭代器1. 迭代器接口作用：定义从生产者逐步获取一系列值的标准接口，核心是next()方法。 next()返回值：{ done: boolean, value: any }，done标识迭代是否结束，value为当前迭代值。 2. for..of循环自动迭代标准迭代器：每次循环调用next()，不传入参数，遇done: true自动停止。 支持内建可迭代对象：如数组（array）等内建数据结构默认实现迭代器，可直接用于for..of。 3. Iterable（可迭代对象）定义：包含迭代器的对象，需实现Symbol.iterator方法（调用时返回一个新迭代器）。 for..of的依赖：for..of循环期望操作可迭代对象，通过调用其Symbol.iterator获取迭代器。 4. 生成器迭代器的特性生成器执行后返回的迭代器兼具迭代器接口与生成器控制能力。 异常终止：for..of因break、return或未捕获异常终止时，会向迭代器发送停止信号；可手动调用it.return(value)终止生成器，返回{ value: 传入值, done: true }。 三、异步迭代生成器生成器可简化异步流程，将异步操作抽象为同步形式的代码：
function foo(x, y) { ajax(&amp;amp;#34;http://...&amp;amp;#34;, (err, data) =&amp;amp;gt; { if (err) …  </content></entry><entry><title>4.3节 Promise</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0403--promise/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 异步</tag><tag>Promise 原理</tag><tag>异步模式</tag><tag>错误处理</tag><tag>前端开发</tag></tags><content type="html">  什么是 Promise1. 未来值核心特性：Promise 封装了一个 “未来才会确定的值”，将 “现在”（发起异步操作）和 “将来”（操作结果）的逻辑归一化，确保输出可预测。 状态与不可变性： 封装依赖时间的状态（等待、完成、拒绝），自身与时间无关，可按可预测方式组合。 一旦决议（完成或拒绝），状态永久固定为 “不变值”，可多次查看且不会被修改，多方依赖时观察结果一致。 then 方法的双回调：调用then(onFulfilled, onRejected)时，第一个参数处理 “完成”（操作成功），第二个处理 “拒绝”（操作失败）。 2. 完成事件（流程控制）本质：Promise 的决议可作为异步任务中多步骤的流程控制信号（时序上的 “this-then-that”）。 反控制反转： 传统回调存在 “控制反转”（第三方控制回调执行），而 Promise 通过 “侦听决议事件” 反转这种关系 —— 调用者通过then注册回调，等待 Promise 决议后触发，将控制返还给调用代码。 信号特性：决议可仅作为流程信号（不传递具体值），且一旦决议，后续步骤逻辑始终一致（无论现在或将来决议）。 具有 then 方法的鸭子类型thenable 定义：任何具有then方法的对象或函数，被视为与 Promise 一致的 “thenable”。 鸭子类型：通过值的形态（是否有then方法）假定其类型，这是识别 Promise 的核心逻辑。 Promise 信任问题（可靠性保障）异步回调：对 Promise 调用then时，即使 Promise 已决议，回调也始终异步执行（下一个事件循环 tick），确保行为一致。 决议的唯一性： Promise 只能被决议一次（首次调用resolve或reject生效，后续调用被忽略），因此then注册的回调仅执行一次。 若同一回调多次注册，会按注册次数执行。 决议值的单一性： 至多有一个决议值（未显式决议时为undefined），传给所有注册的回调。 调用resolve/reject时，仅第一个参数有效，后续参数被忽略；多值需封装为数组 / 对象传递。 异常处理：Promise 创建或决议过程中出现的 JS 异常会被捕捉，导致 Promise 被拒绝。 Promise.resolve 的作用： 传入非 Promise / …  </content></entry><entry><title>4.1节 异步：现在与将来</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0401--%E5%BC%82%E6%AD%A5%E7%8E%B0%E5%9C%A8%E4%B8%8E%E5%B0%86%E6%9D%A5/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 异步</tag><tag>事件循环机制</tag><tag>微任务与宏任务</tag><tag>并发协调</tag><tag>前端开发</tag></tags><content type="html">  一、分块的程序与异步机制分块程序的本质： 将代码包装为函数并指定其响应某个事件执行时，即创建了 “将来执行的块”，由此引入异步机制 —— 代码不再按顺序同步执行，而是分阶段在不同时间点运行。 console.log 的异步特性： 部分浏览器的console.log并非立即输出内容，因 IO 操作通常低速且阻塞，浏览器会后台异步处理控制台 IO 以提升性能，可能导致输出顺序与代码执行顺序不一致。 二、事件循环核心机制： 事件循环是处理程序中多个代码块执行的机制，通过调用 JS 引擎依次执行块。循环的每一轮称为一个tick：
若队列中有等待事件（即回调函数），则从队列中取出一个执行； 无事件时，循环等待新事件加入。 核心流程，循环周期（tick）：检查 “宏任务队列”（如setTimeout、DOM事件），若有等待任务，取出第一个执行； 执行完当前任务后，检查 “微任务队列”（如Promise.then），清空所有微任务； 更新 UI（浏览器环境）； 重复步骤 1-3。 setTimeout 的作用： 并非直接将回调函数加入事件循环队列，而是设定定时器：当定时器到期后，宿主环境会将回调函数放入事件循环队列，等待未来某个 tick 执行。
三、并行执行异步与并行的区别： 异步：关注 “现在与将来的时间间隙”（代码块在不同时间点执行）； 并行：关注 “同时发生”（多个操作在物理上同时进行）。 进程与线程： 进程和线程独立运行，可能并行执行，多线程可共享单个进程的内存； JS 通过 “单线程事件循环” 避免共享内存的并行访问 / 修改，但可通过多线程的事件循环协作实现并行与顺序执行共存。 JS 的单线程特性： 函数代码具有原子性（完整运行特性）：一旦函数开始执行，会在其他代码运行前完成（无中断）； 若函数执行顺序不确定，可能导致竞态条件（因共享状态的修改顺序不可控引发的逻辑错误）。 四、并发定义： 两个或多个进程（虚拟进程 / 任务，即逻辑相关的运算序列）“同时执行”，无论单个运算是否并行。可理解为 “进程级的并行”，与 “运算级的并行” 相对。
JS 的并发形式： 单线程事件循环是并发的一种形式 ——JS 一次只能处理一个事件，不会严格 “同时” 执行，但多个任务可交替在事件循环中运行。
并发交互的协调方式：
门（Gate）：等待多个条件都满足后再执行下一步。例 …  </content></entry><entry><title>4.2节 回调</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0402--%E5%9B%9E%E8%B0%83/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 异步</tag><tag>回调函数</tag><tag>回调地狱优化</tag><tag>错误优先回调</tag><tag>前端开发</tag></tags><content type="html">  回调函数的本质回调函数的核心作用是包裹或封装程序的延续逻辑—— 即当前操作完成后 “接下来要执行的代码”。通过回调，我们可以定义异步操作（如网络请求、定时器）结束后应执行的步骤。
回调地狱（Callback Hell）的成因回调地狱指多层嵌套回调导致的代码可读性差、维护困难问题，根源在于两点：
思维与代码的不匹配：人类习惯线性、顺序的思维模式，而回调驱动的异步代码需要嵌套表达 “先完成 A，再做 B，然后做 C” 的逻辑，形成 “金字塔式嵌套”。
控制反转导致的信任问题： 回调将代码执行控制权交给第三方（如异步 API），导致 “信任链断裂”：
无法确保回调被调用的次数（可能被多次调用或不调用）； 无法确保回调在预期的时机执行（可能过早、过晚或在错误的上下文）； 无法确保回调的参数符合预期。 回调模式的优化设计为缓解回调地狱和信任问题，常见的回调模式设计：
分离回调（Split Callbacks）： 为成功和错误分别指定回调函数，避免在单一回调中用条件判断区分结果。
错误优先回调（Error-First Callbacks，Node 风格）： 回调函数的第一个参数固定为错误对象，后续参数为成功结果：
若操作成功，错误参数为null或undefined； 若操作失败，错误参数为非空值（通常是Error对象）。 回调调用的最佳实践：永远异步执行即使回调逻辑可以同步完成，也应强制异步调用（如通过setTimeout或队列机制），确保回调行为的一致性：
避免同步回调导致的 “时序混乱”（如回调在异步操作触发前执行）； 保证所有回调都遵循相同的异步逻辑，减少不可预测性。   </content></entry><entry><title>3.5节 语法</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0305--%E8%AF%AD%E6%B3%95/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 语法</tag><tag>表达式副作用</tag><tag>运算符短路</tag><tag>ASI 规则</tag><tag>前端开发</tag></tags><content type="html">  一、语句与表达式的基本概念表达式：能返回一个结果值的代码片段（如1 + 2返回3，obj.prop返回属性值）。 语句：执行某种操作的代码（如if、for、return），所有语句都有结果值，但语法默认不允许直接获取。 语句的结果值常见语句的结果值： 赋值语句a = b：结果值为被赋予的值（即b的值）。 变量声明var a：结果值为undefined（let/const同理）。 代码块{...}：结果值为块内最后一个语句 / 表达式的结果（如{1; 2; 3}结果为3）。 获取语句结果值的方式：语法不直接支持，但可通过eval()获取（如eval(&amp;#39;{a=1; b=2}&amp;#39;)返回2）。 二、表达式的副作用副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。
常见有副作用的表达式函数调用：最常见（如console.log(1)会输出内容，改变控制台状态）。 自增 / 自减运算符： a++：先返回a的当前值，再将a加 1（副作用在后）。 ++a：先将a加 1，再返回新值（副作用在前）。 注意：++a++会报错（ReferenceError），因运算符需要可赋值的变量作为操作数。 逗号运算符：将多个表达式串联为一个语句，返回最后一个表达式的结果（如a=1, b=2, a+b结果为3），副作用是执行所有表达式。 delete 操作符： 作用：删除对象属性或数组单元。 结果值：成功删除（属性不存在或可配置）返回true；失败（不可配置属性）返回false或报错。 副作用：实际移除属性 / 单元（如delete obj.prop后obj.prop为undefined）。 赋值语句：a = 42结果为42，副作用是a被赋值为42；链式赋值（如a = b = 42）利用赋值表达式的结果值实现。 三、上下文规则3.1 大括号{}的用法对象常量：定义对象字面量（如{a: 1, b: 2}）。
标签（label）：用于标记代码块，配合break/ continue跳转：
break 标签：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。 continue 标签：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。 注意：标签不能用双引号；非循环代码块可使用break 标签，但不能用continue 标签。 JSON …  </content></entry><entry><title>附录 混合环境JS</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/%E9%99%84%E5%BD%95-%E6%B7%B7%E5%90%88%E7%8E%AF%E5%A2%83js/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 兼容性</tag><tag>宿主环境</tag><tag>Annex B 规范</tag><tag>script 标签</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  一、Annex B（ES 规范的兼容性补充）背景： ECMAScript（ES）是 JS 的官方规范，Annex B 专门定义因浏览器兼容性问题导致的与官方规范的差异，主要针对浏览器环境的 JS 实现。
主要兼容性差异：
非严格模式允许八进制数值常量（如012，严格模式下为语法错误）；
浏览器提供window.escape()和window.unescape()，用于转义 / 还原带%分隔符的十六进制字符串（非标准方法，建议避免使用）；
String.prototype.substr与String.prototype.substring
的区别：
substring(start, end)：第二个参数为结束位置索引（不包含该位置）； substr(start, length)：第二个参数为截取长度。 Web ES 规范的额外差异：
&amp;lt;!--和--&amp;gt;被视为合法单行注释分隔符； String.prototype包含返回 HTML 格式字符串的附加方法（如anchor()、bold()）； 正则表达式（RegExp）扩展及Function.prototype附加方法（非标准，依赖浏览器实现）。 二、宿主对象定义：由宿主环境（如浏览器、Node.js）创建并提供给 JS 引擎的对象 / 函数（如window、document、console），包括内建对象和工具函数。 特殊行为差异： 部分宿主对象强制转换为布尔值时可能为假值（如document.all，不符合 JS 标准假值规则）； 其他特性： 可能无法访问普通Object的内建方法（如toString()）； 部分属性为只读，无法覆盖； 方法的this无法重绑定到其他对象。 console 对象： 宿主环境提供的输出工具，浏览器中输出到开发控制台，Node.js 中指向标准输出（stdout）和标准错误输出（stderr）。 三、全局 DOM 对象全局变量与 global 对象：声明全局变量会同时在全局对象（如浏览器的window）中创建同名属性。 DOM 元素 ID 的副作用：因浏览器历史遗留问题，带id属性的 DOM 元素会自动创建同名全局变量（如&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;会生成window.app）。 四、原生原型扩展的注意事项不建议扩展原生原型：除非确保无代码 …  ]]></content></entry><entry><title>第十章 远程共同协作</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/10--%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 远端操作</tag><tag>GitHub 协作</tag><tag>版本控制工具</tag><tag>Git 命令</tag><tag>静态网站搭建</tag></tags><content type="html"><![CDATA[  将内容推送到 GitHub前置准备
在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。 关联远端仓库
git remote add origin &amp;lt;GitHub仓库地址&amp;gt;remote add：添加远端节点。
origin：远端 节点的默认名称（可自定义或修改）。
远端仓库管理（补充操作）- **查看远端配置**：`git remote -v`（显示远端名称、地址及操作类型，确认是否关联正确）。- **修改远端地址**：`git remote set-url origin &amp;lt;新地址&amp;gt;`（如仓库迁移后更新地址）。- **删除远端关联**：`git remote remove origin`（解除与远端的绑定）。推送内容到远端
git push -u origin master作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。 后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。 upstream 作用 本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。 推送时重命名分支
git push origin master:cat # 将本地master推送到远端并命名为cat从 GitHub 拉取更新（pull/fetch）命令 本质 适用场景 git fetch 仅获取远端更新（更新origin/xxx分支），不合并 需先查看远端修改再决定是否合并（安全） git pull git fetch + git merge 快速同步远端修改（可能产生合并 commit） git pull --rebase git fetch + git rebase 保持历史线性（无合并 commit，推荐协作场景） fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。 pull …  ]]></content></entry><entry><title>09- 类</title><url>/post/ts/09--%E7%B1%BB/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 进阶</tag><tag>类与面向对象</tag><tag>访问修饰符</tag><tag>抽象类</tag><tag>前端开发</tag></tags><content type="html">  类的字段字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。
基本特性 字段声明默认创建公共可写属性，类型可显式声明（如x: number）或通过初始化值推断（如x = 0 → 推断为number）。 未指定类型且无初始化值时，隐式为any（可通过noImplicitAny禁用，强制显式声明）。 初始化相关 初始化器：字段可直接赋值（如x = 0），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。 strictPropertyInitialization 配置： 开启时，字段必须在构造函数内或初始化器中初始化，否则报错（防止访问未初始化的属性）。 例外：用!（明确赋值断言）标记 “后续会初始化” 的字段（如name!: string，常用于依赖注入场景）。 注意：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。 readonly 修饰符 标记字段为只读，仅可在初始化器或构造函数中赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。 构造函数类的初始化函数，用于实例化时设置初始状态。
与函数的异同 相似性：支持类型注释、默认值、重载（如多构造函数签名）。 区别： 不能有类型参数（类型参数属于外部类声明）； 不能有返回类型注释（默认返回类实例类型）。 super () 调用要求 派生类构造函数中，使用this前必须调用super()（调用基类构造函数），否则 TypeScript 报错。 方法与访问器类的函数属性，用于定义行为和属性访问逻辑。
方法 本质是类的函数属性，支持类型注释（参数和返回值）。 方法体内访问字段 / 其他方法必须通过this.，否则引用外部变量。 访问器 包括get（读取）和set（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。 TypeScript 推断规则： 仅有get时，属性自动为readonly； 未指定set参数类型时，从get返回类型推断； 4.3+ 版本支持get和set使用不同类型。 注意：无额外逻辑的get/set对意义不大，建议直接用公共字段。 索引签名类可声明索引签名，与对象类型索引签名规则一致。
示例：class MyClass { [s: string]: …  </content></entry><entry><title>06- 泛型</title><url>/post/ts/06--%E6%B3%9B%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 高级</tag><tag>泛型机制</tag><tag>类型系统</tag><tag>方差</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  类型变量类型变量是泛型的 “灵魂”，用于在类型层面建立关联（而非值层面），解决 “同一份逻辑适配多种类型” 的问题。
基本用法// 定义泛型函数：类型变量&amp;lt;Type&amp;gt;关联输入与输出类型 function identity&amp;lt;Type&amp;gt;(arg: Type): Type { return arg; } // 两种调用方式 let output1 = identity&amp;lt;string&amp;gt;(&amp;#34;myString&amp;#34;); // 显式指定类型参数 let output2 = identity(42); // 类型推断（推荐）：编译器自动推断Type为number 核心价值：避免重复编写不同类型的同名函数（如identityString、identityNumber），同时保持类型安全（对比any：any会丢失类型关联，泛型则保留输入与输出的类型一致性）。 类型推断：编译器可通过传入的值自动推断类型参数，简化代码。复杂场景下若推断失败，需显式指定类型。 类型约束：函数体内必须正确使用泛型参数（视为 “任意类型” 处理）。 泛型函数的类型定义泛型函数的类型与非泛型函数类似，需先声明类型参数，有多种表达方式：
直接作为函数类型
let myIdentity: &amp;lt;Type&amp;gt;(arg: Type) =&amp;gt; Type = identity;使用不同名称的类型变量（只要数量和使用方式一致）
let myIdentity: &amp;lt;Input&amp;gt;(arg: Input) =&amp;gt; Input = identity; // 合法：Input与Type作用相同 对象字面量的调用签名
let myIdentity: { &amp;lt;Type&amp;gt;(arg: Type): Type } = identity;泛型接口
// 接口内声明泛型调用签名 interface GenericIdentityFn { &amp;lt;Type&amp;gt;(arg: Type): Type; } let myIdentity: GenericIdentityFn = identity; // 接口本身泛型化（更常用） interface GenericIdentityFn&amp;lt;Type&amp;gt; { (arg: Type): Type; } let …  ]]></content></entry><entry><title>07- 类型运算符</title><url>/post/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 进阶</tag><tag>类型工具</tag><tag>类型系统</tag><tag>类型查询</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  keyof 运算符keyof 用于将对象类型的所有键名转换为字面量联合类型，是实现 “类型安全的键访问” 的基础。
基础用法type Point = { x: number; y: number }; type P = keyof Point; // 等价于 type P = &amp;#34;x&amp;#34; | &amp;#34;y&amp;#34; 作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。 与索引签名结合当对象类型包含 string 或 number 索引签名时，keyof 会返回对应的索引类型：
// number 索引签名 type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; // type A = number（仅允许 number 类型索引） // string 索引签名 type Mapish = { [k: string]: boolean }; type M = keyof Mapish; // type M = string | number 因为 JavaScript 会将数字索引自动转换为字符串（如 obj[0] 等价于 obj[&amp;quot;0&amp;quot;]），因此 string 索引签名隐含支持 number 索引。 keyof与Object.keys的区别： keyof：在类型层面工作，返回键的字面量联合类型（编译时）。 Object.keys：在值层面工作，返回键的字符串数组（运行时）。 typeof 运算符（类型上下文）typeof 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。
基本用法let s = &amp;#34;hello&amp;#34;; let n: typeof s; // 类型为 string（n 的类型与 s 一致） 与函数结合获取函数的类型（而非调用结果的类型），配合 ReturnType 可提取返回值类型：
function f() { return { x: 10, y: 3 }; } type FType = typeof f; // () =&amp;gt; { x: number; y: number } …  ]]></content></entry><entry><title>08- 条件类型</title><url>/post/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 高级</tag><tag>类型系统</tag><tag>类型工具</tag><tag>条件类型</tag><tag>映射类型</tag></tags><content type="html"><![CDATA[  条件类型条件类型通过判断类型关系返回不同类型，基本形式为 SomeType extends OtherType ? TrueType : FalseType，核心价值在于与泛型结合实现灵活的类型逻辑。
基本用法当 SomeType 可赋值给 OtherType 时，返回 TrueType；否则返回 FalseType
type Example1 = Dog extends Animal ? number : string; // 若Dog是Animal的子类型，返回number 与泛型结合条件类型与泛型结合可简化重载，实现类型与值的动态关联：
// 需求：输入number返回IdLabel，输入string返回NameLabel type IdLabel = { id: number }; type NameLabel = { name: string }; // 条件类型关联输入与输出类型 type Label&amp;lt;T extends number | string&amp;gt; = T extends number ? IdLabel : NameLabel; // 单个函数替代重载 function createLabel&amp;lt;T extends number | string&amp;gt;(value: T): Label&amp;lt;T&amp;gt; { return typeof value === &amp;#34;number&amp;#34; ? { id: value } : ({ name: value } as Label&amp;lt;T&amp;gt;); } const label1 = createLabel(10); // 类型：IdLabel（{ id: number }） const label2 = createLabel(&amp;#34;Alice&amp;#34;); // 类型：NameLabel（{ name: string }） 类型推断与 infer通过 infer 关键字在条件类型中声明性推断类型，无需显式指定提取逻辑：
示例 1：提取数组元素类型
type Flatten&amp;lt;Type&amp;gt; = Type extends Array&amp;lt;infer Item&amp;gt; ? Item : Type; type Str = …  ]]></content></entry><entry><title>第九章 其他常见的情况及冷知识</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/09--%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%8A%E5%86%B7%E7%9F%A5%E8%AF%86/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 进阶操作</tag><tag>工作区临时保存</tag><tag>敏感信息处理</tag><tag>选择性合并</tag><tag>垃圾回收机制</tag></tags><content type="html"><![CDATA[  工作中途切换任务的处理（git stash）git stash用于临时保存工作区和暂存区的修改（未提交的内容），以便切换分支处理其他任务，后续可恢复继续工作。
保存当前修改： git stash # 保存已跟踪文件的修改（默认不包含untracked文件） git stash -u # 同时保存untracked文件（新文件） git stash -a # 保存所有修改（包括untracked和ignored文件，谨慎使用） git stash -m &amp;#34;描述信息&amp;#34; # 给stash添加描述，便于区分（推荐）查看保存的 stash： git stash list # 列出所有stash，格式：stash@{n}: WIP on &amp;lt;分支名&amp;gt;: &amp;lt;描述&amp;gt; # 示例：stash@{0}: WIP on feature/login: 完善表单验证恢复 stash：
git stash pop &amp;lt;stash@{n}&amp;gt;：恢复指定 stash 并从列表中删除（默认恢复最新的 stash@{0}）。 git stash apply &amp;lt;stash@{n}&amp;gt;：恢复指定 stash 但不删除（可多次应用，适合多分支复用）。 删除 stash：
git stash drop &amp;lt;stash@{n}&amp;gt; # 删除指定stash git stash clear # 清空所有stash（谨慎！）移除 Git 历史中的敏感信息（如账号密码）当不慎提交敏感文件后，需彻底从历史中删除。
推荐方法：git filter-repo（现代替代filter-branch） git filter-branch因性能差、易出错已被官方推荐git filter-repo替代（需先安装：pip install git-filter-repo）。
移除历史中的敏感文件：
# 彻底删除历史中所有&amp;#34;敏感文件路径&amp;#34;的痕迹 git filter-repo --path &amp;#34;敏感文件路径&amp;#34; --invert-paths--path：指定要删除的文件路径； --invert-paths：保留除指定路径外的所有内容（即删除目标文件）。 简单但粗暴的方法 删除 .git 目录（丢失所有历史）→ 删除敏感文件 → 重新初始化仓 …  ]]></content></entry><entry><title>05- 对象类型</title><url>/post/ts/05--%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 进阶</tag><tag>对象类型系统</tag><tag>泛型数据结构</tag><tag>元组</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  对象类型的基本定义对象类型是 TS 中描述数据结构的核心方式，主要有三种定义形式：
匿名对象类型 直接在参数或变量声明中定义，无需命名：
function greet(person: { name: string; age: number }) { return &amp;#34;Hello &amp;#34; + person.name; }接口（interface） 通过interface关键字命名对象类型，支持声明合并（多次定义同一接口会自动合并），可复用：
interface Person { name: string; age: number; } function greet(person: Person) { /* ... */ }类型别名（type alias） 通过type关键字为对象类型命名：
type Person = { name: string; age: number; }; function greet(person: Person) { /* ... */ }面试高频对比：
场景 interface type 声明合并 支持 不支持（重复声明报错） 扩展方式 extends继承 交叉类型（&amp;amp;）合并 适用类型 仅对象 / 类形状 任意类型（对象、联合、基础类型等） 对象属性的特性对象类型的属性可通过修饰符指定特性：
可选属性
标记为?的属性可省略，类型为T | undefined（在strictNullChecks开启时需显式处理undefined）。
示例：
interface User { name: string; age?: number; // 可选属性 } const user: User = { name: &amp;#34;Alice&amp;#34; }; // 合法，age可省略 只读属性（readonly）
标记为readonly的属性在类型检查期间不可被重写，但不影响其内部内容的可变性（如对象属性仍可修改）。
TypeScript 检查类型兼容性时不考虑readonly，因此可通过别名修改只读属性。
示例：
interface Point { readonly x: number; readonly y: number; } const p: Point = { x: 1, y: 2 }; p.x = 3; // 错误：只读属 …  ]]></content></entry><entry><title>第八章和第十一章 标签和gitflow</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/0811--%E6%A0%87%E7%AD%BE%E5%92%8Cgitflow/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 标签管理</tag><tag>Git Flow 分支模型</tag><tag>版本管理规范</tag><tag>团队协作流程</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  Git 标签相关知识一、标签的概念与作用标签是 Git 中指向某个 commit 的指示标，常用于标记软件开发的特定里程碑（如版本发布）。 标签本质类似 “贴纸”，标签一旦创建，默认不会随新提交移动，删除标签不会影响对应的 commit 或文件。 二、标签的类型及使用轻量标签
特点：仅作为指向某个 commit 的指示标，不含额外信息。
创建方式：直接指定 commit（若不指定则默认当前 commit）
git tag &amp;lt;标签名&amp;gt; [commit的SHA-1值]示例：
git tag big_cats 51d54ff存储：指向某个 commit 的 SHA-1 值，存于 .git/refs/tags 目录。
有附注的标签
特点：包含更多信息（如标签创建者、时间、描述等），推荐使用。
创建方式：通过-a 参数创建，-m 可添加描述（若无-m则弹出 vim 编辑器）
```bashgit tag &amp;lt;标签名&amp;gt; [commit 的 SHA-1 值] -a -m &amp;ldquo;描述信息&amp;rdquo;
示例： ``` git tag big_cats 51d64ff -a -m &amp;#34;big cats are comming&amp;#34;存储：指向某个 Tag 对象的 SHA-1 值，该 Tag 对象再指向对应的 commit，存于 .git/refs/tags 目录。
标签的查看与删除
查看标签信息：git show &amp;lt;标签名&amp;gt;（如 git show big_cats） 删除标签：git tag -d &amp;lt;标签名&amp;gt;（如 git tag -d big_cats） 三、标签与分支的区别对比项 标签 分支 存储位置 .git/refs/tags 目录 .git/refs/heads 目录 内容格式 40 字节的 SHA-1 值 40 字节的 SHA-1 值 动态性 固定不变，不会随新 commit 移动 会随新 commit 推进而移动 本质类比 固定的 “贴纸” 可移动的 “标签” 删除影响 不影响被指向的对象 不影响被指向的对象 Git Flow 分支模型Git Flow 是一种规范化的分支管理流程，适用于中大型项目的协同开发，核心是通过不同类型分支的分工保证代码质量。
Git Flow 建议的分支类型及功能如 …  ]]></content></entry><entry><title>03- 类型缩小</title><url>/post/ts/03--%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 进阶</tag><tag>类型系统</tag><tag>控制流分析</tag><tag>类型保护</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  类型缩小与控制流分析基础TS 会跟踪代码执行路径（如if/else、switch、循环等），分析变量在不同分支中的具体类型。
类型保护：特殊表达式（如typeof x === &#39;string&#39;），TS 可通过它判断变量类型，从而缩小类型范围。
类型缩小：通过类型保护或赋值操作，将变量类型从 “宽泛”（如联合类型）收缩为 “具体”（如单一类型）的过程。
基于 typeof 运算符的类型缩小TS 可识别typeof的 8 种返回值：&amp;quot;string&amp;quot;、&amp;quot;number&amp;quot;、&amp;quot;bigint&amp;quot;、&amp;quot;boolean&amp;quot;、&amp;quot;symbol&amp;quot;、&amp;quot;undefined&amp;quot;、&amp;quot;object&amp;quot;、&amp;quot;function&amp;quot;。
typeof 检查是一种类型保护，TypeScript 编码了 typeof 对不同值的操作逻辑，包括其在 JavaScript 中的一些特性。
基于真值检查的类型缩小JavaScript 中，if 等构造会将条件强制为布尔值，0、NaN、&amp;quot;&amp;quot;（空字符串）、0n（bigint 版本零）、null、undefined 强制为 false，其他值强制为 true。
可通过 Boolean 函数或双布尔否定（!!）将值强制为布尔值，后者的优势是 TypeScript 会推断出缩小的字面布尔类型 true，而前者推断为 boolean 类型。
利用这种行为防范 null 或 undefined 很常见，带有!的布尔否定会从否定分支中过滤掉这些值。
基于相等性检查的类型缩小TypeScript 使用 switch 语句和===、!==、==、!=等相等性检查来缩小类型。
== null 不仅检查值是否为 null，还检查是否为 undefined；== undefined 同样检查值是 null 还是 undefined。
基于 in 运算符的类型缩小JavaScript 的 in 运算符用于确定对象或其原型链是否具有指定名称的属性。
TypeScript 将 in 运算符视为缩小潜在类型的方式：对于&amp;quot;value&amp;quot; in x（&amp;ldquo;value&amp;quot;为字符串字面，x 为联合类 …  ]]></content></entry><entry><title>04- 更多关于函数</title><url>/post/ts/04--%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 进阶</tag><tag>函数类型</tag><tag>泛型</tag><tag>函数重载</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  函数类型表达式基本语法：用箭头函数形式描述函数类型，如(a: string) =&amp;gt; void（参数a为string类型，无返回值）。
特点：参数名必须存在（仅用于标识，不影响类型匹配），未指定类型时隐式为any（可通过noImplicitAny禁用）。 示例：
function greeter(fn: (a: string) =&amp;gt; void) { fn(&amp;#34;Hello, World&amp;#34;); } function printToConsole(s: string) { console.log(s); } greeter(printToConsole); // 符合函数类型要求 类型别名命名：通过type给函数类型命名，提升可读性和复用性： type GreetFunction = (a: string) =&amp;gt; void; function greeter(fn: GreetFunction) { /* ... */ }类型兼容性（面试高频）：函数类型兼容遵循 “参数少的可赋值给参数多的”（逆变原则简化版）： type F1 = (a: string) =&amp;gt; void; type F2 = (a: string, b: number) =&amp;gt; void; const f1: F1 = (a) =&amp;gt; {}; const f2: F2 = f1; // 合法：F1参数更少，可兼容F2 带属性的函数与调用签名函数类型表达式的局限：仅能描述函数的调用方式，无法声明函数自身的属性（如fn.prop）。
调用签名：若需描述可调用且带属性的对象，可在对象类型中编写调用签名，参数列表与返回类型间用:分隔（而非=&amp;gt;）：
type DescribableFunction = { description: string; (someArg: number): boolean; // 调用签名 }; function doSomething(fn: DescribableFunction) { console.log(fn.description + &amp;#34; returned &amp;#34; + fn(6)); } function myFunc(someArg: number) { return someArg &amp;gt; 3; } …  ]]></content></entry><entry><title>02- 日常类型</title><url>/post/ts/02--%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 基础</tag><tag>类型系统</tag><tag>interface 与 type</tag><tag>枚举类型</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  基础类型与数组类型JavaScript 基础类型：string、number 、 boolean（对应 JS 原始类型），TypeScript 中可直接作为类型注解使用。
特点：使用typeof运算符对这些类型的值操作时，返回值与类型名一致（如typeof &#39;abc&#39; === &#39;string&#39;）。 数组类型：
两种声明方式：T[]（如number[]表示数字数组）或Array&amp;lt;T&amp;gt;（泛型形式，如Array&amp;lt;number&amp;gt;），两者完全等价。 特殊类型 any核心特性：关闭类型检查，允许值被任意操作（访问任意属性、作为函数调用、赋值给任何类型等）。
适用场景：
处理动态内容（如来自 API 的未知数据）。 迁移 JS 项目时临时兼容无类型代码。 隐式any：未指定类型且 TS 无法推断时，编译器默认视为any（可通过noImplicitAny配置项禁用，强制显式声明类型，面试高频考点）。
风险与替代：
滥用any会失去 TS 类型检查的意义，建议优先使用unknown（更安全，需显式类型断言后使用）。 变量与函数的类型注解变量注解： let 变量名: 类型 = 值（如 let age: number = 20）。
多数情况可省略：TS 会自动推断类型（如let name = &#39;ts&#39; → 推断为string）。 函数参数类型注解：在每个参数名称后添加，用于声明函数接受的参数类型，即使参数无类型注释，TypeScript 仍会检查参数数量是否正确。
函数返回类型注解：出现在参数列表之后。（如function add(a: number, b: number): number { return a + b }）。
函数参数类型自动推断：当函数出现在 TypeScript 可确定调用方式的地方时，其参数会自动被赋予类型。
对象类型基础定义：通过属性列表描述对象形状，如{ name: string; age: number }（属性间可用,或;分隔，最后一个可选）。
可选属性：属性名后加?（如{ name: string; age?: number }），表示该属性可不存在。
注意：访问可选属性前需检查是否为undefined（如if (obj.age !== undefined) { ... }）。 联合类型含义：由两种或多种其他类型组成，表 …  ]]></content></entry><entry><title>01-ts</title><url>/post/ts/01--ts/</url><categories><category>TS官方手册</category></categories><tags><tag>TypeScript 基础</tag><tag>静态类型</tag><tag>类型系统</tag><tag>泛型</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  静态检查与静态类型检查静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。
静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。
TypeScript 与 JavaScript 的关系TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。
关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。
重要特性：
TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。 TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。 注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = &#39;str&#39;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。
TypeScript 的核心优势（面试高频）提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。
增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。
提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。
更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。
TypeScript 的类型推断与扩展类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。 例：let x = 10 → TS 推断x为number；const y = { name: &#39;ts&#39; } → 推断y为{ name: string }。
类型注解：当推断结果不符合预期时，可显式指定类型（:后接类型）。 例：let z: string = &#39;hello&#39;；function add(a: number, b: number): number { return a + b }。
TypeScript 的类型系统基础类型（ …  ]]></content></entry><entry><title>第七章 修改历史记录</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/07--%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 历史管理</tag><tag>rebase 操作</tag><tag>Git 指令对比</tag><tag>commit 管理</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  修改历史信息命令：git rebase -i &lt;基准 commit&gt; -i：进入互动模式，可编辑历史提交。 &lt;基准commit&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。 操作过程： 执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与 git log的 “从新到旧” 相反）。 每行开头为操作指令，将 pick 改成 reword（或简写 r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。 影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。 取消 rebase：git reset ORIG_HEAD &ndash;hard 把多个 commit 合并成一个 commit执行 git rebase -i &lt;最早要合并的commit的前一个哈希&gt;（如合并最近 3 个 commit，基准为 HEAD~4）。 在编辑器中，将目标 commit 的 pick改为 squash（或 fixup） 保存退出后，若用 squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。 完成后，多个 commit 被合并为一个，历史更简洁。 把一个 commit 拆解成多个 commit在 rebase 的互动模式下使用 edit 指令，继续执行 rebase，rebase 会在 edit 位置停下来。 执行 git reset HEAD^指令。 重新 commit 拆出来的文件，再执行 git rebase &ndash;continue 让 rebase 继续即可。 在某些 commit 之间加新的 commit在 rebase 互动模式下，将目标 commit 改成 edit，继续执行 rebase，让 rebase 停在该 commit 上。 注意：处于 rebase 状态的 commit 列表与平常记录相反，需确认停下来的点正确。 增加新的 commit，完成后执行 git rebase &ndash;continue，即可在指定位置中间增加新 commit。 删除某几个 commit 或调整 commit 顺序调整顺序：在 rebase 交互模式下调整 commit 的位置，存档离开即可。 删除 commit：在 rebase 交互模式下，把对应 commit 的 pick 改成 drop，或直接删掉该记录即可。 reset、revert 和 rebase 指令的区别指令 特点 适用场景 reset 将 HEAD 指针移动到指定 commit，可重置工作区 / 暂存区（--hard/--mixed/--soft） 通常适用于尚未推出去的 commit revert 生成新 commit 抵消目标 commit 的修改，原 commit 保留 适用于已经推出去的 commit，或不允许使用 reset 和 rebase 修改历史记录的情景。例如取消最后的 commit：git revert HEAD &ndash;no-edit（&ndash;no-edit 表示不编辑 commit 信息） rebase 重建 commit 历史（修改、合并、拆分、插入 commit） 通常只适用于尚未推出去的 commit   ]]></content></entry><entry><title>第六章 使用分支</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/06--%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git 分支操作</tag><tag>分支合并</tag><tag>rebase 合并</tag><tag>合并冲突解决</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  分支的基本操作查看分支 执行 git branch 命令，不带任何参数时，会输出当前项目中的所有分支，前面带有星号的分支表示当前所在分支（即 HEAD 指向的分支）。 扩展命令（面试高频）： git branch -r：查看远程分支（如origin/main）。 git branch -a：查看本地 + 远程所有分支（远程分支以remotes/前缀显示）。 git branch -v：显示各分支最后一次提交信息（哈希 + 说明）。 创建分支 在 git branch 命令后加上想要创建的分支名称，即可基于当前分支为基准创建新分支（仅创建，不切换），例如 git branch cat。 修改分支名称 使用-m 参数可以修改分支名称，即使是 master 分支也能修改，且不会影响文件或目录（当前分支可省略旧名，直接git branch -m &amp;lt;新名&amp;gt;），如 git branch -m cat tiger。 删除分支 使用-d 参数可以删除不需要的分支，如 git branch -d dog。
若要删除的分支未被完全合并，-d 参数无法删除，此时可使用-D 参数强制删除，如 git branch -D dog。
当前所在的分支不能删除，需先切换到其他分支再进行删除操作。
切换分支 使用 git checkout 命令切换分支，如 git checkout dog，切换的分支必须已存在，否则会出错（Git 2.23 + 推荐用git switch &amp;lt;分支名&amp;gt;，更直观）。
若要切换的分支不存在，可在 git checkout 后加上-b 参数，若分支不存在则创建并切换过去，若已存在则直接切换，如 git checkout -b new_branch。
注意：切换分支前，需 commit 或 stash 工作区的修改（否则未提交的修改会被带到新分支）。
对分支的理解可以将分支想象成一张贴纸，贴在某个 commit 上。当进行新的 commit 后，新的 commit 会指向其前一个 commit，当前分支（HEAD 所指分支）会贴到新的 commit 上，HEAD 也会随之前进。
Git 中的分支并非通过复制目录或文件夹形成，它只是一个指向 commit 的指标。
切换分支的原理切换分支时，Git 会用该分支指向的 commit 内容更新暂存区及工 …  ]]></content></entry><entry><title>3.4节 强制类型转换</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0304--%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 类型转换</tag><tag>相等比较规则</tag><tag>JSON.stringify</tag><tag>parseInt</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  值类型转换的基本概念定义与区分： 显式类型转换：主动将值从一种类型转换为另一种（如String(123)）。 隐式强制类型转换：操作中自动发生的类型转换（如1 + &amp;quot;2&amp;quot;）。 特性：JS 强制类型转换始终返回标量基本类型值，对象封装（如new Number(1)）不算严格意义上的强制转换。 与其他语言的差异： 静态类型语言的 “类型转换” 发生在编译阶段； 动态类型语言（如 JS）的 “强制类型转换” 发生在运行时，隐式转换常为操作的副作用。 抽象值操作（内部使用的转换规则）抽象操作是 JS 引擎内部用于类型转换的逻辑，主要包括ToString、ToNumber、ToBoolean。
ToString（非字符串 → 字符串）基本类型转换规则：
null → &amp;quot;null&amp;quot;；undefined → &amp;quot;undefined&amp;quot;；true → &amp;quot;true&amp;quot;；false → &amp;quot;false&amp;quot;。 数字：常规数字直接转换（如123→&amp;quot;123&amp;quot;），极小 / 极大数字用指数形式（如1e-20、1e+20）。 对象 / 数组转换：
普通对象：默认返回内部属性[[Class]]值（如&amp;quot;[object Object]&amp;quot;）；若自定义toString()方法，则调用该方法并使用其返回值。 数组：toString()将所有元素字符串化后用,连接（如[1, 2, 3].toString() → &amp;quot;1,2,3&amp;quot;）。 JSON.stringify () 的特殊处理：
作用：将 JSON 对象序列化为字符串，遵循ToString规则但结果必为字符串。
安全 JSON 值：可被序列化的值（字符串、数字、布尔值、null、数组、符合 JSON 结构的对象）；非安全值（ undefined、function 、symbol、循环引用对象）的处理：
对象中遇到非安全值：自动忽略。 数组中遇到非安全值：返回null（保持数组长度）。 循环引用对象：直接报错。 toJSON()方法：若对象定义了toJSON()，序列化时会先调用该方法，使用其返回的安全值进行序列化（注意：toJSON()应返回安全值，而非字符串）。
可选参数：
replacer（数组 / 函 …  ]]></content></entry><entry><title>第五章 开始使用git</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/05--%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>Git 命令</tag><tag>版本控制工具</tag><tag>Git 核心概念</tag><tag>代码协作</tag></tags><content type="html"><![CDATA[  新增、初始 Repository命令：git init
作用：在目录中创建一个.git 目录，该目录是 Git 进行版本控制的核心。若移除.git 目录，Git 将失去对该目录的控制权，可用于提供不含版控记录的内容给客户。
把文件交给 Git 管控查看目录状态：git status
显示文件状态：Untracked（未跟踪，新文件）、Modified（已修改未暂存）、Staged（已暂存待提交）。 添加文件到暂存区：
单个文件：git add &amp;lt;文件名&amp;gt;，将指定文件安置到暂存区。
特定类型文件：git add *.html，把所有后缀为.html 的文件加到暂存区。
全部文件：
git add &amp;ndash;all（或git add -A），添加项目中所有异动文件到暂存区；
git add .，添加当前目录及子目录中的异动文件到暂存区，对目录外文件无效。
注意事项：git add 后若再次改动文件，改动内容不会自动加入暂存区，暂存区仍为之前的版本，此时git status会显示文件同时处于Modified（工作区）和Staged（暂存区）状态。
提交到存储库：git commit -m &amp;lsquo;init commit&amp;rsquo;，-m 后为提交说明，将暂存区内容永久保存到存储库。每次 commit 仅处理暂存区内容，未加入暂存区的文件不会被提交。
空提交：git commit &amp;ndash;allow-empty -m &amp;ldquo;&amp;quot;，加上&amp;ndash;allow-empty 参数，无文件变动时强制提交（常用于触发 CI/CD 流程或标记重要节点）。
工作区、暂存区与存储库关系：git add 将文件从工作目录移至暂存区，git commit 将暂存区内容移至存储库，完成 commit 才算整个流程结束。
简化提交：git commit -a -m &amp;ldquo;update content&amp;rdquo;，-a 参数可缩短流程，跳过git add，直接将已跟踪文件的修改提交（新文件Untracked不生效，仍需手动add）。
查看记录基本查看：git log，越新的信息越靠上，显示作者、提交时间、提交说明等。 精简查看： git log --oneline：每行显示一条记录（哈希前缀 + 说明）。 git log …  ]]></content></entry><entry><title>3.1节 类型</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0301--%E7%B1%BB%E5%9E%8B/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 类型</tag><tag>typeof 运算符</tag><tag>基本类型与对象类型</tag><tag>JS 基础</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内置类型概述定义：类型是值的内部特征，决定值的行为，以区分于其他值。 分类： 基本类型（共 6 种）：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、符号（symbol）。不可再分的原子值，存储值本身（而非引用）。 对象类型（1 种）：对象（object），其他类型统称为基本类型。复杂结构，存储引用地址，可包含多个值（属性 / 元素）。 typeof 运算符作用：用于查看值的类型，返回类型的字符串值，共 7 种可能结果。 特殊情况： null 类型使用 typeof 检测时返回 “object”。（JavaScript 历史 bug，无法修复，需特殊处理） 检测 null 值类型的复合条件：!a &amp;&amp; typeof a === 'object'（因 null 是假值，且是唯一用 typeof 检测返回 &lsquo;object&rsquo; 的基本类型值）。 对象子类型函数（function）： 是 object 的子类型，属于可调用对象。 具有内部属性 [[Call]]，使其可被调用。 可拥有属性，如 length 属性表示其声明的参数个数。 typeof function返回&quot;function&quot;，是历史遗留的特殊处理 数组： 是 object 的子类型。 元素按数字顺序索引，length 属性表示元素个数。 值和类型的特性变量与类型的关系： JS 中变量无类型，只有值有类型。 变量可随时持有任何类型的值，语言引擎不强制变量持有与初始值同类型的值。 对变量执行 typeof 操作，结果是变量所持值的类型（因变量无类型），且 typeof 始终返回字符串。 undefined 与 undeclared 的区别： undefined：变量已在作用域中声明但未赋值。 undeclared：变量未在作用域中声明过。 typeof 的安全防范机制： 对 undeclared 变量使用 typeof，返回 undefined，不会抛出 ReferenceError 错误。 应用场景：在共享全局命名空间中，检查用户定义变量或内建 API 是否存在。 其他安全检查方法： 检查全局变量是否为全局对象的属性（访问不存在的对象属性不会产生 Reference 错误）。 依赖注入设计模式：将依赖通过参数显式传递到函数中。   ]]></content></entry><entry><title>3.2节 值</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0302--%E5%80%BC/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 数据类型</tag><tag>数组操作</tag><tag>浮点数精度</tag><tag>值与引用</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  数组特性： 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。 使用delete运算符删除单元后，位置变为空白单元，数组length属性不变。 稀疏数组： 指含有空白 / 空缺单元的数组，空白单元值为undefined，但与显式赋值为undefined的单元有区别（如[,,]与[undefined, undefined]行为不同）。 索引与属性： 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在length内，length只计算数字索引的最大整数 + 1）。 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。 类数组转换： 类数组特征：有length和数字索引，但无数组方法（如arguments、DOM 集合NodeList） 可转换为真正的数组，常用方法： Array.prototype.slice.call(类数组) ES6 的Array.from(类数组) 扩展运算符（需类数组为可迭代对象） 字符串与数组的区别： 是类数组（有length、indexOf()、concat()等），但并非字符数组。 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。 数组方法的借用： 可借用数组的非变更方法（如Array.prototype.indexOf.call(str, &#39;a&#39;)）处理字符串。 不可借用数组的变更方法（因字符串不可变），需先通过split(&#39;&#39;)转为数组，处理后再用join(&#39;&#39;)转回字符串。 数字类型与格式：
JS 只有一种数值类型number（双精度浮点数），包含整数（如42.0）和带小数的十进制数。 字面量表示： 十进制：可省略小数点前的 0（.42）或后多余的 0（42.）。 特殊格式：指数形式（1e3）、二进制（0b1010）、八进制（0o12）、十六进制（0xa）。 显示规则：
大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同toExponential()）。 Number 对象方法：
toFixed(n)：指定小数部分显示位数，不足用 0 补齐（返回字符串）。 toPrecision(n)：指定有效数位的显示位数。 注意：数字字面量调用方法时，需避免.被误判为数字一部分（如42..toFixed(2)或42 …  ]]></content></entry><entry><title>3.3节 原生函数</title><url>/post/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/0303--%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/</url><categories><category>你不知道的JS</category></categories><tags><tag>JavaScript 原生 API</tag><tag>封装对象</tag><tag>原生构造函数</tag><tag>原型</tag><tag>前端开发</tag></tags><content type="html"><![CDATA[  内部属性 [[Class]]基本概念： 内建函数（原生函数）可作为构造函数，用于创建封装基本类型值的封装对象。 属性特征： 所有typeof返回值为object的对象都包含内部属性[[Class]]，该属性无法直接访问。 通常通过Object.prototype.toString()方法查看[[Class]]的值。 对应关系： 多数情况下，对象的[[Class]]属性值与创建该对象的内建原生构造函数相对应。 特殊情况：虽然不存在Null()和undefined()原生构造函数，但null和undefined的[[Class]]属性值分别为&#39;Null&#39;和&#39;Undefined&#39;。 封装对象包装自动包装机制： 基本类型值（如string、number等）本身没有属性和方法，JS 会自动为其包装一个封装对象，以便访问属性和方法，操作完成后立即销毁，避免性能损耗。 手动封装与拆封： 手动封装：使用Object()函数（不带new关键字）可将基本类型值封装为对象。 拆封：通过valueOf()方法可获取封装对象中的基本类型值；在需要基本类型值的场景中，会发生隐式拆封。 使用建议：除非必要，应避免使用构造函数创建封装对象。 原生函数作为构造函数Array()：
不带new关键字时会被自动补全（等效于new Array()）。 仅带一个数字参数时，该参数表示数组预设长度（创建稀疏数组），而非数组元素。 替代方案：ES6 的Array.of()（无歧义，始终将参数作为元素） 稀疏数组：包含至少一个空单元的数组，可通过以下方式创建： 设置length属性值超过实际单元数； 使用delete删除数组单元。 可通过Array.apply(null, {length: 3})创建包含undefined单元（非空单元）的数组。 不建议使用的构造函数： 除非特殊需求，尽量避免使用Object()、Function()、RegExp()作为构造函数。
Date()：
必须使用new Date()创建日期对象：带参数时指定日期时间，不带参数时使用当前日期时间。 时间戳获取：getTime()方法或Date.now()（ES5+）可获取 Unix 时间戳。 特殊情况：不带new关键字调用Date()时，返回当前日期的字符串值（格式无统一规范）。 Error()： 带或不带new关键字均可使用。  …  ]]></content></entry><entry><title>第一 ~ 四章 初步使用git</title><url>/post/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/01-04--%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8git/</url><categories><category>Git从入门到精通</category></categories><tags><tag>Git</tag><tag>命令行</tag><tag>vim</tag><tag>版本控制工具</tag></tags><content type="html"><![CDATA[  Git 概述Git 是一种分布式版本控制系统，具有以下优点：
免费开源，降低使用成本，支持二次开发和定制化需求。 操作速度快、存储效率高，通过快照式存储而非差异对比，高效处理大型项目的版本控制。 分布式架构：无需依赖中央服务器，每个开发者可拥有完整版本库，断网时仍能提交代码，多人协作更灵活。 常用命令（跨系统对比）Windows macOS/Linux 说明 cd cd 切换目录 cd pwd 获取当前所在的位置 dir ls 列出当前目录的文件和目录 mkdir mkdir 创建新的目录 无 touch 创建文件 copy cp 复制文件 move mv 移动文件 del rm 删除文件 cls clear 清除终端显示内容 命令示例# 切换到上一层目录 cd .. # ~表示home目录，切换到home目录下的project目录 cd ~/project/ # 显示当前所在目录 pwd # 列出当前目录下所有文件及目录，包括以小数点开头的文件，并显示完整信息（权限、所有者、创建及修改时间等） ls -al # 删除目录中所有的.html文档 rm *.html # 创建文件，若文件不存在则创建空白文件，若已存在则仅修改最后修改时间 touch index.htmlls 命令说明ls 命令用于列出当前目录下的所有文件及目录，-al 参数中：
a：表示显示以小数点开头的文件。 l：表示显示文件的完整权限、所有者以及创建、修改的时间等信息。 vim 操作vim 主要通过模式切换进行输入、光标移动、选取、复制及粘贴等操作，常用模式有两种：
Normal 模式（命令模式）：默认进入的模式，无法输入文本，仅能进行复制、粘贴、存储或离开等操作。 Insert 模式（插入模式）：输入文本前需进入该模式，可通过按下 i（当前位置插入）、a（当前位置后插入）、o（新行插入）进入进入。在 Insert 模式下，按下 &amp;lsquo;Esc&amp;rsquo; 键或 &amp;lsquo;Ctrl+[&amp;rsquo; 组合键可退回 Normal 模式。 Normal 模式常用命令按下 “:w”：对文件进行存储。 按下 “:q”：关闭文件（若未存储会提示先存储再离开）。 按下 “:wq”：存储完成后直接关闭文件。 :q!：强制退出（不保存修改，放弃当前编辑）。 Git 配置基本配置（用户信 …  ]]></content></entry></search>