<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.148.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My New Hugo Site">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My New Hugo Site",
  "url": "https://example.org/",
  "description": "",
  "logo": "https://example.org/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="first-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>Git 概述 Git 是一种分布式版本控制系统，具有以下优点：
免费开源，降低使用成本，支持二次开发和定制化需求。
操作速度快、存储效率高，通过快照式存储而非差异对比，高效处理大型项目的版本控制。
分布式架构：无需依赖中央服务器，每个开发者可拥有完整版本库，断网时仍能提交代码，多人协作更灵活。
常用命令（跨系统对比） Windows macOS/Linux 说明 cd cd 切换目录 cd pwd 获取当前所在的位置 dir ls 列出当前目录的文件和目录 mkdir mkdir 创建新的目录 无 touch 创建文件 copy cp 复制文件 move mv 移动文件 del rm 删除文件 cls clear 清除终端显示内容 命令示例 # 切换到上一层目录 cd .. # ~表示home目录，切换到home目录下的project目录 cd ~/project/ # 显示当前所在目录 pwd # 列出当前目录下所有文件及目录，包括以小数点开头的文件，并显示完整信息（权限、所有者、创建及修改时间等） ls -al # 删除目录中所有的.html文档 rm *.html # 创建文件，若文件不存在则创建空白文件，若已存在则仅修改最后修改时间 touch index.html ls 命令说明 ls 命令用于列出当前目录下的所有文件及目录，-al 参数中：
a：表示显示以小数点开头的文件。
l：表示显示文件的完整权限、所有者以及创建、修改的时间等信息。
vim 操作 vim 主要通过模式切换进行输入、光标移动、选取、复制及粘贴等操作，常用模式有两种：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%80-~-%E5%9B%9B%E7%AB%A0-%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8git/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>修改历史信息 命令：git rebase -i &lt;基准commit&gt;
-i：进入互动模式，可编辑历史提交。
&lt;基准commit&gt;：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。
操作过程：
执行命令后，弹出 vim 编辑器，列表中从上到下为 “从旧到新” 的 commit（与git log的 “从新到旧” 相反）。
每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。
影响：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。
取消 rebase：git reset ORIG_HEAD –hard
把多个 commit 合并成一个 commit 执行git rebase -i &lt;最早要合并的commit的前一个哈希&gt;（如合并最近 3 个 commit，基准为HEAD~4）。
在编辑器中，将目标 commit 的pick改为squash（或fixup）
保存退出后，若用squash：弹出编辑器，合并所有 commit 信息为一个（fixup则直接使用上一个 commit 的信息）。
完成后，多个 commit 被合并为一个，历史更简洁。
把一个 commit 拆解成多个 commit 在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、工作中途切换任务的处理（git stash） git stash用于临时保存工作区和暂存区的修改（未提交的内容），以便切换分支处理其他任务，后续可恢复继续工作。
保存当前修改： git stash # 保存已跟踪文件的修改（默认不包含untracked文件） git stash -u # 同时保存untracked文件（新文件） git stash -a # 保存所有修改（包括untracked和ignored文件，谨慎使用） git stash -m &#34;描述信息&#34; # 给stash添加描述，便于区分（推荐） 查看保存的 stash： git stash list # 列出所有stash，格式：stash@{n}: WIP on &lt;分支名&gt;: &lt;描述&gt; # 示例：stash@{0}: WIP on feature/login: 完善表单验证 恢复 stash：
git stash pop &lt;stash@{n}&gt;：恢复指定 stash 并从列表中删除（默认恢复最新的 stash@{0}）。 git stash apply &lt;stash@{n}&gt;：恢复指定 stash 但不删除（可多次应用，适合多分支复用）。 删除 stash：
git stash drop &lt;stash@{n}&gt; # 删除指定stash git stash clear # 清空所有stash（谨慎！） 二、移除 Git 历史中的敏感信息（如账号密码） 当不慎提交敏感文件后，需彻底从历史中删除。
推荐方法：git filter-repo（现代替代filter-branch） git filter-branch因性能差、易出错已被官方推荐git filter-repo替代（需先安装：pip install git-filter-repo）。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%8A%E5%86%B7%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>新增、初始 Repository 命令：git init
作用：在目录中创建一个.git目录，该目录是 Git 进行版本控制的核心。若移除.git目录，Git 将失去对该目录的控制权，可用于提供不含版控记录的内容给客户。
把文件交给 Git 管控 查看目录状态：git status
显示文件状态：Untracked（未跟踪，新文件）、Modified（已修改未暂存）、Staged（已暂存待提交）。 添加文件到暂存区：
单个文件：git add &lt;文件名&gt;，将指定文件安置到暂存区。
特定类型文件：git add *.html，把所有后缀为.html的文件加到暂存区。
全部文件：
git add –all（或git add -A），添加项目中所有异动文件到暂存区；
git add .，添加当前目录及子目录中的异动文件到暂存区，对目录外文件无效。
注意事项：git add后若再次改动文件，改动内容不会自动加入暂存区，暂存区仍为之前的版本，此时git status会显示文件同时处于Modified（工作区）和Staged（暂存区）状态。
提交到存储库：git commit -m ‘init commit’，-m后为提交说明，将暂存区内容永久保存到存储库。每次commit仅处理暂存区内容，未加入暂存区的文件不会被提交。
空提交：git commit –allow-empty -m “&#34;，加上–allow-empty参数，无文件变动时强制提交（常用于触发 CI/CD 流程或标记重要节点）。
工作区、暂存区与存储库 关系：git add将文件从工作目录移至暂存区，git commit将暂存区内容移至存储库，完成commit才算整个流程结束。
简化提交：git commit -a -m “update content”，-a参数可缩短流程，跳过git add，直接将已跟踪文件的修改提交（新文件Untracked不生效，仍需手动add）。
查看记录 基本查看：git log，越新的信息越靠上，显示作者、提交时间、提交说明等。 精简查看： git log --oneline：每行显示一条记录（哈希前缀 &#43; 说明）。 git log --graph --oneline：图形化展示分支合并历史（直观看到分支流向）。 按作者筛选：git log –author=“Sherly\|Eddie”，\|表示 “或者”，可查找多个人的提交记录。 按提交信息筛选：git log –grep=“LOL”，从提交信息中搜索含关键字的内容。 按内容筛选：git log -S ‘Ruby’，在所有提交文件中搜索符合特定条件的内容。 按时间筛选：git log –since=“9am” –until=“12am” –after=“2017-01”，找出 2017 年 1 月之后每天早上 9 点到 12 点之间的提交。 删除文件或变更文件名 删除文件： 系统命令删除：使用rm或资源管理器删除后，git add将改动加到暂存区再提交。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8git/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>Git 标签相关知识 一、标签的概念与作用 标签是 Git 中指向某个 commit 的指示标，常用于标记软件开发的特定里程碑（如版本发布）。 标签本质类似 “贴纸”，标签一旦创建，默认不会随新提交移动，删除标签不会影响对应的 commit 或文件。 二、标签的类型及使用 轻量标签
特点：仅作为指向某个 commit 的指示标，不含额外信息。
创建方式：直接指定 commit（若不指定则默认当前 commit）
git tag &lt;标签名&gt; [commit的SHA-1值] 示例：
git tag big_cats 51d54ff 存储：指向某个 commit 的 SHA-1 值，存于 .git/refs/tags 目录。
有附注的标签
特点：包含更多信息（如标签创建者、时间、描述等），推荐使用。
创建方式：通过-a 参数创建，-m 可添加描述（若无-m则弹出 vim 编辑器）
git tag &lt;标签名&gt; [commit的SHA-1值] -a -m “描述信息” ```
示例：```git tag big_cats 51d64ff -a -m “big cats are comming” ```
存储：指向某个 Tag 对象的 SHA-1 值，该 Tag 对象再指向对应的 commit，存于 .git/refs/tags 目录。 标签的查看与删除
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%92%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%A0%87%E7%AD%BE%E5%92%8Cgitflow/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>分支的基本操作 查看分支 执行git branch命令，不带任何参数时，会输出当前项目中的所有分支，前面带有星号的分支表示当前所在分支（即 HEAD 指向的分支）。 扩展命令（面试高频）： git branch -r：查看远程分支（如origin/main）。 git branch -a：查看本地 &#43; 远程所有分支（远程分支以remotes/前缀显示）。 git branch -v：显示各分支最后一次提交信息（哈希 &#43; 说明）。 创建分支 在git branch命令后加上想要创建的分支名称，即可基于当前分支为基准创建新分支（仅创建，不切换），例如git branch cat。 修改分支名称 使用-m参数可以修改分支名称，即使是 master 分支也能修改，且不会影响文件或目录（当前分支可省略旧名，直接git branch -m &lt;新名&gt;），如git branch -m cat tiger。 删除分支 使用-d参数可以删除不需要的分支，如git branch -d dog。
若要删除的分支未被完全合并，-d参数无法删除，此时可使用-D参数强制删除，如git branch -D dog。
当前所在的分支不能删除，需先切换到其他分支再进行删除操作。
切换分支 使用git checkout命令切换分支，如git checkout dog，切换的分支必须已存在，否则会出错（Git 2.23 &#43; 推荐用git switch &lt;分支名&gt;，更直观）。
若要切换的分支不存在，可在git checkout后加上-b参数，若分支不存在则创建并切换过去，若已存在则直接切换，如git checkout -b new_branch。
注意：切换分支前，需 commit 或 stash 工作区的修改（否则未提交的修改会被带到新分支）。
对分支的理解 可以将分支想象成一张贴纸，贴在某个 commit 上。当进行新的 commit 后，新的 commit 会指向其前一个 commit，当前分支（HEAD 所指分支）会贴到新的 commit 上，HEAD 也会随之前进。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、将内容推送到 GitHub 前置准备
在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。 关联远端仓库
git remote add origin &lt;GitHub仓库地址&gt; remote add：添加远端节点。
origin：远端 节点的默认名称（可自定义或修改）。
远端仓库管理（补充操作） 查看远端配置：git remote -v（显示远端名称、地址及操作类型，确认是否关联正确）。 修改远端地址：git remote set-url origin &lt;新地址&gt;（如仓库迁移后更新地址）。 删除远端关联：git remote remove origin（解除与远端的绑定）。 推送内容到远端
git push -u origin master 作用：将本地 master 分支推送到 origin 远端，若远端无 master 则创建，同时通过 -u 设置 upstream（上游跟踪关系）。 后续推送：设置 upstream 后，直接执行 git push 即可（无需重复指定远端和分支）。 upstream 作用 本地分支通过 -u 关联远端分支（如 origin/master）后，pull/push 会默认操作关联的远端分支。 推送时重命名分支
git push origin master:cat # 将本地master推送到远端并命名为cat 二、从 GitHub 拉取更新（pull/fetch） 命令 本质 适用场景 git fetch 仅获取远端更新（更新origin/xxx分支），不合并 需先查看远端修改再决定是否合并（安全） git pull git fetch &#43; git merge 快速同步远端修改（可能产生合并 commit） git pull --rebase git fetch &#43; git rebase 保持历史线性（无合并 commit，推荐协作场景） fetch是 “安全查看”：获取后可通过git diff origin/main对比本地与远端差异，再手动merge或rebase。 pull --rebase优于pull：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时） 三、推送失败的原因及解决 原因：本地版本落后于远端（远端 有更新未同步到本地）。 解决： 先拉取更新：git pull（合并入远端修改后再推送）。 强制推送（谨慎使用）：git push -f（会覆盖远端内容，仅用于协作分支使用）。 四、从服务器克隆仓库（git clone） 基本用法
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E5%85%B1%E5%90%8C%E5%8D%8F%E4%BD%9C/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、DOM（文档对象模型） 核心定义：DOM 是一套对文档内容进行抽象和概念化的方法，它将 HTML/XML 文档的结构转化为一个树形的对象模型，使得程序（如 JS）可以访问和操作文档的内容、结构和样式。 作用：作为 JS 与网页内容之间的桥梁，允许开发者通过代码动态修改文档的元素、属性、文本等（例如添加节点、修改样式、绑定事件等）。 二、DHTML（动态 HTML） 本质：DHTML 并非一项独立技术，而是 HTML、CSS 和 JavaScript 三种技术的组合术语，用于描述 “动态操控网页内容和样式” 的技术方案。 核心组成与目标： HTML：负责标记网页的结构和内容（如 &lt;div&gt;、&lt;p&gt; 等元素）； CSS：负责定义元素的样式（颜色、布局、位置等）； JavaScript：负责实时操控页面元素和样式（如动态修改 CSS 属性、显示 / 隐藏元素、响应用户交互等）。 核心价值：通过三者协同，实现网页内容的动态更新，无需重新加载页面即可改变外观和行为（如表单验证、菜单切换、实时数据展示等）。 三、API（应用程序编程接口） 定义：API 是一组得到各方共同认可的基本约定，规定了不同组件（如软件、库、服务）之间如何交互的规则（包括可调用的函数、参数格式、返回值类型等）。 举例： DOM API：如 document.getElementById()、element.appendChild() 等，规定了 JS 操作文档的方法； 浏览器 API：如 fetch()（网络请求）、localStorage（本地存储）等，提供了 JS 与浏览器功能交互的接口。 作用：简化开发，使不同模块或系统能够按照统一规则协作，无需关注内部实现细节。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%80%E7%AB%A0-js%E7%AE%80%E5%8F%B2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、传统文档操作方法 1. document.write() 功能：将字符串直接插入到文档中，语法简单（如 document.write(&#34;&lt;p&gt;Hello&lt;/p&gt;&#34;)）。 缺点： 违背 “行为与表现分离” 原则，需在 HTML 中嵌入 &lt;script&gt; 调用，导致代码耦合。 可能引发文档验证错误，且与 application/xhtml&#43;xml 类型文档不兼容（浏览器会忽略该方法）。 2. innerHTML 功能：读写元素内的 HTML 内容（如 div.innerHTML = &#34;&lt;span&gt;Hi&lt;/span&gt;&#34; 可设置内容，const html = div.innerHTML 可读取内容）。 特点： 简洁高效，适合批量操作 HTML 片段，但无法精确控制单个节点（会整体替换元素内容）。 局限性：HTML 专有属性，不支持 XHTML 文档；安全性风险（可能引入 XSS 攻击，需谨慎处理用户输入）。 替代方案：标准 DOM 方法（如 createElement、appendChild）虽代码量增加，但可精确控制节点，兼容性更强。 二、标准 DOM 操作方法 1. 核心思想 DOM 是文档的双向映射：既能读取文档结构（通过节点属性和方法），也能修改节点树（实时反映到浏览器渲染结果）。 浏览器显示的是 DOM 节点树，而非原始 HTML 代码，因此修改 DOM 会直接改变页面表现。 2. 创建与插入节点 创建元素节点：document.createElement(tagName)
示例：const newDiv = document.createElement(&#34;div&#34;);（创建 &lt;div&gt; 元素，初始为 “文档碎片”，未插入文档）。 创建文本节点：document.createTextNode(text)
示例：const textNode = document.createTextNode(&#34;Hello DOM&#34;);（创建包含文本的节点）。 插入节点到文档：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、DOM 的核心概念 DOM（Document Object Model，文档对象模型）是一套用于抽象和概念化文档内容的接口，它将网页文档转换为可通过 JavaScript 操作的对象树结构。
1. D：文档（Document） 当网页加载到浏览器时，浏览器会自动将 HTML/XML 文档解析为一个 文档对象，即 DOM 的基础。 2. O：对象（Object） 对象是包含数据和方法的集合： 属性：对象关联的变量（如 element.id）； 方法：对象可调用的函数（如 element.appendChild()）。 JS 中的对象类型： 用户定义对象：开发者创建的自定义对象； 内建对象：JS 自带的对象（如 Array、Date）； 宿主对象：浏览器环境提供的对象（如 window、document）。 关键宿主对象： window：对应浏览器窗口，属于 BOM（浏览器对象模型）； document：对应网页内容，是操作 DOM 的核心对象。 3. M：模型（Model） DOM 将文档表示为一棵节点树（类似家谱树），用 “父子”“兄弟” 等关系描述元素间的层次结构： 根元素是 &lt;html&gt;，所有其他元素都是其后代； 节点树清晰展示了元素的嵌套关系，便于通过 JS 遍历和操作。 二、节点（Node） DOM 文档由多种节点组成，核心类型包括：
1. 元素节点（Element Node） 文档的基本构成单位，对应 HTML 标签（如 &lt;div&gt;、&lt;p&gt;）。 特点：可包含其他元素节点或文本节点，是节点树的 “骨架”。 根元素：&lt;html&gt; 是唯一不被其他元素包含的元素节点。 2. 文本节点（Text Node） 包含文本内容（如文字、空格），总是被元素节点包含（如 &lt;p&gt;Hello&lt;/p&gt; 中，“Hello” 是文本节点）。 注意：并非所有元素节点都包含文本节点（如空标签 &lt;img&gt;）。 3. 属性节点（Attribute Node） 描述元素的附加信息（如 class、id、src），仅存在于元素的起始标签中。 特点：依赖元素节点存在，无法独立于元素存在（如 &lt;a href=&#34;url&#34;&gt; 中，href 是属性节点）。 三、CSS 与 DOM 的关联 CSS 通过节点树结构应用样式，子元素会继承父元素的样式（继承性）。 为精准定位元素，常用 class 和 id 属性： class 属性： 可在多个元素上重复使用，用于为一组元素定义相同样式（如 .active { color: red; }）。 一个元素可包含多个类名（用空格分隔，如 class=&#34;btn primary&#34;）。 id 属性： 每个 id 在文档中唯一，用于标识单个元素（如 id=&#34;logo&#34;）。 可作为样式或 DOM 操作的 “挂钩”（如 #logo { width: 100px; }）。 四、获取元素节点的 DOM 方法 1. getElementById() 作用：根据元素的 id 属性值获取唯一元素节点。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B8%89%E7%AB%A0-dom/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://example.org/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
