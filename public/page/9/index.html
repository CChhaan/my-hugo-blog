<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.148.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My New Hugo Site">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My New Hugo Site",
  "url": "https://example.org/",
  "description": "",
  "logo": "https://example.org/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>工厂模式 function createPerson(name, age, job){ let o = new	Object() o.name = name o.age = age o.job = job o.sayName = function(){ console.log(this.name) } return o } let person1 = createPerson(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;) let person2 = createPerson(&#34;Greg&#34;, 27, &#34;Doctor&#34;) 这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。
构造函数模式 构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
function Person(name, age, job){ this.name = name this.age = age this.job = job this.sayName = function(){ console.log(this.name) } } let person1 = new Person(&#34;Nicholas&#34;, 29, &#34;Software Egineer&#34;) let person2 = new Person(&#34;Greg&#34;, 27, &#34;Doctor&#34;) 构造函数和工厂函数的区别：
没有显式的创建对象 属性和方法直接赋值给了this 没有return 创建Person实例用new操作符，会执行如下操作：
在内存中创建一个新对象 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 构造函数内部的this被赋值为这个新对象(即this指向新对象) 执行构造函数内部的代码(给新对象添加属性) 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象 新创建的对象都有一个constructor属性指向构造函数
person1.constructor == Person constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式
定义自定义构造函数可以确保实例被标识为特定类型。 构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数
构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数
在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。
构造函数的问题 构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象 解决这个问题，可以把函数定义转移到构造函数外部 虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。
原型模式 每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。 与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。
理解原型 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。 在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个[[Prototype]]的标准方式，有些浏览器会在对象上暴露__proto__属性，通过这个属性可以访问对象的原型。 可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的[[Prototype]]指向调用它的对象时返回true。 Object.getPrototypeOf()返回参数的内部特性[[prototype]]的值。 Object.setPrototypeOf()方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。 但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：
let person = Object.create(bipe)	//Object.getPrototypeOf(person) === bipe 原型层级 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。 只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。 hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>原型链 如果原型是另一个类型的实例，那就意味着这个原型本身有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数，这样就在实例和圆形之间构造了一条原型链。
默认原型 原型链还有一环，默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的，任何函数的默认原型都是一个Object的实例，这意味着这个实例有一个默认指针指向Object.prototype
原型与继承的关系 原型与实例的关系可以通过两种方式确定：
使用instanceof操作符，如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true 使用isPrototypeOf()方法，原型链中每个原型都可以调用这个方法，只要原型链中包含这个原型，就返回true 关于方法 子类有时候需要覆盖父类的方法，或者增加父类没有的方法，为此，这些方法必须在原型复制之后再添加到原型上。 对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链
原型链的问题 原型中包含的引用值会在实例间共享 子类型在实例化时不能给父类型的构造函数传参。 盗用构造函数</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.3-%E7%BB%A7%E6%89%BF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/8.4-%E7%B1%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>ES数组每个槽位可以存储任意类型的数据。ES数组是动态大小的，会随着数据添加而自动增长
创建数组 使用Array构造函数：
let colors = new Array() 如果知道数组中元素的数量，可以给构造函数传入一个数值，然后length属性就会被自动创建并设置为这个值。 也可以给构造函数传入一个要保存的元素。 也可以省略new操作符
let colors = Array(3)	//包含3个元素的数组 let names = Array(&#39;Greg&#39;)	//一个只包含一个元素字符串Greg的数组 使用数组字面量表示法，即在中括号中包含以逗号分隔的元素列表。
let colors = [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;] Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。
Array.from()用于将类数组结构转换为数组实例，第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构。 Array.from()还接受第二个可选的映射函数参数，用于增强新数组的值(相当于map方法)。还可以接收第三个可选参数，用于指定映射函数中this的值，在箭头函数中不适用。
const a1 = [1, 2, 3, 4] const a2 = Array.from(a1, function(x){return x**this.exponent}, {exponent: 2}) Array.of()可以把一组参数转换为数组，用于替代ES6之前的Array.prototype.slice.call(arguments)写法
数组空位 使用数组字面量初始化数组时，可以用一串逗号来创建空位。ES会将逗号之间索引位置的值当成空位。 ES6新增的方法和迭代器普遍将这些空位当成存在的元素，只不过值为undefined ES6之前的方法会忽略这个空位，具体行为因方法而异 由于行为不一致和存在性能隐患，要避免使用数组空位，如果确实需要，可以显式的用undefined代替
数组索引 要取得或设置数组的值,需要使用中括号并提供相应值的数字索引。 在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元素数，则返回存储在相应位置的元素，设置数组的方法也是一样的，就是替换指定位置的值。如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1。
数组中元素的数量保存在length属性中，这个属性始终返回0或大于0的值 数组length属性不是只读的，通过修改length属性可以从数组末尾删除或添加元素。 如果将length设置为大于数组元素的值，则新添加的元素都将以undefined填充。
使用length属性可以方便的向数组末尾添加元素，数组中最后一个元素的索引始终是length-1，因此下一个新增槽位的索引就是length。每次在数组最后一个元素后面新增一项，数组的length属性都会自动更新，以反映变化。新的长度会在新增元素被添加到当前数组外部的位置上时自动更新。
检测数组 if(value instanceof Array) if(Array.isArray(value)) Array.isArray()方法确定一个值是否为数组，不用管它是在哪个全局执行上下文中创建的。
迭代器方法 ES6中，Array原型上暴露了3个用于检索数组内容的方法：keys()返回数组索引的迭代器，values()返回数组元素的迭代器，entries()返回索引/值对的迭代器
复制和填充方法 ES6新增两个方法：批量复制方法copyWithin()和填充数组方法fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小
使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾，负值索引从数组末尾开始计算，也可以将负值索引想象成数组长度加上他得到的一个正索引
const zeroes = [0, 0, 0, 0, 0] //用8填充索引大于等于1且小于4的元素 zero.fill(8, -4, -1)	//[0, 8, 8, 8, 0] zero.fill(0)	//[0, 0, 0, 0, 0] copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。
let ints, reset = () =&gt; inits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] reset() //从ints中复制索引0开始到索引3结束的内容，插入到索引4开始的位置 ints.copyWithin(4, 0, 3) reset() fill()和copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/array/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>以后再说
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/map/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>显示的创建Object的实例有两种方式.第一种是使用new操作符和Object构造函数
let person = new Object() person.name = &#34;Nicholas&#34; person.age = 29 另一种是使用对象字面量表示法。
let person = { name:&#39;Nicholas&#39;, age:29 } 左大括号表示对象字面量开始，接下来指定属性，后跟一个冒号，然后是属性的值。逗号用于在对象字面量中分隔属性，最后一个属性后面加上逗号在非常老的浏览器中可能会报错。 属性名可以是字符串或数值，数值属性会自动转换为字符串。 也可以用对象字面量表示法定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了
let person = { } person.name = &#34;Nicolas&#34; person.age = 29 属性一般是通过点语法来存取的，也可以使用中括号来存取属性，在使用中括号时，要在括号内使用属性名的字符串形式
console.log(peron.name) console.log(peron[&#34;name&#34;]) 使用中括号的优势是可以通过变量访问属性。 如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，也可以使用中括号语法
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/object/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>以后再说
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/set/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>以后再说
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/weakmap/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>以后再说
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/weakset/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>以后再说
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/page/8/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/page/10/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
