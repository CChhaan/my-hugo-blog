<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.148.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My New Hugo Site">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My New Hugo Site",
  "url": "https://example.org/",
  "description": "",
  "logo": "https://example.org/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、keyof 运算符 keyof 用于将对象类型的所有键名转换为字面量联合类型，是实现 “类型安全的键访问” 的基础。
1. 基础用法 type Point = { x: number; y: number }; type P = keyof Point; // 等价于 type P = &#34;x&#34; | &#34;y&#34; 作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。 2. 与索引签名结合 当对象类型包含 string 或 number 索引签名时，keyof 会返回对应的索引类型：
// number 索引签名 type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; // type A = number（仅允许 number 类型索引） // string 索引签名 type Mapish = { [k: string]: boolean }; type M = keyof Mapish; // type M = string | number 因为 JavaScript 会将数字索引自动转换为字符串（如 obj[0] 等价于 obj[&#34;0&#34;]），因此 string 索引签名隐含支持 number 索引。 keyof与Object.keys的区别： keyof：在类型层面工作，返回键的字面量联合类型（编译时）。 Object.keys：在值层面工作，返回键的字符串数组（运行时）。 二、typeof 运算符（类型上下文） typeof 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/ts/07--%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、条件类型 条件类型通过判断类型关系返回不同类型，基本形式为 SomeType extends OtherType ? TrueType : FalseType，核心价值在于与泛型结合实现灵活的类型逻辑。
1. 基本用法 当SomeType可赋值给OtherType时，返回TrueType；否则返回FalseType
type Example1 = Dog extends Animal ? number : string; // 若Dog是Animal的子类型，返回number 2. 与泛型结合 条件类型与泛型结合可简化重载，实现类型与值的动态关联：
// 需求：输入number返回IdLabel，输入string返回NameLabel type IdLabel = { id: number }; type NameLabel = { name: string }; // 条件类型关联输入与输出类型 type Label&lt;T extends number | string&gt; = T extends number ? IdLabel : NameLabel; // 单个函数替代重载 function createLabel&lt;T extends number | string&gt;(value: T): Label&lt;T&gt; { return typeof value === &#39;number&#39; ? { id: value } : { name: value } as Label&lt;T&gt;; } const label1 = createLabel(10); // 类型：IdLabel（{ id: number }） const label2 = createLabel(&#34;Alice&#34;); // 类型：NameLabel（{ name: string }） 3. 类型推断与 infer 通过 infer 关键字在条件类型中声明性推断类型，无需显式指定提取逻辑：
示例 1：提取数组元素类型
type Flatten&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type; type Str = Flatten&lt;string[]&gt;; // type Str = string（推断Item为string） type Num = Flatten&lt;number&gt;; // type Num = number（不满足数组，返回原类型） 示例 2：提取函数返回类型
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/ts/08--%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、类的字段 字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。
基本特性 字段声明默认创建公共可写属性，类型可显式声明（如x: number）或通过初始化值推断（如x = 0 → 推断为number）。 未指定类型且无初始化值时，隐式为any（可通过noImplicitAny禁用，强制显式声明）。 初始化相关 初始化器：字段可直接赋值（如x = 0），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。 strictPropertyInitialization 配置： 开启时，字段必须在构造函数内或初始化器中初始化，否则报错（防止访问未初始化的属性）。 例外：用!（明确赋值断言）标记 “后续会初始化” 的字段（如name!: string，常用于依赖注入场景）。 注意：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。 readonly 修饰符 标记字段为只读，仅可在初始化器或构造函数中赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。 二、构造函数 类的初始化函数，用于实例化时设置初始状态。
与函数的异同 相似性：支持类型注释、默认值、重载（如多构造函数签名）。 区别： 不能有类型参数（类型参数属于外部类声明）； 不能有返回类型注释（默认返回类实例类型）。 super () 调用要求 派生类构造函数中，使用this前必须调用super()（调用基类构造函数），否则 TypeScript 报错。 三、方法与访问器 类的函数属性，用于定义行为和属性访问逻辑。
方法 本质是类的函数属性，支持类型注释（参数和返回值）。 方法体内访问字段 / 其他方法必须通过this.，否则引用外部变量。 访问器 包括get（读取）和set（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。 TypeScript 推断规则： 仅有get时，属性自动为readonly； 未指定set参数类型时，从get返回类型推断； 4.3&#43; 版本支持get和set使用不同类型。 注意：无额外逻辑的get/set对意义不大，建议直接用公共字段。 四、索引签名 类可声明索引签名，与对象类型索引签名规则一致。
示例：class MyClass { [s: string]: boolean | ((s: string) =&gt; boolean); } 注意：需覆盖方法类型，使用复杂，建议将索引数据存储在类实例外。 五、类继承 类可通过implements和extends实现接口约束或基类继承。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/ts/09--%E7%B1%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例
我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。
import { createApp } from &#39;vue&#39; // 从一个单文件组件中导入根组件 import App from &#39;./App.vue&#39; const app = createApp(App) 应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串。应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。
&lt;div id=&#34;app&#34;&gt;&lt;/div&gt; app.mount(&#39;#app&#39;) 根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供，当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。
&lt;div id=&#34;app&#34;&gt; &lt;button @click=&#34;count&#43;&#43;&#34;&gt;{{ count }}&lt;/button&gt; &lt;/div&gt; import { createApp } from &#39;vue&#39; const app = createApp({ data() { return { count: 0 } } }) app.mount(&#39;#app&#39;) 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，应用实例还提供了一些方法来注册应用范围内可用的资源，确保在挂载应用实例之前完成所有应用配置
应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/vue3/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>声明响应式状态 在组合式 API 中，推荐使用 ref() 函数来声明响应式状态，ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回，要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们，在模板中使用 ref 时。
我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包，也可以直接在事件监听器中改变一个 ref，对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref 的函数，并将它们作为方法与状态一起公开，然后，暴露的方法可以被用作事件监听器
在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用单文件组件 (SFC) 来避免这种情况。我们可以使用 &lt;script setup&gt; 来大幅度地简化代码
&lt;script setup&gt; 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。
当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会触发追踪它的组件的一次重新渲染。
在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。该 .value 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。
另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/vue3/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>Vue 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。
声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。 Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：
无需构建步骤，渐进式增强静态的 HTML 在任何页面中作为 Web Components 嵌入 单页应用 (SPA) 全栈 / 服务端渲染 (SSR) Jamstack / 静态站点生成 (SSG) 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面 在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。
Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。
使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。
通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与&lt;script setup&gt; 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，&lt;script setup&gt; 中的导入和顶层变量/函数都能够在模板中直接使用。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/vue3/%E5%BC%80%E5%A7%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>文本插值 Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。
在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。
最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法，双大括号标签会被替换为相应组件实例中 属性的值。同时每次属性更改时它也会同步更新。
&lt;span&gt;Message: {{ msg }}&lt;/span&gt; 原始HTML 双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令这里看到的 v-html attribute 被称为一个指令。指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。
&lt;p&gt;Using text interpolation: {{ rawHtml }}&lt;/p&gt; &lt;p&gt;Using v-html directive: &lt;span v-html=&#34;rawHtml&#34;&gt;&lt;/span&gt;&lt;/p&gt; 这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。
span 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。
在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/vue3/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文介绍了JavaScript函数的几个重要概念。首先指出函数是Function类型的实例，箭头函数具有独特限制（不能使用arguments、不能作为构造函数等）。其次说明函数名是指向函数的指针，ES6函数具有name属性。接着详细讲解函数参数机制，包括arguments对象的使用、参数传递方式（按值传递），以及如何在严格模式下处理参数。关于函数重载，文章指出JavaScript不支持传统重载，但可以模拟实现。最后介绍了ES6默认参数的用法，包括基本语法、参数初始化顺序和作用域规则，以及箭头函数使用默认参数的方法。
箭头函数 函数实际上是对象，每个函数都是Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。函数名是指向函数对象的指针，而且不一定与函数本身紧密绑定
箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性
函数名 函数名就是指向函数的指针，一个函数可以有多个名称，使用不带括号的函数名会访问函数指针，而不是执行函数
ES6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串，如果它是使用function构造函数创建的，则会标识成anonymous，如果函数是一个获取函数、设置函数，或者使用bind实例化，那么标识符前面会加上一个前缀
函数参数 ES函数既不关心传入的参数个数，也不关心这些参数的数据类型。
ES函数的参数在内部表现为一个数组，函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。
在使用function关键字定义函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参数值
arguments对象是一个类数组对象（不是Array的实例），因此可以使用中括号语法访问其中的元素，而要确定传进来多少个参数，可以访问arguments.length属性
ES函数的参数只是为了方便才写出来的，并不是必须写出来的，命名参数不会创建让之后的调用必须匹配的函数签名，因为根本不存在验证命名参数的机制
arguments对象可以跟命名参数一起使用，arguments的值始终会与对应的命名参数同步，但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。
对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined，这就类似于定义了变量但没有初始化
严格模式下，arguments对象与命名参数不同步，并且在函数中尝试重写arguments对象会导致语法错误
如果函数是箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的命名参数访问。虽然箭头函数中没有arguments对象，但可以在包装函数中把它提供给箭头函数
ES中的所有参数都是按值传递的，不可能按引用传递参数，如果把对象作为参数传递，那么传递的值就是这个对象的引用
函数重载 ES函数没有签名，因为参数是由包含零个或多个值的数组表示的，自然也就没有重载。如果在ES中定义了两个同名函数，则后定义的会覆盖先定义的。
可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载
默认参数 ES5之前，实现默认参数的一种常用方式就是检测某个参数是否等于undefined，如果是则意味着没有传这个参数，那就给它赋一个值
ES6支持显示定义默认参数，只要在函数定义中的参数后面用=就可以为参数赋一个默认值
给参数传undefined相当于没有传值，不过这样可以利用多个独立的默认值
在使用默认参数时，arguments对应的值不反映参数的默认值，只反映传给函数的参数。
默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值
函数默认参数只有在函数被调用时才会求值，不会在函数定义时求值，而且计算默认值的函数只有在调用函数但未传相应参数时才会被调用
箭头函数同样也可以这样使用默认参数
给多个参数定义默认值实际上跟使用let关键字顺序声明变量一样，默认参数会按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数。
参数初始化顺序遵循暂时性死区规则，即前面定义的参数不能引用后面定义的，参数也存在于自己的作用域中，它们不能引用函数体的作用域
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/10.1-10.5-%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文介绍了JavaScript中函数表达式、递归、尾调用优化、闭包、立即调用函数表达式(IIFE)和私有变量等核心概念。重点包括：函数表达式的定义与使用；递归的实现方式；尾调用优化的条件；闭包的作用机制及其内存影响；IIFE的模拟块级作用域应用；通过构造函数和静态变量实现私有变量的方法。文章通过代码示例详细说明了这些特性在JavaScript中的实际应用，帮助理解函数式编程的关键技术点。
函数表达式 函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义，这意味着函数声明可以出现在调用它的代码之后
函数表达式看起来像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量，这样创建的函数叫做匿名函数或兰姆达函数，因为function关键字后面没有标识符，未赋值给其他变量的匿名函数的name属性是空字符串
函数表达式跟JS中的其他表达式一样，需要先赋值后使用
任何时候，只要函数被当做值来使用，它就是一个函数表达式
递归 递归函数通常的形式是一个函数通过名称调用自己
arguments.callee是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，但严格模式下不能访问。
可以使用命名函数表达式达到目的
尾调用优化 尾调用：外部函数的返回值是内部函数的返回值
如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做
尾调用优化的条件：
代码在严格模式下执行 外部函数的返回值是对尾调用函数的调用 尾调用函数返回后不需要执行额外的逻辑 尾调用函数不是引用外部函数作用域中自由变量的闭包 无论是递归尾调用还是非递归尾调用，都可以应用优化，引擎并不区分尾调用中调用的是函数自身还是其他函数
闭包 闭包指的是那些引用了另一个作用域中变量的函数，通常是在嵌套函数中实现的，原理是包含外部函数作用域的作用域链
在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止
函数执行时，每个执行上下文中都会有一个包含其中变量的对象，全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。作用域链其实是一个包含指针的列表，每个指针指向一个变量对象，但物理上并不会包含相应的对象
函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域
在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中，活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用
因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用
在闭包中使用this，如果内部函数没有使用箭头函数定义，则this对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则this在非严格模式下等于window，严格模式下等于undefined。如果作为某个对象的方法调用，则this等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着this会指向window，除非在严格模式下this指向undefined
每个函数在被调用时都会自动创建两个特殊变量：this和arguments。内部函数永远不可能直接访问外部函数的这两个变量
赋值表达式的值是函数本身
立即调用函数表达式 立即调用的匿名函数又被称作立即调用的函数表达式(IIFE)，它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式
使用IIFE可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数，这样位于函数体作用域的变量就像是在块级作用域中一样
IIFE不会导致闭包相关问题，因为不存在对这个匿名函数的引用，只要函数执行完毕，其作用域链就可以被销毁
IIFE可以用于锁定参数值
私有变量 任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数
如果函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的变量。基于这一点，就可以创建出能够访问私有变量的公有方法
特权方法是能够访问函数私有变量的公有方法。在对象上有两种方法创建特权方法：构造函数实现，静态私有变量实现
function MyObject(){ let privateVariable = 10 function privateFunction(){ return false } this.publicMethod = function(){ privateVariable&#43;&#43; return privateFunction } } 构造函数实现是把所有私有变量和私有函数都定义在构造函数中，然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。缺点是每个实例都会重新创建一遍新方法
(function(){ let privateVariable = 10 function privateFunction(){ return false } MyObject = function(){} MyObject.prototype.publicMethod = function(){ privateVariable&#43;&#43; return privateFunction() } }) 静态私有变量通过使用私有作用域定义私有变量和函数来实现，在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后有定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。
这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里不是必须的。
构造函数标识符未使用任何关键字，因为不使用关键字声明的变量会创建在全局作用域中，可以在私有作用域外部被访问
该模式，私有变量和私有函数是由实例共享的，因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域
let singleton = function(){ let privateVariable = 10 function privateFunction(){ return false } return { publicProperty:true publicMethod(){ privateVariable&#43;&#43; return privateFunction() } } } 模块模式在一个单例对象上实现了相同的隔离和封装。模块模式使用了匿名函数返回一个对象，在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的公有方法都可以访问同一个作用域的私有变量和私有函数。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/10.11-10.16-%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> ES6扩展操作符简化了函数参数处理，可拆分可迭代对象为单独参数或收集剩余参数为数组。函数声明会提升，表达式则不会。函数可作为值传递或返回。函数内部有arguments、this、caller等特性，方法包括apply/call改变this和bind创建绑定函数。严格模式影响this行为，箭头函数保持定义时上下文。函数属性如length、prototype，继承方法返回函数代码或自身。
参数扩展与收集 在给函数传参时，有时候可能不需要传入一个数组，而是要分别传入数组的元素。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于apply方法
在ES6中，可以通过扩展操作符极为简洁地实现这种操作，对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入
因为数组长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前后再传其他的值，包括使用扩展操作符传其他参数
在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合成一个数组，这有点类似arguments对象的构造机制，只不过收集参数的结果会得到一个Array实例
收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数
箭头函数虽然不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments一样的逻辑
使用收集参数不影响arguments对象，它仍然反映调用时传给函数的参数
函数声明与函数表达式 JS引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义
函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫做函数声明提升。在执行代码时，JS引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部，因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部，如果把函数声明改为等价表达式，那么执行时会报错
函数作为值 不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数
如果是访问函数而不是调用函数，那就必须不带括号
从一个函数中返回另一个函数也是可以的，而且非常有用
函数内部 arguments：是一个类数组对象，包含调用函数时传入的所有参数，这个对象只有以function关键字定义函数时才会有，该对象其中还有一个callee属性，指向arguments对象所在函数的指针，用作递归中可以让函数逻辑与函数名解耦
this
在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候通常称其为this值
箭头函数中this引用的是定义箭头函数的上下文
caller：这个属性引用的是调用当前函数的函数，如果是在全局作用域中调用的则为null
严格模式下访问arguments.callee会报错，arguments.caller也是
new.target：ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。如果是普通调用，则new.target的值是undefined，如果是new关键字调用的，则new.target将引用被调用的构造函数
函数属性与方法 length属性保存函数定义的命名参数的个数
prototype是保存引用类型所有实例方法的地方，由所有实例共享
apply()和call()方法都会以指定的this值来调用函数，即会设置调用函数时函数体内this对象的值。
apply()方法接收两个参数：函数内this的值和一个参数数组。第二个参数可以是Array实例，也可以是arguments对象
在严格模式下，调用函数时，如果没有指定上下文对象，则this值不会指向window。除非使用apply或call把函数指定给一个对象，否则this的值会变成undefined
call()方法与apply()方法一样，只是传参的形式不同，第一个参数也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。
使用call()和apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法
bind()方法会创建一个新的函数实例，其this值会被绑定到传给bind()的对象
继承的toLocaleString()和toString()方法时钟返回函数的代码，返回代码的格式因浏览器而异。valueOf()返回函数本身
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/10.6-10.10-%E5%87%BD%E6%95%B0/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/page/5/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/page/7/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
