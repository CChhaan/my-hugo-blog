<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.148.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>拾光博客 - 永浩</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://growyears.netlify.app/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://growyears.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://growyears.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://growyears.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://growyears.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://growyears.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://growyears.netlify.app/index.xml">
<link rel="alternate" hreflang="en" href="https://growyears.netlify.app/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://growyears.netlify.app/">
  <meta property="og:site_name" content="拾光博客 - 永浩">
  <meta property="og:title" content="拾光博客 - 永浩">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="拾光博客 - 永浩">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "拾光博客 - 永浩",
  "url": "https://growyears.netlify.app/",
  "description": "",
  "logo": "https://growyears.netlify.app/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://growyears.netlify.app/" accesskey="h" title="拾光博客 - 永浩 (Alt + H)">拾光博客 - 永浩</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、网页的三层结构 网页的呈现和交互由结构层、表示层、行为层共同构成，三者各司其职又协同工作：
结构层： 由 HTML/XHTML 标记语言实现，通过标签（如 &lt;p&gt;、&lt;div&gt;）描述内容的语义和结构（如标题、段落、列表），不包含样式或行为信息。 示例：&lt;h1&gt;标题&lt;/h1&gt; 仅定义 “这是一个一级标题”，不规定其颜色、大小。 表示层： 由 CSS 负责，定义内容的视觉呈现（如颜色、字体、布局）。 即使未显式编写 CSS，浏览器也会应用默认样式（如 &lt;h1&gt; 默认加粗、字号较大）。 行为层： 由 JavaScript 和 DOM 控制，定义内容对事件的响应方式（如点击、鼠标悬停）。 浏览器默认也有基础行为（如链接点击跳转、表单提交），JS 可扩展或修改这些行为。 二、通过 DOM 操作样式：style 属性 1. style 属性的特性 每个元素节点的 style 属性是一个对象，包含该元素的内嵌样式（即通过 style 属性直接定义的样式，如 &lt;div style=&#34;color: red&#34;&gt;）。
命名规则：CSS 属性名中的减号（如 font-size）在 style 对象中需转换为驼峰命名法（如 style.fontSize），避免与 JS 语法冲突。
局限性：
仅能获取 / 修改内嵌样式，无法访问外部 CSS 文件或 &lt;style&gt; 标签中定义的样式。
示例：
&lt;div id=&#34;box&#34; style=&#34;width: 100px; color: blue;&#34;&gt;&lt;/div&gt; &lt;script&gt; const box = document.getElementById(&#34;box&#34;); console.log(box.style.width); // 输出 &#34;100px&#34;（获取内嵌样式） console.log(box.style.fontSize); // 输出 &#34;&#34;（非内嵌样式无法获取） &lt;/script&gt; 2. 通过 style 属性设置样式 style 对象的属性是可读写的，可通过赋值修改样式，值需为字符串（需加引号）。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B9%9D%E7%AB%A0-css-dom/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、语法 1. 变量 定义：变量是存储可变值的容器，将值存入变量的操作称为赋值。 声明与赋值： JS 中，未声明的变量赋值时会自动声明（不推荐，易导致全局污染）。 可一次性声明多个变量：var a, b, c;。 可在声明时赋值：var x = 10, y = &#34;hello&#34;;。 命名规则： 区分大小写（name 与 Name 是不同变量）。 允许包含字母、数字、$、_，但不能以数字开头，不能包含空格或标点符号（$ 除外）。 长变量名可读性优化： 下划线命名法：user_name； 驼峰命名法：userName（第二个单词起首字母大写）。 字面量：直接在代码中写出的数据（如 123、&#34;abc&#34;、true）。 2. 数据类型 弱类型特性：JS 是弱类型语言，无需声明变量类型，可随时修改变量的类型（与强类型语言需显式声明类型不同）。 字符串： 由零个或多个字符组成，需用单引号（&#39;）或双引号（&#34;）包裹。 引号选择规则：字符串包含双引号时用单引号包裹（如 &#39;He said &#34;Hi&#34;&#39;），反之亦然。 转义字符：用反斜线（\）转义特殊字符，如 \&#34; 表示双引号（&#34;She said \&#34;Hello\&#34;&#34;）。 数值： 支持整数（如 42）和浮点数（如 3.14），可带正负号（如 -5、-2.7）。 布尔值： 仅两个值：true（真）和 false（假），不可用引号包裹（否则为字符串）。 3. 数组 定义：用一个变量存储一组值（元素），元素可通过下标访问（下标从 0 开始）。 声明与初始化： 用 Array 关键字：var arr = new Array(); 或 var arr = new Array(3);（指定初始长度，可选）。 简洁语法（推荐）：var arr = [1, &#34;a&#34;, true];（直接用方括号包裹元素，元素类型可混合）。 元素操作： 赋值：arr[0] = 10;（通过下标赋值）。 嵌套数组：数组元素可是另一个数组（如 var nested = [1, [2, 3]];）。 关联数组： 用字符串作为下标（如 arr[&#34;name&#34;] = &#34;Alice&#34;），本质是为数组对象添加属性。 注意：不推荐修改 Array 对象的属性，如需键值对存储，建议使用对象。 4. 对象 定义：由属性（变量）和方法（函数）组成的集合，通过属性名而非下标访问元素。 声明与初始化： 用 Object 关键字：var obj = new Object();。 简洁语法（推荐）：var obj = { name: &#34;Bob&#34;, age: 20 };（花括号包裹键值对，键值用 : 分隔，键值对间用 , 分隔）。 属性访问：用点语法（obj.name）或方括号（obj[&#34;name&#34;]）。 特性：属性值可以是任意类型（包括其他对象），适合通过名称而非位置管理数据。 二、操作 1. 算术操作符 基础操作符： 加法（&#43;）、减法（-）、乘法（*）、除法（/）。 可组合操作，用括号改变优先级（如 (2 &#43; 3) * 4）。 快捷操作符： 自增（&#43;&#43;）：x&#43;&#43; 等价于 x = x &#43; 1。 自减（--）：x-- 等价于 x = x - 1。 复合赋值（&#43;=）：x &#43;= 5 等价于 x = x &#43; 5，也可用于字符串拼接（str &#43;= &#34;world&#34;）。 字符串拼接： &#43; 可拼接字符串（如 &#34;Hello&#34; &#43; &#34; &#34; &#43; &#34;World&#34;）。 数值与字符串拼接时，数值自动转为字符串（如 123 &#43; &#34;abc&#34; 结果为 &#34;123abc&#34;）。 三、条件语句 1. 基本语法 if 语句：当条件为true时执行代码块：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0-js%E8%AF%AD%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、平稳退化 定义：确保网站在浏览器不支持 JavaScript 或 JS 被禁用时，核心功能仍可正常使用（如链接可点击、内容可访问）。 关键原则： 为 JS 功能提供 “退路”，例如将链接的 href 属性设置为真实 URL，而非仅依赖 onclick 事件。 避免过度依赖 JS 实现基础功能（如导航、跳转）。 1. 弹出窗口与平稳退化 window.open() 方法：用于创建新窗口，语法为window.open(url, name, features)，参数分别为目标 URL、窗口名称、窗口属性（如尺寸、功能）。
示例函数：
function popUp(winUrl) { window.open(winUrl, &#39;popup&#39;, &#39;width=320,height=480&#39;); } 调用方式的问题：
伪协议（javascript:）：如 &lt;a href=&#34;javascript:popUp(&#39;url&#39;)&#34;&gt;，在禁用 JS 时失效，不推荐。 空链接（#）：如 &lt;a href=&#34;#&#34; onclick=&#34;popUp(&#39;url&#39;);return false&#34;&gt;，禁用 JS 时点击会跳转至页面顶部，体验差。 正确做法：
让href指向真实 URL，onclick中通过return false阻止默认跳转，确保 JS 禁用时仍能正常访问：
&lt;a href=&#34;http://www.baidu.com&#34; onclick=&#34;popUp(&#39;http://www.baidu.com&#39;);return false;&#34;&gt;baidu&lt;/a&gt; 二、分离 JavaScript 核心思想：将 JS 代码从 HTML 中剥离，通过外部脚本文件管理，避免 HTML 与 JS 耦合。
实现步骤：
HTML 保留基础功能：链接使用真实 href，通过 class或id标识需要特殊处理的元素：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、&lt;abbr&gt; 与 &lt;acronym&gt; 标签 &lt;abbr&gt;：表示缩略语（对单词或短语的缩写，如 “Mr.” 是 “Mister” 的缩写），通常建议通过title
属性提供完整含义，例如：
&lt;abbr title=&#34;HyperText Markup Language&#34;&gt;HTML&lt;/abbr&gt; &lt;acronym&gt;：专门表示首字母缩写词（由多个单词首字母组成，且发音为一个单词，如 “NASA” 读作 “nasa”）。
注意：HTML5 中已废弃 &lt;acronym&gt;，推荐统一使用 &lt;abbr&gt; 替代，因其语义更通用。 二、DOCTYPE 与浏览器渲染模式 DOCTYPE 的作用：告知浏览器文档使用的 HTML 版本，决定浏览器以标准模式还是兼容模式渲染页面。
标准模式：浏览器严格遵循 W3C 规范渲染页面，保证跨浏览器一致性。 兼容模式（怪异模式）：模仿早期浏览器（如 IE6）的非标准行为，允许不规范的代码正常运行（如忽略闭合标签、错误的盒模型计算）。 HTML5 的 DOCTYPE：
&lt;!DOCTYPE html&gt; 此声明简洁且默认触发标准模式，无需指定具体版本，是现代网页的推荐写法。
三、换行符与 DOM 文本节点 部分浏览器（如早期 IE、部分基于 WebKit 的浏览器）会将 HTML 中的换行符解析为文本节点（nodeType = 3），导致 childNodes 等集合中包含空文本节点。 影响：遍历子节点时需注意过滤空文本节点（可通过 nodeValue.trim() === &#34;&#34; 判断），避免逻辑错误。 四、accesskey 属性 作用：为元素绑定键盘快捷键，提升可访问性（尤其适合键盘用户）。
用法：
&lt;a href=&#34;index.html&#34; accesskey=&#34;h&#34;&gt;首页&lt;/a&gt; 触发方式：
Windows 系统：Alt &#43; 快捷键（如 Alt &#43; h）； macOS 系统：Ctrl &#43; 快捷键（如 Ctrl &#43; h）。 注意：避免与浏览器默认快捷键冲突（如 Alt &#43; F 通常打开文件菜单），且需在页面中明确提示快捷键（如通过文字说明）。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、JS 与网页结构的解耦原则 核心思想：为网页添加行为时，JS 代码应尽量避免依赖特定的 HTML 结构（如固定的标签嵌套、类名顺序等）。 好处：当 HTML 结构调整时，JS 代码无需频繁修改，提高可维护性。 二、命名规范与注意事项 1. 命名原则 可读性：使用有意义的单词命名变量、函数（如 calculateTotal 而非 fn1），通过命名体现用途。 风格统一：变量和函数名推荐使用驼峰命名法（如 userName、handleClick），常量常用全大写（如 MAX_SIZE）。 2. 命名禁忌 避免保留字：不能使用 JS 语言的保留字（如 if、function、class 等）作为变量名。 避免覆盖内置 API：不使用现有 JS 函数 / 方法名（如 alert、push）作为变量名，防止覆盖内置功能。 三、节点链表（NodeList） 定义：由 DOM 方法（如 getElementsByTagName、querySelectorAll）返回的节点集合，类似数组但并非真正的数组（是类数组对象）。 特性： 每个节点都有自身的属性（如 nodeType、nodeName）和方法（如 appendChild）。 动态性：部分 NodeList（如 getElementsByTagName 返回的集合）会随 DOM 变化自动更新。 四、共享 onload 事件：addLoadEvent 函数 问题：window.onload 只能绑定一个函数，多次赋值会覆盖之前的函数。 解决方案：addLoadEvent 函数用于将多个函数追加到 window.onload 事件中，确保所有函数在页面加载完成后执行。 实现逻辑： function addLoadEvent(func) { const oldOnload = window.onload; // 保存现有 onload 函数 if (typeof window.onload !== &#39;function&#39;) { // 若 onload 未绑定函数，直接赋值 window.onload = func; } else { // 若已绑定函数，追加新函数 window.onload = function() { oldOnload(); // 执行原有函数 func(); // 执行新函数 }; } } 五、nodeName 属性 特性：返回元素节点的标签名，始终为大写字母（即使 HTML 中标签是小写，如 &lt;div&gt; 的 nodeName 为 &#34;DIV&#34;）。 用途：判断元素类型（如 if (element.nodeName === &#34;LI&#34;) 检测是否为列表项）。 六、键盘事件与交互一致性 1. onkeypress 事件 触发时机：按下键盘上的任意按键（包括字母、数字、符号等）时触发。 用途：监听键盘输入（如表单验证、快捷键操作）。 2. 键盘与鼠标事件的一致性 用 Tab 键聚焦到链接后按 Enter 键，会触发该链接的 onclick 事件，与鼠标点击效果一致。 意义：确保键盘用户与鼠标用户获得相同的交互体验，提升可访问性。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、元素属性操作的两种方式 1. 直接属性赋值（传统方式） 语法：element.属性名 = 值（如 input.value = &#34;hello&#34;）。 适用场景：大部分 HTML 元素的标准属性（如 value、src、href 等）。 特点：简单直接，但仅支持预定义的标准属性，不支持自定义属性。 2. setAttribute() 方法（DOM Level 1） 语法：element.setAttribute(属性名, 属性值)（如 div.setAttribute(&#34;data-id&#34;, &#34;123&#34;)）。 优势： 可设置任意元素的任意属性（包括自定义属性），兼容性更强。 遵循 DOM 标准，可移植性好（适用于多种环境和编程语言）。 注意：修改后会实时反映在 DOM 中，但不会改变原始 HTML 源代码。 二、JS 文件优化：合并文件 目的：减少 HTTP 请求次数，提高页面加载性能。 做法：将多个 .js 文件合并为一个文件，通过单次请求加载。 三、事件处理函数 1. 基本概念 作用：在特定事件发生时执行指定 JS 代码（如点击、鼠标悬停等）。 语法：元素.事件处理函数 = &#34;JS 语句&#34; 或通过 DOM 方法绑定（如 element.onclick = function() {}）。 常用事件： onclick：用户点击元素时触发； onmouseover：鼠标指针悬停在元素上时触发； onmouseout：鼠标指针离开元素时触发； onload：页面或资源（如图片）加载完成时触发（常用于页面初始化）。 2. 事件处理函数的返回值 事件触发的 JS 代码可返回一个值，该值会传递给事件处理函数。 典型应用：阻止默认行为 例如，在&lt;a&gt;标签的onclick中返回false，可阻止链接跳转： 1. 子节点获取：childNodes 作用：返回当前元素的所有子节点（包含元素节点、文本节点、空格 / 换行节点等），结果为类数组对象。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 静态检查与静态类型检查 静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是动态检查（运行时检测错误，如 JS 中的TypeError）。
静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。
2. TypeScript 与 JavaScript 的关系 TypeScript 是 JavaScript 的超集：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。
关键区别：TS 增加了静态类型系统，而 JS 是动态类型语言（类型检查仅在运行时发生）。
重要特性：
TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。 TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。 注意：TS 会对 JS 代码进行类型检查（如let a = 1; a = &#39;str&#39;在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。
3. TypeScript 的核心优势（面试高频） 提前发现错误：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。
增强代码可读性：类型注解明确变量 / 函数的预期用途，降低团队协作成本。
提升开发效率：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。
更好的可维护性：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。
4. TypeScript 的类型推断与扩展 类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。 例：let x = 10 → TS 推断x为number；const y = { name: &#39;ts&#39; } → 推断y为{ name: string }。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/01--ts/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 基础类型与数组类型 JavaScript 基础类型：string、number 、 boolean（对应 JS 原始类型），TypeScript 中可直接作为类型注解使用。
特点：使用typeof运算符对这些类型的值操作时，返回值与类型名一致（如typeof &#39;abc&#39; === &#39;string&#39;）。 数组类型：
两种声明方式：T[]（如number[]表示数字数组）或Array&lt;T&gt;（泛型形式，如Array&lt;number&gt;），两者完全等价。 2. 特殊类型 any 核心特性：关闭类型检查，允许值被任意操作（访问任意属性、作为函数调用、赋值给任何类型等）。
适用场景：
处理动态内容（如来自 API 的未知数据）。 迁移 JS 项目时临时兼容无类型代码。 隐式any：未指定类型且 TS 无法推断时，编译器默认视为any（可通过noImplicitAny配置项禁用，强制显式声明类型，面试高频考点）。
风险与替代：
滥用any会失去 TS 类型检查的意义，建议优先使用unknown（更安全，需显式类型断言后使用）。 3. 变量与函数的类型注解 变量注解： let 变量名: 类型 = 值（如 let age: number = 20）。
多数情况可省略：TS 会自动推断类型（如let name = &#39;ts&#39; → 推断为string）。 函数参数类型注解：在每个参数名称后添加，用于声明函数接受的参数类型，即使参数无类型注释，TypeScript 仍会检查参数数量是否正确。
函数返回类型注解：出现在参数列表之后。（如function add(a: number, b: number): number { return a &#43; b }）。
函数参数类型自动推断：当函数出现在 TypeScript 可确定调用方式的地方时，其参数会自动被赋予类型。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/02--%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 类型缩小与控制流分析基础 TS 会跟踪代码执行路径（如if/else、switch、循环等），分析变量在不同分支中的具体类型。
类型保护：特殊表达式（如typeof x === &#39;string&#39;），TS 可通过它判断变量类型，从而缩小类型范围。
类型缩小：通过类型保护或赋值操作，将变量类型从 “宽泛”（如联合类型）收缩为 “具体”（如单一类型）的过程。
2. 基于 typeof 运算符的类型缩小 TS 可识别typeof的 8 种返回值：&#34;string&#34;、&#34;number&#34;、&#34;bigint&#34;、&#34;boolean&#34;、&#34;symbol&#34;、&#34;undefined&#34;、&#34;object&#34;、&#34;function&#34;。
typeof检查是一种类型保护，TypeScript 编码了typeof对不同值的操作逻辑，包括其在 JavaScript 中的一些特性。
3. 基于真值检查的类型缩小 JavaScript 中，if等构造会将条件强制为布尔值，0、NaN、&#34;&#34;（空字符串）、0n（bigint版本零）、null、undefined强制为false，其他值强制为true。
可通过Boolean函数或双布尔否定（!!）将值强制为布尔值，后者的优势是 TypeScript 会推断出缩小的字面布尔类型true，而前者推断为boolean类型。
利用这种行为防范null或undefined很常见，带有!的布尔否定会从否定分支中过滤掉这些值。
4. 基于相等性检查的类型缩小 TypeScript 使用switch语句和===、!==、==、!=等相等性检查来缩小类型。
== null不仅检查值是否为null，还检查是否为undefined；== undefined同样检查值是null还是undefined。
5. 基于 in 运算符的类型缩小 JavaScript 的in运算符用于确定对象或其原型链是否具有指定名称的属性。
TypeScript 将in运算符视为缩小潜在类型的方式：对于&#34;value&#34; in x（“value&#34;为字符串字面，x为联合类型），“true” 分支会缩小x为具有可选或必需属性value的类型，“false” 分支缩小为具有可选或缺少属性value的类型。
6. 基于 instanceof 的类型缩小 检查值的原型链是否包含构造函数的prototype，适用于new创建的对象
instanceof是类型保护，TypeScript 会在instanceof保护的分支中缩小类型。
7. 基于赋值的类型缩小 变量赋值后，TS 会根据赋值内容缩小其类型。 8. 用户定义的类型保护 定义方式：创建返回类型为类型谓词的函数，谓词形式为parameterName is Type，其中parameterName必须是当前函数签名中的参数名称。 9. 可区分的联合 联合类型中的每个成员都包含一个字面量类型的公共属性（如type字段），用于区分不同类型，TypeScript 将其视为可区分的联合，可通过检查该属性缩小联合的成员范围，switch语句中也适用这种检查。 10. never 类型与穷尽检查 缩小类型时，若联合的选项被全部消除，会得到never类型，表示不应该存在的状态。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/03--%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 函数类型表达式 基本语法：用箭头函数形式描述函数类型，如(a: string) =&gt; void（参数a为string类型，无返回值）。
特点：参数名必须存在（仅用于标识，不影响类型匹配），未指定类型时隐式为any（可通过noImplicitAny禁用）。 示例：
function greeter(fn: (a: string) =&gt; void) { fn(&#34;Hello, World&#34;); } function printToConsole(s: string) { console.log(s); } greeter(printToConsole); // 符合函数类型要求 类型别名命名：通过type给函数类型命名，提升可读性和复用性： type GreetFunction = (a: string) =&gt; void; function greeter(fn: GreetFunction) { /* ... */ } 类型兼容性（面试高频）：函数类型兼容遵循 “参数少的可赋值给参数多的”（逆变原则简化版）： type F1 = (a: string) =&gt; void; type F2 = (a: string, b: number) =&gt; void; const f1: F1 = (a) =&gt; {}; const f2: F2 = f1; // 合法：F1参数更少，可兼容F2 2. 带属性的函数与调用签名 函数类型表达式的局限：仅能描述函数的调用方式，无法声明函数自身的属性（如fn.prop）。
调用签名：若需描述可调用且带属性的对象，可在对象类型中编写调用签名，参数列表与返回类型间用:分隔（而非=&gt;）：
type DescribableFunction = { description: string; (someArg: number): boolean; // 调用签名 }; function doSomething(fn: DescribableFunction) { console.log(fn.description &#43; &#34; returned &#34; &#43; fn(6)); } function myFunc(someArg: number) { return someArg &gt; 3; } myFunc.description = &#34;default description&#34;; doSomething(myFunc); // 符合带属性的函数类型 3. 构造函数与构造签名 构造函数：可通过new运算符调用的函数，TypeScript 中用构造签名描述，即在调用签名前加new关键字： type SomeConstructor = { new (s: string): SomeObject; // 构造签名 }; function fn(ctor: SomeConstructor) { return new ctor(&#34;hello&#34;); // 符合构造函数调用方式 } 可同时调用与构造的函数：如Date，可组合调用签名和构造签名（可直接调用Date()返回字符串，也可new Date()返回实例）： interface CallOrConstruct { (n?: number): string; // 普通调用签名 new (s: string): Date; // 构造签名 } function fn(ctor: CallOrConstruct) { console.log(ctor(10)); // 普通调用 console.log(new ctor(&#34;10&#34;)); // 构造调用 } fn(Date); // Date符合该类型 4. 泛型函数 基本概念：通过类型参数（如&lt;T&gt;）关联输入与输出类型，实现 “类型动态适配” // 类型参数Type关联输入数组与返回值 function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined { return arr[0]; } 类型推断：TS 会根据传入的实参自动推断类型参数，无需显式指定（复杂场景需手动指定）： function map&lt;Input, Output&gt;(arr: Input[], func: (arg: Input) =&gt; Output): Output[] { return arr.map(func); } const parsed = map([&#34;1&#34;, &#34;2&#34;, &#34;3&#34;], (n) =&gt; parseInt(n)); // 推断Input为string，Output为number 类型约束：通过extends限制类型参数的范围，仅允许符合约束的类型： // 限制Type必须有length属性 function longest&lt;Type extends { length: number }&gt;(a: Type, b: Type): Type { return a.length &gt;= b.length ? a : b; } 手动指定类型参数：当类型推断不明确时，可手动指定： function combine&lt;Type&gt;(arr1: Type[], arr2: Type[]): Type[] { return arr1.concat(arr2); } const arr = combine&lt;string | number&gt;([1, 2, 3], [&#34;hello&#34;]); // 手动指定Type为string | number 泛型函数设计原则（面试常问）：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://growyears.netlify.app/posts/ts/04--%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://growyears.netlify.app/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://growyears.netlify.app/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://growyears.netlify.app/">拾光博客 - 永浩</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
