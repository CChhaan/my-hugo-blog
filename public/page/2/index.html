<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.148.2"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://example.org/index.xml">
<link rel="alternate" hreflang="en" href="https://example.org/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://example.org/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My New Hugo Site">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My New Hugo Site",
  "url": "https://example.org/",
  "description": "",
  "logo": "https://example.org/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、网页的三层结构 网页的呈现和交互由结构层、表示层、行为层共同构成，三者各司其职又协同工作：
结构层： 由 HTML/XHTML 标记语言实现，通过标签（如 &lt;p&gt;、&lt;div&gt;）描述内容的语义和结构（如标题、段落、列表），不包含样式或行为信息。 示例：&lt;h1&gt;标题&lt;/h1&gt; 仅定义 “这是一个一级标题”，不规定其颜色、大小。 表示层： 由 CSS 负责，定义内容的视觉呈现（如颜色、字体、布局）。 即使未显式编写 CSS，浏览器也会应用默认样式（如 &lt;h1&gt; 默认加粗、字号较大）。 行为层： 由 JavaScript 和 DOM 控制，定义内容对事件的响应方式（如点击、鼠标悬停）。 浏览器默认也有基础行为（如链接点击跳转、表单提交），JS 可扩展或修改这些行为。 二、通过 DOM 操作样式：style 属性 1. style 属性的特性 每个元素节点的 style 属性是一个对象，包含该元素的内嵌样式（即通过 style 属性直接定义的样式，如 &lt;div style=&#34;color: red&#34;&gt;）。
命名规则：CSS 属性名中的减号（如 font-size）在 style 对象中需转换为驼峰命名法（如 style.fontSize），避免与 JS 语法冲突。
局限性：
仅能获取 / 修改内嵌样式，无法访问外部 CSS 文件或 &lt;style&gt; 标签中定义的样式。
示例：
&lt;div id=&#34;box&#34; style=&#34;width: 100px; color: blue;&#34;&gt;&lt;/div&gt; &lt;script&gt; const box = document.getElementById(&#34;box&#34;); console.log(box.style.width); // 输出 &#34;100px&#34;（获取内嵌样式） console.log(box.style.fontSize); // 输出 &#34;&#34;（非内嵌样式无法获取） &lt;/script&gt; 2. 通过 style 属性设置样式 style 对象的属性是可读写的，可通过赋值修改样式，值需为字符串（需加引号）。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%B9%9D%E7%AB%A0-css-dom/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、语法 1. 变量 定义：变量是存储可变值的容器，将值存入变量的操作称为赋值。 声明与赋值： JS 中，未声明的变量赋值时会自动声明（不推荐，易导致全局污染）。 可一次性声明多个变量：var a, b, c;。 可在声明时赋值：var x = 10, y = &#34;hello&#34;;。 命名规则： 区分大小写（name 与 Name 是不同变量）。 允许包含字母、数字、$、_，但不能以数字开头，不能包含空格或标点符号（$ 除外）。 长变量名可读性优化： 下划线命名法：user_name； 驼峰命名法：userName（第二个单词起首字母大写）。 字面量：直接在代码中写出的数据（如 123、&#34;abc&#34;、true）。 2. 数据类型 弱类型特性：JS 是弱类型语言，无需声明变量类型，可随时修改变量的类型（与强类型语言需显式声明类型不同）。 字符串： 由零个或多个字符组成，需用单引号（&#39;）或双引号（&#34;）包裹。 引号选择规则：字符串包含双引号时用单引号包裹（如 &#39;He said &#34;Hi&#34;&#39;），反之亦然。 转义字符：用反斜线（\）转义特殊字符，如 \&#34; 表示双引号（&#34;She said \&#34;Hello\&#34;&#34;）。 数值： 支持整数（如 42）和浮点数（如 3.14），可带正负号（如 -5、-2.7）。 布尔值： 仅两个值：true（真）和 false（假），不可用引号包裹（否则为字符串）。 3. 数组 定义：用一个变量存储一组值（元素），元素可通过下标访问（下标从 0 开始）。 声明与初始化： 用 Array 关键字：var arr = new Array(); 或 var arr = new Array(3);（指定初始长度，可选）。 简洁语法（推荐）：var arr = [1, &#34;a&#34;, true];（直接用方括号包裹元素，元素类型可混合）。 元素操作： 赋值：arr[0] = 10;（通过下标赋值）。 嵌套数组：数组元素可是另一个数组（如 var nested = [1, [2, 3]];）。 关联数组： 用字符串作为下标（如 arr[&#34;name&#34;] = &#34;Alice&#34;），本质是为数组对象添加属性。 注意：不推荐修改 Array 对象的属性，如需键值对存储，建议使用对象。 4. 对象 定义：由属性（变量）和方法（函数）组成的集合，通过属性名而非下标访问元素。 声明与初始化： 用 Object 关键字：var obj = new Object();。 简洁语法（推荐）：var obj = { name: &#34;Bob&#34;, age: 20 };（花括号包裹键值对，键值用 : 分隔，键值对间用 , 分隔）。 属性访问：用点语法（obj.name）或方括号（obj[&#34;name&#34;]）。 特性：属性值可以是任意类型（包括其他对象），适合通过名称而非位置管理数据。 二、操作 1. 算术操作符 基础操作符： 加法（&#43;）、减法（-）、乘法（*）、除法（/）。 可组合操作，用括号改变优先级（如 (2 &#43; 3) * 4）。 快捷操作符： 自增（&#43;&#43;）：x&#43;&#43; 等价于 x = x &#43; 1。 自减（--）：x-- 等价于 x = x - 1。 复合赋值（&#43;=）：x &#43;= 5 等价于 x = x &#43; 5，也可用于字符串拼接（str &#43;= &#34;world&#34;）。 字符串拼接： &#43; 可拼接字符串（如 &#34;Hello&#34; &#43; &#34; &#34; &#43; &#34;World&#34;）。 数值与字符串拼接时，数值自动转为字符串（如 123 &#43; &#34;abc&#34; 结果为 &#34;123abc&#34;）。 三、条件语句 1. 基本语法 if 语句：当条件为true时执行代码块：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0-js%E8%AF%AD%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、平稳退化 定义：确保网站在浏览器不支持 JavaScript 或 JS 被禁用时，核心功能仍可正常使用（如链接可点击、内容可访问）。 关键原则： 为 JS 功能提供 “退路”，例如将链接的 href 属性设置为真实 URL，而非仅依赖 onclick 事件。 避免过度依赖 JS 实现基础功能（如导航、跳转）。 1. 弹出窗口与平稳退化 window.open() 方法：用于创建新窗口，语法为window.open(url, name, features)，参数分别为目标 URL、窗口名称、窗口属性（如尺寸、功能）。
示例函数：
function popUp(winUrl) { window.open(winUrl, &#39;popup&#39;, &#39;width=320,height=480&#39;); } 调用方式的问题：
伪协议（javascript:）：如 &lt;a href=&#34;javascript:popUp(&#39;url&#39;)&#34;&gt;，在禁用 JS 时失效，不推荐。 空链接（#）：如 &lt;a href=&#34;#&#34; onclick=&#34;popUp(&#39;url&#39;);return false&#34;&gt;，禁用 JS 时点击会跳转至页面顶部，体验差。 正确做法：
让href指向真实 URL，onclick中通过return false阻止默认跳转，确保 JS 禁用时仍能正常访问：
&lt;a href=&#34;http://www.baidu.com&#34; onclick=&#34;popUp(&#39;http://www.baidu.com&#39;);return false;&#34;&gt;baidu&lt;/a&gt; 二、分离 JavaScript 核心思想：将 JS 代码从 HTML 中剥离，通过外部脚本文件管理，避免 HTML 与 JS 耦合。
实现步骤：
HTML 保留基础功能：链接使用真实 href，通过 class或id标识需要特殊处理的元素：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、&lt;abbr&gt; 与 &lt;acronym&gt; 标签 &lt;abbr&gt;：表示缩略语（对单词或短语的缩写，如 “Mr.” 是 “Mister” 的缩写），通常建议通过title
属性提供完整含义，例如：
&lt;abbr title=&#34;HyperText Markup Language&#34;&gt;HTML&lt;/abbr&gt; &lt;acronym&gt;：专门表示首字母缩写词（由多个单词首字母组成，且发音为一个单词，如 “NASA” 读作 “nasa”）。
注意：HTML5 中已废弃 &lt;acronym&gt;，推荐统一使用 &lt;abbr&gt; 替代，因其语义更通用。 二、DOCTYPE 与浏览器渲染模式 DOCTYPE 的作用：告知浏览器文档使用的 HTML 版本，决定浏览器以标准模式还是兼容模式渲染页面。
标准模式：浏览器严格遵循 W3C 规范渲染页面，保证跨浏览器一致性。 兼容模式（怪异模式）：模仿早期浏览器（如 IE6）的非标准行为，允许不规范的代码正常运行（如忽略闭合标签、错误的盒模型计算）。 HTML5 的 DOCTYPE：
&lt;!DOCTYPE html&gt; 此声明简洁且默认触发标准模式，无需指定具体版本，是现代网页的推荐写法。
三、换行符与 DOM 文本节点 部分浏览器（如早期 IE、部分基于 WebKit 的浏览器）会将 HTML 中的换行符解析为文本节点（nodeType = 3），导致 childNodes 等集合中包含空文本节点。 影响：遍历子节点时需注意过滤空文本节点（可通过 nodeValue.trim() === &#34;&#34; 判断），避免逻辑错误。 四、accesskey 属性 作用：为元素绑定键盘快捷键，提升可访问性（尤其适合键盘用户）。
用法：
&lt;a href=&#34;index.html&#34; accesskey=&#34;h&#34;&gt;首页&lt;/a&gt; 触发方式：
Windows 系统：Alt &#43; 快捷键（如 Alt &#43; h）； macOS 系统：Ctrl &#43; 快捷键（如 Ctrl &#43; h）。 注意：避免与浏览器默认快捷键冲突（如 Alt &#43; F 通常打开文件菜单），且需在页面中明确提示快捷键（如通过文字说明）。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%85%E5%AE%9E%E7%9A%84%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%85%E5%AE%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、JS 与网页结构的解耦原则 核心思想：为网页添加行为时，JS 代码应尽量避免依赖特定的 HTML 结构（如固定的标签嵌套、类名顺序等）。 好处：当 HTML 结构调整时，JS 代码无需频繁修改，提高可维护性。 二、命名规范与注意事项 1. 命名原则 可读性：使用有意义的单词命名变量、函数（如 calculateTotal 而非 fn1），通过命名体现用途。 风格统一：变量和函数名推荐使用驼峰命名法（如 userName、handleClick），常量常用全大写（如 MAX_SIZE）。 2. 命名禁忌 避免保留字：不能使用 JS 语言的保留字（如 if、function、class 等）作为变量名。 避免覆盖内置 API：不使用现有 JS 函数 / 方法名（如 alert、push）作为变量名，防止覆盖内置功能。 三、节点链表（NodeList） 定义：由 DOM 方法（如 getElementsByTagName、querySelectorAll）返回的节点集合，类似数组但并非真正的数组（是类数组对象）。 特性： 每个节点都有自身的属性（如 nodeType、nodeName）和方法（如 appendChild）。 动态性：部分 NodeList（如 getElementsByTagName 返回的集合）会随 DOM 变化自动更新。 四、共享 onload 事件：addLoadEvent 函数 问题：window.onload 只能绑定一个函数，多次赋值会覆盖之前的函数。 解决方案：addLoadEvent 函数用于将多个函数追加到 window.onload 事件中，确保所有函数在页面加载完成后执行。 实现逻辑： function addLoadEvent(func) { const oldOnload = window.onload; // 保存现有 onload 函数 if (typeof window.onload !== &#39;function&#39;) { // 若 onload 未绑定函数，直接赋值 window.onload = func; } else { // 若已绑定函数，追加新函数 window.onload = function() { oldOnload(); // 执行原有函数 func(); // 执行新函数 }; } } 五、nodeName 属性 特性：返回元素节点的标签名，始终为大写字母（即使 HTML 中标签是小写，如 &lt;div&gt; 的 nodeName 为 &#34;DIV&#34;）。 用途：判断元素类型（如 if (element.nodeName === &#34;LI&#34;) 检测是否为列表项）。 六、键盘事件与交互一致性 1. onkeypress 事件 触发时机：按下键盘上的任意按键（包括字母、数字、符号等）时触发。 用途：监听键盘输入（如表单验证、快捷键操作）。 2. 键盘与鼠标事件的一致性 用 Tab 键聚焦到链接后按 Enter 键，会触发该链接的 onclick 事件，与鼠标点击效果一致。 意义：确保键盘用户与鼠标用户获得相同的交互体验，提升可访问性。 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>一、元素属性操作的两种方式 1. 直接属性赋值（传统方式） 语法：element.属性名 = 值（如 input.value = &#34;hello&#34;）。 适用场景：大部分 HTML 元素的标准属性（如 value、src、href 等）。 特点：简单直接，但仅支持预定义的标准属性，不支持自定义属性。 2. setAttribute() 方法（DOM Level 1） 语法：element.setAttribute(属性名, 属性值)（如 div.setAttribute(&#34;data-id&#34;, &#34;123&#34;)）。 优势： 可设置任意元素的任意属性（包括自定义属性），兼容性更强。 遵循 DOM 标准，可移植性好（适用于多种环境和编程语言）。 注意：修改后会实时反映在 DOM 中，但不会改变原始 HTML 源代码。 二、JS 文件优化：合并文件 目的：减少 HTTP 请求次数，提高页面加载性能。 做法：将多个 .js 文件合并为一个文件，通过单次请求加载。 三、事件处理函数 1. 基本概念 作用：在特定事件发生时执行指定 JS 代码（如点击、鼠标悬停等）。 语法：元素.事件处理函数 = &#34;JS 语句&#34; 或通过 DOM 方法绑定（如 element.onclick = function() {}）。 常用事件： onclick：用户点击元素时触发； onmouseover：鼠标指针悬停在元素上时触发； onmouseout：鼠标指针离开元素时触发； onload：页面或资源（如图片）加载完成时触发（常用于页面初始化）。 2. 事件处理函数的返回值 事件触发的 JS 代码可返回一个值，该值会传递给事件处理函数。 典型应用：阻止默认行为 例如，在&lt;a&gt;标签的onclick中返回false，可阻止链接跳转： 1. 子节点获取：childNodes 作用：返回当前元素的所有子节点（包含元素节点、文本节点、空格 / 换行节点等），结果为类数组对象。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/js-dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6js%E5%9B%BE%E7%89%87%E5%BA%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p>&lt;!DOCTYPE html&gt; Vite App </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/vue%E5%AD%A6%E4%B9%A0/code/vue-project/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> JavaScript中this的绑定规则取决于函数的调用方式而非声明位置。核心规则包括：默认绑定（非严格模式绑定全局对象，严格模式为undefined）、隐式绑定（通过对象调用）、显式绑定（call/apply/bind）和new绑定（构造函数调用）。箭头函数例外，它继承外层作用域的this且不可更改。优先级顺序为：new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。特殊情况下，传入null/undefined会触发默认绑定，而硬绑定函数被new调用时会替换this。理解这些规则对掌握JavaScript的执行上下文至关重要。
this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件
this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
当一个函数被调用时，会创建一个活动记录（也称为执行上下文），这个记录会包含函数在哪里被调用，函数的调用方式，传入的参数等信息，this就是这个记录的一个属性，会在函数执行的过程中用到
调用位置就是函数在代码中被调用的位置，在当前正在执行的函数的前一个调用中
默认绑定：函数直接使用不带任何修饰的函数引用进行调用（独立函数调用），只能使用默认绑定，无法应用其他规则，非严格模式下，默认绑定绑定到全局对象，在严格模式下绑定到undefined
隐式绑定：当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象
对象属性引用链中只有上一层或者说最后一层在调用位置中起作用
显示绑定：所有函数都可以使用call()和apply()方法，它们的第一个参数是一个对象，接着在调用函数时将其绑定到this
如果传入一个原始值来当做this的绑定对象，这个原始值会被转换成它的对象形式，这通常被称为装箱
硬绑定：一种显式的强制绑定
function foo(){ console.log(this.a) } var obj = { a:2 } var bar = function(){ foo.call(obj) } 可以创建一个包裹函数，负责接收参数并返回值
var bar = function(){ return foo.apply(obj,arguments) } 另一种是创建一个可以重复使用的辅助函数
function bind(fn,obj){ return function(){ return fn.apply(obj,arguments) } } var bar = bind(foo,obj) bar(3) ES5提供了内置的方法Function.prototype.bind，返回一个硬编码的新函数，把指定的参数设置为this的上下文并调用原始函数
JS许多内置函数或第三方库函数都提供了一个可选的参数，通常被称为上下文，其作用和bind一样，确保回调函数使用指定的this，实际上都是通过call或apply实现了显示绑定
new绑定：在JS中，构造函数只是一些使用new操作符时被调用的函数，它们并不会属于某个类，也不会实例化一个类，只是被new操作符调用的普通函数而已
所有函数都可以用new调用，这种函数调用被称为构造函数调用
使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
创建一个全新的对象 这个新对象会被执行[[Prototype]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 bind()方法会判断硬绑定函数是否被new调用，如果是的话就会使用新创建的this替换硬绑定的this。
在new中使用硬绑定函数主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数
根据优先级判断this：
函数是否在new中调用？如果是的话this绑定的是新创建的对象 函数是否通过call，apply或者硬绑定调用？如果是的话，this绑定的是指定的对象 函数是否在某个上下文对象中调用？如果是的话，this绑定的是那个上下文对象 如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到undefined，否则绑定到全局对象 如果null或undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则
apply可以用来展开数组，并当做参数传入一个函数；bind可以对参数进行柯里化，预先设置一些参数
Object.create(null)可以创建一个空对象，并且不会创建Object.prototype这个委托，比{}更空
忽略this绑定时传入空对象可以避免对全局对象产生影响
有可能会创建一个函数的间接引用，在这种情况下，调用这个函数会应用默认绑定规则
箭头函数不使用this的四种标准规则，而是根据外层作用域来决定this
箭头函数的绑定无法被修改，箭头函数可以像bind一样确保函数的this绑定到指定的对象，用常见的词法作用域取代了传统的this机制
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/1.this/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文摘要：JavaScript对象可以通过文字声明或构造形式定义，两种方式结果相同但写法不同。JS有6种基本类型和多种对象子类型，包括内置对象如Array、Date等。对象属性存储的是名称而非值本身，可通过点语法或块访问访问。属性描述符可控制属性的可写性、可配置性等特性。通过Object.preventExtensions()、Object.seal()和Object.freeze()可实现不同级别的对象不可变性。in、hasOwnProperty()等方法可用于检查属性存在性，forEach、every等辅助迭代器可用于数组遍历。for..of循环通过内置@@iterator实现迭代访问。
对象可以通过两种形式定义：声明文字形式和构造形式
构造形式和文字形式生成的对象是一样的，唯一的区别是，在文字声明中可以添加多个键值对，但是在构造形式中必须逐个添加属性
在JS中一共有六种主要类型：string、number、boolean、null、undefined和object
简单基本类型本身并不是对象，JS中有许多特殊的对象子类型，我们称之为复杂基本类型
函数就是对象的一个子类型（可调用的对象），JS中的函数是一等公民，因为他本质上和普通的对象一样（只是可调用），所以可以像操作其他对象一样操作函数
数组也是对象的一种类型，具备一些额外的行为，数组中内容的组织方式比一般的对象要稍微复杂一些
JS还有一些对象子类型，被称为内置对象，String、Number、Boolean、Object、Function、Array、Date、RegExp、Error
这些内置函数可以当做构造函数来使用，从而可以构造一个对应子类型的新对象
有必要时，语言会自动把字面量转换成对应的内置对象，也就是说并不需要显式创建一个对象
null和undefined没有对应的构造形式，它们只有文字形式，Date只有构造，没有文字形式
对于Object、Array、Function和RegExp来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，构造形式可以提供一些额外选项，建议只在需要那些额外选项时使用构造形式
Error对象很少在代码中显式创建，一般是在抛出异常时被自动创建，也可以使用new Error()这种构造形式来创建
对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性
在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部，存储在对象容器内部的是这些属性的名称，它们就像指针一样，指向这些值真正的存储位置
.语法通常被称为属性访问，[&#34;&#34;]语法通常被称为块访问，这两种语法的主要区别是.操作符要求属性名满足标识符的命名规范，[&#34;&#34;]语法可以接受任意UTF-8/Unicode字符串作为属性名。此外，由于[&#34;&#34;]语法使用字符串来访问属性，所以可以在程序中构造这个字符串
在对象中，属性名永远都是字符串，如果使用string字面量以外的其他值作为属性名，那它首先会被转换为一个字符串
可以在文字形式中使用[]包裹一个表达式来当做属性名（可计算属性名）
函数永远不会属于一个对象，无论返回值是什么类型，每次访问对象的属性就是属性访问，属性访问返回的函数和其他函数没有任何区别
数组也支持[]访问形式，数组有一套更加结构化的值存储机制，数组期望的是数值下标，也就是说值存储的位置是非负整数
数组也是对象，虽然每个下标都是整数，但仍然可以给数组添加命名属性，数组的length值不会发生变化
完全可以把数组当成一个普通的键值对象来使用，并且不添加任何数值索引，但最好只用对象来存储键值对，只用数组来存储下标值对
如果试图向数组添加一个属性，但是属性名看起来像一个数字，那他会变成一个数值下标
对于JSON安全的对象来说，进行深拷贝可以通过：
var newObj = JSON.parse(JSON.stringify(someObj)) ES6定义了Object.assign()方法实现浅拷贝，第一个参数是目标对象，之后可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象，最后返回目标对象。
因为Object.assign()使用=操作符来赋值，所以源对象属性的一些特性不会被复制到目标对象
在创建普通属性时属性描述符会使用默认值，我们也可以使用Object.defineProperty()来添加一个新属性或者修改一个已有属性并对特性进行设置
writable：决定是否可以修改属性的值 configurable：只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符，将其改成false是单项操作，不能撤销 ​	除了无法修改，configurable:false还会禁止删除这个属性
​	delete只用来删除对象的属性
enumerable：这个描述符控制的是属性是否会出现在对象的属性枚举中。如果把enumerable设置成false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。
get：对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到名称相同的属性，GET算法会执行原型链查找，如果无论如何都没有找到名称相同的属性，会返回undefined
put：如果已经存在这个属性，put算法大致会检查下面这些内容：
属性是否是访问操作符？如果是并且存在setter就调用setter 属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出类型异常 如果都不是，将该值设置为属性值 如果对象中不存在这个属性，put操作会更加复杂
getter是一个隐藏函数，会在获取属性值时调用。setter也是一个隐藏函数，会在设置属性值时调用。当给一个属性定义getter、setter或者两者都有时，这个属性会被定义为访问描述符（和数据描述符相对）。对于访问描述符来说，JS会忽略它们的value和writable特性，取而代之的是关心set和get特性
​	不管是对象文字语法中的get a(){}，还是defineProperty()中的显示定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值
​	setter会覆盖单个属性默认的put操作，通常来说getter和setter是成对出现的
让属性或对象是不可变的：
对象常量：结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改、重定义或者删除）
禁止扩展：使用Object.preventExtensions()可以禁止一个对象添加新属性并且保留已有属性
密封：Object.seal()会创建一个密封的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions()并把所有现有属性标记为configurable:false。所以密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）
Object.freeze()会创建一个冻结对象。这个方法实际上会在一个现有对象上调用Object.seal()并把所有数据访问属性标记为writable:false，这样就无法修改它们的值
这个方法是可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改
以上所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。
存在性：
in操作符会检查属性是否在对象及其原型链中。hasOwnProperty()只会检查属性是否在对象中，不会检查原型链
propertyIsEnumerable()方法会检查给定的属性名是否直接存在于对象中，而不是原型链上，并且满足enumerable:true
Object.keys()会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames()会返回一个数组，包含所有属性，无论它们是否可枚举
in和hasOwnProperty()的区别在于是否查找原型链，然而，Object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性
for…in循环可以用来遍历对象的可枚举属性列表（包括原型链），遍历顺序是不确定的，在不同的JS引擎中可能不一样
对于数值索引的数组来说，可以使用标准的for循环来遍历值
ES5中增加了一些数组的辅助迭代器，每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它对于回调函数返回值的处理方式不同：
forEach()会遍历数组中的所有值并忽略回调函数的返回值 every()会一直运行直到回调函数返回false some()会一直运行直到回调函数返回true every()和some()中特殊的返回值和普通for循环中的break语句类似，它们会提前终止遍历
for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值
数组有内置的@@iterator（返回迭代器对象的函数），因此for…of可以直接应用在数组上
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/2.-%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p> 摘要：面向对象编程中，类作为蓝图定义了数据结构与行为的封装，通过继承实现父类与子类的特殊化关系，核心概念包括多态（方法重写与相对引用）和实例化（构造函数创建对象副本）。然而JavaScript的对象机制与传统类继承不同，采用原型关联而非复制，并不存在真正的类实例化概念。(148字)
类继承描述了一种代码的组织结构形式，一种在软件中对真实世界中问题领域的建模方法
面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为打包起来。这在正式的计算机科学中有时被称为数据结构
我们可以实用类对数据结构进行分类，把任意数据结构看作范围更广的定义的一种特例
类的另一个核心概念是多态，这个概念就是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行为
类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类
一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有共有数据属性。这个对象就是类中描述的所有特性的一份副本
通常不会使用一个实例对象来直接访问并操作它的类，不过至少可以判断出这个实例对象来自哪个类
类通过复制操作被实例化为对象形式
类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息。
类构造函数属于类，而且通常和类同名，此外，构造函数大多需要用new来调，这样语言引擎才知道你想用构造一个新的类实例
在面向类的语言中，可以先定义一个类，然后定义一个继承前者的类，后者通常被称为子类，前者通常被称为父类。
定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本。但是也可以重写所有继承的行为甚至定义新行为
多态是一个很广泛的话题，相对是多态的一个方面：任何方法都可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说相对，是因为我们并不会定义想要访问的绝对继承层次，而是使用相对引用查找上一层
许多语言中可以用super，它的含义是超类，表示当前类的父类/祖先类，从子类的构造函数中通过super可以直接调用父类的构造函数。
多态的另一方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义
方法定义的多态性取决于是在哪个类的实例中引用它
在继承和实例化时，JS的对象机制并不会自动执行复制行为，JS中只有对象，并不存在可以被实例化的类，一个对象并不会被复制到其他对象，它们会被关联起来
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://example.org/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/3.-%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://example.org/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://example.org/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
