---
# 文章标题
title: 第十章 远程共同协作
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Git, GitHub, git push, git pull, git clone, Pull Request (PR), 远端仓库，强制推送，GitHub Pages, 补丁共享，协作开发
# 发表日期
date: 2025-07-29
# 分类
categories:
  - git从入门到精通
# 标签
tags:
  - Git 远端操作
  - GitHub 协作
  - 版本控制工具
  - Git 命令
  - 静态网站搭建
---

## 将内容推送到 GitHub

- **前置准备**

  - 在 GitHub 新建仓库，设置仓库名称（不重复）和权限（public 免费，private 付费）。
  - 仓库创建后，根据场景选择操作指南（新项目 / 现有项目），并选择连接方式（HTTPS/SSH，SSH 需配置 SSH Key）。
  <!--more-->

- **关联远端仓库**

  ```bash
  git remote add origin <GitHub仓库地址>
  ```

  - `remote add`：添加远端节点。

  - `origin`：远端 节点的默认名称（可自定义或修改）。

## 远端仓库管理（补充操作）

    - **查看远端配置**：`git remote -v`（显示远端名称、地址及操作类型，确认是否关联正确）。
    - **修改远端地址**：`git remote set-url origin <新地址>`（如仓库迁移后更新地址）。
    - **删除远端关联**：`git remote remove origin`（解除与远端的绑定）。

- **推送内容到远端**

  ```bash
  git push -u origin master
  ```

  - 作用：将本地 `master` 分支推送到 `origin` 远端，若远端无 `master` 则创建，同时通过 `-u` 设置 upstream（上游跟踪关系）。
  - 后续推送：设置 upstream 后，直接执行 `git push` 即可（无需重复指定远端和分支）。
  - **upstream 作用**
    - 本地分支通过 `-u` 关联远端分支（如 `origin/master`）后，`pull/push` 会默认操作关联的远端分支。

- **推送时重命名分支**

  ```bash
  git push origin master:cat  # 将本地master推送到远端并命名为cat
  ```

## 从 GitHub 拉取更新（pull/fetch）

| 命令                | 本质                                           | 适用场景                                    |
| ------------------- | ---------------------------------------------- | ------------------------------------------- |
| `git fetch`         | 仅获取远端更新（更新`origin/xxx`分支），不合并 | 需先查看远端修改再决定是否合并（安全）      |
| `git pull`          | `git fetch + git merge`                        | 快速同步远端修改（可能产生合并 commit）     |
| `git pull --rebase` | `git fetch + git rebase`                       | 保持历史线性（无合并 commit，推荐协作场景） |

- `fetch`是 “安全查看”：获取后可通过`git diff origin/main`对比本地与远端差异，再手动`merge`或`rebase`。
- `pull --rebase`优于`pull`：避免生成不必要的合并 commit，使历史更清晰（尤其多人协作时）

## 推送失败的原因及解决

- **原因**：本地版本落后于远端（远端 有更新未同步到本地）。
- 解决：
  1. 先拉取更新：`git pull`（合并入远端修改后再推送）。
  2. 强制推送（谨慎使用）：`git push -f`（会覆盖远端内容，仅用于协作分支使用）。

## 从服务器克隆仓库（git clone）

1. **基本用法**

   ```bash
   git clone <仓库地址>  # 克隆到同名目录
   git clone <仓库地址> <自定义目录名>  # 克隆到指定目录
   ```

   - 克隆内容：包含完整文件、历史记录、分支、标签等。

   - 浅克隆（适合大型仓库）

     ```bash
     git clone --depth 1 <仓库地址>  # 仅克隆最近1个提交，节省时间和空间（但丢失完整历史）
     ```

   - 克隆指定分支

     ```bash
     git clone -b <分支名> --single-branch <仓库地址>  # 仅克隆指定分支，减少冗余
     ```

2. **与 pull 的区别**

   - `clone`：首次下载完整仓库时使用。
   - `pull`：已克隆仓库后，拉取后续更新时使用。

## 协作与 Pull Request（PR）

- **PR 流程**
  - **Fork**：复制原作者仓库到自己的 GitHub 账号（获得完整修改权限）。
  - **修改并推送**：在自己的仓库中修改，推送至自己的远端。
  - **创建 PR**：向原作者发送合并请求，原作者审核后可合并到其主仓库。

**同步原仓库更新**

- 方法 1：删除自己的 Fork 仓库，重新 Fork（简单但丢失本地修改）。

- 方法 2：关联原仓库为上游，手动同步：

  ```bash
  # 1. 添加原仓库为远端节点（命名为upstream）
  git remote add upstream <原仓库地址>
  # 2. 查看远端节点（确认配置）
  git remote -v
  # 3. 拉取原仓库更新
  git fetch upstream
  # 4. 合并到本地分支（如master）
  git merge upstream/master
  # 5. 推送到自己的仓库
  git push origin master
  ```

## 删除远端分支

```bash
git push origin :<分支名>  # 如 git push origin :cat 删除远端cat分支
```

- 原理：向远端分支推送 “空内容”，变相删除该分支。

更直观的现代命令：

```bash
git push origin --delete <分支名>  # 如 git push origin --delete feature/old（推荐，可读性更高）
```

## git push -f（强制推送）的使用场景

- 适用情况：
  1. 整理历史记录后（如用 rebase 修改本地历史，需强制覆盖远端）。
  2. 仅用于个人分支（避免影响协作分支）。
- **风险**：覆盖远端历史，导致他人修改丢失，协作场景慎用。
- **更安全的替代**：`git push --force-with-lease`（先检查远端是否有未同步的修改，有则拒绝推送，避免误覆盖）。
- **恢复**：若误操作，可重新强制推送正确历史：`git push -f`。

## 使用 GitHub 搭建静态网站（GitHub Pages）

1. **基本用法**
   - 推送内容到 `gh-pages` 分支，GitHub 会自动部署为静态网站。
   - 仓库命名为 `username.github.io` 时，可通过 `https://username.github.io` 访问。
2. **限制**
   - 仅支持静态内容（HTML/CSS/JS），不支持 PHP/ASP 等动态语言。
   - 不支持 `.htaccess` 配置，内容公开可见。
3. 自定义域名步骤：
   1. 仓库根目录添加`CNAME`文件，内容为域名（如`blog.example.com`）。
   2. 域名解析平台添加`CNAME`记录，指向`username.github.io`。
   3. GitHub 仓库 →`Settings → Pages → Custom domain`填写域名，启用 HTTPS。

## 离线共享更新（git format-patch & git am）

1. **生成更新补丁**

   ```bash
   git format-patch A...B  # 生成从A（不含）到B的所有commit补丁
   git format-patch -2 -o /temp/patches  # 生成最近2个commit的补丁，保存到/temp/patches
   ```

2. **应用补丁**

   ```bash
   git am /tmp/patches/*  # 批量应用补丁
   ```

- 冲突处理：

  冲突时执行`git am --abort`放弃，或解决冲突后`git add . && git am --continue`。
