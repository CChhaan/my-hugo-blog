---
# 文章标题
title: 7.2 性能优化
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 性能优化, Vue 页面加载优化, Vue 更新性能, SSR, SSG, 异步组件, 代码分割, Tree-shaking, props 稳定性, v-once, v-memo, 列表虚拟化, shallowRef, shallowReactive
# 发表日期
date: 2025-04-19
summary: 本文主要介绍了 Vue 3 中的性能优化方法，包括页面加载优化、更新性能优化、通用优化等方面。通过这些优化方法，可以提高 Vue 应用的性能，提升用户体验。
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue
  - vue3
  - 前端框架
  - 前端开发
  - 性能优化
---

## 概述

Web 应用性能的两个主要方面：

- **页面加载性能**：首次访问时，应用展示出内容与达到可交互状态的速度。
- **更新性能**：应用响应用户输入更新的速度。

**结论**：优化性能的第一步是为应用类型确定合适的架构。

## 页面加载优化

### 选用正确的架构

如果应用对 **页面加载性能** 敏感：

- 避免纯客户端的 SPA
- 使用 **SSR** 或 **SSG** 来缓解首屏加载缓慢的问题

如果应用对 **交互性要求不高**：

- 使用传统后端渲染 HTML
- 在客户端用 Vue 进行增强

如果主应用必须是 **SPA**，但有营销相关页面（如落地页、关于页、博客等）：

- 将这些页面单独部署
- 理想情况：使用 **静态 HTML**，尽量少 JS，用 **SSG** 部署

### 包体积与 Tree-shaking 优化

减少打包产物体积的方法：

- **尽可能地采用构建步骤**
  - 模板预编译 → 避免在浏览器中加载 Vue 编译器
  - 体积缩小 **14kb**（最小化 + gzip）
  - 避免运行时编译开销
- **谨慎引入依赖**
  - 包体积膨胀常因无意识引入过重依赖
  - 优先选择 **提供 ES 模块格式** 的依赖（对 tree-shaking 友好）
  - 实际体积大小取决于导入的 API
- **渐进式增强场景**
  - 如果不使用构建步骤，可考虑使用 petite-vue

### 代码分割

定义：构建工具将 JS 包拆分为多个较小文件，可按需或并行加载。

优点：

- 初次加载只下载必要功能
- 额外功能仅在需要时加载

在 Vue 应用中：

- 结合 异步组件使用
- Vue Router 应用强烈建议：路由组件使用 **异步组件**

## 更新优化

### Props 稳定性

子组件只在至少一个 **props 改变时** 才会更新。应保持传给子组件的 props 稳定

### `v-once`

内置指令。用于渲染依赖运行时数据但无需再更新的内容。**整个子树会在未来更新中被跳过**

### `v-memo`

内置指令。有条件地跳过某些大型子树或 `v-for` 列表的更新

### 计算属性稳定性

Vue 3.4+：计算属性仅在值变更时触发副作用

问题：若每次计算都创建新对象 → Vue 认为始终不同

优化方法：

- 手动比较新旧值
- 若无变化则返回旧值
- **必须先完整计算**，确保依赖收集一致

## 通用优化

### 大型虚拟列表

渲染大型列表 → 性能瓶颈

浏览器需处理大量 DOM 节点

解决方法：**列表虚拟化**

- 仅渲染用户视口中可见部分

### 减少大型不可变数据的响应性开销

Vue 响应性系统默认是 **深度的**

在数据量巨大时 → 性能负担明显

解决方法：

- 使用 `shallowRef()`
- 使用 `shallowReactive()`
- 浅层式 API → 仅顶层响应式，深层对象不可变
- 更新方式：替换整个根状态

### 避免不必要的组件抽象

创建无渲染组件或高阶组件会增加组件实例数量

组件实例比 DOM 节点更昂贵

过多抽象 → 性能损失

**注意**：减少少量组件实例对性能改善不明显
