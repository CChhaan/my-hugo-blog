---
# 文章标题
title: 2.11 模板引用
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 模板引用，useTemplateRef (), defineExpose, v-for 模板引用，函数式模板引用
summary: 本节详细介绍了 Vue 3 中模板引用的使用方法，包括访问 DOM 元素和子组件实例，以及注意事项。通过模板引用，开发者可以直接操作 DOM 或调用子组件方法，解决声明式渲染无法覆盖的场景。
# 发表日期
date: 2025-04-08
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 前端开发
---

## 模板引用核心作用

模板引用（通过 `ref` attribute 实现）用于**直接访问底层 DOM 元素或子组件实例**，解决声明式渲染无法覆盖的场景（如设置输入框焦点、初始化第三方 DOM 库、调用子组件方法等）。

Vue 3 中通过 `useTemplateRef()` 函数（3.5+ 版本）或声明同名 `ref` 对象（3.5 前版本）获取引用，需注意**仅在组件挂载后才能访问到有效引用**（初次渲染前为 `null`）。

## 基础用法：访问 DOM 元素

### 3.5+ 版本（推荐 `useTemplateRef()`）

`useTemplateRef()` 是 Vue 3.5 引入的辅助函数，无需手动声明响应式对象，直接通过函数名与模板中 `ref` 属性值关联，TypeScript 可自动推断元素类型。

#### 步骤：

1. 导入 `useTemplateRef`；
2. 调用函数创建引用（函数名需与模板 `ref` 属性值一致）；
3. 在组件挂载后访问引用（如 `onMounted` 钩子中）。

#### 示例：设置输入框焦点

```js
import { useTemplateRef, onMounted } from "vue";

// 1. 创建模板引用：函数名 "inputRef" 需与模板 ref 属性值一致
const inputRef = useTemplateRef("inputRef");

// 2. 组件挂载后访问 DOM 元素（挂载前 inputRef.value 为 null）
onMounted(() => {
  // 直接操作 DOM：设置输入框焦点
  inputRef.value?.focus();
});
```

```xml
<!-- 模板：ref 属性值 "inputRef" 与函数名对应 -->
<input type="text" ref="inputRef" placeholder="自动获取焦点">
```

### 3.5 前版本（声明同名 `ref` 对象）

3.5 之前无 `useTemplateRef()`，需手动声明与模板 `ref` 属性值**完全同名**的 `ref` 对象，且需确保从 `setup()` 中返回（非 `<script setup>` 场景）。

#### 示例：

```js
import { ref, onMounted } from "vue";

// 1. 声明与模板 ref 同名的 ref 对象（初始值为 null）
const inputRef = ref(null);

// 2. 组件挂载后访问 DOM
onMounted(() => {
  inputRef.value?.focus();
});

// 非 <script setup> 场景：需返回 ref 对象
// export default {
//   setup() {
//     return { inputRef }
//   }
// }
```

```xml
<input type="text" ref="inputRef" placeholder="自动获取焦点">
```

### 关键注意事项

- **访问时机**：模板引用在组件挂载前（如 `setup()` 同步代码中）值为 `null`，必须在 `onMounted` 钩子或其他确保挂载后的时机访问（如点击事件回调）；
- **TypeScript 类型**：3.5+ 版本 `useTemplateRef()` 会自动根据元素类型推断（如 `<input>` 对应 `HTMLInputElement`），3.5 前需手动指定类型（`const inputRef = ref<HTMLInputElement | null>(null)`）；
- **条件渲染**：若元素通过 `v-if` 条件渲染，需确保元素存在时再访问（可通过 `watch` 侦听引用变化，处理 `null` 情况）。

## 进阶用法：访问子组件实例

模板引用也可绑定到子组件上，此时引用值为**子组件实例**，可调用子组件的方法或访问其状态，但需遵守组件封装原则（优先用 `props`/`emit` 通信，仅必要时用引用）。

### 子组件未使用 `<script setup>`（默认暴露所有属性/方法）

若子组件用选项式 API 或非 `<script setup>` 的组合式 API，父组件可直接访问子组件的 `this` 上的所有属性和方法。

#### 示例：

```js
// 父组件
import { useTemplateRef, onMounted } from "vue";
import Child from "./Child.vue";

// 创建子组件引用
const childRef = useTemplateRef("childRef");

onMounted(() => {
  // 调用子组件方法
  childRef.value?.childMethod();
  // 访问子组件状态
  console.log("子组件状态：", childRef.value?.childState);
});
```

```xml
<!-- 父组件模板：ref 绑定到子组件 -->
<Child ref="childRef" />
```

```js
// 子组件（非 <script setup>）
import { ref } from "vue";

export default {
  setup() {
    const childState = ref("子组件状态");
    const childMethod = () => {
      console.log("子组件方法被调用");
    };
    // 返回属性和方法，供父组件访问
    return { childState, childMethod };
  },
};
```

### 子组件使用 `<script setup>`（需 `defineExpose` 显式暴露）

`<script setup>` 中的组件默认**私有**，父组件无法访问其内部属性/方法，需通过 `defineExpose` 宏显式暴露需要对外提供的内容。

#### 示例：

```js
// 子组件（<script setup>）
import { ref, defineExpose } from "vue";

// 私有状态（未暴露，父组件无法访问）
const privateState = ref("私有状态");
// 需暴露的状态和方法
const exposedState = ref("暴露的状态");
const exposedMethod = () => {
  console.log("子组件暴露的方法被调用");
};

// 显式暴露属性和方法（仅暴露的内容可被父组件访问）
// 注意：defineExpose 必须在 await 操作前调用
defineExpose({
  exposedState,
  exposedMethod,
});
```

```js
// 父组件
import { useTemplateRef, onMounted } from "vue";
import Child from "./Child.vue";

const childRef = useTemplateRef("childRef");

onMounted(() => {
  // 访问子组件暴露的状态
  console.log("子组件暴露状态：", childRef.value?.exposedState);
  // 调用子组件暴露的方法
  childRef.value?.exposedMethod();
  // 无法访问未暴露的私有状态（childRef.value?.privateState 为 undefined）
});
```

```xml
<Child ref="childRef" />
```

## 特殊场景：v-for 中使用模板引用

当在 `v-for` 中绑定模板引用时，引用值会自动变为**数组**，包含列表中所有元素/子组件的引用。需注意：

- 数组顺序**不保证与源数组完全一致**（因 DOM 渲染和更新顺序可能变化）；
- 需在所有元素挂载后访问数组（避免部分元素未挂载导致数组不完整）。

### 示例：

```js
import { useTemplateRef, onMounted } from "vue";

// 创建引用（v-for 场景下，ref.value 会自动变为数组）
const itemRefs = useTemplateRef("itemRef");
const list = ref(["Item 1", "Item 2", "Item 3"]);

onMounted(() => {
  // 访问所有列表项的 DOM 元素
  itemRefs.value?.forEach((el, index) => {
    console.log(`第 ${index + 1} 项：`, el.textContent);
  });
});
```

```xml
<!-- v-for 中绑定 ref，所有元素引用会存入 itemRefs 数组 -->
<div v-for="item in list" :key="item" ref="itemRef">
  {{ item }}
</div>
```

### 3.5 前版本兼容：

需手动声明数组类型的 `ref` 对象：

```js
const itemRefs = ref<HTMLElement[]>([]) // 声明为数组类型
```

## 高级用法：函数式模板引用

除字符串值外，`ref` 属性还可绑定为**函数**（需用 `:ref` 动态绑定），函数会在元素挂载/更新/卸载时被调用，接收元素引用作为参数（卸载时参数为 `null`）。

适用于动态处理多个引用（如无需手动维护数组，直接在函数中处理元素）。

### 示例：

```js
import { onUnmounted } from "vue";

// 存储所有元素引用的对象
const elementMap = new Map();

// 函数式 ref 处理逻辑
const handleRef = (el, item) => {
  if (el) {
    // 元素挂载：存入 Map（key 为列表项，value 为 DOM 元素）
    elementMap.set(item, el);
  } else {
    // 元素卸载：从 Map 中移除
    elementMap.delete(item);
  }
};

// 组件卸载时清空 Map（避免内存泄漏）
onUnmounted(() => {
  elementMap.clear();
});
```

```xml
<!-- :ref 绑定函数，传递列表项作为额外参数 -->
<div v-for="item in list" :key="item" :ref="(el) => handleRef(el, item)">
  {{ item }}
</div>
```

### 注意：

- 必须用 `:ref` 动态绑定（而非静态 `ref`），才能传入函数；
- 函数第一个参数固定为元素引用（`el`），可额外传递自定义参数（如列表项 `item`）；
- 元素卸载时函数会被调用，此时 `el` 为 `null`，需处理清理逻辑（如移除引用、销毁第三方库实例）。

## 核心总结

| 应用场景                          | 实现方式                                           | 关键注意点                            |
| --------------------------------- | -------------------------------------------------- | ------------------------------------- |
| 访问 DOM 元素（3.5+）             | `useTemplateRef('refName')` + 模板 `ref="refName"` | 仅挂载后访问，TypeScript 自动推断类型 |
| 访问 DOM 元素（3.5 前）           | 声明同名 `ref` 对象 + 模板 `ref="refName"`         | 非 `<script setup>` 需返回 ref 对象   |
| 访问子组件（非 `<script setup>`） | 引用绑定到子组件，直接访问属性/方法                | 优先用 `props`/`emit`，避免耦合       |
| 访问子组件（`<script setup>`）    | 子组件 `defineExpose` 暴露，父组件引用访问         | `defineExpose` 需在 await 前调用      |
| v-for 中访问列表元素              | 引用自动变为数组，遍历访问                         | 数组顺序不保证与源数组一致            |
| 动态处理多个引用                  | `:ref` 绑定函数，在函数中处理元素挂载/卸载         | 卸载时 `el` 为 `null`，需清理引用     |

- 模板引用是“逃生舱”，优先通过 Vue 声明式 API 解决问题，仅在需直接操作 DOM/子组件时使用；
- 访问引用前需判断 `null`（如 `ref.value?.method()`），避免挂载前调用导致错误；
- 子组件使用 `<script setup>` 时，必须通过 `defineExpose` 暴露内容，否则父组件无法访问。
