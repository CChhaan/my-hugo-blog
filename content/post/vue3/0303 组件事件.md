---
# 文章标题
title: 3.3 组件事件
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 自定义事件，defineEmits (), 事件触发 (emit), 事件监听 (@), 事件参数校验
summary: 本节详细介绍了 Vue 3 中组件事件的使用方法，包括如何在子组件中触发事件、在父组件中监听事件，以及如何传递参数和进行类型校验。通过示例代码，展示了如何使用 `defineEmits` 宏声明事件、在模板中触发事件、在父组件中监听事件并处理参数。
# 发表日期
date: 2025-04-09
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 组件化开发
  - 前端开发
---

## 自定义事件核心作用

自定义事件是子组件向父组件传递信息、触发父组件逻辑的**标准接口**，解决“子传父”的通信需求（如子组件按钮点击后通知父组件更新数据、执行异步操作等）。

Vue 中，子组件通过 `emit` 函数触发事件，父组件通过 `v-on`（`@`）监听事件，支持事件参数传递、类型校验和显式声明，确保通信可追踪、可维护。

## 基础用法：触发与监听事件

### 子组件触发事件（`<script setup>` 场景）

在 `<script setup>` 中，需通过 `defineEmits()` 宏声明要触发的事件（可选但推荐），该宏返回一个与 `$emit` 功能一致的 `emit` 函数，用于在脚本中触发事件；模板中可直接使用 `$emit`。

#### 步骤：

1. 用 `defineEmits()` 声明事件（数组式，指定事件名）；
2. 脚本中调用 `emit(事件名, 参数)` 触发事件，或模板中用 `$emit(事件名, 参数)`；
3. 父组件通过 `@事件名` 监听，接收参数。

#### 示例：子组件触发事件并传参

```xml
<!-- 子组件 Child.vue -->
<template>
  <!-- 模板中直接用 $emit 触发事件，传递参数 -->
  <button @click="$emit('add', 1)">点击加 1</button>
</template>

<script setup>
// 1. 声明要触发的事件（数组式，显式文档化）
const emit = defineEmits(['add', 'reset'])

// 2. 脚本中调用 emit 触发事件，传递多个参数
const handleReset = () => {
  emit('reset', '重置原因：用户主动触发', new Date())
}
</script>
```

#### 父组件监听事件并接收参数

```xml
<!-- 父组件 Parent.vue -->
<template>
  <!-- 监听子组件事件，内联函数接收参数 -->
  <Child
    @add="(step) => count += step"
    @reset="handleReset"
  />
  <p>当前计数：{{ count }}</p>
</template>

<script setup>
import Child from './Child.vue'
import { ref } from 'vue'

const count = ref(0)

// 方法接收事件参数（与子组件 emit 顺序一致）
const handleReset = (reason, time) => {
  count.value = 0
  console.log(`重置：${reason}，时间：${time}`)
}
</script>
```

### 非 `<script setup>` 场景（选项式 API / 普通 setup）

若不使用 `<script setup>`，需通过 `emits` 选项声明事件，`emit` 函数从 `setup` 上下文对象中获取（或选项式 API 直接用 `this.$emit`）。

#### 示例：

```js
// 选项式 API 示例
export default {
  // 1. 声明事件
  emits: ['add', 'reset'],
  methods: {
    handleClick() {
      // 2. 触发事件（选项式 API 用 this.$emit）
      this.$emit('add', 1)
    }
  }
}

// 普通 setup 函数示例（非 <script setup>）
export default {
  emits: ['add', 'reset'], // 声明事件
  setup(props, { emit }) { // 从上下文解构 emit
    const handleReset = () => {
      emit('reset', '重置原因') // 触发事件
    }
    return { handleReset }
  }
}
```

### 事件名格式规范

与 Props 类似，事件名也支持自动格式转换：

- 子组件触发：推荐用 `camelCase`（如 `handleChange`），脚本中书写符合 JavaScript 规范；
- 父组件监听：推荐用 `kebab-case`（如 `handle-change`），模板中符合 HTML attribute 规范；
- Vue 自动映射：父组件 `@handle-change` 会自动匹配子组件 `emit('handleChange')`，无需手动转换。

#### 示例：

```js
// 子组件：camelCase 触发
emit("handleChange", newValue);
```

```xml
<!-- 父组件：kebab-case 监听 -->
<Child @handle-change="onChange" />
```

## 进阶用法：事件声明与校验

为提高组件健壮性，可通过**对象式声明**为事件添加参数校验（类似 Props 校验），确保子组件触发事件时传递的参数符合预期，开发环境下参数不合法会抛出警告。

### 对象式声明与参数校验（`<script setup>`）

`defineEmits()` 支持传入对象，对象的 key 为事件名，value 为“参数校验函数”（接收子组件 `emit` 的参数，返回 `true` 表示校验通过，`false` 表示失败）。

#### 示例：

```js
// 子组件 Child.vue（<script setup>）
const emit = defineEmits({
  // 1. 无参数事件：value 设为 null 或空函数
  reset: null,

  // 2. 有参数事件：校验函数（参数为子组件 emit 传递的值）
  add: (step) => {
    // 校验：step 必须是正数
    if (typeof step === "number" && step > 0) {
      return true;
    } else {
      console.warn("add 事件参数错误：step 必须是正数");
      return false;
    }
  },

  // 3. 多参数事件：校验所有参数
  update: (newVal, oldVal) => {
    if (newVal !== undefined && oldVal !== undefined) {
      return true;
    }
    console.warn("update 事件需传递 newVal 和 oldVal 两个参数");
    return false;
  },
});

// 触发事件：参数不合法时，开发环境会打印警告
emit("add", -1); // 校验失败，警告
emit("update", "new"); // 缺少 oldVal，警告
```

### TypeScript 类型标注（类型安全场景）

结合 TypeScript 时，可通过**类型标注**声明事件及参数类型，无需手动写校验函数，Vue 会在编译时推导类型，IDE 提供自动补全。

#### 示例：

```ts
// 子组件 Child.vue（<script setup lang="ts">）
// 用类型标注声明事件：键为事件名，值为参数类型数组
const emit = defineEmits<{
  (e: "reset"): void; // 无参数事件
  (e: "add", step: number): void; // 单参数事件（step 为 number）
  (e: "update", newVal: string, oldVal: string): void; // 多参数事件
}>();

// 类型提示：emit('add') 会报错（缺少 step 参数）
emit("add", 2); // 正确
emit("update", "new", "old"); // 正确
```

## 关键特性与注意事项

### 事件的“非冒泡”特性

组件自定义事件**没有冒泡机制**，父组件只能监听**直接子组件**触发的事件，无法监听孙子组件或平级组件的事件。

若需跨层级通信，需通过以下方式解决：

- 中间组件“转发”事件（子组件触发 → 父组件接收后再触发 → 祖父组件监听）；
- 使用全局状态管理（如 Pinia）；
- 使用 `Provide/Inject` 传递事件处理函数。

### 显式声明事件的必要性

`defineEmits()` 或 `emits` 选项是**可选但强烈推荐**的，原因如下：

- **文档化**：明确组件对外触发的事件，其他开发者使用时可快速了解组件接口；
- **避免冲突**：Vue 可区分“自定义事件”与“透传 attribute”（如避免将自定义事件当作原生 DOM 事件绑定到子组件根元素）；
- **支持校验**：仅对象式声明支持参数校验，提高组件健壮性。

### `.once` 修饰符：事件仅触发一次

父组件监听事件时，可添加 `.once` 修饰符，使事件仅响应一次（后续触发不生效），适合“一次性操作”（如弹窗确认、表单提交）。

#### 示例：

```xml
<!-- 父组件：事件仅触发一次 -->
<Child @add.once="count += 1" />
<!-- 第一次点击加 1，后续点击无反应 -->
```

### `defineEmits()` 的使用限制

- **作用域限制**：`defineEmits()` 必须在 `<script setup>` 的**顶级作用域**调用，不能在子函数、`if` 语句等嵌套结构中使用；
- **无导入需求**：`defineEmits()` 是编译宏，无需手动导入，直接在 `<script setup>` 中使用。

## 对比：自定义事件 vs Props

| 维度     | 自定义事件（子传父）                     | Props（父传子）                            |
| -------- | ---------------------------------------- | ------------------------------------------ |
| 数据流向 | 子组件 → 父组件                          | 父组件 → 子组件                            |
| 核心作用 | 子组件触发父组件逻辑（如通知更新、提交） | 父组件向子组件传递数据（如初始值、配置）   |
| 使用方式 | 子组件 `emit` 触发，父组件 `@` 监听      | 父组件 `:` 传递，子组件 `defineProps` 接收 |
| 参数传递 | 支持多参数，子组件主动传递               | 支持单个值/对象，父组件主动传递            |

## 核心总结

| 主题       | 关键要点                                                        | 最佳实践                                             |
| ---------- | --------------------------------------------------------------- | ---------------------------------------------------- |
| 事件触发   | `<script setup>` 用 `defineEmits()` 获取 `emit`，模板用 `$emit` | 显式声明事件（数组/对象式），提高可维护性            |
| 事件监听   | 父组件用 `@事件名` 监听，内联函数/方法接收参数                  | 事件名用 `kebab-case`，与子组件 `camelCase` 自动映射 |
| 参数校验   | 对象式声明中用校验函数，TypeScript 用类型标注                   | 对关键事件（如表单提交）添加参数校验，避免非法数据   |
| 跨层级通信 | 自定义事件不冒泡，需转发/状态管理/Provide/Inject                | 优先用状态管理（如 Pinia），避免多层转发             |
| 性能与安全 | 避免频繁触发事件（如输入框实时触发），可防抖处理                | 一次性操作加 `.once` 修饰符，减少不必要响应          |

自定义事件是 Vue 组件“子传父”的核心方案，遵循“显式声明、参数校验、单向触发”原则，能有效保证组件通信的清晰性和可维护性，是中大型项目的必备实践。
