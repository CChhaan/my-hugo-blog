---
# 文章标题
title: 2.3 响应式基础
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 响应式状态, Vue ref, Vue reactive, Vue ref 和 reactive 区别, Vue 深层响应性, Vue shallowRef, Vue shallowReactive, Vue nextTick, Vue Proxy, Vue 组合式 API
# 发表日期
date: 2025-04-10
summary: 本文主要介绍了 Vue 3 的响应式基础，包括如何声明响应式状态、如何使用 ref 和 reactive、以及如何处理深层响应性和 DOM 更新时机。
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue
  - vue3
  - 前端框架
  - 前端开发
---

## 声明响应式状态

### `ref()`

在 Vue 的组合式 API 中，推荐使用 `ref()` 函数来声明响应式状态。

`ref()` 接收一个初始值，并将其包裹在一个具有 `.value` 属性的 `ref` 对象中返回

```js
import { ref } from "vue";

const count = ref(0);

console.log(count); // { value: 0 }
console.log(count.value); // 0
```

要在组件模板中访问 ref，请从组件的 `setup()` 函数中声明并返回它们

- 在组件模板中访问 `ref` 时，不需要附加 `.value`，Vue 会自动解包。
- 你可以在事件监听器中修改 `ref` 的值。

对于更复杂的逻辑，可以在同一作用域内声明修改 `ref` 的函数，并将它们作为方法公开给模板。这样可以在事件监听器中使用这些方法。

### `<script setup>`

使用 `<script setup>` 可以大幅简化代码，避免手动暴露大量状态和方法。

\<script setup> 中的顶层导入、变量和函数在同一组件的模板中可以直接使用。

### 为什么要使用 ref？

`ref` 允许 Vue 自动检测变化并更新 DOM。这是通过 Vue 的响应式系统实现的。

Vue 使用 `getter` 和 `setter` 方法来拦截对 `ref` 的访问和修改，进而进行依赖追踪和触发更新。

`ref` 作为一个对象，具有 `.value` 属性：

```js
// 伪代码，不是真正的实现
const myRef = {
  _value: 0,
  get value() {
    track();
    return this._value;
  },
  set value(newValue) {
    this._value = newValue;
    trigger();
  },
};
```

通过 `ref`，你可以将值传递给函数并保持响应式连接。当逻辑重构为可重用代码时，`ref` 是非常有用的。

### 深层响应性

`ref` 可以持有任何类型的值，包括嵌套的对象、数组等。

`ref` 会使它的值具有深层响应性，即使对象内部发生变化也会被检测到。

非原始值将通过 `reactive()` 转换为响应式代理。

使用 shallowRef 可以避免深层响应性，适用于优化性能或外部库管理其内部状态的情况。

### DOM 更新时机

当响应式状态发生变化时，DOM 会自动更新，但 DOM 更新是 **异步** 的，Vue 会在 "next tick" 更新周期中缓冲所有状态修改，确保每个组件只会更新一次。

使用 nextTick()可以等待 DOM 更新完成后再执行额外的代码。

## `reactive()`

`reactive()` 也是声明响应式状态的另一种方式。与 `ref` 将值包裹在对象中不同，`reactive()` 直接使对象本身具有响应性。

```js
import { reactive } from "vue";

const state = reactive({ count: 0 });
```

`reactive()` 返回一个 **Proxy** 对象，Vue 能够拦截对该对象属性的访问和修改，以进行依赖追踪和触发更新。

`reactive()` 会深层地转换对象，访问嵌套对象时，它们也会被 `reactive()` 包装。

与浅层 shallowRef 类似，shallowReactive() API 可以选择退出深层响应性。

### Reactive Proxy vs. Original

`reactive()` 返回的对象是 **Proxy**，与原始对象不相等。

只有代理对象是响应式的，修改原始对象不会触发更新。因此，应该只使用代理版本，避免直接操作原始对象。

为保证访问代理的一致性，对同一个原始对象调用 `reactive()` 会总是返回同样的代理对象，而对一个已存在的代理对象调用 `reactive()` 会返回其本身

这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理

`reactive()` 的局限性：

1. **有限的值类型**：它只能用于对象类型，不能用于原始类型
2. **不能替换整个对象**：由于 Vue 是通过属性访问来进行响应式跟踪的，不能轻易替换响应式对象，否则会丢失连接。

3. **对解构操作不友好**：当解构响应式对象时，响应性会丢失。

由于这些限制，建议在大多数情况下使用 `ref()` 来声明响应式状态。

## 额外的 ref 解包细节

### 作为 reactive 对象的属性

当 `ref` 作为 `reactive` 对象的属性时，它会自动解包。

如果将一个新的 `ref` 赋值给已关联 `ref` 的属性，它会替换旧的 `ref`。

只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。

### 数组和集合的注意事项

与 `reactive` 对象不同，当 `ref` 作为响应式数组或集合类型的元素时，它 **不会** 被自动解包。

### 在模板中解包的注意事项

只有 **顶级** 的 `ref` 属性在模板中会被自动解包。

如果 `ref` 是文本插值的最终计算值（如 `{{ }}` 标签），它将被解包。
