---
# 文章标题
title: 2.3 响应式基础
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 组合式 API, ref (), reactive (), 响应式状态，nextTick (), shallowRef/shallowReactive
summary: 本节介绍 Vue 3 的响应式 API，包括 `ref()` 和 `reactive()` 的基本用法和特性。
# 发表日期
date: 2025-04-07
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 前端开发
---

## ref()：基础响应式状态声明

### 核心特性与用法

- **作用**：声明任意类型的响应式状态（推荐作为主要响应式 API）
- **语法**：`const 变量名 = ref(初始值)`，返回一个含 `.value` 属性的 **ref 对象**
- **示例**：
  ```js
  import { ref } from "vue";
  // 声明字符串类型 ref
  const msg = ref("Hello Vue");
  // 声明数字类型 ref
  const count = ref(0);
  ```

### ref 的访问与修改

| 场景                   | 访问/修改方式                                       | 说明                                                                |
| ---------------------- | --------------------------------------------------- | ------------------------------------------------------------------- |
| 脚本中（`<script>`）   | 访问：`ref变量.value`；修改：`ref变量.value = 新值` | 必须通过 `.value` 操作，Vue 通过 `.value` 拦截访问/修改以实现响应式 |
| 模板中（`<template>`） | 直接使用 `ref变量`（无需 `.value`）                 | 模板自动解包 ref，简化语法                                          |
| 事件监听器中           | 直接修改 `ref变量.value`                            | 可在事件处理函数中直接变更 ref 值，触发 DOM 更新                    |

### 深层响应性与浅层 ref

- **默认行为**：ref 持有对象/数组时，会通过 `reactive()` 自动转为**深层响应式**（嵌套属性修改也能被检测）
  ```js
  const user = ref({ name: "Alice", age: 20 });
  // 修改嵌套属性，仍具响应性
  user.value.age = 21;
  ```
- **浅层 ref（shallowRef）**：仅追踪 `.value` 的修改，不处理嵌套属性的响应性，用于优化大型数据或外部管理状态
  ```js
  import { shallowRef } from "vue";
  const bigData = shallowRef({
    /* 大型嵌套数据 */
  });
  // 仅 .value 赋值触发响应：bigData.value = 新对象
  // 嵌套属性修改不触发响应：bigData.value.key = 新值（无响应）
  ```

### ref 的优势

- 支持所有值类型（原始类型+对象类型），无 `reactive()` 的类型限制
- 可传递给函数，保留响应式连接（普通变量传递会丢失响应性）
- 模板自动解包，使用简洁

## reactive()：对象类型响应式状态

### 核心特性与用法

- **作用**：使对象/数组/集合（如 `Map`/`Set`）本身成为响应式代理
- **语法**：`const 响应式对象 = reactive(原始对象)`，返回一个 **Proxy 对象**
- **示例**：
  ```js
  import { reactive } from "vue";
  const user = reactive({ name: "Bob", age: 22 });
  // 直接修改属性，触发响应
  user.age = 23;
  ```

### 关键特性

- **深层响应性**：默认递归处理嵌套对象，嵌套属性也会转为响应式代理
  ```js
  const obj = reactive({ nested: { count: 0 } });
  // 嵌套属性修改触发响应：obj.nested.count = 1
  ```
- **浅层 reactive（shallowReactive）**：仅处理顶层属性的响应性，嵌套对象不转为代理，用于优化性能
  ```js
  import { shallowReactive } from "vue";
  const shallowObj = shallowReactive({ nested: { count: 0 } });
  // 顶层属性响应：shallowObj.key = 1（有效）
  // 嵌套属性不响应：shallowObj.nested.count = 1（无效）
  ```
- **代理一致性**：
  - 同一原始对象调用 `reactive()`，始终返回同一代理
  - 对代理对象调用 `reactive()`，返回其本身
  - 嵌套对象也是代理（依靠深层响应性）

### reactive() 的局限性

1. **值类型限制**：仅支持对象类型（不能用于原始类型 `string`/`number`/`boolean`）
2. **不可替换整个对象**：必须保持代理引用不变，替换对象会丢失响应性
   ```js
   let user = reactive({ name: "Bob" });
   // 错误：替换代理，原响应性连接丢失
   user = reactive({ name: "Charlie" });
   ```
3. **解构/传递属性丢失响应性**：解构原始类型属性或传递属性给函数时，会失去响应式连接
   ```js
   const { age } = user; // age 为普通变量（非响应式）
   function logAge(age) {
     /* age 非响应式 */
   }
   logAge(user.age);
   ```

## ref 与 reactive 的关联与差异

### 关联：ref 内部调用 reactive()

- 当 ref 持有对象/数组时，Vue 会在内部调用 `reactive()`，使嵌套值成为深层响应式代理（与 `reactive()` 底层一致）

### ref 自动解包规则

| 场景                          | 是否自动解包 | 示例                                                                                        |
| ----------------------------- | ------------ | ------------------------------------------------------------------------------------------- |
| 作为响应式对象的属性          | 是           | `const obj = reactive({ refVal: ref(0) })`，访问 `obj.refVal` 等价于 `refVal.value`         |
| 作为浅层响应式对象的属性      | 否           | `const shallowObj = shallowReactive({ refVal: ref(0) })`，需 `shallowObj.refVal.value` 访问 |
| 作为响应式数组/集合的元素     | 否           | `const arr = reactive([ref(0)])`，需 `arr[0].value` 访问                                    |
| 模板中顶级 ref 属性           | 是           | 模板直接用 `{{ refVal }}`（无需 `.value`）                                                  |
| 模板文本插值最终值（`{{ }}`） | 是           | `{{ refVal }}` 自动解包，`{{ { refVal } }}` 不解包（非最终值）                              |

### 选型建议

- **优先用 ref()**：覆盖所有场景，无 `reactive()` 局限性，模板使用更简洁
- **慎用 reactive()**：仅在明确需要“对象整体响应”且无解构/替换需求时使用（如组件状态对象无需拆分）

## 响应式更新与 nextTick()

### DOM 更新机制

- Vue 缓冲所有状态修改，在“next tick”更新周期中统一执行 DOM 更新（避免多次修改导致多次渲染，优化性能）
- 状态修改后，DOM 不会立即更新，而是异步执行

### nextTick() 用法

- **作用**：等待 DOM 更新完成后执行回调函数
- **语法**：`import { nextTick } from 'vue'`，调用 `nextTick(回调函数)` 或使用 `await nextTick()`
- **示例**：

  ```js
  import { ref, nextTick } from "vue";
  const count = ref(0);

  async function increment() {
    count.value++;
    // DOM 尚未更新
    console.log(document.getElementById("count").textContent); // 0
    // 等待 DOM 更新完成
    await nextTick();
    console.log(document.getElementById("count").textContent); // 1
  }
  ```
