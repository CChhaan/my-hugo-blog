---
# 文章标题
title: 8.4 渲染机制
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 虚拟 DOM, VDOM, 渲染管线, 挂载, patch, diffing, reconciliation, 模板渲染, 渲染函数, 静态 vnode 缓存, 编译时优化, 树结构打平, 区块追踪, SSR 激活, 前端性能优化
# 发表日期
date: 2025-04-23
summary: 本文介绍了 Vue 3 的渲染机制，包括虚拟 DOM、渲染管线、模板 vs. 渲染函数、带编译时信息的虚拟 DOM 等。
# 分类
categories:
  - Vue3文档阅读
# 标签
tags:
  - vue
  - vue3
  - 前端框架
  - 前端开发
---

## 虚拟 DOM

**虚拟 DOM (Virtual DOM, VDOM)**：一种编程概念，将目标 UI 用数据结构“虚拟”表示，保存在内存中，并与真实 DOM 保持同步。

虚拟 DOM 不是具体技术，而是一种模式，没有标准实现。

**挂载 (mount)**：运行时渲染器遍历虚拟 DOM 树，构建真实 DOM 树。

**更新 (patch / diffing / reconciliation)**：比较两份虚拟 DOM 树的差异，并将变化应用到真实 DOM。

主要收益：

- **声明式**、**灵活**地创建、检查和组合 UI 结构。
- 具体 DOM 操作交由渲染器处理。

## 渲染管线

Vue 组件挂载时的步骤：

1. **编译**
   - Vue 模板被编译为**渲染函数**（返回虚拟 DOM 树的函数）。
   - 可通过构建步骤提前完成，也可使用运行时编译器即时完成。
2. **挂载**
   - 渲染器调用渲染函数，遍历虚拟 DOM 树并创建真实 DOM 节点。
   - 作为响应式副作用执行，追踪所有响应式依赖。
3. **更新**
   - 当依赖变化时，副作用重新运行，创建新的虚拟 DOM 树。
   - 渲染器比较新旧树，应用必要更新到真实 DOM。

## 模板 vs. 渲染函数

**模板**：预编译为虚拟 DOM 渲染函数。

**渲染函数**：直接使用 JavaScript 手写 vnode。

渲染函数的灵活性：更适合处理**高度动态逻辑**。

模板的优势：

**贴近 HTML**

- 更易重用 HTML 片段。
- 提供更好的可访问性。
- 更方便使用 CSS。
- 设计师更容易理解和修改。

**确定语法**

- 模板可被静态分析。
- 编译器可进行编译时优化，提升虚拟 DOM 性能。

模板对大多数场景够用且高效；渲染函数主要用于可重用组件的动态渲染逻辑。

## 带编译时信息的虚拟 DOM

React 等纯运行时实现的问题

- 更新算法无法预知新树结构。
- 每次都需遍历整棵树并比较 props。
- 即使未变部分，每次也会创建新 vnode。
- 带来 **性能开销** 和 **内存压力**。

Vue 的优化

- 框架同时控制 **编译器** 和 **运行时**。
- 编译器静态分析模板，在生成代码中添加标记。
- 运行时可基于标记走捷径。
- 保留使用渲染函数的能力。
- 称为 **带编译时信息的虚拟 DOM**。

### 缓存静态内容

模板中无动态绑定的部分：

- 首次渲染后缓存 vnode。
- 后续渲染直接使用缓存，跳过比对。

多个连续静态元素：

- 压缩为 **静态 vnode**（纯 HTML 字符串）。
- 挂载时通过 `innerHTML` 渲染。

### 更新类型标记

**编译时推断元素更新类型**。

渲染函数中直接编码更新类型。

多个标记合并为一个数字。

渲染器通过**位运算**检查标记并决定更新操作。

子节点类型也会被标记：

- 例如，多个根节点被表示为 **片段 (fragment)**，其顺序被认为稳定。
- 渲染时跳过顺序协调过程。

### 树结构打平

虚拟 DOM 树由 `createElementBlock()` 创建。

**区块 (block)**：结构稳定的部分。

区块追踪所有带更新标记的后代节点。

编译结果打平为仅含动态后代节点的数组。重渲染时只遍历打平数组，而非整棵树。**静态部分被高效跳过**。

`v-if` 和 `v-for` 会创建新区块，并在父区块中被追踪。

### 对 SSR 激活的影响

更新类型标记和树结构打平提升了 **SSR 激活性能**：

- 单元素激活基于标记走捷径。
- 激活时只需遍历区块节点及其动态子节点。
- 模板层面支持更高效的部分激活。
