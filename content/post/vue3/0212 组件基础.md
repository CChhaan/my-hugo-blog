---
# 文章标题
title: 2.12 组件基础
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 组件基础，组件定义 (单文件 / 非构建式), 组件注册 (局部 / 全局), 组件通信 (Props/Emit/Slot), 动态组件与缓存 (KeepAlive)
summary: 本节详细介绍了 Vue 组件的基础概念、定义方式、注册方式、通信机制以及动态组件和缓存等高级特性，帮助读者全面掌握 Vue 组件开发。
# 发表日期
date: 2025-04-09
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 组件化开发
  - 前端开发
---

## 组件核心概念与分类

组件是 Vue 中**复用 UI 片段、拆分复杂界面**的核心机制，可将页面划分为独立、可维护的单元，最终组织成树状嵌套结构。根据使用场景，组件主要分为两类：

| 类型              | 定义方式                                                       | 适用场景                                         |
| ----------------- | -------------------------------------------------------------- | ------------------------------------------------ |
| 单文件组件（SFC） | 以 `.vue` 文件形式存在，包含 `<template>`/`<script>`/`<style>` | 项目开发的主流方式，支持完整的组件逻辑与样式封装 |
| 非构建式组件      | 以 JavaScript 对象形式定义（含 `template` 选项）               | 无构建步骤的场景（如通过 CDN 引入 Vue）          |

## 组件定义方式

### 单文件组件（SFC，推荐）

`.vue` 文件是 Vue 项目的标准组件格式，结构清晰，支持 CSS 作用域、预处理器等特性，需配合构建工具（如 Vite、Webpack）使用。

#### 基础结构：

```xml
<!-- 1. 模板：组件的 UI 结构 -->
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
  </div>
</template>

<!-- 2. 脚本：组件的逻辑（组合式 API 为例） -->
<script setup>
// 定义响应式状态
const msg = 'Hello Vue Component'
</script>

<!-- 3. 样式：组件的样式（scoped 表示样式仅作用于当前组件） -->
<style scoped>
.hello {
  color: #333;
}
</style>
```

### 非构建式组件（无构建步骤）

无需构建工具，直接通过 JavaScript 对象定义组件，`template` 可内联字符串或指向 DOM 元素。

#### 示例 1：内联模板字符串

```js
// 定义组件对象
const HelloComponent = {
  // 模板：内联字符串（Vue 运行时编译）
  template: `
    <div>
      <p>{{ message }}</p>
      <button @click="handleClick">点击</button>
    </div>
  `,
  // 组合式 API 逻辑
  setup() {
    const message = Vue.ref("非构建式组件");
    const handleClick = () => {
      message.value = "按钮被点击";
    };
    return { message, handleClick };
  },
};
```

#### 示例 2：模板指向 DOM 元素

通过 `template` 选项的 ID 指向页面中的 `<template>` 元素，避免字符串模板的可读性问题：

```html
<!-- 页面中的模板元素 -->
<template id="hello-template">
  <div>{{ message }}</div>
</template>

<script>
  // 定义组件，模板指向 #hello-template
  const HelloComponent = {
    template: "#hello-template",
    setup() {
      const message = Vue.ref("模板来自 DOM 元素");
      return { message };
    },
  };
</script>
```

### 多组件导出

一个文件中可通过**具名导出**定义多个组件，导入时按需使用：

```js
// components/CommonComponents.js
export const Button = {
  template: "<button>{{ text }}</button>",
  setup(props) {
    return { text: props.text };
  },
};

export const Card = {
  template: '<div class="card">{{ content }}</div>',
  setup(props) {
    return { content: props.content };
  },
};

// 导入使用
import { Button, Card } from "./components/CommonComponents.js";
```

## 组件注册方式

组件注册分为**局部注册**（仅当前组件可用）和**全局注册**（整个应用可用），推荐优先使用局部注册（避免全局污染）。

### 局部注册（`<script setup>` 场景）

`<script setup>` 中导入的组件**自动局部注册**，无需额外配置，直接在模板中使用（推荐 PascalCase 标签名，区分原生 HTML 元素）。

#### 示例：

```xml
<!-- 父组件 Parent.vue -->
<template>
  <!-- 直接使用导入的子组件（PascalCase 标签名） -->
  <HelloComponent msg="Hello Child" />
  <UserCard :user="userInfo" />
</template>

<script setup>
// 1. 导入子组件（自动局部注册）
import HelloComponent from './HelloComponent.vue'
import UserCard from './UserCard.vue'

// 2. 定义传递给子组件的数据
const userInfo = { name: 'Alice', age: 20 }
</script>
```

### 全局注册（应用级可用）

在应用实例（`createApp`）上注册组件，所有子组件无需导入即可使用，适合通用组件（如 Button、Input）。

#### 示例：

```js
// main.js（应用入口）
import { createApp } from "vue";
import App from "./App.vue";
// 导入需全局注册的组件
import GlobalButton from "./components/GlobalButton.vue";

// 1. 创建应用实例
const app = createApp(App);

// 2. 全局注册组件（参数1：组件名，参数2：组件对象）
app.component("GlobalButton", GlobalButton);

// 3. 挂载应用
app.mount("#app");
```

```xml
<!-- 任意组件中直接使用全局组件 -->
<template>
  <GlobalButton text="全局按钮" />
</template>
```

## 组件通信核心方式

组件间通信是组件协作的关键，Vue 提供 3 种核心方式：`Props`（父传子）、`Emit`（子传父）、`Slot`（内容分发）。

### Props：父组件向子组件传递数据

`Props` 是父组件向子组件传递数据的**唯一标准方式**，子组件需先声明接收的 Props，再通过自定义 attribute 接收数据。

#### 步骤 1：子组件声明 Props（`<script setup>`）

通过 `defineProps` 宏声明 Props（无需导入），支持类型定义、默认值、校验规则。

```xml
<!-- 子组件 Child.vue -->
<template>
  <div>
    <p>父组件传递的消息：{{ msg }}</p>
    <p>用户年龄：{{ user.age }}</p>
  </div>
</template>

<script setup>
// 声明 Props（支持类型校验）
const props = defineProps({
  // 基础类型：字符串
  msg: String,
  // 复杂类型：对象，指定默认值
  user: {
    type: Object,
    default: () => ({ name: 'Unknown', age: 0 }) // 对象默认值需用函数返回
  }
})

// 访问 Props（模板中直接用，脚本中通过 props.xxx 访问）
console.log(props.msg)
</script>
```

#### 步骤 2：父组件传递 Props

通过“自定义 attribute”传递数据，静态值直接写，动态值用 `v-bind`（`:`）绑定。

```xml
<!-- 父组件 Parent.vue -->
<template>
  <!-- 1. 传递静态值（字符串） -->
  <Child msg="静态消息" />
  <!-- 2. 传递动态值（响应式数据） -->
  <Child :msg="dynamicMsg" :user="currentUser" />
</template>

<script setup>
import Child from './Child.vue'
import { ref, reactive } from 'vue'

// 动态数据
const dynamicMsg = ref('动态消息（可更新）')
const currentUser = reactive({ name: 'Bob', age: 22 })
</script>
```

#### 非 `<script setup>` 场景

Props 需通过 `props` 选项声明，且作为 `setup` 函数的第一个参数传入：

```js
export default {
  // 声明 Props
  props: ["msg", "user"],
  setup(props) {
    console.log(props.msg); // 访问 Props
  },
};
```

### Emit：子组件向父组件传递事件

子组件通过 `Emit` 抛出事件，父组件通过 `v-on`（`@`）监听事件，实现“子传父”通信（如子组件触发父组件逻辑）。

#### 步骤 1：子组件声明并抛出事件

通过 `defineEmits` 宏声明抛出的事件（无需导入），再通过返回的 `emit` 函数触发事件。

```xml
<!-- 子组件 Child.vue -->
<template>
  <button @click="handleClick">点击触发父组件事件</button>
</template>

<script setup>
// 1. 声明抛出的事件（支持参数校验）
const emit = defineEmits([
  'click', // 无参数事件
  'send-data' // 带参数事件
])

// 2. 触发事件（可传递参数）
const handleClick = () => {
  emit('click') // 触发无参数事件
  emit('send-data', '子组件数据', 123) // 触发带参数事件
}
</script>
```

#### 步骤 2：父组件监听事件

通过 `@事件名` 监听子组件抛出的事件，接收参数并执行逻辑。

```xml
<!-- 父组件 Parent.vue -->
<template>
  <Child
    @click="onChildClick"
    @send-data="onChildSendData"
  />
</template>

<script setup>
import Child from './Child.vue'

// 监听无参数事件
const onChildClick = () => {
  console.log('子组件按钮被点击')
}

// 监听带参数事件（参数与子组件 emit 顺序一致）
const onChildSendData = (data, num) => {
  console.log('子组件传递的数据：', data, num)
}
</script>
```

#### 非 `<script setup>` 场景

通过 `emits` 选项声明事件，`emit` 函数从 `setup` 上下文获取：

```js
export default {
  emits: ["click", "send-data"], // 声明事件
  setup(props, { emit }) {
    // 从上下文获取 emit
    const handleClick = () => {
      emit("send-data", "数据");
    };
    return { handleClick };
  },
};
```

### Slot：父组件向子组件传递内容

`Slot`（插槽）用于父组件向子组件**传递 HTML 内容**（如文本、元素、其他组件），子组件通过 `<slot>` 标签定义内容占位符。

#### 基础用法：默认插槽

子组件定义单个插槽，父组件传递的内容会填充到插槽位置。

```xml
<!-- 子组件 Card.vue（定义插槽） -->
<template>
  <div class="card">
    <!-- 插槽：父组件内容的占位符 -->
    <slot>默认内容（父组件未传递时显示）</slot>
  </div>
</template>

<!-- 父组件 Parent.vue（传递内容） -->
<template>
  <Card>
    <!-- 传递给子组件的内容 -->
    <h3>卡片标题</h3>
    <p>卡片内容：通过插槽传递</p>
  </Card>
</template>
```

#### 进阶用法：具名插槽

当子组件需多个插槽时，通过 `name` 属性区分不同插槽，父组件用 `v-slot:name`（简写 `#name`）指定内容对应的插槽。

```xml
<!-- 子组件 Layout.vue（多插槽） -->
<template>
  <div class="layout">
    <header>
      <!-- 具名插槽：header -->
      <slot name="header"></slot>
    </header>
    <main>
      <!-- 默认插槽：无 name，对应 #default -->
      <slot></slot>
    </main>
    <footer>
      <!-- 具名插槽：footer -->
      <slot name="footer"></slot>
    </footer>
  </div>
</template>

<!-- 父组件 Parent.vue（指定插槽内容） -->
<template>
  <Layout>
    <!-- 具名插槽：header -->
    <template #header>
      <h1>页面标题</h1>
    </template>
    <!-- 默认插槽：main 内容 -->
    <p>页面主体内容</p>
    <!-- 具名插槽：footer -->
    <template #footer>
      <p>© 2024 版权信息</p>
    </template>
  </Layout>
</template>
```

## 组件动态切换与缓存

### 动态组件（`<component :is="...">`）

通过 `<component>` 元素和 `is` 属性实现**组件动态切换**，`is` 的值可是“组件名”或“组件对象”。

#### 示例：

```xml
<template>
  <div>
    <!-- 切换按钮 -->
    <button @click="currentComponent = 'Home'">首页</button>
    <button @click="currentComponent = 'User'">用户页</button>

    <!-- 动态组件：is 绑定当前组件名 -->
    <component :is="currentComponent" />
  </div>
</template>

<script setup>
import { ref } from 'vue'
// 导入需切换的组件
import Home from './Home.vue'
import User from './User.vue'

// 当前激活的组件名
const currentComponent = ref('Home')
</script>
```

#### 注意：

- `is` 也可直接绑定组件对象（无需注册）：`const currentComponent = ref(Home)`；
- 切换 HTML 元素：`is` 绑定标签名（如 `:is="'div'"`），但需配合 `vue:` 前缀避免混淆（如 `:is="'vue:div'"`）。

### 组件缓存（`<KeepAlive>`）

默认情况下，动态切换组件时，被隐藏的组件会被**卸载**（状态丢失）。通过 `<KeepAlive>` 包裹动态组件，可保持组件“存活”（状态不丢失），优化性能。

#### 示例：

```xml
<template>
  <!-- KeepAlive 包裹动态组件，缓存被隐藏的组件 -->
  <KeepAlive>
    <component :is="currentComponent" />
  </KeepAlive>
</template>
```

#### 配置项：

- `include`：仅缓存指定组件（如 `include="Home,User"`，组件名匹配）；
- `exclude`：排除指定组件（不缓存）；
- `max`：最大缓存数量（超过时按 LRU 策略删除旧缓存）。

## DOM 内模板的限制（无构建步骤场景）

若直接在 DOM 中书写模板（如 `<template>` 元素），需遵守浏览器 HTML 解析规则，存在以下限制（单文件组件无此问题）：

| 限制             | 原因                                                | 解决方案                                                         |
| ---------------- | --------------------------------------------------- | ---------------------------------------------------------------- |
| 大小写不敏感     | 浏览器将大写标签/属性转为小写                       | 组件名/Props 用 kebab-case（如 `<user-card>` 替代 `<UserCard>`） |
| 必须显式关闭标签 | HTML 仅允许少数元素（如 `<input>`）省略关闭标签     | 所有组件标签必须闭合（如 `<child-component></child-component>`） |
| 元素嵌套限制     | 部分 HTML 元素（如 `<ul>`/`<table>`）限制子元素类型 | 用 `is` 属性嵌套组件（如 `<li :is="ChildComponent">`）           |

#### 示例：解决 `<table>` 嵌套组件限制

```xml
<!-- 错误：<ChildComponent> 不能直接作为 <table> 子元素 -->
<table>
  <ChildComponent />
</table>

<!-- 正确：用 is 属性嵌套组件 -->
<table>
  <tr :is="ChildComponent"></tr>
</table>
```

## 核心总结

| 主题       | 关键知识点                                         | 最佳实践                                   |
| ---------- | -------------------------------------------------- | ------------------------------------------ |
| 组件定义   | 优先使用单文件组件（`.vue`），无构建步骤用对象定义 | 拆分复杂界面为细粒度组件，提高复用性       |
| 组件注册   | 局部注册为主（避免全局污染），通用组件全局注册     | 组件名用 PascalCase，区分原生元素          |
| 组件通信   | Props 传数据、Emit 抛事件、Slot 传内容             | 避免直接访问子组件实例，优先用标准通信方式 |
| 动态组件   | `<component :is="...">` 切换，`<KeepAlive>` 缓存   | 频繁切换的组件用缓存，减少卸载/重建开销    |
| DOM 内模板 | 注意大小写、标签闭合、元素嵌套限制                 | 优先使用单文件组件，规避解析限制           |
