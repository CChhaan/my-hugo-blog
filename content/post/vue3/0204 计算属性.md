---
# 文章标题
title: 2.4 计算属性
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 计算属性 (computed), 组合式 API, 缓存机制，可写计算属性，响应式依赖追踪
summary: 本节介绍 Vue 3 中计算属性（computed）的基本用法、核心作用、响应式依赖追踪、缓存机制以及可写计算属性等。
# 发表日期
date: 2025-04-07
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 前端开发
---

## 一、计算属性的核心作用

- **解决问题**：避免在模板中编写复杂逻辑，防止模板臃肿、难以维护
- **本质**：基于响应式依赖（如 ref、reactive 状态）派生新值的**响应式属性**
- **优势**：自动追踪依赖、缓存计算结果、简化模板逻辑

## 二、基础用法与语法

### 1. 基本声明（只读计算属性）

- **语法**：`const 计算属性名 = computed( getter函数 )`，返回一个**计算属性 ref**
- **示例**：

  ```js
  import { ref, computed } from "vue";

  const count = ref(0);
  // 声明计算属性：基于 count 派生新值
  const doubleCount = computed(() => {
    return count.value * 2;
  });
  ```

- **访问方式**：
  - 脚本中：`doubleCount.value`（需 `.value`，因返回 ref 对象）
  - 模板中：`{{ doubleCount }}`（自动解包，无需 `.value`）

### 2. 响应式依赖追踪

- Vue 会自动追踪计算属性 getter 中使用的**所有响应式状态**（如 ref、reactive 属性）
- 当依赖的状态更新时，计算属性会**自动重新计算**，并触发相关 DOM 更新
- **示例**：`count.value` 变化时，`doubleCount` 会自动重新计算为新值的 2 倍

## 三、计算属性 vs 方法：核心差异（缓存机制）

| 特性     | 计算属性（computed）                               | 方法（methods）                            |
| -------- | -------------------------------------------------- | ------------------------------------------ |
| 执行时机 | 仅当**响应式依赖更新**时重新计算                   | 每次组件重渲染或调用时**重新执行**         |
| 缓存机制 | 结果会被缓存，依赖不变时直接返回缓存值             | 无缓存，每次调用均重新计算                 |
| 适用场景 | 基于响应式状态的复杂派生值（依赖稳定、计算开销大） | 需动态执行的逻辑（如事件处理、参数化计算） |

**示例对比**：

```js
// 计算属性（缓存）
const cachedResult = computed(() => {
  return heavyCalculation(count.value); // 仅 count 变化时执行
});

// 方法（无缓存）
function methodResult() {
  return heavyCalculation(count.value); // 每次调用/重渲染均执行
}
```

## 四、可写计算属性（getter + setter）

- **默认行为**：计算属性是只读的，直接修改会触发运行时警告
- **可写场景**：需通过修改计算属性间接更新依赖状态（特殊场景使用）
- **语法**：`computed({ get: () => {}, set: (newValue) => {} })`
- **示例**：

  ```js
  const firstName = ref("John");
  const lastName = ref("Doe");

  const fullName = computed({
    // getter：计算并返回 fullName
    get() {
      return `${firstName.value} ${lastName.value}`;
    },
    // setter：接收新值，更新依赖状态
    set(newValue) {
      const [newFirst, newLast] = newValue.split(" ");
      firstName.value = newFirst;
      lastName.value = newLast;
    },
  });

  // 修改计算属性，触发 setter
  fullName.value = "Alice Smith";
  // 此时 firstName 变为 'Alice'，lastName 变为 'Smith'
  ```

## 五、高级特性：访问上一个值

- **语法**：计算属性 getter 的第一个参数为**上一次计算的结果**（初始为 `undefined`）
- **用途**：基于前值计算新值（如累计、比较等场景）
- **示例**：
  ```js
  const count = ref(0);
  // 计算属性：记录 count 变化的差值
  const diff = computed((prev) => {
    const current = count.value;
    const difference = prev === undefined ? 0 : current - prev;
    return difference;
  });
  ```

## 六、计算属性的重要限制

1. **无副作用**：getter 应仅做计算并返回值，**禁止**：

   - 修改其他响应式状态（如 `count.value++`）
   - 执行异步操作（如 `fetch` 请求）
   - 操作 DOM（如修改元素样式）

2. **只读派生状态**：计算属性返回的是“基于源状态的临时快照”，**不应直接修改**（应通过更新源状态触发重新计算）

3. **依赖稳定性**：避免在 getter 中创建响应式状态（如 `const temp = ref(0)`），会导致依赖追踪异常

## 七、核心结论

- 计算属性是处理**响应式依赖派生值**的最佳选择，通过缓存机制优化性能
- 优先使用只读计算属性，仅在特殊场景（需反向更新源状态）使用可写计算属性
- 严格遵守“无副作用”原则，确保计算属性仅负责“计算与返回值”
- 与方法的选择标准：依赖稳定且计算开销大 → 用计算属性；需动态执行或无缓存需求 → 用方法
