---
# 文章标题
title: 2.7 列表渲染
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 列表渲染，v-for 用法，key 属性优化，v-for 与 v-if 优先级，响应式列表更新
summary: 本节详细介绍了 Vue 3 中列表渲染的用法，包括 v-for 的基础用法、key 属性优化、v-for 与 v-if 的优先级以及响应式列表更新。
# 发表日期
date: 2025-04-08
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 前端开发
---

## v-for 基础用法：遍历数组/对象/整数

`v-for` 用于基于数据源重复渲染元素或模板块，支持数组、对象、整数三种数据源，核心语法为 `别名 in 数据源`（可替换 `in` 为 `of`，更贴近 JS 迭代器语法）。

### 遍历数组

#### 基础遍历（仅迭代项）

- **语法**：`v-for="item in items"`，`items` 为源数组，`item` 为当前迭代项的别名
- **示例**：
  ```js
  const items = ref(["Apple", "Banana", "Cherry"]);
  ```
  ```xml
  <ul>
    <li v-for="item in items">{{ item }}</li>
  </ul>
  <!-- 渲染结果：3个li，分别显示 Apple、Banana、Cherry -->
  ```

#### 遍历数组（含索引）

- **语法**：`v-for="(item, index) in items"`，`index` 为可选参数，代表当前项的位置索引（从 0 开始）
- **示例**：
  ```xml
  <ul>
    <li v-for="(item, index) in items">
      {{ index + 1 }}. {{ item }}
    </li>
  </ul>
  <!-- 渲染结果：1. Apple、2. Banana、3. Cherry -->
  ```

#### 数组项解构遍历

- **语法**：若数组项为对象，可直接解构属性作为别名，如 `v-for="({ key1, key2 }) in items"`
- **示例**：
  ```js
  const users = ref([
    { name: "Alice", age: 20 },
    { name: "Bob", age: 22 },
  ]);
  ```
  ```xml
  <ul>
    <li v-for="({ name, age }) in users">
      {{ name }} ({{ age }}岁)
    </li>
  </ul>
  ```

### 遍历对象

#### 基础遍历（仅属性值）

- **语法**：`v-for="value in object"`，`object` 为源对象，`value` 为当前属性值
- **示例**：
  ```js
  const user = ref({ name: "Alice", age: 20, gender: "female" });
  ```
  ```xml
  <ul>
    <li v-for="value in user">{{ value }}</li>
  </ul>
  <!-- 渲染结果：Alice、20、female -->
  ```

#### 遍历对象（含属性名/索引）

- **语法**：`v-for="(value, key, index) in object"`，`key` 为属性名，`index` 为遍历索引（从 0 开始）
- **示例**：
  ```xml
  <ul>
    <li v-for="(value, key, index) in user">
      {{ index + 1 }}. {{ key }}: {{ value }}
    </li>
  </ul>
  <!-- 渲染结果：1. name: Alice、2. age: 20、3. gender: female -->
  ```
- **遍历顺序**：基于 `Object.values()` 的返回顺序，与对象属性定义顺序一致（ES6+ 特性）。

### 遍历整数

- **语法**：`v-for="n in count"`，`count` 为正整数，模板会从 1 到 `count` 重复渲染（初值为 1，非 0）
- **示例**：
  ```xml
  <div v-for="n in 3">第 {{ n }} 个元素</div>
  <!-- 渲染结果：3个div，分别显示 第1个元素、第2个元素、第3个元素 -->
  ```

### 多元素遍历：v-for 作用于 `<template>`

- **问题**：`v-for` 需依附于单个元素，若需重复渲染多个元素，直接使用会冗余
- **解决方案**：在 `<template>` 上使用 `v-for`（`<template>` 为不可见包装器，最终不渲染到 DOM）
- **示例**：
  ```xml
  <template v-for="item in items">
    <h3>{{ item.title }}</h3>
    <p>{{ item.content }}</p>
  </template>
  <!-- 每个 item 对应 1个h3 + 1个p，无 <template> 标签 -->
  ```

## v-for 与 key：优化列表更新

Vue 默认采用“就地更新”策略更新 `v-for` 列表（仅更新内容，不移动 DOM 位置），为让 Vue 跟踪每个元素的唯一标识，需添加 `key` 属性，优化重用和重新排序逻辑。

### key 的作用与语法

- **作用**：作为元素的唯一标识，帮助 Vue 识别元素身份，避免错误复用（如表单输入值混乱）
- **语法**：`:key="唯一值"`，值需为**基础类型**（字符串/数字），不可用对象
- **示例**：
  ```js
  const users = ref([
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
  ]);
  ```
  ```xml
  <li v-for="user in users" :key="user.id">
    {{ user.name }}
  </li>
  ```

### key 的使用规则

- **`<template v-for>` 场景**：`key` 需放在 `<template>` 容器上，而非内部元素
  ```xml
  <template v-for="user in users" :key="user.id">
    <p>{{ user.name }}</p>
    <span>{{ user.age }}</span>
  </template>
  ```
- **推荐场景**：除非迭代内容极简单（无组件/有状态 DOM），否则均需添加 `key`
- **禁用场景**：不使用数组索引作为 `key`（若数组项顺序改变，会导致 DOM 错误更新）

## v-for 与 v-if：优先级与使用规范

### 优先级规则

- **核心结论**：`v-if` 优先级高于 `v-for`，若二者作用于同一元素，`v-if` 无法访问 `v-for` 的迭代变量（因 `v-if` 先执行）
- **反例（不推荐）**：
  ```xml
  <!-- 错误：v-if 无法访问 item（v-if 先执行） -->
  <li v-for="item in items" v-if="item.isActive">
    {{ item.name }}
  </li>
  ```

### 正确使用方式

#### 过滤列表：用计算属性替代

- **场景**：需渲染数组中符合条件的项，先通过计算属性过滤数据，再用 `v-for` 遍历
- **示例**：
  ```js
  const items = ref([
    { name: "Apple", isActive: true },
    { name: "Banana", isActive: false },
  ]);
  // 计算属性过滤激活项
  const activeItems = computed(() => {
    return items.value.filter((item) => item.isActive);
  });
  ```
  ```xml
  <!-- 正确：遍历过滤后的数组，无需 v-if -->
  <li v-for="item in activeItems" :key="item.name">
    {{ item.name }}
  </li>
  ```

#### 控制列表显示：v-if 移至容器元素

- **场景**：需整体显示/隐藏列表，将 `v-if` 作用于 `v-for` 的父容器，而非同一元素
- **示例**：
  ```xml
  <!-- 正确：v-if 控制整个列表显示，v-for 遍历数组 -->
  <ul v-if="showList">
    <li v-for="item in items" :key="item.name">
      {{ item.name }}
    </li>
  </ul>
  ```

## 响应式更新列表：变更方法与不可变方法

Vue 能侦听响应式数组的变更，自动触发列表更新，但需区分“变更方法”（修改原数组）和“不可变方法”（返回新数组）。

### 变更方法（自动触发更新）

直接修改原数组的方法，Vue 会侦听并更新 DOM，常用方法如下：
| 方法名 | 作用 | 示例 |
|----------|-------------------------------|-------------------------------|
| `push()` | 向数组末尾添加元素 | `items.value.push('Date')` |
| `pop()` | 删除数组末尾元素 | `items.value.pop()` |
| `shift()`| 删除数组首元素 | `items.value.shift()` |
| `unshift()` | 向数组开头添加元素 | `items.value.unshift('Grape')` |
| `splice()`| 插入/删除/替换元素 | `items.value.splice(1, 1)` |
| `sort()` | 排序数组（修改原数组） | `items.value.sort()` |
| `reverse()`| 反转数组（修改原数组） | `items.value.reverse()` |

### 不可变方法（需替换原数组）

不修改原数组，返回新数组的方法，需将原数组替换为新数组以触发更新，常用方法如下：
| 方法名 | 作用 | 示例 |
|------------|-------------------------------|---------------------------------------|
| `filter()` | 过滤数组，返回新数组 | `items.value = items.value.filter(...)`|
| `concat()` | 合并数组，返回新数组 | `items.value = items.value.concat(...)`|
| `slice()` | 截取数组，返回新数组 | `items.value = items.value.slice(...)` |
| `map()` | 映射数组，返回新数组 | `items.value = items.value.map(...)` |

#### 注意事项：计算属性中避免修改原数组

若在计算属性中使用 `sort()`/`reverse()`（变更方法），需先创建原数组副本，避免修改原始数据：

```js
// 错误：直接修改原数组
const sortedItems = computed(() => items.value.sort());
// 正确：先复制数组，再排序
const sortedItems = computed(() => [...items.value].sort());
```

## v-for 与组件：传递数据

直接在组件上使用 `v-for` 时，组件不会自动接收迭代项，需通过 **props 显式传递数据**（避免组件与 `v-for` 耦合，提高复用性）。

### 示例：组件上使用 v-for

```js
// 子组件：Child.vue
const props = defineProps(["item"]);
```

```xml
<!-- 父组件：使用 v-for 遍历并传递 props -->
<Child
  v-for="item in items"
  :key="item.id"
  :item="item"
/>
```

## 核心总结

| 场景                  | 语法示例                                         | 关键注意点                        |
| --------------------- | ------------------------------------------------ | --------------------------------- |
| 遍历数组（含索引）    | `v-for="(item, index) in items"`                 | 索引从 0 开始                     |
| 遍历对象（含键/索引） | `v-for="(val, key, idx) in obj"`                 | 遍历顺序与 `Object.values()` 一致 |
| 遍历整数              | `v-for="n in 3"`                                 | 从 1 开始，非 0                   |
| 多元素遍历            | `<template v-for="item in items">...</template>` | `key` 需放在 `<template>` 上      |
| 优化列表更新          | `:key="唯一基础值"`                              | 不用索引/对象作为 key             |
| 过滤列表              | 计算属性过滤后再遍历                             | 避免 v-if 与 v-for 作用于同一元素 |
