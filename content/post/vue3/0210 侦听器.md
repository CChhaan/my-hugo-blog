---
# 文章标题
title: 2.10 侦听器
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 组合式 API 侦听器，watch 用法，watchEffect 自动追踪，副作用清理 (onCleanup), 侦听器停止 (stop)
summary: 本节详细介绍了 Vue 3 组合式 API 中的侦听器，包括 `watch` 和 `watchEffect` 的用法、副作用清理、侦听器停止等，帮助开发者更好地控制响应式状态变化。
# 发表日期
date: 2025-04-08
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue3
  - 前端框架
  - 前端开发
---

## 侦听器核心作用

侦听器用于在**响应式状态变化时执行副作用**（如修改 DOM、发起异步请求、更新其他状态等），Vue 组合式 API 提供 `watch` 和 `watchEffect` 两种核心侦听方式，分别适用于“精确控制依赖”和“自动追踪依赖”场景。

## watch：精确侦听指定数据源

`watch` 需**明确指定侦听的数据源**，仅当数据源变化时触发回调，支持细粒度控制（如深层侦听、立即执行），适合需精确控制触发时机的场景。

### 基础用法：侦听不同类型的数据源

`watch` 第一个参数（数据源）支持 4 种形式，需根据状态类型选择对应方式：

| 数据源类型             | 语法示例                                                     | 说明                                                           |
| ---------------------- | ------------------------------------------------------------ | -------------------------------------------------------------- |
| Ref（含计算属性）      | `watch(ref变量, (newVal, oldVal) => {})`                     | 直接传入 Ref，回调接收新值和旧值                               |
| 响应式对象的属性       | `watch(() => reactiveObj.key, (newVal) => {})`               | 需用 getter 函数返回属性（不能直接侦听 `reactiveObj.key`）     |
| 响应式对象（Reactive） | `watch(reactiveObj, (newVal) => {}, { deep: true })`         | 直接传入 Reactive 对象，默认隐式深层侦听（嵌套属性变化也触发） |
| 多个数据源（数组）     | `watch([ref1, () => reactiveObj.key], ([new1, new2]) => {})` | 数组内可混合 Ref、getter 函数，回调接收对应新值数组            |

#### 示例：

```js
import { ref, reactive, watch } from "vue";

// 1. 侦听 Ref
const count = ref(0);
watch(count, (newCount, oldCount) => {
  console.log(`count 从 ${oldCount} 变到 ${newCount}`);
});

// 2. 侦听 Reactive 对象的属性（需 getter 函数）
const user = reactive({ name: "Alice", age: 20 });
watch(
  () => user.age,
  (newAge) => {
    console.log(`年龄变为 ${newAge}`);
  }
);

// 3. 侦听多个数据源（数组）
const name = ref("Bob");
watch([count, () => user.age, name], ([newCount, newAge, newName]) => {
  console.log(`count: ${newCount}, age: ${newAge}, name: ${newName}`);
});
```

### 关键配置项

`watch` 第三个参数为配置对象，支持 4 种核心配置，用于调整侦听行为：

| 配置项      | 类型           | 默认值 | 作用                                                                                                                                    |
| ----------- | -------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| `deep`      | boolean/number | false  | - 布尔值：`true` 表示深层侦听（如侦听对象嵌套属性）；<br>- 数字：表示最大遍历深度（优化大型数据结构性能）                               |
| `immediate` | boolean        | false  | `true` 表示创建侦听器时**立即执行一次回调**（默认仅数据源变化时执行）                                                                   |
| `once`      | boolean        | false  | `true` 表示回调仅触发一次（数据源变化一次后自动停止侦听）                                                                               |
| `flush`     | string         | 'pre'  | 控制回调执行时机：<br>- `'pre'`：组件 DOM 更新前执行；<br>- `'post'`：组件 DOM 更新后执行；<br>- `'sync'`：同步执行（数据变化立即触发） |

#### 示例：

```js
// 深层侦听对象（仅追踪 user.address.city 变化，深度为 2）
watch(
  () => user.address,
  (newAddr) => console.log("城市变化：", newAddr.city),
  { deep: 2 } // 仅遍历到 address 的子属性（city）
);

// 立即执行 + 深层侦听（初始执行一次，后续嵌套属性变化也触发）
watch(user, (newUser) => console.log("user 任意属性变化", newUser), {
  immediate: true,
  deep: true,
});
```

### 注意事项

- **侦听 Reactive 对象的陷阱**：直接侦听 Reactive 对象时，`deep` 配置无效（默认隐式深层侦听）；若用 getter 函数返回 Reactive 对象（`() => user`），则需显式加 `{ deep: true }` 才会深层侦听。
- **性能优化**：`deep: true` 会遍历对象所有嵌套属性，大型数据结构慎用；可通过“指定 getter 函数+`deep: 数字`”限制遍历深度，减少性能开销。
- **旧值问题**：侦听 Reactive 对象或其嵌套属性时，回调的 `oldVal` 可能与 `newVal` 相同（因 Reactive 是 Proxy，新旧值指向同一对象），需通过“浅拷贝”（如 `JSON.parse(JSON.stringify(oldVal))`）保存旧值。

## watchEffect：自动追踪依赖的侦听器

`watchEffect` 无需指定数据源，**自动追踪回调中访问的响应式状态**，回调会**立即执行一次**（默认无 `immediate` 配置），适合副作用与依赖紧密关联、无需手动维护依赖列表的场景。

### 基础用法

```js
import { ref, watchEffect } from "vue";

const keyword = ref("");
// 自动追踪 keyword 的变化（回调中访问了 keyword.value）
const stopWatch = watchEffect(() => {
  console.log("搜索关键词：", keyword.value);
  // 副作用：发起搜索请求（示例）
  // fetch(`/api/search?keyword=${keyword.value}`)
});

// 后续可手动停止侦听（调用返回的 stop 函数）
// stopWatch()
```

### 核心特性与限制

- **自动追踪依赖**：仅追踪回调中**同步访问**的响应式状态（异步操作中访问的状态不会被追踪）。  
  示例（异步场景限制）：

  ```js
  watchEffect(async () => {
    // 1. 同步访问：keyword 会被追踪
    console.log("keyword:", keyword.value);
    // 2. 异步后访问：user 不会被追踪（await 后脱离同步执行上下文）
    const res = await fetch("/api/user");
    const user = await res.json();
    console.log(user.name); // user 非响应式，且不被追踪
  });
  ```

- **执行时机**：默认在“组件 DOM 更新前”执行（与 `watch` 配置 `flush: 'pre'` 一致），可通过配置调整：

  ```js
  // 1. DOM 更新后执行（等价于 watch 的 flush: 'post'）
  watchEffect(() => {}, { flush: "post" });
  // 简写：watchPostEffect（Vue 提供的别名）
  import { watchPostEffect } from "vue";
  watchPostEffect(() => {
    /* DOM 更新后执行 */
  });

  // 2. 同步执行（数据变化立即触发，无批处理）
  watchEffect(() => {}, { flush: "sync" });
  // 简写：watchSyncEffect（Vue 提供的别名）
  import { watchSyncEffect } from "vue";
  watchSyncEffect(() => {
    /* 同步执行 */
  });
  ```

## watch 与 watchEffect 的核心差异

| 维度         | watch                                       | watchEffect                                 |
| ------------ | ------------------------------------------- | ------------------------------------------- |
| 依赖追踪方式 | 手动指定数据源（需明确告诉要侦听什么）      | 自动追踪回调中访问的响应式状态              |
| 初始执行     | 默认不执行（需 `immediate: true`）          | 默认立即执行（无需配置）                    |
| 回调参数     | 接收新值、旧值（明确对比变化）              | 无参数（依赖自动追踪，无需对比）            |
| 适用场景     | 需精确控制依赖、对比新旧值、延迟执行        | 副作用与依赖紧密关联，无需手动维护依赖      |
| 深层侦听     | 需显式配置 `deep: true`（除 Reactive 对象） | 自动追踪回调中访问的嵌套属性（无需 `deep`） |

## 侦听器的清理与停止

### 清理副作用（onCleanup）

当侦听器回调执行异步操作（如请求）时，若数据源频繁变化，可能导致“旧请求未完成、新请求已触发”的问题。可通过 `onCleanup` 注册**清理函数**，在侦听器重新触发或停止时执行（如取消旧请求）。

#### 用法：

`onCleanup` 有两种获取方式，效果一致：

- 作为 `watchEffect` 回调的第一个参数；
- 作为 `watch` 回调的第三个参数；
- 通过 `onWatcherCleanup` API（需在回调同步执行期间调用）。

#### 示例（取消旧请求）：

```js
import { watchEffect } from "vue";

watchEffect((onCleanup) => {
  // 发起请求，获取取消函数（假设请求库支持）
  const abortController = new AbortController();
  fetch(`/api/data?keyword=${keyword.value}`, {
    signal: abortController.signal,
  });

  // 注册清理函数：重新触发/停止时取消旧请求
  onCleanup(() => {
    abortController.abort();
  });
});
```

### 停止侦听器

侦听器默认绑定到组件实例，**组件卸载时自动停止**，无需手动处理。仅当以下场景需手动停止：

- 异步创建的侦听器（未绑定到组件实例）；
- 需在组件未卸载时提前停止（如条件满足时）。

#### 用法：

`watch` 和 `watchEffect` 均返回一个 `stop` 函数，调用该函数即可停止侦听。

#### 示例：

```js
import { watch, ref } from "vue";

const count = ref(0);
// 创建侦听器，获取 stop 函数
const stop = watch(count, (newCount) => {
  console.log("count 变化：", newCount);
  // 条件满足时停止侦听（如 count 达到 5）
  if (newCount >= 5) {
    stop();
  }
});
```

## 核心总结

| 侦听器类型  | 核心优势                                   | 适用场景                                   | 关键注意点                                             |
| ----------- | ------------------------------------------ | ------------------------------------------ | ------------------------------------------------------ |
| watch       | 精确控制数据源、支持新旧值对比、细粒度配置 | 需明确依赖、对比变化、延迟执行副作用       | 侦听对象属性需用 getter 函数，深层侦听注意性能         |
| watchEffect | 自动追踪依赖、代码简洁、默认立即执行       | 副作用与依赖紧密关联，无需手动维护依赖列表 | 异步操作中仅同步阶段追踪依赖，需清理副作用用 onCleanup |

- 优先用 `watchEffect` 处理“副作用依赖明确且无需对比新旧值”的场景（如搜索请求）；
- 优先用 `watch` 处理“需精确控制依赖、对比新旧值、延迟执行”的场景（如表单值变化校验）；
- 组件内同步创建的侦听器无需手动停止，异步创建的需调用 `stop` 函数避免内存泄漏。
