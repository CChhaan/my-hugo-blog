---
# 文章标题
title: 8.3 深入响应式系统
# 文章内容摘要
# description:
# 文章内容关键字
keywords: Vue 响应性, 响应式副作用, ref, reactive, computed, watchEffect, 依赖追踪, trigger, track, 组件渲染更新, 计算属性调试, 侦听器调试, shallowRef, 状态机集成, 不可变数据, 信号机制, Vue 运行时响应性, 编译时响应性
# 发表日期
date: 2025-04-22
summary: 本文介绍了 Vue 3 的响应性系统，包括响应性、Vue 中的响应性、依赖追踪与触发等内容。
# 分类
categories:
  - vue3文档阅读
# 标签
tags:
  - vue
  - vue3
  - 前端框架
  - 前端开发
---

## 什么是响应性

**响应性**是一种可以使我们声明式地处理变化的编程范式。

```js
let A2;

function update() {
  A2 = A0 + A1;
}

whenDepsChange(update);
```

### 核心术语

- **作用 (effect)**：`update()` 函数会更改程序状态，因此称为副作用或作用。
- **依赖 (dependency)**：`A0` 和 `A1` 被用来执行作用，因此它们是依赖。
- **订阅者 (subscriber)**：依赖的订阅者即作用。

我们需要一个魔法函数，能够在 `A0` 或 `A1` (这两个**依赖**) 变化时调用 `update()` (产生**作用**)。

### 魔法函数 `whenDepsChange()`

任务如下：

1. 当变量被读取时进行追踪。
2. 如果变量在当前副作用中被读取，则将副作用设为该变量的订阅者。
3. 当变量变化时，通知所有订阅副作用重新执行。

## Vue 中的响应性是如何工作的

无法追踪局部变量的读写。**可以追踪对象属性的读写**。

### 两种方式

- Vue 2：`getter / setter`（为支持旧浏览器）。
- Vue 3：`Proxy`（主要），仅在 `ref` 中使用 `getter / setter`。

```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key);
      return target[key];
    },
    set(target, key, value) {
      target[key] = value;
      trigger(target, key);
    },
  });
}

function ref(value) {
  const refObject = {
    get value() {
      track(refObject, "value");
      return value;
    },
    set value(newValue) {
      value = newValue;
      trigger(refObject, "value");
    },
  };
  return refObject;
}
```

### `reactive()` 的局限性

- 属性赋值/解构到本地变量后，访问不再响应式。
- 从 `reactive()` 返回的代理与原对象不同，可通过 `===` 区分。

## 依赖追踪与触发

**track()**：

- 检查是否有活跃副作用。
- 若有，将副作用加入属性订阅集合。

```js
// 这会在一个副作用就要运行之前被设置
// 我们会在后面处理它
let activeEffect;

function track(target, key) {
  if (activeEffect) {
    const effects = getSubscribersForProperty(target, key);
    effects.add(activeEffect);
  }
}
```

**trigger()**：

- 查找属性的所有订阅副作用并执行。

```js
function trigger(target, key) {
  const effects = getSubscribersForProperty(target, key);
  effects.forEach((effect) => effect());
}
```

**whenDepsChange()**：

- 将 `update` 包装为副作用函数。
- 在执行时设置为当前活跃副作用。

```js
function whenDepsChange(update) {
  const effect = () => {
    activeEffect = effect;
    update();
    activeEffect = null;
  };
  effect();
}
```

这样就创建了一个能自动跟踪依赖并在依赖变化时重新运行的**响应式副作用**。

### Vue 提供的 API

`watchEffect()`：用于创建响应式副作用，类似 `whenDepsChange()`。

`computed()`：在内部使用响应式副作用来管理失效与重新计算。

```js
import { ref, watchEffect } from "vue";

const A0 = ref(0);
const A1 = ref(1);
const A2 = ref();

watchEffect(() => {
  // 追踪 A0 和 A1
  A2.value = A0.value + A1.value;
});

// 将触发副作用
A0.value = 2;
```

```js
import { ref, computed } from "vue";

const A0 = ref(0);
const A1 = ref(1);
const A2 = computed(() => A0.value + A1.value);

A0.value = 2;
```

响应式副作用常见用途：**更新 DOM**。

```js
import { ref, watchEffect } from "vue";

const count = ref(0);

watchEffect(() => {
  document.body.innerHTML = `Count is: ${count.value}`;
});

// 更新 DOM
count.value++;
```

Vue 组件的渲染更新机制：

- 每个组件实例对应一个响应式副作用。
- 保持状态与 DOM 同步。
- 内部更新方式比 `innerHTML` 更高效。

## 运行时 vs. 编译时响应性

**运行时响应性**：

- 在浏览器运行时进行追踪与触发。
- 优点：无需构建步骤，边界情况少。
- 缺点：受 JS 语法制约，需要 ref 容器。

**编译时响应性**（如 Svelte）：

- 编译时分析与转换，改变 JS 语义。
- 优点：绕过语法限制。
- 缺点：需构建步骤，本质是“新语言”。

## 响应性调试

## 组件调试钩子

- `onRenderTracked`：查看哪些依赖被使用。
- `onRenderTriggered`：确定哪个依赖触发更新。
- 仅在开发模式下工作。

这些钩子都会收到一个调试事件，其中包含了触发相关事件的依赖的信息。推荐在回调中放置一个 `debugger` 语句，可以在开发者工具中交互式地查看依赖

### 计算属性调试

`computed()` 第二个参数，是一个包含了 `onTrack` 和 `onTrigger` 两个回调函数的对象

- `onTrack`：依赖被跟踪时调用。
- `onTrigger`：依赖变更触发时调用。

这两个回调都会作为组件调试的钩子，接受相同格式的调试事件

仅在开发模式下工作。

### 侦听器调试

与 `computed()` 类似，支持 `onTrack` 和 `onTrigger`。

仅在开发模式下工作。

## 与外部状态系统集成

Vue 响应性基于**深度转换对象**。与外部状态管理集成时，应避免深度转换。

方法：使用 `shallowRef`，仅 `.value` 是响应式的。

### 不可变数据

用于撤销/重做等功能。Vue 可变响应性在大状态树下性能差。

解决方案：使用 不可变数据结构。

推荐工具：Immer+ Vue。

```js
import { produce } from "immer";
import { shallowRef } from "vue";

export function useImmer(baseState) {
  const state = shallowRef(baseState);
  const update = (updater) => {
    state.value = produce(state.value, updater);
  };

  return [state, update];
}
```

### 状态机

**状态机**：描述应用所有状态及其转换方式。适合复杂状态流管理。

```js
import { createMachine, interpret } from "xstate";
import { shallowRef } from "vue";

export function useMachine(options) {
  const machine = createMachine(options);
  const state = shallowRef(machine.initialState);
  const service = interpret(machine)
    .onTransition((newState) => (state.value = newState))
    .start();
  const send = (event) => service.send(event);

  return [state, send];
}
```

## 与信号 (signal) 的联系

许多框架引入了与 Vue `ref` 类似的 **信号**。

**本质**：信号与 ref 相同，都是依赖跟踪 + 副作用触发的值容器。

Vue 选项式 API 和 React MobX 也是同一原理，只是隐藏在对象属性背后。

现今信号常与细粒度订阅和更新模型讨论。

Vue 使用虚拟 DOM，并依靠编译器实现优化。
