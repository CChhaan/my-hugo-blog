---
# 文章标题
title: 1.4节 提升
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 声明提升，变量提升，函数提升，暂时性死区，重复声明覆盖，块级函数声明
# 发表日期
date: 2025-06-02
summary: 本节详细介绍了 JavaScript 中变量和函数声明的提升机制，包括提升的本质、分类、优先级、特殊情况及注意事项。通过学习这些内容，读者可以更好地理解 JavaScript 代码的执行顺序和作用域规则。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
---

## 变量和函数声明的提升机制

1. **提升的本质**：
   引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。
2. **本质**：并非字面意义的 “代码移动”，而是引擎在编译时将声明信息存入作用域的 “标识符表”，执行时优先从表中查找，而非按代码顺序。

3. **作用域范围**：每个作用域（全局、函数、块作用域）都会独立进行提升操作。
4. `let`/`const`并非 “不提升”，而是提升后进入 “暂时性死区”（从作用域顶部到声明语句之间的区域），禁止访问，避免`var`的 “声明前使用为`undefined`” 的反直觉行为。

## 函数声明与变量声明的提升优先级

1. 函数声明优先：
   - **规则 1**：函数声明先提升（完整提升：声明 + 函数体），变量声明后提升（仅声明，重复声明会被忽略）；
   - **规则 2**：若变量后续有赋值操作，赋值会覆盖函数声明（执行阶段生效）。
2. 函数表达式不提升：
   - 函数表达式（如`var fn = function() {}`）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到`undefined`。
   - 具名函数表达式（如`var fn = function named() {}`）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。

## 特殊情况与注意事项

### 重复声明的覆盖：

- 变量重复声明（如`var a = 1; var a = 2`）会被忽略前序，保留最后一次赋值；
- 函数重复声明（如`function a() {}; function a() {}`）后序声明会覆盖前序。
- 变量赋值（执行阶段）会覆盖函数声明（编译阶段提升），但函数声明不会覆盖变量赋值；

### 块级函数声明的问题：

ES6 前无块级作用域，函数在块内（如`if`/`for`）声明时，不同 JS 环境（浏览器 / Node.js）处理差异极大，易导致逻辑混乱：

- **非严格模式**：部分浏览器（如 Chrome）会将块内函数声明提升到**所在函数 / 全局作用域顶部**（而非块级）；
- **严格模式**：块内函数声明被限制在块级作用域内（类似`let`），但仍不推荐使用；
- **最佳实践**：**避免在块内声明函数**，如需在块内定义函数，用函数表达式（如`if (true) { const fn = function() {}; }`），行为更可控。
