---
# 文章标题
title: 2.2节 对象
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 对象，对象拷贝，属性描述符，对象不变性，对象遍历，内置对象
# 发表日期
date: 2025-06-11
summary: 本节详细介绍了 JavaScript 对象的定义形式、分类、属性访问方式、数组特性、对象复制等内容，帮助读者更好地理解和使用 JavaScript 对象。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 对象
  - 类型系统
  - 数组
  - 前端开发
---

## 对象定义形式

1. **声明文字形式**：`{ key1: value1, key2: value2 }`
   - 可一次性定义多个键值对，简洁高效
2. **构造形式**：`new Object()`
   - 需逐个添加属性（`obj.key = value`）
   - 与文字形式生成的对象功能一致

## JS 主要类型与对象子类型

### 六种主要类型

- 基本类型：`string`、`number`、`boolean`、`null`、`undefined`
- 复杂类型：`object`（所有对象的基类）

### 特殊对象子类型

- **函数**：可调用的对象，一等公民（可像普通对象操作）
- **数组**：有序数值下标存储的对象，含额外数组方法
- **内置对象**（构造函数）：`String`、`Number`、`Boolean`、`Object`、`Function`、`Array`、`Date`、`RegExp`、`Error`
  - 可构造对应子类型对象（如 `new Array()`）
  - 语言会自动将字面量转换为内置对象（无需显式创建）

### 特殊说明

- `null`/`undefined`：无构造形式，仅字面量
- `Date`：仅有构造形式（`new Date()`），无字面量
- `Object`/`Array`/`Function`/`RegExp`：文字形式与构造形式均为对象，构造形式仅在需要额外选项时使用
- `Error`：通常在抛出异常时自动创建，也可显式构造（`new Error()`）

## 对象内容与属性访问

### 属性本质

- 对象内容由**属性**（键值对）组成，存储的是属性名（指向值的指针）
- 属性名永远是字符串，非字符串类型会自动转换为字符串

### 属性访问方式

- **. 语法（属性访问）**：`obj.key`，要求属性名符合标识符规范
- **[""] 语法（键访问）**：`obj["key"]`，支持任意 UTF-8/Unicode 字符串作为属性名，可动态构造键名

### 可计算属性名

- 文字形式中用 `[]` 包裹表达式作为属性名：`{ [expr]: value }`

### 符号（Symbol）

- 新基础类型，值不透明且唯一，通常作为属性名避免冲突
- 实际值在不同引擎中可能不同，一般使用其名称

### 属性与方法

- 函数不属于对象，属性访问返回的函数与普通函数无区别（非“方法”）
- 本质是对函数对象的引用

## 数组特性

- 支持 `[]` 访问，期望数值下标（非负整数）
- 是特殊对象，可添加命名属性（不影响 `length`）
- 建议：对象存键值对，数组存下标值对
- 若属性名类似数字，会自动转为数值下标

## 对象复制

### 深拷贝（复制所有层级，嵌套对象独立）

| 方法                           | 语法示例                                            | 适用场景与局限                                                            |
| ------------------------------ | --------------------------------------------------- | ------------------------------------------------------------------------- |
| `JSON.parse(JSON.stringify())` | `const newObj = JSON.parse(JSON.stringify(oldObj))` | 仅支持 “JSON 安全对象”（无函数、`undefined`、`Symbol`等），无法复制原型链 |
| 第三方库（如 Lodash）          | `_.cloneDeep(oldObj)`                               | 支持所有类型，深拷贝彻底，需引入库                                        |
| 手动递归                       | 自定义递归函数遍历所有属性                          | 灵活可控，需处理循环引用（如`obj.self = obj`）                            |

- JSON 深拷贝的局限：
  - 忽略`undefined`、`function`、`Symbol`属性；
  - 无法复制循环引用（如`const obj = {}; obj.self = obj;`会报错）；
  - 日期对象会转为字符串（如`new Date()` → `"2024-05-20T00:00:00.000Z"`）。

### 浅拷贝（仅复制顶层属性，嵌套对象共享引用）

| 方法                      | 语法示例                            | 特点与局限                               |
| ------------------------- | ----------------------------------- | ---------------------------------------- |
| `Object.assign()`         | `Object.assign(target, ...sources)` | 复制可枚举自有属性，覆盖同名属性，浅拷贝 |
| 扩展运算符（...）         | `const newObj = { ...oldObj }`      | 同`Object.assign()`，语法更简洁，浅拷贝  |
| `Array.prototype.slice()` | `const newArr = arr.slice()`        | 数组专用，浅拷贝，返回新数组             |

## 属性描述符

### 定义方式

- 普通属性默认使用默认描述符
- `Object.defineProperty(obj, prop, descriptor)`：添加/修改属性并设置特性

### 数据描述符

- `writable`：是否可修改属性值（`true`/`false`）
- `configurable`：是否可修改描述符/删除属性（`true`/`false`，`false` 为单向操作）
  - 即使 `configurable: false`，可将 `writable: true` 改为 `false`，反之不行
- `enumerable`：是否可被枚举（`for-in` 等，`true`/`false`）
- `value`：属性值

### 访问描述符

- `get`：获取属性值时调用的函数
- `set`：设置属性值时调用的函数
- 注：访问描述符忽略 `value` 和 `writable`

### [[Get]] 与 [[Put]] 操作

- [[Get]]：查找属性，未找到返回 `undefined`（与变量未声明报错不同）
- [[Put]]：设置属性值，检查访问描述符/`writable` 状态

## 对象不变性

| 方法                         | 特性                                                                                  |
| ---------------------------- | ------------------------------------------------------------------------------------- |
| 对象常量                     | `writable: false` + `configurable: false`，不可修改/重定义/删除                       |
| `Object.preventExtensions()` | 禁止添加新属性，保留已有属性                                                          |
| `Object.seal()`              | 调用 `preventExtensions()` + 所有属性 `configurable: false`，不可添加/删除/重定义属性 |
| `Object.freeze()`            | 调用 `seal()` + 所有数据属性 `writable: false`，最高级不可变性                        |

- 以上均为**浅不变性**，不影响引用对象的内部内容

## 属性存在性检查

| 方法                              | 作用                                       |
| --------------------------------- | ------------------------------------------ |
| `in` 操作符                       | 检查属性是否在对象及其原型链中             |
| `obj.hasOwnProperty(prop)`        | 仅检查属性是否在对象本身（不含原型链）     |
| `obj.propertyIsEnumerable(prop)`  | 检查属性是否为对象自有且可枚举             |
| `Object.keys(obj)`                | 返回对象所有可枚举自有属性数组             |
| `Object.getOwnPropertyNames(obj)` | 返回对象所有自有属性数组（无论是否可枚举） |

## 遍历方式

### for...in 循环

- 遍历对象可枚举属性（含原型链），顺序不确定

### 数组遍历

- 标准 for 循环：`for (let i=0; i<arr.length; i++)`
- ES5 辅助迭代器：
  - `forEach()`：遍历所有值，忽略回调返回值
  - `every()`：回调返回 `false` 时终止
  - `some()`：回调返回 `true` 时终止

### for...of 循环（ES6+）

- 遍历可迭代对象，先请求迭代器（`@@iterator`），调用其 `next()` 方法
- 迭代器返回 `{ value: ..., done: ... }`，`done` 为 `true` 时终止
- 可自定义对象的 `@@iterator` 实现遍历逻辑
