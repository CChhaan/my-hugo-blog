---
# 文章标题
title: 2.2节 对象
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 对象，对象拷贝，属性描述符，对象不变性，对象遍历，内置对象
# 发表日期
date: 2025-06-11
summary: 本节详细介绍了 JavaScript 对象的定义形式、分类、属性访问方式、数组特性、对象复制等内容，帮助读者更好地理解和使用 JavaScript 对象。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
---

## 语法

对象可以通过两种形式定义：声明文字形式和构造形式。

两种形式生成的对象是一样的。唯一的区别是文字声明中可以**添加多个键值对**，但是构造形式中必须**逐个添加属性**。

## 类型

在 JavaScript 中共有六种主要类型：`string`、`number`、`boolean`、`null`、`undefined`、`object`

简单基本类型本身并不是对象。

存在一些特殊的对象子类型，可称为**复杂基本类型**：

- **函数**：对象的一个子类型，是**可调用的对象**，是 JavaScript 中的**一等公民**，可以像对象一样被操作、作为参数传递。
- **数组**：对象的一种类型，具有更结构化的值存储方式，内容的组织方式比一般对象更复杂。

### 内置对象

常见的内置对象包括：`String`、`Number`、`Boolean`、`Object`、`Function`、`Array`、`Date`、`RegExp`、`Error`

这些内置函数可作为**构造函数**使用，构造对应子类型的新对象。

语言会在必要时**自动装箱**（将字面量转换为对象），无需显式创建。

`null` 和 `undefined`**只有文字形式**；`Date`**只有构造形式**。

对于 `Object`、`Array`、`Function`、`RegExp`，无论使用文字形式还是构造形式，都生成对象，**推荐**使用文字形式，仅在需要额外选项时使用构造形式。

`Error` 对象通常在**抛出异常时自动创建**，很少显式使用 `new Error()`。

## 内容

对象的内容由**属性**组成，每个属性存储一个值。属性名称像“指针”一样指向值的存储位置。

访问语法：

- **点操作符（.）**：属性访问；
- **方括号（[]）**：键访问

`.` 要求属性名符合标识符命名规范；`[]` 可以接受任意 UTF-8 / Unicode 字符串；

`[]` 可在程序中**动态构造属性名**。

在对象中，属性名**永远是字符串**，若使用非字符串值作为属性名，会先被**转换为字符串**。

### 可计算属性名

可在对象文字形式中使用方括号包裹表达式作为属性名。

**符号**：一种新的基础数据类型，值是不可预测、引擎间不同的，通常只接触到符号名称，而非其真实值。

### 属性与方法

从技术角度看，**函数不属于对象**。若属性访问返回函数，该函数仍是普通函数，即使在对象字面量中声明函数，也只是**对同一函数对象的引用**。

### 数组

数组支持 `[]` 访问形式；使用**数值下标（索引）**访问；

数组也是对象，可以添加属性，添加命名属性不会改变 `length`

最好使用对象来存储键值对，只用数组来存储数值下标值对。

若属性名看起来像数字，会自动变为数值下标。

### 复制对象

浅拷贝：新对象复制旧对象中的值；若属性引用对象，仍指向同一引用。

JSON 安全的对象可以通过下面的方法实现深拷贝：

```js
var newObj = JSON.parse(JSON.stringify(someObj));
```

ES6：`Object.assign()`：

- 第一个参数是目标对象，后续参数为源对象。
- 浅复制**可枚举的自有键**，返回目标对象。
- 属性特性（如 writable）不会被复制。

### 属性描述符

默认创建属性时使用**默认描述符值**。可用 `Object.defineProperty()` 设置或修改属性特性。

关键特性：

- **writable**：是否可修改属性值。

- **configurable**：

  - 若为 `false`，不可重新定义或删除；

  - 可将 writable 从 true 改为 false，但不可反向；

  - 修改 `configurable:false` 为单向操作。

- **enumerable**：

  - 控制属性是否出现在枚举中；

  - 默认：`enumerable:true`；

  - 即使不可枚举，仍可正常访问。

### 不变性

浅不变性：所有不变操作只影响**对象本身与其直接属性**，若引用其他对象，其内容仍可变。

对象不变方式：

- **对象常量**：`writable:false` + `configurable:false`

- **禁止扩展**：`Object.preventExtensions()` — 禁止添加新属性。

- **密封（sealed）**：`Object.seal()` — 禁止扩展且所有属性 `configurable:false`。

- **冻结（frozen）**：`Object.freeze()` — 禁止扩展且所有数据属性 `writable:false`。

### [[Get]]

查找属性名：若存在，返回值；若不存在，沿 [[Prototype]] 链查找；若未找到，返回 `undefined`。

与变量访问不同：变量不存在，抛出引用错误；属性不存在，返回 `undefined`。

**注意**：无法通过返回值判断属性是否存在或值为 undefined。

### [[Put]]

当属性已存在：

- 若为访问描述符且有 setter → 调用 setter；
- 若 writable 为 false：非严格模式，静默失败；严格模式，抛出类型异常；
- 否则 → 设置属性值。

当属性不存在时，操作更复杂。

### Getter 和 Setter

ES5 可通过 **getter/setter** 改写默认操作，getter 在取值时调用，setter 在赋值时调用。

定义后，该属性为**访问描述符**，忽略 `value` 和 `writable`。

getter/setter 通常成对出现，可用对象字面量或 `defineProperty` 定义。

### 存在性

`in`：检查属性是否在对象或其原型链中。

`hasOwnProperty()`：仅检查对象自身。

`propertyIsEnumerable()`：检查属性是否自有且 `enumerable:true`。

`Object.keys()`：返回所有可枚举属性数组。

`Object.getOwnPropertyNames()`：返回所有自有属性（包括不可枚举）。

`in` 与 `hasOwnProperty()`：区别在于是否查原型链。

`Object.keys()` 与 `Object.getOwnPropertyNames()`：只查自身属性。

## 遍历

`for...in`：遍历对象可枚举属性（包含原型链）。遍历顺序不确定，不同引擎可能不同。

数组：

- 标准 `for`：遍历数值索引；
- ES5 辅助迭代器：
  - `forEach`：遍历所有值；
  - `every`：直到回调返回 false；
  - `some`：直到回调返回 true；

every 和 some 中特殊的返回值和普通 for 循环中 break 语句类似，会提前终止遍历。

for of 循环首先会请求被访问对象的 **迭代器对象**，然后通过迭代器的 `next()` 方法遍历。调用迭代器的 next 方法返回 `{value: ..., done: ...}`；

数组自带 `@@iterator`；可为任意对象自定义不可枚举的 `@@iterator`。
