---
# 文章标题
title: 1.4节 作用域闭包
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 闭包，循环闭包问题，IIFE 解决方案，let 块作用域，模块模式，ES6 模块对比
# 发表日期
date: 2025-06-02
summary: 本节详细介绍了闭包的概念、分类、循环与闭包问题、模块模式等内容，帮助读者深入理解闭包的原理和应用。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
---

## 闭包本质

**闭包**：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

无论通过何种方式将内部函数传递到所在的词法作用域之外，它都会持有对**原始定义作用域的引用**。无论函数在何处执行，都会**使用闭包**。

只要将访问词法作用域的函数作为**第一类值类型**传递，就会使用闭包。只要使用了回调函数，实际上就是在使用闭包。

## 循环和闭包

在迭代内部使用 **IIFE（立即执行函数表达式）**，会为每次迭代创建一个新的作用域。延迟函数的回调可以封闭在该新的作用域中，从而在每个迭代中都能访问到**正确的变量值**。

本质上这是将一个**块转换为可被关闭的作用域**。

`for` 循环头部的 `let` 声明有特殊机制：变量在循环过程中**不只被声明一次**，**每次迭代都会重新声明**，每次新的迭代都会使用**上一个迭代结束时的值**来初始化变量。

## 模块

最常见的模块实现方式被称为 **模块暴露**。

模块模式的两个必要条件

1. 必须有**外部封闭函数**，并且该函数**至少被调用一次**；每次调用都会创建一个新的模块实例。
2. 封闭函数必须**返回至少一个内部函数**，内部函数在私有作用域中形成闭包，能够访问或修改私有状态。

模块模式可以为即将作为**公共 API 返回的对象**命名。

模块模式的两个特点：调用一个**包装了函数定义的包装函数**；将**返回值作为模块的 API**。

### 未来的模块机制

基于函数的模块**无法被静态识别**，编译器不能识别其 API 语义，只有在运行时，模块的 API 才能被解析，因此，模块的 API 可在运行时**动态修改**。

ES6 模块的特征：**API 是静态的**，不会在运行时改变，编译器可在编译时**检查导入 API 是否存在**，若不存在，编译器会在编译期抛出**早期错误**，而非运行期错误。

**ES6 模块必须定义在独立文件中**，**一个文件就是一个模块**，浏览器或引擎内置默认模块加载器，可被重载，导入模块时，可以**同步加载模块文件**。

`import`：将模块中的一个或多个 API 导入当前作用域，并绑定到变量上；

`export`：将模块中的标识符、变量或函数导出为公共 API；可在模块定义中**多次使用**。

模块文件中的内容会被当作**包含在作用域闭包中**一样处理。
