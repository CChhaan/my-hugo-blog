---
# 文章标题
title: 1.5节 作用域闭包
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 闭包，循环闭包问题，IIFE 解决方案，let 块作用域，模块模式，ES6 模块对比
# 发表日期
date: 2025-06-02
summary: 本节详细介绍了闭包的概念、分类、循环与闭包问题、模块模式等内容，帮助读者深入理解闭包的原理和应用。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - 闭包
  - 模块模式
  - 前端开发
---

## 闭包的核心定义与本质

1. **定义**：即使函数在词法作用域之外执行，仍能通过闭包访问原作用域的变量，且原作用域不会被垃圾回收机制销毁。
2. **底层逻辑**：函数创建时会记录其词法作用域（作用域链），当函数被传递到词法作用域之外执行时，引擎会通过函数的 “[[Scope]]” 内部属性，持续引用原作用域，阻止其被回收；
3. **常见场景**：只要使用回调函数（如定时器、事件监听器、Ajax 请求、异步任务等），本质都是在利用闭包。

## 循环与闭包：解决变量共享问题

### 循环变量共享的痛点（`var` 声明）

用 `var` 声明循环变量时，变量作用域为全局 / 函数级（非块级），所有迭代的回调函数共享同一个变量，导致执行时获取的是变量最终值（而非迭代时的值）：

```js
// 问题代码：输出 5、5、5、5（而非 1、2、3、4）
for (var i = 1; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```

### 解决方案

1. IIFE（立即执行函数表达式）

通过 IIFE 为每个迭代创建**独立的词法作用域**，将当前迭代的 `i` 作为参数传入，使回调函数闭包捕获该作用域的变量：

```js
// 正确输出 1、2、3、4
for (var i = 1; i < 5; i++) {
  (function (j) {
    // j 是每个迭代的独立变量
    setTimeout(function () {
      console.log(j);
    }, j * 1000);
  })(i); // 立即执行，传入当前 i 的值
}
```

2. `let` 声明的特殊行为

`let` 支持**块级作用域**，且在 `for` 循环头部声明时，会为**每个迭代单独创建变量实例**（每次迭代用前一次迭代的变量值初始化），无需额外闭包即可解决共享问题：

```js
// 正确输出 1、2、3、4
for (let i = 1; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```

`let` 解决该问题的本质是 “块作用域 + 迭代变量独立实例”，而非闭包，但底层仍依赖作用域机制（可理解为引擎自动为每个迭代创建了闭包）。

## 模块模式：基于闭包的封装

### 模块模式的核心条件

需满足两个必要条件，本质是利用闭包实现 “私有状态 + 公共 API” 的封装：

- 有**外部封闭函数**：该函数至少被调用一次，每次调用生成一个新的模块实例（独立的私有作用域）；
- **返回内部函数 / 对象**：内部函数形成闭包，可访问外部函数的私有状态，同时作为公共 API 暴露（外部通过 API 操作私有状态，无法直接访问私有变量）。

- **核心价值**：私有状态无法被外部直接修改（只能通过公共 API 操作），实现 “信息隐藏” 和 “最小特权原则”。

### ES6 模块与函数模块的区别

ES6 模块虽也基于闭包逻辑（模块内容如同在闭包中处理），但与传统函数模块有关键差异：

| 对比维度        | 传统函数模块（基于闭包）                  | ES6 模块（基于文件作用域）                   |
| --------------- | ----------------------------------------- | -------------------------------------------- |
| API 特性        | 动态 API（运行时可修改暴露的方法 / 属性） | 静态 API（编译期确定，不可动态修改）         |
| 实例化方式      | 手动调用工厂函数（如 `createCounter()`）  | 自动实例化（每个文件是单例，加载即实例化）   |
| 作用域隔离      | 每个实例独立作用域（私有状态不共享）      | 每个文件独立作用域（模块是单例，状态共享）   |
| 暴露 / 导入方式 | 返回对象暴露 API（需手动维护）            | `export` 暴露、`import` 导入（引擎自动处理） |
| 错误检查        | 运行时检查（调用不存在的 API 才报错）     | 编译期检查（导入不存在的 API 直接报错）      |
