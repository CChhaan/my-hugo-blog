---
# 文章标题
title: 2.5节 行为委托和class
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 对象关联风格，class 语法，super 关键字，原型链委托，对象组织模式
# 发表日期
date: 2025-06-14
summary: 本节详细介绍了对象关联风格的核心特性与设计原则，包括状态存储原则、方法命名原则、委托本质、委托限制和思维模型与灵活性。同时，还介绍了 class 语法特点，包括多态实现、声明限制、扩展能力和本质与局限性。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
---

## 对象关联风格的核心特性与设计原则

### 状态存储原则

- **核心规则**：状态（数据属性）应保存在**委托者对象**上，而非委托目标（原型链上层对象）。
  - 避免委托目标状态被多个委托者共享，导致数据污染或不可预期的修改。

### 方法命名原则

- **核心规则**：尽量避免在 [[Prototype]] 链不同级别使用**相同命名的方法**（与类风格的“重写”逻辑相反）。
  - 设计建议：使用**描述性方法名**（需体现对象行为类型），降低命名冲突风险，提升代码可理解性与可维护性。

### 委托本质

- 委托行为的核心：当对象自身找不到属性/方法时，会将请求**委托给 [[Prototype]] 关联的对象**（沿原型链向上查找）。

### 委托限制

- 禁止**循环委托**：无法在两个及以上对象间创建互相委托（如 A 关联 B、B 关联 A），会触发错误。

### 思维模型与灵活性

| 维度             | 特点                                                                       |
| ---------------- | -------------------------------------------------------------------------- |
| 思维模型         | 仅关注**对象之间的关联关系**，不强调实体及实体间的层级（如父类-子类）      |
| 创建与初始化分离 | 支持“创建对象”与“初始化状态”分步执行，更符合关注分离原则，灵活性更高       |
| 对比类风格       | 类风格通常强制“构造+初始化”合并为一步（如 `new` 调用构造函数时同步初始化） |

## class 语法特点（ES6+）

### 多态实现

- 支持通过 `super()` 实现**相对多态**：子类方法可通过 `super` 引用原型链上层的同名方法（模拟类继承中的“调用父类方法”）。

### 声明限制

- **仅能声明方法**：class 字面量语法中，无法直接声明数据属性（需在构造函数 `constructor` 中通过 `this.属性名` 定义）。
  - 示例：`class A { foo() {}; // 允许；bar = 1; // 类字段语法（ESNext，非标准字面量声明） }`

### 扩展能力

- 支持通过 `extends` 关键字**自然扩展对象类型**，包括内置对象类型（如 `class MyArray extends Array {}`），模拟类继承的“子类扩展父类”逻辑。

### 本质与局限性

| 维度             | 特点                                                                                                               |
| ---------------- | ------------------------------------------------------------------------------------------------------------------ |
| 本质             | 是 [[Prototype]] 机制的**语法糖**，并非真正实现面向类语言的“类”（无类实例化复制、无类级别的类型约束）              |
| `super` 绑定方式 | **静态绑定**：`super` 指向的原型链上层对象在 class 定义时确定，无法动态修改（与类风格的动态关联不同）              |
| 动态修改难度     | class 定义后，难以对其原型链、方法等进行动态调整（如修改 `prototype` 指向、新增/删除方法），灵活性低于原生对象关联 |
