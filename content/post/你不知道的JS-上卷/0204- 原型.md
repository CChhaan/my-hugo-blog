---
# 文章标题
title: 2.4节 原型
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript [[Prototype]], 原型链，Object.prototype, 属性屏蔽，原型关联，instanceof, JavaScript 对象关联风格，class 语法，super 关键字，原型链委托，对象组织模式
# 发表日期
date: 2025-06-14
summary: 本节详细介绍了 JavaScript 中原型链的概念和原理，包括原型链的构建、原型链的查找过程、原型链的终点以及属性设置与屏蔽等内容。同时，还介绍了对象关联风格的核心特性与设计原则，包括状态存储原则、方法命名原则、委托本质、委托限制和思维模型与灵活性，介绍了 class 语法特点，包括多态实现、声明限制、扩展能力和本质与局限性。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
---

## [[Prototype]]

对象具有特殊的 **[[Prototype]] 内置属性**，用于引用其他对象。

大多数对象在创建时，**[[Prototype]] 会被赋值为非空对象**。

对象的 [[Prototype]] 可以为空，但较少见。

当访问对象属性时，会触发 **[[Get]]** 操作。

1. 首先检查对象本身是否存在该属性。

2. 若不存在，则继续查找对象的 **[[Prototype]] 链**。

3. 查找会持续到：找到匹配属性名，或遍历完整条原型链仍未找到，此时返回 **undefined**。

`for...in`：遍历可枚举属性，包括来自原型链的属性。

`in` 操作符：检查对象及其原型链上是否存在某属性（无论是否可枚举）。

### Object.prototype

所有普通的 prototype 链最终指向 **Object.prototype**。

**Object.prototype** 包含 JavaScript 中许多通用功能。

### 属性设置和屏蔽

`myObject.foo = 'bar'`

**若 foo 在当前对象中：**直接修改已有属性值。

**若 foo 不在当前对象中：**查找原型链：

- 若找不到 foo：在当前对象上创建新属性。
- 若在原型链找到 foo：可能发生“屏蔽”。当对象自身具有某属性时，它会 **屏蔽原型链中的同名属性**。

三种赋值行为的结果：

- **原型链上 foo 是可写的数据属性：**在当前对象上创建同名新属性，实现屏蔽。
- **原型链上 foo 是只读属性：**无法修改原型链中属性，无法在当前对象创建屏蔽属性，严格模式下抛错，非严格模式下忽略。
- **原型链上 foo 是 setter：**调用 setter，不创建屏蔽属性。

若想在情况 2 和 3 中也进行屏蔽，需使用 **Object.defineProperty** 创建属性。

## 类

在 JS 中，类无法描述对象行为，因为 **根本不存在类**。

对象直接定义自己的行为，JS 中只有对象。

### 类函数

所有函数默认拥有一个 **prototype** 属性，指向一个对象（函数原型）。

使用 `new` 调用函数创建对象时，这些对象会将其 **[[Prototype]] 关联到该函数的 prototype**。

传统面向类语言：类 → 实例 **复制行为**。

JavaScript：对象关联，不产生复制，多对象共享同一原型对象。

`new` 调用函数会：生成新对象，将新对象的 **[[Prototype]] 关联到函数的 prototype**。

JS 中并不存在“初始化一个类”的过程。 JS 中通过关联机制实现 **原型继承 / 差异继承 / 委托**。

### 构造函数

`.prototype` 默认包含一个不可枚举的 `constructor` 属性，指向函数本身。使用 `new` 创建的对象也带有 `.constructor`，指回创建它的函数。

函数本身不是构造函数，**只有用 `new` 调用时才成为构造函数调用**。

若替换了 `.prototype`，新对象不会自动获得 `.constructor`。`.constructor` 可修改、可重新赋值。

## 继承

**Object.create(obj)**：创建新对象并让其 [[Prototype]] 指向给定对象。

**Object.setPrototypeOf(obj, proto)** ：修改已有对象的 [[Prototype]]。

**instanceof**：检查右侧函数的 `.prototype` 是否出现在左侧对象的原型链上。

**obj.isPrototypeOf(target)** ：检查对象是否出现在目标对象的原型链中。

**Object.getPrototypeOf(obj)** ：直接获取对象的 [[Prototype]]。

**\_\_proto\_\_（非标准）**：getter/setter 属性，用于访问内部 [[Prototype]]。

## 对象关联

原型链定义：一系列通过 [[Prototype]] 关联的对象称为 **原型链**。

Object.create 的优势：创建对象并指定原型。避免使用 new 引入不必要的 `.prototype` 和 `.constructor`。

空原型对象：**Object.create(null)** 创建无原型对象，无原型链、无类型判断支持（instanceof 返回 false），常用于“字典对象”。

## 行为委托

特点：

- 保持状态在委托者，而非委托目标。
- 避免在原型链不同层级使用相同方法名，否则会产生引用歧义。
- 推荐使用更具描述性的名称。

委托行为意味着某些对象在找不到属性或者方法引用时，会把这个请求委托给另一个对象。

限制：无法创建循环委托（互相作为 [[Prototype]] 时会报错）。

优势：

- 强调对象之间的关联关系，而非类结构。
- 创建与初始化可分离，更灵活。

## ES6 中的 class

特性：

- 通过 `super` 使用原型链上层的同名方法。
- class 语法只能声明方法，不能声明属性。
- 可以使用 `extends` 扩展对象子类型（包括内置类型）。
- **class 是现有 [[Prototype]] 机制的语法糖**。
- `super` 是静态绑定的，而非动态绑定。
