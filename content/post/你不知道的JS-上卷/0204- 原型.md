---
# 文章标题
title: 2.4节 原型
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript [[Prototype]], 原型链，Object.prototype, 属性屏蔽，原型关联，instanceof
# 发表日期
date: 2025-06-14
summary: 本节详细介绍了 JavaScript 中原型链的概念和原理，包括原型链的构建、原型链的查找过程、原型链的终点以及属性设置与屏蔽等内容。
# 分类
categories:
  - 你不知道的JS
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 对象
  - 原型链
  - 前端开发
---

## [[Prototype]] 基础

- **定义**：对象的特殊内置属性，本质是对其他对象的引用
- **默认值**：几乎所有对象创建时，[[Prototype]] 都会被赋予非空值
- **[[Get]] 操作逻辑**（属性查找）：
  1. 优先检查对象本身是否有目标属性，有则使用；
  2. 若无，沿 [[Prototype]] 链向上查找；
  3. 直至找到属性或遍历完整条原型链，未找到则返回 `undefined`

## 原型链终点：Object.prototype

- **地位**：所有普通对象的 [[Prototype]] 链最终都会指向 `Object.prototype`
- **作用**：包含 JS 通用功能（如 `toString()`、`hasOwnProperty()` 等），供所有普通对象继承
- #### 核心通用方法

  | 方法                  | 作用                                            | 示例                                                |
  | --------------------- | ----------------------------------------------- | --------------------------------------------------- |
  | `toString()`          | 返回对象的字符串表示（默认`"[object Object]"`） | `({}).toString() → "[object Object]"`               |
  | `hasOwnProperty(key)` | 检查属性是否为对象**自身所有**（不含原型链）    | `cat.hasOwnProperty("eat") → false`（eat 在原型上） |
  | `isPrototypeOf(obj)`  | 检查当前对象是否在`obj`的原型链上               | `animal.isPrototypeOf(cat) → true`                  |
  | `valueOf()`           | 返回对象的原始值（默认返回对象本身）            | `(new Number(123)).valueOf() → 123`                 |

## 属性设置与屏蔽（`myObject.foo = 'bar'`）

### 基础逻辑

- 若 `myObject` 本身有 `foo` 普通数据属性：仅修改属性值；
- 若 `foo` 不在 `myObject` 中：沿 [[Prototype]] 链查找，未找到则直接在 `myObject` 上添加 `foo`；
- 若 `foo` 既在 `myObject` 中，也在原型链上层：`myObject` 的 `foo` 屏蔽原型链上层的 `foo`（优先取最底层属性）。

### 特殊场景（`foo` 在原型链上层）

| 原型链上层 `foo` 特性             | 结果                                                                 |
| --------------------------------- | -------------------------------------------------------------------- |
| 普通数据属性（非只读）            | 在 `myObject` 上添加 `foo` 屏蔽属性                                  |
| 只读数据属性（`writable: false`） | 非严格模式：忽略赋值；严格模式：报错（无法添加屏蔽属性或修改原属性） |
| 访问描述符（含 `setter`）         | 调用 `setter`，不向 `myObject` 添加 `foo`，也不重定义 `setter`       |

### 强制屏蔽

- 上述特殊场景中，需用 `Object.defineProperty(myObject, 'foo', { ... })` 向 `myObject` 显式添加 `foo` 以实现屏蔽。

## JS 中的“类”与原型关联

### 核心结论

- JS 中**无真正的类**，只有对象；对象直接定义行为，不通过类描述。

### “类”函数与 prototype 属性

- 所有函数默认有公有、不可枚举的 `prototype` 属性，指向该函数的“原型对象”；
- `new Xxx()` 创建的对象，其 [[Prototype]] 会关联到 `Xxx.prototype`；
- 关键差异：JS 无“类实例化复制”机制，多个 `new Xxx()` 创建的对象，仅 [[Prototype]] 关联同一 `Xxx.prototype`，对象间无复制关系（仅关联）。

### `new` 操作符作用

- 劫持普通函数调用，将其转为“构造对象调用”；
- 生成新对象，使其 [[Prototype]] 关联到函数的 `prototype` 对象；
- 无“类初始化”，仅间接实现“对象关联”。

### “构造函数”本质

- 函数本身不是构造函数；
- 仅当函数调用前加 `new` 时，才成为“构造函数调用”。

### `constructor` 属性

- **默认特性**：`Xxx.prototype` 默认有公有、不可枚举的 `constructor` 属性，指向 `Xxx` 函数；
- **注意点**：
  1. 若替换函数默认的 `prototype` 对象，新对象不会自动拥有 `constructor`；
  2. `constructor` 可写（非不可变），可在原型链任意对象上修改或添加；
  3. 逻辑关系：`Xxx.prototype.constructor === Xxx`（默认情况）。

## 原型继承与关联操作

### 原型继承核心

- 本质是“对象关联”，通过 [[Prototype]] 链实现属性/方法的委托（非复制）。

### 原型关联方法

| 方法                                | 作用                                                        |
| ----------------------------------- | ----------------------------------------------------------- |
| `Object.create(obj)`                | 创建新对象，使其 [[Prototype]] 关联到 `obj`                 |
| `Object.setPrototypeOf(obj1, obj2)` | 修改 `obj1` 的 [[Prototype]]，使其关联到 `obj2`（标准方法） |

### 原型链检查（内省/反射）

| 检查方式                         | 逻辑（回答的问题）                                           | 示例                                                         |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `a instanceof Foo`               | `a` 的 [[Prototype]] 链中，是否有 `Foo.prototype` 指向的对象 | `new Foo() instanceof Foo // true`                           |
| `Foo.prototype.isPrototypeOf(a)` | `a` 的 [[Prototype]] 链中，是否出现过 `Foo.prototype`        | `Foo.prototype.isPrototypeOf(new Foo()) // true`             |
| `Object.getPrototypeOf(a)`       | 直接获取 `a` 的 [[Prototype]] 对象                           | `Object.getPrototypeOf(new Foo()) === Foo.prototype // true` |
| `a.__proto__`                    | 非标准方法（多数浏览器支持），引用 `a` 的 [[Prototype]]      | `new Foo().__proto__ === Foo.prototype // true`              |

### `__proto__` 特性

- 存在于 `Object.prototype` 中（非对象自身属性），是 getter/setter；
- 通常无需修改已有对象的 [[Prototype]]。

## 对象关联与特殊对象

### 原型链作用

- 引擎查找属性时，若当前对象无目标属性，沿 [[Prototype]] 链向上委托，直至找到或遍历结束。

### 空 [[Prototype]] 对象

- 创建方式：`Object.create(null)`；
- 特性：无 [[Prototype]] 链，不受原型干扰；
- 用途：适合作为“字典”存储数据（避免原型链属性污染）。
