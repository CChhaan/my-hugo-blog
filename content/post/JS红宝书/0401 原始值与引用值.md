---
# 文章标题
title: 4.1 原始值与引用值
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 原始值与引用值，执行上下文 (全局 / 函数), 作用域链，var/let/const 差异，typeof 与 instanceof
# 发表日期
date: 2025-01-11
summary: 本章详细介绍了 JavaScript 中原始值与引用值的概念、分类、动态属性、复制值、传递参数以及确定类型等内容，帮助读者更好地理解 JavaScript 的数据类型和操作方式。
# 分类
categories:
  - JS红宝书
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
  - 作用域
---

## 原始值与引用值

ES 变量可包含两种数据类型：原始值和引用值，二者在存储、访问、复制等行为上存在本质差异。

### 基本定义与访问方式

- **原始值**：最简单的数据，对应 ES 六大基本数据类型（Undefined、Null、Boolean、Number、String、Symbol）。  
  保存原始值的变量按**值访问**，操作的是变量中存储的实际值。
- **引用值**：由多个值构成的对象（如 Object、Array、Function 等）。  
  引用值保存在内存中，JS 无法直接操作内存空间，实际操作的是对象的**引用（地址）**，保存引用值的变量按**引用访问**。

### 动态属性

- **引用值**：可随时添加、修改、删除其属性和方法，示例：
  ```js
  let obj = {};
  obj.name = "Alice"; // 新增属性
  obj.age = 20; // 修改属性
  delete obj.age; // 删除属性
  ```
- **原始值**：不能有属性，尝试添加属性不会报错，但属性无法生效，示例：
  ```js
  let str = "hello";
  str.length = 10; // 无报错，但属性不生效
  console.log(str.length); // 仍为 5（字符串原始值的内置 length 属性不受此影响）
  ```
- **特殊初始化**：原始类型可通过原始字面量（如 `let num = 10`）初始化；若用 `new` 关键字（如 `let num = new Number(10)`），JS 会创建 `Object` 实例，但行为类似原始值。

### 复制值

- **原始值复制**：将原始值从一个变量赋给另一个变量时，原始值会被**完整复制**到新变量，两个变量独立（修改一个不影响另一个），示例：
  ```js
  let a = 10;
  let b = a; // b 复制 a 的值（10）
  b = 20;
  console.log(a); // 10（a 不受 b 修改影响）
  ```
- **引用值复制**：将引用值从一个变量赋给另一个变量时，复制的是**指向堆内存对象的指针**，两个变量指向同一个对象（修改一个会影响另一个），示例：
  ```js
  let obj1 = { name: "Bob" };
  let obj2 = obj1; // obj2 复制 obj1 的引用（指向同一对象）
  obj2.name = "Charlie";
  console.log(obj1.name); // Charlie（obj1 指向的对象被修改）
  ```

### 传递参数

ES 中所有函数的参数均按**值传递**，即函数外部的值会复制到函数内部的参数（类似变量间的复制）：

- 若参数是**原始值**：复制原始值到局部变量（命名参数/`arguments` 槽位），函数内修改参数不影响外部变量，示例：
  ```js
  function changeNum(num) {
    num = 100;
  }
  let a = 10;
  changeNum(a);
  console.log(a); // 10（外部变量未变）
  ```
- 若参数是**引用值**：复制引用（指针）到局部变量，函数内通过参数修改对象属性，会影响外部变量指向的对象（因指向同一内存），示例：
  ```js
  function changeName(obj) {
    obj.name = "Dave";
  }
  let person = { name: "Eve" };
  changeName(person);
  console.log(person.name); // Dave（外部对象被修改）
  ```

### 确定类型

- **`typeof` 运算符**：最适合判断**原始类型**，返回值包括 `"undefined"`、`"boolean"`、`"number"`、`"string"`、`"symbol"`；对引用值（除 `function` 外）均返回 `"object"`，用处有限，示例：
  ```js
  typeof 10; // "number"（原始值，正确）
  typeof {}; // "object"（引用值，正确但不精确）
  typeof function () {}; // "function"（特殊，可识别函数）
  ```
- **`instanceof` 运算符**：判断变量是否为指定引用类型的实例，语法：`result = variable instanceof constructor`，示例：
  ```js
  {} instanceof Object; // true
  [] instanceof Array; // true
  function(){} instanceof Function; // true
  ```
  注意：`instanceof` 对原始值始终返回 `false`（原始值不是对象实例）。

## 执行上下文与作用域

执行上下文决定变量/函数可访问的数据及行为，作用域则控制变量/函数的访问范围，二者共同构成 JS 的代码执行环境。

### 执行上下文基础

- **定义**：每个执行上下文关联一个**变量对象**，上下文内定义的所有变量和函数均存储在该对象上。
- **类型**：
  1. **全局上下文**：最外层上下文，浏览器中为 `window` 对象；通过 `var` 定义的全局变量/函数会成为 `window` 的属性/方法；`let`/`const` 的顶级声明不挂载到 `window`，但作用域链解析效果一致。
  2. **函数上下文**：每个函数调用对应一个独立上下文；函数执行前，上下文会被推到**上下文栈**，执行完毕后从栈中弹出，控制权返回给之前的上下文（JS 执行流通过上下文栈控制）。
- **生命周期**：上下文在所有代码执行完毕后销毁，其关联的变量/函数也随之释放。

### 作用域链

- **定义**：上下文代码执行时，会创建变量对象的**作用域链**，决定代码访问变量/函数的顺序。
- **结构**：
  - 最前端：当前执行上下文的变量对象（若为函数上下文，此对象称为**活动对象**，初始仅包含 `arguments` 对象，全局上下文无 `arguments`）。
  - 后续节点：包含上下文的变量对象（如函数嵌套时，内层函数的作用域链包含外层函数的变量对象）。
  - 最末端：全局上下文的变量对象。
- **标识符解析**：访问变量/函数时，从作用域链最前端开始搜索，找到标识符后停止；若搜索至全局上下文仍未找到，则该标识符未声明，示例：
  ```js
  let globalVar = "global";
  function outer() {
    let outerVar = "outer";
    function inner() {
      let innerVar = "inner";
      console.log(innerVar); // 从内层开始搜索，找到 "inner"
      console.log(outerVar); // 内层未找到，沿链搜索外层，找到 "outer"
      console.log(globalVar); // 外层未找到，搜索全局，找到 "global"
    }
    inner();
  }
  outer();
  ```

### 作用域链增强

常规执行上下文仅全局和函数两种，`eval` 调用有第三种；某些语句会临时在作用域链前端添加上下文，执行后删除，主要场景：

- **`try/catch` 语句的 `catch` 块**：`catch` 会创建新变量对象，包含抛出的错误对象声明，该对象仅在 `catch` 块内可访问。
- **`with` 语句**：将指定对象添加到作用域链前端，简化对象属性访问，示例：
  ```js
  let obj = { name: "Frank", age: 25 };
  with (obj) {
    console.log(name); // 等价于 console.log(obj.name)，直接访问链前端的 obj 属性
    console.log(age); // 等价于 console.log(obj.age)
  }
  ```

### 变量声明

#### `var`：函数作用域声明

- **作用域**：变量自动添加到最接近的上下文（函数内为局部上下文，`with` 内为函数上下文；未声明直接初始化的变量会自动添加到全局上下文）。
- **变量提升**：`var` 声明会被“提升”到函数/全局作用域顶部（代码执行前），允许在声明前使用变量（值为 `undefined`），示例：
  ```js
  console.log(num); // undefined（提升后未赋值）
  var num = 10;
  ```

#### `let`：块级作用域声明

- **作用域**：块级作用域由最近的 `{}` 界定（如 `if`、`for`、函数体等），变量仅在块内可访问。
- **重复声明限制**：同一作用域内不能重复声明 `let` 变量（会报错），而 `var` 重复声明会被忽略，示例：
  ```js
  let a = 10;
  let a = 20; // 报错：Identifier 'a' has already been declared
  ```
- **循环迭代变量**：`let` 声明的迭代变量不会泄露到循环外部，`var` 则会，示例：

  ```js
  for (let i = 0; i < 3; i++) {}
  console.log(i); // 报错：i is not defined（块级作用域限制）

  for (var j = 0; j < 3; j++) {}
  console.log(j); // 3（泄露到全局）
  ```

- **暂时性死区（TDZ）**：`let` 会提升，但声明前访问变量会报错（TDZ 限制），示例：
  ```js
  console.log(b); // 报错：Cannot access 'b' before initialization
  let b = 20;
  ```

#### `const`：常量声明

- **初始化要求**：`const` 声明的变量必须同时赋值，且生命周期内不能重新赋值，示例：
  ```js
  const c = 30;
  c = 40; // 报错：Assignment to constant variable
  ```
- **对象特殊性**：`const` 仅限制变量不能重新赋值为其他引用值，但对象的属性可修改；若需禁止对象属性修改，可使用 `Object.freeze()`（赋值时静默失败，不报错），示例：
  ```js
  const o = Object.freeze({ name: "Grace" });
  o.name = "Hebe"; // 静默失败，属性不修改
  console.log(o.name); // "Grace"
  ```
- **性能优化**：JS 运行时编译器可将 `const` 变量替换为实际值，减少变量查找开销。

### 标识符查找规则

- **搜索顺序**：从作用域链最前端开始，逐级向后搜索；若局部上下文找到标识符，搜索停止（局部变量屏蔽父级同名变量）；若全局上下文仍未找到，标识符未声明。
- **原型链影响**：搜索引用类型属性时，若作用域链中的对象有原型链，会同时搜索原型链（如 `obj.prop` 若 `obj` 自身无 `prop`，会搜索 `obj.__proto__`）。
- **块级作用域影响**：`let`/`const` 的块级声明不会改变搜索流程，但会给词法层级添加额外层次，限制变量访问范围。
