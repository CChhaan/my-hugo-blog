---
# 文章标题
title: 4.3 垃圾回收
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 垃圾回收 (标记清理 / 引用计数), 内存管理 (主动解除引用), V8 隐藏类优化，内存泄漏 (全局变量 / 定时器 / 闭包), 对象池 (静态分配)
# 发表日期
date: 2025-01-11
summary: 本章详细介绍了 JavaScript 的垃圾回收机制，包括垃圾回收算法、内存管理、性能优化和内存泄漏等内容。通过学习本章，读者可以更好地理解 JavaScript 的内存管理机制，并掌握如何避免内存泄漏和提高程序性能。
# 分类
categories:
  - JS红宝书
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
  - 性能优化
---

## 垃圾回收基础

JS 是**自动垃圾回收语言**，执行环境负责代码运行时的内存管理（自动分配内存、回收闲置资源）。核心逻辑是：周期性判断“不再使用的变量”，释放其占用的内存（垃圾回收程序每隔一定时间自动运行）。

## 常见垃圾回收算法

### 标记清理

当前 JS 引擎最主流的垃圾回收算法，核心步骤如下：

1. **标记阶段**：
   - 变量进入上下文（如函数内声明变量）时，标记为“存在于上下文”；
   - 变量离开上下文（如函数执行完毕）时，标记为“离开上下文”；
   - 垃圾回收程序运行时，先标记内存中所有变量。
2. **清理阶段**：
   - 移除“存在于上下文的变量”及“被其引用的变量”的标记；
   - 剩余带标记的变量=“无法被上下文访问的变量”，视为待回收；
   - 销毁待回收变量，释放其内存。

### 引用计数

早期算法，因缺陷已较少使用，核心逻辑是“通过引用次数判断变量是否可回收”：

1. **计数规则**：
   - 声明变量并赋值引用值时，该值的引用数=1；
   - 同一值被赋给其他变量，引用数+1；
   - 保存该值引用的变量被覆盖（如赋值其他值），引用数-1。
2. **回收时机**：当值的引用数=0 时，下次垃圾回收程序运行时释放其内存。
3. **核心缺陷：循环引用**  
   若对象 A 引用对象 B，对象 B 同时引用对象 A，二者引用数永远不会变为 0，导致内存无法回收（如早期 COM 对象场景）。
   - 解决方案：不再使用时，主动切断引用（如用 `null` 覆盖变量，示例：`objA = null; objB = null`）。

## 主动内存管理

优化内存占用的核心是“只保留必要数据”，关键手段如下：

1. **解除引用**  
   数据不再必要时，将其赋值为 `null`，释放引用（让垃圾回收程序可识别为待回收）。
   - 适用场景：**全局变量/全局对象属性**（局部变量超出作用域后会自动解除引用）。
   - 注意：解除引用不代表立即回收内存，仅确保值“脱离上下文”，等待下次垃圾回收。
2. **通过 `const` 和 `let` 提升性能**
   - `const`/`let` 是**块级作用域**，变量在块执行完毕后更快脱离上下文，垃圾回收程序可更早回收内存；
   - 对比 `var`（函数/全局作用域），减少内存占用时长。

## 隐藏类与性能优化（以 V8 引擎为例）

V8 引擎通过“隐藏类”跟踪对象属性特征，**共享相同隐藏类的对象性能更优**（减少属性查找开销）。

### 隐藏类的共享条件

对象需满足“相同构造函数+相同原型”，示例：

```js
function Article() {
  this.title = "Ingauration Ceremony Features Kazoo Band"; // 构造函数内声明属性
}
let a1 = new Article();
let a2 = new Article();
// a1 和 a2 共享相同隐藏类（同构造函数、同原型）
```

### 破坏隐藏类共享的行为及解决方案

- **问题行为**：动态添加/删除属性（导致对象属性特征变化，隐藏类不共享），示例：
  ```js
  a1.author = "Alice"; // 动态添加属性，a1 隐藏类改变，与 a2 不再共享
  delete a2.title; // 动态删除属性，a2 隐藏类改变，与 a1 不再共享
  ```
- **解决方案**：
  1. 构造函数中**一次性声明所有属性**（避免动态添加）；
  2. 不使用 `delete` 删除属性，改用 `null` 赋值（保留属性特征，维持隐藏类共享），示例：`a2.title = null`。

## 内存泄漏

内存泄漏指“不再使用的内存未被回收”，常见场景及避免方案：
| 泄漏场景 | 原因分析 | 避免方案 |
|-------------------|-------------------------------------------|-------------------------------------------|
| 意外声明全局变量 | 未用 `var`/`let`/`const` 声明的变量，自动挂载到全局（如 `num = 10`），全局变量不会自动回收 | 1. 所有变量用 `var`/`let`/`const` 声明；<br>2. 避免全局变量存储临时数据，使用后赋值 `null` |
| 定时器未清理 | `setTimeout`/`setInterval` 未用 `clearTimeout`/`clearInterval` 取消，回调函数及内部引用的变量持续占用内存 | 不再需要定时器时，主动调用清理方法（如 `let timer = setTimeout(...); clearTimeout(timer)`） |
| 闭包过度使用 | 闭包持续引用外部函数的变量，导致外部函数上下文无法回收（即使外部函数已执行完毕） | 1. 避免不必要的闭包；<br>2. 闭包内不再使用的变量，主动赋值 `null` 解除引用 |

## 静态分配与对象池

### 问题背景

若短时间内大量创建对象（如循环中动态创建），对象“快速创建-快速脱离作用域”会导致浏览器**频繁触发垃圾回收**，影响性能。

### 解决方案：对象池

- **核心思想**：提前创建一组可复用的对象，避免动态创建新对象，减少垃圾回收频率。
- **实现步骤**：
  1. **初始化对象池**：创建数组等结构，存储一定数量的“空白对象”（如初始化时创建 10 个空对象）；
  2. **请求对象**：应用程序需要对象时，从池中取一个空白对象，设置其属性并使用；
  3. **归还对象**：使用完毕后，重置对象属性（如赋值 `null`），将其放回池中，供下次复用。
- **注意事项**：
  - 对象池大小需提前预估（避免频繁扩容/缩容）；
  - 属于“极端优化”，仅当垃圾回收严重影响性能时使用，多数场景无需考虑（避免过早优化）。
