---
# 文章标题
title: 3.2 变量
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: JavaScript 变量声明，var/let/const 差异，流控制语句，循环语句，条件判断，暂时性死区
# 发表日期
date: 2025-01-09
summary: 本章详细介绍了 JavaScript 中变量声明与流控制语句的使用，包括 var、let、const 的核心差异、变量声明最佳实践、流控制语句的分类等。
# 分类
categories:
  - JS红宝书
# 标签
tags:
  - JavaScript
  - ECMAScript
  - 前端开发
---

## 变量声明：var、let、const 的核心差异

变量是 JS 中保存数据的命名占位符，ES 提供 `var`、`let`、`const` 三种声明方式，核心差异体现在**作用域、提升行为、可修改性**上。

### var 关键字（ES5 及之前）

- **作用域**：函数作用域（若在函数外声明则为全局作用域），无块级作用域（如 `if`/`for` 块内声明的 `var` 变量可在块外访问）。
- **初始化与类型**：
  - 可单独声明（`var a;`）或声明时赋值（`var a = 1;`）；
  - 松散类型，可后续修改值的类型（如 `a = "hello"`）。
- **变量提升**：`var` 声明的变量会自动提升到**函数作用域顶部**（仅声明提升，赋值不提升），示例：
  ```js
  console.log(a); // undefined（声明提升，赋值未提升）
  var a = 1;
  ```
- **全局变量特性**：在全局作用域声明的 `var` 变量，会成为 `window` 对象的属性（如 `var a = 1; console.log(window.a); // 1`）。
- **重复声明**：允许同一作用域内重复声明（如 `var a = 1; var a = 2;` 不报错，后者覆盖前者）。
- **函数内声明**：
  - 函数内用 `var` 声明的变量为局部变量（函数退出时销毁）；
  - 省略 `var` 则为全局变量（不推荐，易污染全局作用域）。
- **严格模式限制**：不可声明名为 `arguments` 或 `eval` 的变量。

### let 声明（ES6+）

- **作用域**：块级作用域（`{}` 包裹的区域，如 `if`、`for`、函数块），块外无法访问。
- **重复声明**：同一作用域内不允许重复声明（如 `let a = 1; let a = 2;` 报错），且与 `var` 混用时也报错（`var a = 1; let a = 2;` 报错）。
- **暂时性死区（TDZ）**：`let` 声明的变量**无变量提升**，在声明语句之前的区域称为“暂时性死区”，引用变量会报错：
  ```js
  console.log(a); // 报错（暂时性死区）
  let a = 1;
  ```
- **全局变量特性**：全局作用域声明的 `let` 变量，不会成为 `window` 对象的属性（如 `let a = 1; console.log(window.a); // undefined`），但仍在全局作用域存续。
- **for 循环特殊行为**：`let` 声明的迭代变量（如 `for (let i = 0; i < 3; i++)`），JS 引擎会为**每个迭代循环创建独立的变量实例**，解决 `var` 迭代变量共享的问题（如定时器回调能获取正确的迭代值）。

### const 声明（ES6+）

- **作用域与提升**：与 `let` 一致（块级作用域、无提升、有暂时性死区、不重复声明）。
- **初始化要求**：声明时**必须同时赋值**（如 `const a = 1;` 合法，`const a;` 报错）。
- **可修改性**：
  - 若赋值为**基本类型**（数字、字符串等），则值不可修改（如 `const a = 1; a = 2;` 报错）；
  - 若赋值为**引用类型**（对象、数组等），则变量指向的“引用地址”不可修改，但对象/数组内部属性可修改（如 `const obj = {a:1}; obj.a = 2;` 合法）。
- **for 循环限制**：
  - 不可用于普通 `for` 循环的迭代变量（如 `for (const i = 0; i < 3; i++)` 报错，因 `i` 会自增修改）；
  - 可用于 `for-in`/`for-of` 循环（迭代变量不修改，仅读取属性/元素，如 `for (const key in obj) {}`）。

### 变量声明最佳实践

**不使用 var，const 优先，let 次之**

- 优先用 `const`：明确变量值/引用不修改，提升代码可读性和稳定性；

- 仅当变量需要后续修改时用 `let`；

- 避免用 `var`：函数作用域易导致变量泄漏，提升行为易引发逻辑错误。

## 流控制语句：控制代码执行顺序

流控制语句通过关键词控制代码的执行路径，核心包括**条件判断、循环、跳转**三类。

### 条件判断语句：if

- **基本结构**：根据条件（`condition`）的布尔值执行不同语句，`else` 可选，`else if` 可串联多个条件：

  ```js
  // 基础形式
  if (condition) {
    statement1; // condition 为 true 时执行
  } else {
    statement2; // condition 为 false 时执行
  }

  // 多条件串联
  if (condition1) {
    statement1;
  } else if (condition2) {
    statement2;
  } else {
    statement3; // 所有条件均为 false 时执行
  }
  ```

- **条件特性**：`condition` 可为任意表达式，JS 会自动调用 `Boolean()` 转换为布尔值（如 `if (1)` 等价于 `if (true)`）。
- **最佳实践**：无论语句是否为单行，均用 `{}` 包裹（避免逻辑歧义，如 `if (a) b = 1; c = 2;` 中 `c=2` 不受 `if` 控制）。

### 循环语句：重复执行代码块

循环语句分为“先测试”（先判断条件再执行）和“后测试”（先执行再判断条件）两类，核心包括 `while`、`do-while`、`for`、`for-in`、`for-of`。

| 循环类型   | 语法结构                                                     | 执行逻辑（先/后测试）                 | 适用场景                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------- | -------------------------------- |
| `while`    | `while (expression) { statement; }`                          | 先测试（条件为 true 才执行）          | 循环次数不确定时                 |
| `do-while` | `do { statement; } while (expression);`                      | 后测试（至少执行一次）                | 循环体必须执行至少一次时         |
| `for`      | `for (initialization; expression; post-loop) { statement; }` | 先测试（初始化 → 判断 → 执行 → 更新） | 循环次数确定时（如固定迭代）     |
| `for-in`   | `for (property in obj) { statement; }`                       | 迭代对象属性                          | 枚举对象的非符号键属性           |
| `for-of`   | `for (element of iterable) { statement; }`                   | 迭代元素值                            | 遍历可迭代对象（数组、字符串等） |

- **`for` 循环细节**：
  - `initialization`：循环前初始化变量（如 `let i = 0`），可省略；
  - `expression`：循环条件（如 `i < 5`），为 `false` 时退出循环，可省略（省略则为无限循环）；
  - `post-loop`：循环后执行的更新（如 `i++`），可省略。
- **`for-in` 注意事项**：
  - 遍历对象属性时**无顺序**（不保证按定义顺序）；
  - 若对象为 `null`/`undefined`，循环不执行；
  - 会遍历对象原型链上的可枚举属性，需用 `hasOwnProperty()` 过滤（如 `if (obj.hasOwnProperty(property)) { ... }`）。
- **`for-of` 注意事项**：
  - 仅可遍历“可迭代对象”（如数组、字符串、`Map`、`Set`）；
  - 直接获取元素值（而非 `for-in` 的属性名）；
  - 若迭代非可迭代对象（如普通对象），会报错。

### 跳转语句：break 与 continue

用于中断循环或跳过当前迭代，可单独使用或配合**标签语句**定位跳转位置。

- **`break`**：立即退出当前循环/`switch`，执行后续代码：
  ```js
  for (let i = 0; i < 5; i++) {
    if (i === 2) break; // 当 i=2 时退出循环，后续 i=3、4 不执行
    console.log(i); // 输出 0、1
  }
  ```
- **`continue`**：立即跳过当前迭代，直接进入下一次循环判断：
  ```js
  for (let i = 0; i < 5; i++) {
    if (i === 2) continue; // 跳过 i=2 的迭代，不执行 console.log
    console.log(i); // 输出 0、1、3、4
  }
  ```
- **标签语句配合跳转**：标签（`label`）用于标记代码块，`break/continue` 可通过标签跳转到指定位置（常用于嵌套循环）：
  ```js
  outer: for (let i = 0; i < 3; i++) {
    // 外层循环标签 outer
    inner: for (let j = 0; j < 3; j++) {
      // 内层循环标签 inner
      if (j === 1) break outer; // 直接退出外层循环
      console.log(j); // 仅输出 0（j=1 时退出外层）
    }
  }
  ```

### 其他语句：with、switch

- **`with` 语句**：

  - 作用：将代码作用域绑定到指定对象，简化对该对象属性的重复访问：
    ```js
    with (location) {
      let qs = search.substring(1); // 等价于 location.search.substring(1)
      let url = href; // 等价于 location.href
    }
    ```
  - 缺点：影响性能（JS 引擎无法优化作用域查找）、难以调试（变量来源不明确）；
  - 限制：严格模式下禁用，会抛出错误，**不推荐使用**。

- **`switch` 语句**：
  - 作用：多条件匹配，根据 `expression` 的值匹配 `case`，执行对应代码：
    ```js
    switch (num) {
      case 1:
        console.log("一");
        break; // 退出 switch，避免向下匹配
      case 2:
        console.log("二");
        break;
      default: // 所有 case 不匹配时执行
        console.log("其他");
    }
    ```
  - 匹配规则：使用**全等操作符（===）**，不进行类型转换（如 `case 1` 不匹配 `num = "1"`）；
  - 注意事项：
    - 若省略 `break`，代码会“穿透”到下一个 `case`（需注释说明是故意穿透）；
    - `case` 的值可为变量或表达式（如 `case a + b:`），支持所有数据类型（字符串、对象等）。
