---
# 文章标题
title: 2.16 RPC
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TCP 粘包问题, 裸 TCP, TCP 字节流, TCP 消息边界, 消息头消息体, 自定义通信协议, TCP 协议, HTTP 协议, RPC 协议, HTTP 与 RPC 区别, 服务发现, Consul, Etcd, Redis, CoreDNS, TCP 长连接, 连接池机制, 序列化与反序列化, JSON, Protobuf, C/S 架构, B/S 架构, 微服务通信, HTTP Keep-Alive, 应用层协议, 网络通信协议
# 发表日期
date: 2025-09-25
summary: 本节详细介绍了 RPC 的概念、使用纯裸 TCP 的问题、HTTP 和 RPC 的区别等。
# 分类
categories:
  - 计算机网络
# 标签
tags:
  - 计算机基础
  - 计算机网络
  - RPC
---

## 使用纯裸 TCP 会有什么问题

TCP 的三个特点：**面向连接**、**可靠**、**基于字节流**

字节流可以理解为一个**双向通道中的二进制数据流（01 串）**。

在纯裸 TCP 中，这些数据之间**没有任何边界**，无法确定一条完整消息的开始与结束。这被称为 **粘包问题**。

在纯 TCP 之上定义**自定义规则**，用于区分消息边界。将每条数据进行包装：

- **消息头**：包含完整包的长度；
- **消息体**：为实际传输的数据。

根据消息头中的长度信息，可以准确截取消息体。

消息头中还可以放：消息体是否压缩、消息体格式等信息。只要上下游**约定一致**即可，这种约定即为 **协议**。

不同项目会自定义不同协议解析标准，但原理相似。

由于这种封装机制，基于 TCP 衍生出了多种协议，如：**HTTP**、**RPC**

## HTTP 和 RPC

**TCP**：传输层协议。

**HTTP / RPC**：基于 TCP 定义不同消息格式的**应用层协议**。

HTTP 协议，中文名：**超文本传输协议**。用于浏览器访问网页时的数据传输。

RPC，中文名：**远程过程调用**。**不是具体协议**，而是一种**调用方式**。虽多数基于 TCP，但也可以基于 **UDP** 或 **HTTP** 实现。

### 为什么既有 RPC 又要有 HTTP

Client/Server (C/S) 架构：各种联网软件作为客户端与服务器通信，可使用自定义的 RPC 协议，仅服务于**自己公司的服务器**。

Browser/Server (B/S) 架构：浏览器需访问**不同公司的服务器**，为保证互通，必须有统一标准，**HTTP** 因此成为 B/S 架构下的统一通信协议。

HTTP 主要用于 **B/S 架构**，RPC 更多用于 **C/S 架构**。

随着 **B/S 与 C/S 融合**，软件往往需要多端兼容：例如云盘类应用需同时支持网页版、手机端、PC 端；使用 HTTP 可实现**服务器复用同一套协议**。

**RPC** 逐渐用于**内部集群微服务通信**。

## HTTP 和 RPC 的区别

### 服务发现

HTTP：需先知道目标服务器的 **IP 地址和端口**，才能建立连接，这个查找服务对应 IP 端口的过程称为 **服务发现**。

RPC：一般使用**中间服务**保存服务名与 IP 信息，例如：**Consul**、**Etcd**、**Redis**。请求服务时，通过这些中间服务获取 IP 与端口。

**DNS** 也是一种服务发现机制，也存在基于 DNS 实现的服务发现组件，如 **CoreDNS**。

### 底层连接形式

以 **HTTP/1.1** 为例：建立 TCP 连接后默认开启 **Keep Alive**，之后的请求与响应会**复用同一连接**。

RPC 同样基于 **TCP 长连接** 进行通信，通常会建立 **连接池**，高并发时创建多条连接，每次请求从连接池中取出连接，使用后归还，下次可复用，提高性能。

许多编程语言的 HTTP 网络库中也加入了连接池机制。

### 传输的内容

基于 TCP 的消息结构：**消息头（Header） + 消息体（Body）**

- **Header**：包含消息体长度及其他标识；
- **Body**：实际传输的数据（01 二进制串）。

字符串与数字可直接转为二进制；

**结构体** 需先转为二进制：转换为二进制的过程称为 **序列化**，反向恢复为结构体的过程称为 **反序列化**。

常见方案：**JSON**、**Protobuf**

**HTTP/1.1** 以字符串为主：Header 与 Body 都是字符串，使用 **JSON** 进行序列化。

RPC 的传输特点：定制化程度更高；可采用体积更小的 **Protobuf** 或其他协议，不需处理浏览器行为（如 **302 重定向**），**性能更优**，因此常用于**内部微服务通信**。
