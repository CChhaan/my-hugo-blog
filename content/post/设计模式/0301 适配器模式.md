---
# 文章标题
title: 3.1 适配器模式
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: 适配器模式, Adapter Pattern, 结构型设计模式, 接口不兼容, 对象适配器, 类适配器, 接口转换, 组合实现适配器, 多重继承适配器, 双向适配器, 客户端接口, 服务类适配, 遗留系统兼容, 第三方库适配, 设计模式应用场景, 适配器实现步骤, 适配器优缺点, 接口复用, 动态扩展功能, 代码兼容性提升
# 发表日期
date: 2025-11-03
summary: 本节详细介绍了适配器模式，包括其定义、解决方案、模式结构、适合应用场景、实现方式以及优缺点等内容。
# 分类
categories:
  - 设计模式
# 标签
tags:
  - 设计模式
---

## 定义

**适配器模式**是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。

## 解决方案

**核心思路**：通过创建一个“适配器”对象，将不兼容接口之间的交互转换为可兼容的形式。

适配器的作用

- 转换对象接口，使其能与其他对象交互。
- 封装复杂的转换过程，被封装的对象察觉不到适配器的存在。

运作方式：

1. **适配器**实现与其中一个现有对象兼容的接口。
2. **现有对象**通过该接口安全地调用适配器方法。
3. **适配器方法**将请求转换为另一个对象兼容的格式和顺序并传递给该对象。

> 有时可以创建**双向适配器**来实现双向转换调用。

## 模式结构

### 对象适配器

**实现方式**：使用**组合原则**，适配器实现其中一个对象的接口，并封装另一个对象。

角色说明

- **客户端**：包含当前程序业务逻辑的类。
- **客户端接口**：描述与客户端合作的协议。
- **服务**：功能类（通常来自第三方或遗留系统），接口与客户端不兼容。
- **适配器**：同时与客户端和服务交互，实现客户端接口并封装服务对象，接受客户端调用并转换为服务对象可理解的请求。

**特性**：

- 客户端只通过接口与适配器交互，无需了解适配器实现。
- 可添加新的适配器类型而不修改已有代码。
- 当服务类接口被更改或替换时，可新建适配器而无需修改客户端代码。

### 类适配器

**实现方式**：使用**继承机制**，适配器同时继承客户端和服务的接口。

> 仅适用于支持多重继承的语言（如 C++）。

**特征**：

- 不需封装对象，因为继承了两者的行为。
- 适配功能通过重写方法实现。
- 生成的适配器可直接替代客户端类使用。

## 适合应用场景

- **接口不兼容场景**：当希望使用某个类，但其接口与现有代码不兼容时，可使用适配器。

- **类复用与扩展场景**：当需要复用同一继承体系中存在额外公共方法的类，但这些方法并非所有子类共有。

直接扩展每个子类 → 代码重复，存在“坏味道”。

使用适配器类 → 将缺失功能封装于适配器中，动态获得所需功能。

> 目标类需有通用接口，适配器的成员变量应遵循该接口。这种方式与**装饰模式**相似。

## 实现方式

1. 确保至少有两个类的接口不兼容：
   - 一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性*服务*类。
   - 一个或多个将受益于使用服务类的*客户端*类。
2. 声明客户端接口， 描述客户端如何与服务交互。
3. 创建遵循客户端接口的适配器类。 所有方法暂时都为空。
4. 在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。
5. 依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。
6. 客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。

## 优缺点

优点：

- **单一职责原则**：将接口或数据转换逻辑从业务逻辑中分离。
- **开闭原则**：客户端通过接口交互，可在不修改客户端代码的情况下添加新适配器类型。

缺点：

- **代码复杂度增加**：需要新增接口和类，有时直接修改服务类更简单。
