---
# 文章标题
title: 2.4 原型模式
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: 原型模式, Prototype 模式, 创建型设计模式, 对象克隆, 原型克隆, 克隆方法 clone, 原型接口, 具体原型类, 原型注册表, 原型构造函数, 复制对象, 深拷贝与浅拷贝, 解耦对象创建, 复杂对象复制, 对象初始化优化, 设计模式原型模式, 克隆对象无需依赖具体类, 复用对象配置, 替代复杂构造函数
# 发表日期
date: 2025-11-02
summary: 本节详细介绍了原型模式，包括定义、解决方案、模式结构、细节说明、适合应用场景、实现方式、优缺点等内容。
# 分类
categories:
  - 设计模式
# 标签
tags:
  - 设计模式
---

## 定义

**原型模式** 是一种创建型设计模式，**使你能够复制已有对象，而又无需使代码依赖它们所属的类。**

## 解决方案

原型模式将 **克隆过程委派给被克隆的实际对象**。

模式为所有支持克隆的对象声明了一个通用接口，使得对象可以在不依赖具体类的情况下被克隆。通常情况下，该接口中仅包含一个 **克隆方法**。

克隆方法的实现：每个类的克隆方法都会创建当前类的新对象，并将原始对象的所有成员变量值复制到新对象中。

对象可以复制私有成员变量，因为大多数编程语言允许同类对象互访其私有成员。

支持克隆的对象即为 **原型**。

当对象具有大量成员变量和多种类型时，克隆可以替代复杂的构造。

工作方式：

1. 创建一系列不同类型的对象，并以不同方式配置。
2. 若所需对象与已配置对象相同，直接克隆原型即可，无需重新创建。

## 模式结构

**原型**声明克隆方法（通常命名为 `clone`）。

**具体原型**实现克隆方法。除了复制数据外，还可能处理关联对象或递归依赖等特殊情况。

**客户端**可复制任何实现了原型接口的对象。

**原型注册表**提供对常用原型的访问：

- 存储预生成对象的映射（如 `名称 → 原型`）。
- 可扩展为根据多种条件搜索原型的注册表。

## 细节说明

基础原型：

- 包含常规构造函数与原型构造函数。
- 使用已有对象的数值初始化新对象。
- `clone` 操作返回一个形状子类实例。

具体原型：

- 克隆方法创建新对象并传递给构造函数。
- 构造函数运行期间持有克隆对象引用，防止外部访问未完成的对象。
- 通过调用父构造函数复制父类中的私有成员变量。

**原型的关键特征**：可以在**不知晓对象类型**的情况下，生成一个与其完全相同的复制品。

## 适合应用场景

- **当需要复制对象且希望代码独立于具体类时。**

  适用于处理来自第三方接口传递的对象。原型模式提供通用接口，使客户端与具体类解耦。

- **当子类的区别仅在初始化方式上时。**

  可使用预生成的不同类型对象作为原型。客户端通过克隆现有原型代替子类实例化。

## 实现方式

1. **创建原型接口**，在其中声明克隆方法。

   若已有类层次结构，只需在各类中添加该方法。

2. **定义以本类对象为参数的构造函数**，将参数对象的成员变量复制到新实例，子类修改时需调用父类构造函数复制父类的私有成员。

   若语言不支持重载，可通过特殊方法复制对象数据。

3. **实现克隆方法**

   通常仅包含一行代码：使用 `new` 调用原型构造函数。

   每个类需显式重写克隆方法，避免生成父类对象。

4. **创建中心化原型注册表**，可作为独立工厂类，或添加到原型基类中。

   根据客户端提供的搜索条件（字符串或参数组）查找原型，找到后克隆并返回复制对象。

5. **替换直接构造调用**，将对子类构造函数的直接调用替换为原型注册表的工厂方法。

## 优缺点

优点：

- **解耦**：可克隆对象而无需依赖其具体类。
- **性能优化**：克隆预生成原型可避免重复初始化。
- **简化复杂对象创建**。
- **提供继承之外的配置复用方式**。

缺点：**克隆包含循环引用的复杂对象可能非常麻烦。**
