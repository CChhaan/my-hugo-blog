---
# 文章标题
title: 05- 对象类型
# 文章内容摘要
# description: q
# 文章内容关键字
keywords: TypeScript, 对象类型，interface, 索引签名，交叉类型，泛型对象，ReadonlyArray, 元组类型
# 发表日期
date: 2025-07-23
summary: 本节详细介绍了 TypeScript 中对象类型的基本定义、属性特性、索引签名、交叉类型、泛型对象、ReadonlyArray 和元组类型等概念，帮助读者深入理解 TypeScript 的对象类型系统。
# 分类
categories:
  - typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## 对象类型的基本定义

对象类型是 TS 中描述数据结构的核心方式，主要有三种定义形式：

1. **匿名对象类型**
   直接在参数或变量声明中定义，无需命名：

   ```ts
   function greet(person: { name: string; age: number }) {
     return "Hello " + person.name;
   }
   ```

2. **接口（interface）**
   通过`interface`关键字命名对象类型，支持**声明合并**（多次定义同一接口会自动合并），可复用：

   ```ts
   interface Person {
     name: string;
     age: number;
   }
   function greet(person: Person) {
     /* ... */
   }
   ```

3. **类型别名（type alias）**
   通过`type`关键字为对象类型命名：

   ```ts
   type Person = {
     name: string;
     age: number;
   };
   function greet(person: Person) {
     /* ... */
   }
   ```

**面试高频对比**：

| 场景     | `interface`     | `type`                             |
| -------- | --------------- | ---------------------------------- |
| 声明合并 | 支持            | 不支持（重复声明报错）             |
| 扩展方式 | `extends`继承   | 交叉类型（`&`）合并                |
| 适用类型 | 仅对象 / 类形状 | 任意类型（对象、联合、基础类型等） |

## 对象属性的特性

对象类型的属性可通过修饰符指定特性：

1. **可选属性**

   - 标记为`?`的属性可省略，类型为`T | undefined`（在`strictNullChecks`开启时需显式处理`undefined`）。

   - 示例：

     ```ts
     interface User {
       name: string;
       age?: number; // 可选属性
     }
     const user: User = { name: "Alice" }; // 合法，age可省略
     ```

2. **只读属性（readonly）**

   - 标记为`readonly`的属性在类型检查期间不可被重写，但不影响其内部内容的可变性（如对象属性仍可修改）。

   - TypeScript 检查类型兼容性时不考虑`readonly`，因此可通过别名修改只读属性。

   - 示例：

     ```ts
     interface Point {
       readonly x: number;
       readonly y: number;
     }
     const p: Point = { x: 1, y: 2 };
     p.x = 3; // 错误：只读属性不可修改
     ```

## 索引签名

当属性名不确定但值类型已知时，用索引签名描述键值关系：

1. **基本语法**

   ```ts
   interface StringArray {
     [index: number]: string; // 索引签名：number类型索引返回string
   }
   const arr: StringArray = ["a", "b"];
   const item = arr[0]; // 类型为string
   ```

2. **允许的索引类型**
   索引签名的类型只能是`string`、`number`、`symbol`、模板字符串模式，或这些类型的联合。

3. **number 与 string 索引的关系**

   - 当同时使用 number 和 string 索引时，number 索引返回的类型必须是 string 索引返回类型的子类型（因为 JavaScript 会将 number 索引转为 string）。

   - 示例：

     ```ts
     interface Example {
       [x: string]: number;
       [x: number]: number; // 合法：number是string索引返回类型的子类型
     }
     ```

4. **只读索引签名**
   禁止通过索引赋值，确保对象不可修改：

   ```ts
   interface ReadonlyDict {
     readonly [key: string]: string;
   }
   const dict: ReadonlyDict = { a: "1" };
   dict["b"] = "2"; // 错误：只读索引不可赋值
   ```

## 溢出属性检查

对象字面量被分配给变量或作为参数传递时，TypeScript 会进行额外的属性检查，若存在目标类型没有的属性则报错。

```ts
interface Square {
  color: string;
}
const square = { color: "red", size: 10 }; // 对象字面量
const s: Square = square; // 合法：通过变量间接赋值，不触发溢出检查
const s2: Square = { color: "red", size: 10 }; // 错误：直接赋值触发检查，size为溢出属性
```

绕过检查的方法

- 类型断言：强制指定类型，忽略额外属性。

  ```ts
  interface SquareConfig {
    color?: string;
  }
  const config = { color: "red", size: 10 } as SquareConfig;
  ```

- 添加字符串索引签名：允许任意额外属性。

  ```ts
  interface SquareConfig {
    color?: string;
    [prop: string]: unknown; // 允许任意string属性
  }
  ```

- 分配给变量：变量不会触发溢出检查，只要存在公共属性即可。

  ```ts
  const options = { color: "red", size: 10 };
  const config: SquareConfig = options; // 合法：共享color属性
  ```

## 接口扩展与交叉类型

### 接口扩展（extends）

- 作用：从其他类型复制成员并添加新成员，可扩展多个类型。

- 示例：

  ```ts
  interface Shape {
    name: string;
  }
  interface Circle extends Shape {
    radius: number;
  } // 扩展Shape
  const circle: Circle = { name: "circle", radius: 10 };
  ```

- 冲突处理：若父接口与子接口有同名属性且类型不兼容，直接报错。

### 交叉类型（&）

- 作用：组合现有对象类型，使用`&`运算符定义。

- 示例：

  ```ts
  type A = { x: number };
  type B = { y: string };
  type C = A & B; // 交叉类型：{ x: number; y: string }
  ```

- 冲突处理：同名属性类型不同时，会合并为联合类型（如`{ x: number } & { x: string }`的`x`类型为`number & string`，即`never`）。

接口扩展更适合 “is-a” 关系（如 Circle 是一种 Shape），交叉类型更适合 “has-a” 组合（如同时具有 A 和 B 的属性）。

## 泛型对象类型

通过类型参数实现 “与元素类型无关的容器类型” 复用

1. **泛型接口**
   示例：

   ```ts
   interface Box<Type> {
     contents: Type; // 类型参数Type定义内容类型
   }
   const stringBox: Box<string> = { contents: "hello" };
   ```

2. **泛型类型别名**
   类型别名也可泛型，适用于描述非对象类型的组合：

   ```ts
   type Pair<Type> = [Type, Type];
   const numPair: Pair<number> = [1, 2];
   ```

3. **常见泛型数据结构**

   - `Array<Type>`（简写`Type[]`）：数组类型，如`number[]`即`Array<number>`。
   - `Map<K, V>`：键为`K`、值为`V`的映射。
   - `Set<T>`：元素为`T`的集合。
   - `Promise<T>`：返回值为`T`的 Promise。

## ReadonlyArray

用于描述不应被修改的数组，是类型安全的只读容器。

1. **特性**

   - 无构造函数，可将普通数组赋值给`ReadonlyArray`，无修改方法（`push`、`pop`等），确保数组不可变，提升类型安全。。
   - 简写形式：`readonly Type[]`（与`ReadonlyArray<T>`完全等价）。
   - 赋值关系：普通数组可赋值给`ReadonlyArray`，但反之不可。

2. **示例**

   ```ts
   const arr: number[] = [1, 2];
   const readonlyArr: ReadonlyArray<number> = arr; // 合法
   arr.push(3); // 合法
   readonlyArr.push(3); // 错误：ReadonlyArray无push方法
   ```

## 元组类型

元组是明确元素数量和类型的数组类型，适用于固定结构的数据。

1. **基本定义**

   ```ts
   type StringNumberPair = [string, number]; // 元组：第一个元素string，第二个number
   const pair: StringNumberPair = ["a", 10];
   ```

2. **可选元素**
   用`?`标记末尾元素为可选，影响元组长度：

   ```ts
   type OptionalTuple = [string, number?];
   const t1: OptionalTuple = ["a"]; // 合法，长度1
   const t2: OptionalTuple = ["a", 10]; // 合法，长度2
   ```

3. **剩余元素**
   用`...`指定可变数量的元素，需为数组 / 元组类型：

   ```ts
   type TupleWithRest = [number, ...string[]];
   const t: TupleWithRest = [1, "a", "b"]; // 合法
   ```

   **只读元组**
   前缀`readonly`禁止修改（推荐默认使用，避免意外修改）：

   ```ts
   type ReadonlyTuple = readonly [string, number];
   const rt: ReadonlyTuple = ["a", 10];
   rt[0] = "b"; // 错误：只读元组不可修改
   ```

   访问超出元组长度的索引时，类型为`undefined`
