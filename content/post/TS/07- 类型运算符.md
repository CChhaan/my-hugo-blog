---
# 文章标题
title: 07- 类型运算符
# 文章内容摘要
# description: q
# 文章内容关键字
keywords: TypeScript, keyof, typeof, 索引访问类型，类型查询，字面量联合类型，类型安全
# 发表日期
date: 2025-07-24
summary: 本节主要介绍 TypeScript 中的类型运算符，包括 `keyof`、`typeof` 和索引访问类型，以及它们在类型查询和类型推导中的应用。
# 分类
categories:
  - TS官方手册
# 标签
tags:
  - TypeScript 进阶
  - 类型工具
  - 类型系统
  - 类型查询
  - 前端开发
---

## `keyof` 运算符

`keyof` 用于将对象类型的所有键名转换为**字面量联合类型**，是实现 “类型安全的键访问” 的基础。

### 基础用法

```ts
type Point = { x: number; y: number };
type P = keyof Point; // 等价于 type P = "x" | "y"
```

- 作用：将对象类型的所有键名提取为联合类型，常用于约束函数参数必须是对象的有效键，避免拼写错误（如访问不存在的属性）。

### 与索引签名结合

当对象类型包含 `string` 或 `number` 索引签名时，`keyof` 会返回对应的索引类型：

```ts
// number 索引签名
type Arrayish = { [n: number]: unknown };
type A = keyof Arrayish; // type A = number（仅允许 number 类型索引）

// string 索引签名
type Mapish = { [k: string]: boolean };
type M = keyof Mapish; // type M = string | number
```

- 因为 JavaScript 会将数字索引自动转换为字符串（如 `obj[0]` 等价于 `obj["0"]`），因此 `string` 索引签名隐含支持 `number` 索引。
- **`keyof`与`Object.keys`的区别**：
  - `keyof`：在类型层面工作，返回键的**字面量联合类型**（编译时）。
  - `Object.keys`：在值层面工作，返回键的**字符串数组**（运行时）。

## `typeof` 运算符（类型上下文）

`typeof` 在类型上下文中用于获取变量或属性的类型，将 “值世界” 的信息传递到 “类型世界”，避免重复声明类型，常与其他类型工具结合使用。

### 基本用法

```ts
let s = "hello";
let n: typeof s; // 类型为 string（n 的类型与 s 一致）
```

### 与函数结合

获取函数的类型（而非调用结果的类型），配合 `ReturnType` 可提取返回值类型：

```ts
function f() {
  return { x: 10, y: 3 };
}
type FType = typeof f; // () => { x: number; y: number }
type FReturn = ReturnType<FType>; // { x: number; y: number }
```

### 与数组结合

获取数组变量的类型，用于推导数组元素的类型：

```ts
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
];
type MyArrayType = typeof MyArray; // { name: string; age: number }[]
```

### 限制

仅允许在**标识符（变量名）或其属性**上使用，不能直接用于表达式结果：

```ts
type Invalid = typeof (1 + 2); // 错误：typeof 只能用于标识符或其属性
```

- 与 JS 中的`typeof`区别：
  - 类型上下文的`typeof`：返回**TypeScript 类型**（如 `typeof "hello"` 是 `string`）。
  - 值上下文的`typeof`：返回**字符串**（如 `typeof "hello"` 是 `"string"`）。

## 索引访问类型

通过索引访问类型（`Type[IndexType]`）可以获取对象类型中特定属性的类型，`IndexType` 必须是类型。

### 基本用法

```ts
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"]; // type Age = number（获取 age 属性的类型）
```

### 结合联合类型

索引类型可以是联合类型，获取多个属性的类型联合：

```ts
type I1 = Person["age" | "name"]; // type I1 = number | string
type I2 = Person[keyof Person]; // type I2 = number | string | boolean（等价于所有属性类型的联合）
```

### 结合数组与 `typeof`

通过 `number` 索引获取数组元素的类型，配合 `typeof` 推导数组字面量的元素类型：

```ts
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
];
type Person = (typeof MyArray)[number]; // 数组元素的类型：{ name: string; age: number }
type Age = (typeof MyArray)[number]["age"]; // type Age = number（元素的 age 属性类型）
```

### 注意事项

- 索引必须是类型：不能直接使用变量作为索引，需通过`typeof`转换为类型或使用类型别名：

  ```ts
  const key = "age";
  type Age1 = Person[key]; // 错误：key 是值，不是类型
  type Age2 = Person[typeof key]; // 正确：typeof key 是类型 "age"

  // 或使用类型别名
  type Key = "age";
  type Age3 = Person[Key]; // 正确
  ```

- 不存在的属性：访问不存在的属性会报错：

  ```ts
  type Invalid = Person["height"]; // 错误：类型 Person 没有属性 "height"
  ```
