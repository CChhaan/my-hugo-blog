---
# 文章标题
title: 9. 类
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript 类, TypeScript 类成员, TypeScript 构造函数, TypeScript readonly, TypeScript getter setter, TypeScript implements 接口, TypeScript 继承 extends, TypeScript 成员可见性, TypeScript public protected private, TypeScript 静态成员, TypeScript 静态块, TypeScript 泛型类, TypeScript this 类型, TypeScript 参数属性, TypeScript 抽象类, TypeScript 类表达式, TypeScript 类之间的关系
# 发表日期
date: 2025-06-27
summary: 本文主要介绍了 TypeScript 类的使用，包括类成员、构造函数、方法、Getter/Setter、索引签名、继承、成员可见性等。
# 分类
categories:
  - Typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## 类成员

### 字段

字段声明在类上创建公共可写属性。类型注释可选，若未指定则为隐式 `any`。

字段可带初始化程序，实例化时自动运行。类属性的初始化器会用于推断类型。

[`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization) 控制字段是否必须在构造函数中初始化。

TypeScript 不会分析构造函数中调用的方法是否初始化字段。

若字段在构造函数外初始化，可使用**明确赋值断言运算符** `!`。

```ts
class OKGreeter {
  name!: string; // 不初始化但不报错
}
```

### readonly

使用 `readonly` 前缀修饰字段，**禁止在构造函数之外赋值**。

### 构造函数

类构造函数可添加参数、类型注释、默认值和重载。

```ts
class Point {
  x: number = 0;
  y: number = 0;

  constructor(x: number, y: number);
  constructor(xy: string);
  constructor(x: string | number, y: number = 0) {}
}
```

类构造函数签名和函数签名之间的**差异**：

- 不能有类型参数。
- 不能指定返回类型注释。

**继承规则**：若类继承自基类，需在使用 `this` 前调用 `super()`。

### 方法

类上的函数属性称为**方法**。

TypeScript 对方法无新增特性。

方法体中必须通过 `this.` 访问成员。

### Getter/Setter

类可以有访问器（getter/setter）

在 JavaScript 中，没有额外逻辑的、由字段支持的 get/set 对很少用到。如果不需要在 get/set 操作中添加额外的逻辑，那么暴露公共字段也是可以的。

TypeScript 对于访问器有一些特殊的推理规则：

- 若仅存在 `get`，则该属性为 `readonly`。
- 若 `set` 未声明参数类型，则从 `get` 返回类型推断。

### 索引签名

与普通对象索引签名相同。

```ts
class MyClass {
  [s: string]: boolean | ((s: string) => boolean);

  check(s: string) {
    return this[s] as boolean;
  }
}
```

一般不推荐直接在类实例上存储索引数据。

## 类继承

### `implements` 子句

用于**检查类是否满足某个接口**。

仅进行类型检查，不改变类本身类型。

```ts
interface Pingable {
  ping(): void;
}

class Sonar implements Pingable {
  ping() {
    console.log("ping!");
  }
}
```

### extends 子句

类可继承基类，获得其属性与方法。

#### 覆盖方法

派生类可覆盖基类成员。

使用 `super.` 访问基类方法。

派生类必须是基类的**子类型**。

#### 仅类型字段声明

当仅想重新声明字段类型时，可使用 `declare`。

#### 初始化顺序

1. 基类字段初始化
2. 基类构造函数执行
3. 派生类字段初始化
4. 派生类构造函数执行

#### 继承内置类型

继承 `Error`、`Array` 等内置对象需手动调整原型。

## 成员可见性

可以使用 TypeScript 来控制某些方法或属性是否对类外的代码可见。

### public

默认可见性，任何地方都能访问。

### protected

`protected` 成员仅对其声明的类的子类可见。但**不能在类的实例上直接访问**。

#### `protected` 成员的曝光

仅子类可见，**实例不可访问**。

派生类可将 `protected` 成员公开为 `public`。

```ts
class Base {
  protected m = 10;
}
class Derived extends Base {
  m = 15; // 默认 public
}
```

不允许兄弟类访问彼此的 `protected` 成员。

### private

不可被子类或外部访问。

TypeScript 允许跨实例访问同类的 `private`。

编译后仅在类型检查中生效，属于**软私有**。

```ts
class MySafe {
  private secretKey = 12345;
}

const s = new MySafe();
console.log(s["secretKey"]); // 允许
```

真正的**硬私有**需使用 JavaScript 私有字段 `#`。

## 静态成员

静态成员不与实例绑定，通过类访问。

可使用 `public`、`protected`、`private` 修饰。

**可继承**。

### 特殊静态名称

`name`、`length`、`call` 等保留名称不可用作静态成员。

### 无静态类的原因

TypeScript 中不强制所有数据放入类内。单例通常使用对象表示。

## 类中的静态块

允许编写初始化语句，访问类的私有字段。

```ts
class Foo {
  static #count = 0;

  static {
    try {
      const lastInstances = loadLastInstances();
      Foo.#count += lastInstances.length;
    } catch {}
  }
}
```

## 泛型类

类可以是泛型的。

类型参数推断与函数相同。

**注意**：类型在编译后会被完全擦除，`static` 成员无法引用类型参数。

## this 在运行时的行为

### 箭头函数

使用箭头函数可防止丢失 `this` 上下文。

**代价**：

- 每个实例都会持有函数副本。
- 不能使用 `super.getName`。

### this 参数

可以在函数或方法中显式声明 `this` 参数（编译时移除）。

```ts
function fn(this: SomeType, x: number) {}

// JavaScript output
function fn(x) {
  /* ... */
}

console.log(fn());
// The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.
```

优点：静态检查 `this` 调用上下文。

缺点：运行时仍可能误用。

## this 类型

`this` 是动态引用当前类类型的特殊类型。

可用于类型保护（`this is Type`）。

```ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }
  isDirectory(): this is Directory {
    return this instanceof Directory;
  }
  isNetworked(): this is Networked & this {
    return this.networked;
  }
  constructor(public path: string, private networked: boolean) {}
}

class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {
  fso.content; // const fso: FileRep
} else if (fso.isDirectory()) {
  fso.children; // const fso: Directory
} else if (fso.isNetworked()) {
  fso.host; // const fso: Networked & FileSystemObject
}
```

基于 this 的类型保护的一个常见用例是允许对特定字段进行惰性验证。

## 参数属性

在构造函数参数前添加修饰符可直接声明为字段。

```ts
class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);
```

## 类表达式

与类声明相同，但**不需要名称**。

## abstract 类和成员

抽象类不能实例化，只能被继承。

抽象成员必须由子类实现。

未实现抽象成员会导致错误。

## 类之间的关系

TypeScript 使用**结构类型系统**比较类。

即使无继承关系，只要结构兼容即可赋值。

```ts
class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

const p: Person = new Employee(); // OK
```

**空类**是所有类型的超类型。
