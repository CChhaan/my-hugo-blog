---
# 文章标题
title: 5. 对象类型
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript 属性修饰符, 可选属性, readonly 属性, 索引签名, 额外的属性检查, 扩展类型, 交叉类型, 泛型对象类型, 泛型接口, ReadonlyArray, 元组类型, readonly 元组, TypeScript 接口扩展, TypeScript 类型系统
# 发表日期
date: 2025-06-24
summary: 本文主要介绍 TypeScript 中对象类型的使用，包括属性修饰符、可选属性、readonly 属性、索引签名、额外的属性检查、扩展类型、交叉类型、泛型对象类型等。
# 分类
categories:
  - Typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## 属性修饰符

对象类型中的每个属性都可以指定几件事：**类型**、**属性是否可选**以及**属性是否可以写入**。

### 可选属性

很多时候，我们会处理*可能设置*了属性的对象。在这种情况下，可以在属性名称末尾添加问号（`?`）将属性标记为*可选*。

```ts
interface PaintOptions {
  shape: Shape;
  xPos?: number;
  yPos?: number;
}
```

可选属性若被设置，则最好具有特定的类型。

在启用 `strictNullChecks` 时，TypeScript 会提示这些属性可能是 `undefined`。

在 JavaScript 中，未设置的属性访问结果为 `undefined`，可通过判断 `undefined` 特殊处理。

为未指定的值设置默认值是一种常见模式，JavaScript 对此有专门语法支持。

当前无法在解构模式中添加类型注解，因为语法在 JavaScript 中已有不同含义。

### readonly 属性

在类型检查期间无法写入被标记为 `readonly` 的属性。

并不意味着值完全不可变，仅表示属性本身不能被重写。

在类型兼容性检查中，`readonly` 属性不会被特殊对待，仍可通过别名更改。

有助于在开发中**明确对象的使用意图**。

### 索引签名

当事先不知道所有属性名，但知道值的形状时，可使用**索引签名**：

```ts
interface StringArray {
  [index: number]: string;
}
```

当 `StringArray` 被 `number` 索引时，返回值为 `string`。

允许的索引类型：`string`、`number`、`symbol`、模板字符串模式及其联合。

当同时存在数字与字符串索引器时，数字索引器返回类型必须是字符串索引器类型的子类型。

字符串索引签名会使所有属性类型与返回类型匹配。

可以将索引签名设为 `readonly` 以防止写入。

## 额外的属性检查

对象在被**创建并分配类型**时，会触发更严格的验证，即**额外的属性检查**。

对象字面量在赋值或作为参数传递时，会进行额外检查。

若存在“目标类型”中未定义的属性，会报错。

**绕过方式：**

1. 使用**类型断言**。
2. 添加一个**字符串索引签名**。
3. **赋值给变量**后再使用（变量赋值不会触发额外检查）。

若两个对象至少有一个共同属性（如 `width`），上述方式有效，否则无效。

## 扩展类型

`extends` 关键字允许接口从其他类型**复制成员并新增属性**。

`interface` 可从多个类型扩展。减少重复声明，表明类型间的关联。

```ts
interface ColorfulCircle extends Colorful, Circle {}
```

## 交叉类型

使用 `&` 操作符创建**交叉类型**，用于组合多个对象类型。

交叉类型使类型同时满足多个结构要求。

```ts
type ColorfulCircle = Colorful & Circle;
```

## 接口扩展与交叉

两种方式都可**组合类型**，但处理冲突的方式不同：

**接口扩展（`extends`）**：相同名称的属性若类型兼容会**合并**，不兼容则报错。

**交叉类型（`&`）**：不同类型的属性会被强制同时满足，可能导致结果为 `never`。

## 泛型对象类型

可以创建**泛型接口**：

```ts
interface Box<Type> {
  contents: Type;
}

let box: Box<string>;
```

`Type` 是占位符，会被替换为具体类型。

类型别名也可为泛型，用于定义通用辅助类型。

```ts
type OrNull<Type> = Type | null;

type OneOrMany<Type> = Type | Type[];

type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;
```

### Array 类型

泛型对象类型常用于容器结构，如数组。 `number[]` 是 `Array<number>` 的简写。

`Map`、`Set`、`Promise` 等也可与任意类型配合使用。

### ReadonlyArray 类型

`ReadonlyArray` 表示**不可修改**的数组。

表达“只读意图”。

常规 `Array` 可赋给 `ReadonlyArray`。

简写语法：`readonly Type[]`。

常规 `Array` 与 `ReadonlyArray` 的可分配性**不是双向的**。

### 元组类型

**元组类型**是明确长度和元素类型的数组。

```ts
type StringNumberPair = [string, number];
```

超出定义索引会报错。

可用数组解构。

可声明特定索引的类型和 `length`。

可选元素写法：`[number, number, number?]`（仅末尾可选）。

可定义剩余元素：`[string, number, ...boolean[]]`。

可用于函数的剩余参数与参数列表。

### readonly 元组类型

可通过 `readonly` 修饰元组：

```ts
function doSomething(pair: readonly [string, number]) {
  // ...
}
```

不允许修改属性。

建议默认使用 `readonly` 元组。

`const` 断言的数组字面量会被推断为 `readonly` 元组类型。
