---
# 文章标题
title: 10. 模块
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript 模块, TypeScript import export, TypeScript 模块系统, TypeScript ES 模块, TypeScript CommonJS, TypeScript 模块解析, TypeScript 模块输出, TypeScript namespace, TypeScript 模块化, TypeScript esModuleInterop, TypeScript moduleResolution, JavaScript 模块, TypeScript 模块导入导出, TypeScript 模块语法
# 发表日期
date: 2025-06-28
summary: 本文主要介绍了 TypeScript 中的模块，包括 JavaScript 模块的定义、TypeScript 中的模块分类、ES 模块语法、CommonJS 语法、TypeScript 特定的 ES 模块语法等。
# 分类
categories:
  - Typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## JavaScript 模块是如何定义的

在 TypeScript 中，任何包含顶级 `import` 或 `export` 的文件都被视为**模块**。

没有顶级导入或导出声明的文件将被视为**脚本**，其内容在全局范围内可用。

模块在其自身作用域内执行，不在全局作用域执行。

模块中声明的变量、函数、类等在模块外不可见，除非显式导出。

使用其他模块的导出内容时，必须显式导入。

## 非模块

JavaScript 规范规定，没有 `import`、`export` 或顶层 `await` 的文件被视为**脚本**。

在脚本文件中：

- 变量和类型被声明在**共享的全局范围内**。
- 假定使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) 合并多个文件，或在 HTML 中通过多个 `<script>` 标签加载。

将文件显式设为模块：

```ts
export {};
```

此语法有效地将文件转换为一个不导出任何内容的模块。

## TypeScript 中的模块

编写模块化 TypeScript 代码时，需考虑三点：

1. **语法**：选择导入和导出的语法形式。
2. **模块解析**：确定模块名称/路径与文件之间的关系。
3. **模块输出目标**：确定编译后的 JavaScript 模块形式。

### ES 模块语法

默认导出与导入：

```ts
export default function helloWorld() {
  console.log("Hello, world!");
}

import helloWorld from "./hello.js";
helloWorld();
```

命名导出与导入：

```ts
export var pi = 3.14;
export let squareTwo = 1.41;
export const phi = 1.61;

export class RandomNumberGenerator {}

export function absolute(num: number) {
  if (num < 0) return num * -1;
  return num;
}

import { pi, phi, absolute } from "./maths.js";
```

### 附加导入语法

可通过 `import {old as new}` **重命名导入**。

可通过 `import * as name` **导入整个命名空间**。

```ts
import RandomNumberGenerator, { pi as π } from "./maths.js";

import * as math from "./maths.js";
```

仅执行模块文件（不导入变量）：

```ts
import "./file";
```

此导入语句仅执行模块中的代码（用于副作用）。

### TypeScript 特定的 ES 模块语法

可导出或导入**类型**：

```ts
export type Cat = { breed: string; yearOfBirth: number };
export interface Dog {
  breeds: string[];
  yearOfBirth: number;
}

import { Cat, Dog } from "./animal.js";
```

TypeScript 扩展了导入语法：

- **`import type`**：仅导入类型。
- **内联 `type` 导入**：在同一行中区分值和类型导入。

```ts
import type { createCatName } from "./animal.js";
import { createCatName, type Cat, type Dog } from "./animal.js";
```

## CommonJS 语法

导出与导入：

```ts
function absolute(num: number) {
  if (num < 0) return num * -1;
  return num;
}

module.exports = {
  pi: 3.14,
  squareTwo: 1.41,
  phi: 1.61,
  absolute,
};

const maths = require("./maths");
maths.pi;

const { squareTwo } = require("./maths");
```

CommonJS 与 ES 模块在默认导入和命名空间导入上存在不匹配。
可使用 [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) 编译器选项来减少差异。

## TypeScript 的模块解析选项

模块解析是将 `import`/`require` 字符串映射到实际文件的过程。
TypeScript 提供两种解析策略：

1. **Classic**：当 `module` 不是 `commonjs` 时的默认策略，用于向后兼容。
2. **Node**：模仿 Node.js 在 CommonJS 模式下的解析逻辑，并扩展支持 `.ts` 与 `.d.ts`。

**相关配置选项：**[`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution)、[`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)、[`paths`](https://www.typescriptlang.org/tsconfig#paths)、[`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs)

## TypeScript 的模块输出选项

两个配置会影响输出的 JavaScript：

- **`target`**：决定哪些 JS 功能被降级。
- **`module`**：决定模块间交互的形式。

`target` 取决于运行环境（浏览器、Node.js、Electron 等）。

模块加载由运行时的**模块加载器**负责。

编译器选项 `module` 决定使用哪种加载机制。

## TypeScript 命名空间

TypeScript 拥有早于 ES 模块标准的模块系统：**`namespace`**。

此语法用于创建复杂定义文件，仍在 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) 中使用。

尽管未被弃用，但建议使用 **ES 模块** 来保持与现代 JavaScript 一致。
