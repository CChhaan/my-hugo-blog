---
# 文章标题
title: 02- 日常类型
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript, 基础类型，any 类型，类型注解，interface, 联合类型，类型断言，枚举，strictNullChecks
summary: 本节介绍 TypeScript 的基础类型、类型别名、接口、联合类型、类型断言、枚举等概念，帮助读者理解 TypeScript 的类型系统。
# 发表日期
date: 2025-07-18
# 分类
categories:
  - TS官方手册
# 标签
tags:
  - TypeScript 基础
  - 类型系统
  - interface 与 type
  - 枚举类型
  - 前端开发
---

## **基础类型与数组类型**

- JavaScript 基础类型：`string`、`number `、` boolean`（对应 JS 原始类型），TypeScript 中可直接作为类型注解使用。

  - 特点：使用`typeof`运算符对这些类型的值操作时，返回值与类型名一致（如`typeof 'abc' === 'string'`）。

- 数组类型：

  - 两种声明方式：`T[]`（如`number[]`表示数字数组）或`Array<T>`（泛型形式，如`Array<number>`），两者完全等价。

## **特殊类型** **any**

- **核心特性**：关闭类型检查，允许值被任意操作（访问任意属性、作为函数调用、赋值给任何类型等）。

- **适用场景**：
  - 处理动态内容（如来自 API 的未知数据）。
  - 迁移 JS 项目时临时兼容无类型代码。
- **隐式`any`**：未指定类型且 TS 无法推断时，编译器默认视为`any`（可通过`noImplicitAny`配置项禁用，强制显式声明类型，面试高频考点）。
- **风险与替代**：
  - 滥用`any`会失去 TS 类型检查的意义，建议优先使用`unknown`（更安全，需显式类型断言后使用）。

## **变量与函数的类型注解**

- 变量注解： `let 变量名: 类型 = 值`（如 `let age: number = 20`）。

  - 多数情况可省略：TS 会自动推断类型（如`let name = 'ts'` → 推断为`string`）。

- 函数参数类型注解：在每个参数名称后添加，用于声明函数接受的参数类型，即使参数无类型注释，TypeScript 仍会检查参数数量是否正确。

- 函数返回类型注解：出现在参数列表之后。（如`function add(a: number, b: number): number { return a + b }`）。

- 函数参数类型自动推断：当函数出现在 TypeScript 可确定调用方式的地方时，其参数会自动被赋予类型。

## **对象类型**

- **基础定义**：通过属性列表描述对象形状，如`{ name: string; age: number }`（属性间可用`,`或`;`分隔，最后一个可选）。

- 可选属性：属性名后加`?`（如`{ name: string; age?: number }）`，表示该属性可不存在。
  - 注意：访问可选属性前需检查是否为`undefined`（如`if (obj.age !== undefined) { ... }`）。

## **联合类型**

- 含义：由两种或多种其他类型组成，表示值可能是这些类型中的任何一种（如`string | number`表示 “字符串或数字”），组成类型称为联合的成员。

- 典型应用：

  - 限制取值范围：`type Direction = 'up' | 'down' | 'left' | 'right'`（字符串字面量联合）。
  - 处理多类型输入：`function format(value: string | number): string { ... }`。

- 分隔符：联合成员的分隔符允许放在第一个元素之前。

- 类型缩小：通过代码逻辑将联合类型收窄为更具体的类型。

## **类型别名与接口**

- 类型别名：为任意类型起别名（如`type ID = string | number`），可表示基础类型、联合、交叉等。

- 接口声明：主要用于描述对象形状，与类型别名相似，多数情况下可自由选择。interface 的几乎所有功能在 type 中可用，主要区别是类型别名无法重新打开添加新属性，而接口始终可扩展。

- 接口与类型的对比**（面试必问）**：

| **特性**          | `interface`                                       | `type`                                 |
| :---------------- | :------------------------------------------------ | :------------------------------------- |
| **声明合并**      | ✅ 支持多次声明自动合并                           | ❌ 禁止重复声明                        |
| **扩展方式**      | `extends` 继承（`interface B extends A`）         | 交叉类型 `&`（`type B = A & { ... }`） |
| **类实现**        | ✅ 类可直接实现（`class C implements Interface`） | ❌ 需通过对象类型间接实现              |
| **元组/联合类型** | ❌ 不支持                                         | ✅ `type Tuple = [string, number]`     |
| **性能**          | 更好（编译器优化）                                | 复杂类型可能降低性能                   |

- **最佳实践**：优先用`interface`（便于扩展和合并），需联合 / 交叉类型或给基础类型起别名时用`type`。

## **类型断言**

- 用途：告诉 TS “我比你更清楚值的类型”

- 语法：
  - `as`语法（推荐，TSX 中唯一可用）：`const canvas = document.getElementById('app') as HTMLCanvasElement`。
  - 尖括号语法（非 TSX 文件）：`const canvas = <HTMLCanvasElement>document.getElementById('app')`。
- 特性：仅编译时有效，不影响运行时（无类型检查，断言错误不会抛异常）。

- 限制与解决：只能断言为更具体或更宽泛的类型（如`string`可断言为`unknown`，但不能直接断言为`number`，需先断言为`any`过渡）

## **字面类型与** **as const**

- 字面类型：特定值的类型（如`'hello'`是`string`的子类型，`10`是`number`的子类型）。
- 应用：限制取值范围（如`type Status = 'success' | 'error'`）。
- as const：将变量 / 对象转换为 “字面量类型”（类似`const`的类型版本）：
  - 例：`const arr = [1, 2] as const` → 类型为`readonly [1, 2]`（而非`number[]`）。
  - 作用：锁定值的类型，防止 TS 推断为更宽泛的类型（如字符串默认推断为`string`，`as const`后为具体字面量）。

## **null**与**undefined**

- 对应 JavaScript 中表示值不存在或未初始化的基础值，其行为取决于 strictNullChecks 选项。
- **非空断言（`!`）**：断言值不为`null/undefined`（如`const a: string | null = getValue(); a!.length`），注意运行时风险。
- 关闭`strictNullChecks`（默认关闭）：`null`和`undefined`可赋值给任意类型（如`let a: number = null`不报错）。
- 开启`strictNullChecks`（推荐）：`null`和`undefined`是独立类型，使用值的方法或属性前需测试是否为 null 或 undefined，（面试高频配置项）。
- 处理方式：
  - 类型缩小：`if (x !== null) { x.toFixed() }`。
  - 非空断言：`x!.toFixed()`（断言`x`非`null/undefined`）。
  - 可选链（`?.`）与空值合并（`??`）：`obj?.prop ?? 'default'`（简化`null/undefined`处理）。

## **枚举**

- **定义**：TS 新增的类型，用于描述命名常量集合（不仅是类型，还影响运行时）。
- 分类：
  - 数字枚举：默认自增（`enum E { A, B }` → `A=0`，`B=1`），支持自定义值（`enum E { A=2, B }` → `B=3`）。
  - 字符串枚举：必须显式赋值（`enum Direction { Up = 'UP', Down = 'DOWN' }`）。
- 特性（面试高频）：
  - 反向映射：数字枚举支持（`E[A] === 0`，`E[0] === 'A'`），字符串枚举不支持。
  - `const enum`：编译时被移除（不生成运行时代码），减少开销（`const enum E { A }` → 编译后直接替换为值）。
- **注意**：枚举会增加运行时代码，简单场景可用字面量联合类型替代（如`type E = 'A' | 'B'`更轻量）。
