---
# 文章标题
title: 2. 日常类型
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript 基础类型, JavaScript 原始类型, TypeScript 类型注解, TypeScript 数组类型, any 类型, noImplicitAny, TypeScript 函数参数类型, 返回类型注解, TypeScript 对象类型, 可选属性, 联合类型, 类型缩小, 类型别名, 接口, 接口与类型别名区别, 类型断言, 字面量类型, as const, null undefined strictNullChecks, 非空断言操作符, TypeScript 枚举, bigint, symbol
# 发表日期
date: 2025-07-21
summary: 本文主要介绍了 TypeScript 中的日常类型，包括原始类型、数组、any、变量的类型注解、函数、对象类型、联合类型、类型别名和接口等。
# 分类
categories:
  - typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## 原始类型：字符串、数字和布尔值

JavaScript 有三个常用的原始类型：`string`、`number`、`boolean`。

TypeScript 中对应的类型名称与 JavaScript 中 `typeof` 运算符的结果一致。

**应始终使用** 小写的 `string`、`number`、`boolean` 作为类型。

以大写开头的 `String`、`Number`、`Boolean` 是特殊内置类型，几乎不使用。

## 数组

数组类型的写法：

- `number[]`：数字数组
- `string[]`：字符串数组
- `Array<number>`：与 `number[]` 含义相同

注意：`[number]` 是不同的东西。

## any

特殊类型 `any` 用于在不希望引发类型检查错误时使用。

当值为 `any` 类型时：

- 可以访问任何属性；
- 可以像函数一样调用；
- 可以赋值给任意类型或从任意类型赋值；
- 可执行所有语法合法的操作。

当不想写出冗长类型以通过编译时，`any` 很有用。

### noImplicitAny

当未指定类型且 TypeScript 无法推断类型时，编译器默认将其设为 `any`。应避免这种情况。

使用编译器标志 `noImplicitAny` 可将隐式 `any` 标记为错误。

## 变量的类型注解

使用 `const`、`var` 或 `let` 声明变量时，可选择添加类型注解。

```ts
let myName: string = "Alice";
```

TypeScript 不使用“左侧类型”声明（如 `int x = 0;`），类型注解总是写在变量之后。

多数情况下无需显式类型注解，TypeScript 会自动 **推断类型**。

## 函数

### 参数类型注解

在参数名后添加类型注释声明函数的参数类型。

TypeScript 会检查：

- 参数类型是否匹配；
- 参数数量是否正确。

```ts
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase() + "!!");
}
```

### 返回类型注释

返回类型注释位于参数列表之后。

TypeScript 通常能自动推断返回类型，但可显式指定以增强可读性。

```ts
function getFavoriteNumber(): number {
  return 26;
}
```

### 匿名函数

当函数出现在 TypeScript 能确定其调用方式的位置时，参数类型会自动分配。

这一过程称为 **上下文类型识别**（contextual typing）。

## 对象类型

对象类型表示带有属性的 JavaScript 值。

定义方式：列出属性及其类型，可使用 `,` 或 `;` 分隔。

若未指定类型，则默认是 `any`。

### 可选属性

使用 `?` 表示可选属性。

```ts
function printName(obj: { first: string; last?: string }) {
  // ...
}
```

访问不存在的属性会返回 `undefined`，因此读取可选属性前应检查是否为 `undefined`。

## 联合类型

联合类型由两个或多个类型组成，值可以是其中任意一种类型。

### 使用联合类型

仅能执行对每个联合成员都有效的操作。

可通过代码结构进行 **缩小（narrowing）**，以推断更具体的类型。

```ts
function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

如果联合类型成员具有共同属性（如 `slice`），可直接使用该属性。

## 类型别名

为任意类型命名以便复用。

```ts
type Point = {
  x: number;
  y: number;
};

type ID = number | string;
```

类型别名不会创建新类型，仅是已存在类型的别名。

## 接口

另一种命名对象类型的方式。

```ts
interface Point {
  x: number;
  y: number;
}
```

### 类型别名和接口之间的区别

二者功能相似，通常可互换使用。

区别：

- 接口可扩展（可多次声明同名接口）；
- 类型别名不可重新声明。

```ts
// 扩展接口
interface Animal {
  name: string;
}
interface Bear extends Animal {
  honey: boolean;
}

// 通过交叉类型扩展
type Animal = { name: string };
type Bear = Animal & { honey: boolean };

// 接口可重复声明
interface Window {
  title: string;
}
interface Window {
  ts: TypeScriptAPI;
}

// 类型别名重复声明会报错
type Window = { title: string };
type Window = { ts: TypeScriptAPI }; // Error: Duplicate identifier 'Window'.
```

使用带有 `extends` 的接口通常比交叉类型性能更佳。

## 类型断言

当你知道值的类型而 TypeScript 无法推断时，可使用类型断言。

```ts
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;

const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
```

类型断言只在编译时起作用，不会影响运行时行为。

TypeScript 仅允许断言为 **更具体** 或 **更不具体** 的类型。

若规则过于严格，可通过双重断言实现：

```ts
const a = expr as any as T;
```

## 字面量类型

除通用类型外，TypeScript 还支持特定字符串或数字的字面量类型。

可将多个字面量组成联合类型来表达更复杂的概念。

布尔字面量类型：`true`、`false`，`boolean` 实际是 `true | false` 的联合。

### 字面量推断

默认情况下，对象属性被推断为可变。

解决方法：

1. 添加类型断言；
2. 使用 `as const` 将对象转为字面量类型。

```ts
const req = { url: "https://example.com", method: "GET" as "GET" };
handleRequest(req.url, req.method);

const req = { url: "https://example.com", method: "GET" } as const;
handleRequest(req.url, req.method);
```

`as const` 确保所有属性被赋予字面量类型，而非通用类型。

## null 和 undefined

JavaScript 使用 `null` 和 `undefined` 表示缺失或未初始化的值。

TypeScript 对应有同名类型，其行为取决于 [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) 设置。

当 `strictNullChecks` 关闭时，`null` 和 `undefined` 可赋给任意类型。无需显式检查空值。

当开启 `strictNullChecks` 时，必须在使用值前显式检查 `null` 或 `undefined`。

```ts
function doSomething(x: string | null) {
  if (x === null) {
    // do nothing
  } else {
    console.log("Hello, " + x.toUpperCase());
  }
}
```

### 非空断言操作符

用于在不显式检查的情况下从类型中移除 `null` 和 `undefined`。

```ts
function liveDangerously(x?: number | null) {
  // No error
  console.log(x!.toFixed());
}
```

不影响运行时行为，仅在确定值非空时使用。

## 枚举

枚举是 TypeScript 添加的功能，用于表示一组命名常量值。

它属于语言和运行时层面的扩展，而非类型系统特性。

## 较少使用的原始类型

#### `bigint`

从 ES2020 起，JavaScript 引入了 `BigInt` 原始类型，用于表示非常大的整数。

#### `symbol`

JavaScript 中的原始类型，可通过 `Symbol()` 创建全局唯一引用。
