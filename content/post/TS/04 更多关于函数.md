---
# 文章标题
title: 4. 更多关于函数
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript 函数类型, TypeScript 函数签名, TypeScript 调用签名, TypeScript 构造函数签名, TypeScript 泛型函数, TypeScript 泛型约束, TypeScript 可选参数, TypeScript 默认参数, TypeScript 函数重载, TypeScript this 参数, TypeScript void 类型, TypeScript never 类型, TypeScript unknown 类型, TypeScript object 类型, TypeScript Function 类型, TypeScript 剩余参数, TypeScript 参数解构, TypeScript 函数类型表达式, TypeScript 可分配性, TypeScript 函数设计规范
# 发表日期
date: 2025-07-23
summary: 本文主要介绍了 TypeScript 中函数的更多知识，包括函数类型、函数签名、构造函数签名、泛型函数、可选参数、默认参数、函数重载、this 参数、void 类型、never 类型、unknown 类型、object 类型、Function 类型、剩余参数、参数解构、函数类型表达式、可分配性、函数设计规范等。
# 分类
categories:
  - typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## 函数类型表达式

描述函数最简单的方法是使用*函数类型表达式*。这些类型在语法上类似于箭头函数。

```ts
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

`(a: string) => void` 表示一个带有一个参数 `a` 的函数，该参数的类型为 `string`，没有返回值。

如果未指定参数类型，则隐式为 `any`。

**参数名称是必需的。**`(string) => void` 表示“具有 `any` 类型名为 `string` 的参数的函数”。

## 调用签名

函数类型表达式语法不允许声明属性。如果想描述可调用且带属性的函数，可以用对象类型编写*调用签名*。

```ts
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};
function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}

function myFunc(someArg: number) {
  return someArg > 3;
}
myFunc.description = "default description";

doSomething(myFunc);
```

与函数类型表达式不同，在参数列表和返回类型之间使用 `:` 而不是 `=>`。

## 构造函数签名

JavaScript 函数可以通过 `new` 调用，TypeScript 称这些为*构造函数*。
通过在调用签名前添加 `new` 来编写*构造函数签名*。

```ts
type SomeConstructor = {
  new (s: string): SomeObject;
};
function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

可组合调用与构造签名：

```ts
interface CallOrConstruct {
  (n?: number): string;
  new (s: string): Date;
}
```

## 泛型函数

当输入与输出类型相关，或多个输入类型相关时使用。
通过在函数签名中声明*类型参数*来建立对应关系。

```ts
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```

### 推理

TypeScript 会自动**推断**类型参数。

我们也可以使用多个类型参数。

```ts
function map<Input, Output>(
  arr: Input[],
  func: (arg: Input) => Output
): Output[] {
  return arr.map(func);
}

// Parameter 'n' is of type 'string'
// 'parsed' is of type 'number[]'
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

在此示例中，`Input` 从 `string[]` 推断，`Output` 从 `parseInt` 的返回值 `number` 推断。

### 约束

通过 `extends` 限制类型参数的可接受类型。

```ts
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}
```

允许访问 `.length` 属性。

TypeScript 会自动推断返回类型。

### 使用约束值

函数承诺返回与传入类型相同的对象，而不是仅符合约束的对象。

```ts
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj;
  } else {
    return { length: minimum }; // Error
  }
}
```

### 指定类型参数

可以手动指定泛型的类型参数。

```ts
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

```ts
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

### 编写良好泛型函数的指南

- **下推类型参数**：尽量直接使用类型参数本身，而不是限制它
- **使用更少的类型参数**：保持最简。
- **类型参数应出现两次**：用于关联多个值的类型。

## 可选参数与默认值

可选参数：

```ts
function f(x?: number) {
  // ...
}
```

可选参数的类型为 `number | undefined`。

默认值：

```ts
function f(x = 10) {
  // ...
}
```

默认值会将参数类型限定为具体类型（如 `number`）。

### 回调中的可选参数

参数较少的函数可替代参数较多的函数。

**切勿**为回调编写可选参数，除非打算在不传参时调用。

## 函数重载

通过编写多个*重载签名*描述不同参数数量和类型的调用。

为此，请编写一些函数签名（通常两个或更多），然后是函数主体

```ts
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}
```

### 重载签名和实现签名

实现签名对外不可见。

实现签名必须与所有重载签名兼容。

实现函数体应位于重载签名下方。

### 编写好的重载

TypeScript 只能解析为**单个重载**。

优先使用**联合类型参数**替代过多重载。

## 在函数中声明 this

TypeScript 利用 JavaScript 未保留的 `this` 参数名来声明类型。

常用于**回调式 API**。

必须使用 `function` 声明（而非箭头函数）。

## 其他需要了解的类型

### void

表示无返回值的函数返回类型。

与 `undefined` 不同。

在 JavaScript 中，不返回值的函数隐式返回 `undefined`。

### object

表示任何非原始类型的值。

不同于 `{}` 或全局 `Object`。

`object` 不是 `Object` 。 **请始终**使用 `object`

函数类型也属于 `object`。

### unknown

表示任意值，比 `any` 更安全。

对 `unknown` 值的操作需先检查类型。

### never

表示**永不返回**的函数（抛错或终止）。

当联合类型被完全排除时也会出现。

### Function

表示所有函数值的通用类型。

可调用，返回 `any`。

通常应避免，使用 `() => void` 更安全。

## 剩余参数和实参

剩余参数的类型注释为 `Array<T>` 或 `T[]`。

```ts
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}
```

展开语法用于从可迭代对象提供参数。

`const` 上下文有助于防止类型推断问题。

## 参数解构

类型注释位于解构语法之后。

也可使用命名类型。

```ts
type ABC = { a: number; b: number; c: number };
function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

## 函数的可分配性

### 返回类型`void`

返回类型为 `void` 的上下文不会强制函数不返回值。

当赋值时，返回类型仍为 `void`。

但显式声明 `void` 的函数体**不得**返回值。

因此即使 `Array.prototype.push` 返回一个数字，并且 `Array.prototype.forEach` 方法需要一个返回类型为 `void` 的函数，以下代码仍然是有效的。

```ts
const src = [1, 2, 3];
const dst = [0];

src.forEach((el) => dst.push(el));
```
