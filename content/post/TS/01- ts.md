---
# 文章标题
title: 01-ts
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript, 静态类型检查，TypeScript 与 JavaScript 关系，interface, type, 泛型，联合类型，结构类型系统
summary: 本节介绍了 TypeScript 的基础概念，包括静态类型检查、TypeScript 与 JavaScript 的关系、TypeScript 的核心优势、TypeScript 的类型推断与扩展、TypeScript 的类型系统以及类型定义语法等。
# 发表日期
date: 2025-07-16
# 分类
categories:
  - TS官方手册
# 标签
tags:
  - TypeScript
  - 静态类型
  - 类型系统
  - 前端开发
---

## **静态检查与静态类型检查**

- 静态检查：在代码运行前（编译阶段）检测错误，无需执行代码。与之对应的是**动态检查**（运行时检测错误，如 JS 中的`TypeError`）。

- 静态类型检查：基于值的类型规则检测错误（如给 number 类型变量赋值字符串），而静态检查还包括语法错误、变量未定义等非类型错误。

## **TypeScript 与 JavaScript 的关系**

- TypeScript 是 JavaScript 的**超集**：所有合法 JS 语法在 TS 中均有效，TS 代码最终会被编译为纯 JS 代码运行。

- 关键区别：TS 增加了**静态类型系统**，而 JS 是动态类型语言（类型检查仅在运行时发生）。
- 重要特性：
  - TS 不会改变 JS 的运行时行为（“不破坏 JS” 原则）：即使 TS 代码有类型错误，编译后的 JS 仍可正常运行（类型错误不影响执行）。
  - TS 类型系统仅在编译阶段生效，编译后会被完全擦除（“类型擦除”），生成的 JS 无任何类型信息。
- 注意：TS 会对 JS 代码进行**类型检查**（如`let a = 1; a = 'str'`在 TS 中会报错），但不会拒绝 JS 语法（语法上完全兼容）。

## **TypeScript 的核心优势（面试高频）**

- **提前发现错误**：静态类型检查在编码阶段捕获类型不匹配、未定义变量等问题，减少运行时错误。

- **增强代码可读性**：类型注解明确变量 / 函数的预期用途，降低团队协作成本。
- **提升开发效率**：IDE 支持（自动补全、类型提示、重构安全）大幅提升编码速度。
- **更好的可维护性**：类型约束使代码逻辑更严谨，重构时更可靠（如修改函数参数类型时，所有调用处会即时报错）。

## **TypeScript 的类型推断与扩展**

- 类型推断：TS 会自动推导变量 / 表达式的类型（无需显式声明）。
  例：`let x = 10` → TS 推断`x`为`number`；`const y = { name: 'ts' }` → 推断`y`为`{ name: string }`。

- 类型注解：当推断结果不符合预期时，可显式指定类型（`:`后接类型）。
  例：`let z: string = 'hello'`；`function add(a: number, b: number): number { return a + b }`。

## **TypeScript 的类型系统**

- **基础类型**（同 JS）：`boolean`、`number`、`string`、`null`、`undefined`、`bigint`、`symbol`。
  注意：`null`和`undefined`是所有类型的子类型（默认配置下，`let a: number = null`不报错，可通过`strictNullChecks`开启严格检查）。

- **TS 扩展类型**：
  - `any`：关闭类型检查，允许赋值任意类型（滥用会失去 TS 优势，建议避免）。
  - `unknown`：类型安全的`any`，使用前必须明确类型（如`if (typeof u === 'string') { ... }`）。
  - `never`：表示 “不可能发生的类型”（如抛出错误的函数返回值`function error(): never { throw new Error() }`）。
  - `void`：函数无返回值或返回`undefined`（`function log(): void { console.log('hi') }`）。

## **类型定义语法**

- 相同点：均可定义对象类型（`{ name: string }`）。

- 核心区别：
  - `interface`支持**声明合并**（多次定义同一接口会自动合并），`type`不支持。
    例：`interface User { name: string }`与`interface User { age: number }`合并为`{ name: string; age: number }`。
  - `type`可定义**联合类型**（`A | B`）、**交叉类型**（`A & B`）、**字面量类型**（`'success' | 'error'`）等，`interface`不行。
- 最佳实践：
  - 定义对象 / 类的结构时优先用`interface`（便于扩展和合并）。
  - 需要联合、交叉等复杂类型时用`type`。

## **复杂类型的创建方式**

- **联合类型**（`A | B`）：值可以是多种类型之一。
  例：`type ID = number | string`（ID 可以是数字或字符串）；`type Status = 'pending' | 'done'`（字符串字面量联合，限制取值范围）。

- **交叉类型**（`A & B`）：合并多个类型为一个（同时具备所有类型的属性）。
  例：`type User = { name: string } & { age: number }` → 等价于`{ name: string; age: number }`。

- **泛型**：为类型添加 “变量”，实现类型复用（解决 “类型不固定但需保持一致性” 问题）。

  例：

  ```typescript
  // 泛型函数：保证输入和输出类型一致
  function identity<T>(arg: T): T {
    return arg;
  }
  // 泛型接口：定义数组中元素的类型
  interface List<T> {
    data: T[];
  }
  ```

  常见场景：函数参数与返回值关联、容器类（数组、Promise）的类型约束。

## **TypeScript 的核心原则：结构类型系统**

- 又称 “鸭子类型”：判断类型兼容性时，只关注**值的形状**（属性和方法），不关注类型名称。

- 例：

  ```typescript
  interface Cat {
    meow(): void;
  }
  interface Dog {
    meow(): void;
  } // 与 Cat 结构相同
  const animal: Cat = { meow: () => {} }; // 正确：形状匹配
  const dog: Dog = animal; // 正确：结构相同，可互相赋值
  ```

- 注意：只要对象包含目标类型的**必需属性**，就视为兼容（允许额外属性）。

## **TypeScript 的目标**

为 JS 提供**静态类型检查**，在不破坏 JS 灵活性的前提下，解决动态类型导致的常见问题（如拼写错误、API 误用）。
