---
# 文章标题
title: 6. 泛型
# 文章内容摘要
# description:
# 文章内容关键字
keywords: TypeScript 泛型, 泛型函数, 泛型类型, 泛型类, 泛型参数默认值, 类型变量, 类型推断, 协变 与 逆变, 方差注解, 泛型接口, 交叉类型, 类型别名 泛型, 泛型性能优化, 类型系统最佳实践
# 发表日期
date: 2025-06-25
summary: 本文主要介绍了 TypeScript 中泛型的使用，包括泛型变量、泛型类型、泛型类、泛型参数默认值和方差等。
# 分类
categories:
  - Typescript文档阅读
# 标签
tags:
  - TypeScript
  - 前端开发
---

## 使用泛型变量

**类型变量**：一种特殊的变量，它作用于类型而不是值。

调用泛型函数的方式

1. **显式传入类型参数**：将所有参数（包括类型参数）传递给函数。

2. **类型参数推断**

- 编译器自动推断类型参数。
- 若编译器无法推断类型（如复杂示例中），则需显式传递类型参数。

创建泛型函数时，编译器会强制在函数体中正确使用泛型参数，将其视为任意类型。

## 泛型类型

泛型函数的类型与非泛型函数类似，类型参数列在最前：

```ts
let myIdentity: <Type>(arg: Type) => Type = identity;
```

可以在类型中使用不同名称的类型变量，只要**数量和使用方式一致**。

也可以将泛型类型写为**对象文字类型的调用签名**：

```ts
interface GenericIdentityFn {
  <Type>(arg: Type): Type;
}

interface GenericIdentityFn<Type> {
  (arg: Type): Type;
}
```

除了泛型接口，还可以创建**泛型类**。但**无法创建泛型枚举和泛型命名空间**。

## 泛型类

泛型类的结构与泛型接口类似。在类名后的尖括号 (`<>`) 中定义泛型类型参数。

类的类型有两个方面：**静态方面**与**实例方面**。泛型类仅在**实例方面**是泛型。**静态成员不能使用类的类型参数**。

## 泛型参数默认值

通过为泛型类型参数声明默认值，可根据需要指定类型参数。

```ts
declare function create<
  T extends HTMLElement = HTMLDivElement,
  U extends HTMLElement[] = T[]
>(element?: T, children?: U): Container<T, U>;
```

规则：

- 若类型参数有默认值，则该类型参数被视为**可选**。
- **必需类型参数**不得跟随可选类型参数。
- 默认类型必须**满足约束**。
- 指定类型实参时，只需为**必需类型参数**指定类型。未指定的类型参数将解析为其默认类型。
- 若推断无法选择候选项，则推断为默认类型。
- 与现有类或接口声明合并时，可为现有类型参数引入默认值。
- 也可引入新的类型参数，只要其指定默认值。

## 方差

方差：指泛型类型中的可变性，决定类型参数如何与子类型和超类型交互。

[协变和逆变](<https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)>)描述泛型类型间的关系。

协变（Covariance）：从 `Producer<T>` 到 `Producer<U>` 的关系与从 `T` 到 `U` 的关系相同。

```ts
interface Producer<T> {
  make(): T;
}
```

逆变（Contravariance） ：从 `Consumer<T>` 到 `Consumer<U>` 的关系与从 `U` 到 `T` 的关系相同。

```ts
interface Consumer<T> {
  consume: (arg: T) => void;
}
```

TypeScript 采用**结构化类型系统**。

比较类型（如 `Producer<Cat>` 是否可用于 `Producer<Animal>`）时，会展开结构再比较。

若 `Producer<T>` 在 `T` 上协变，则可直接比较 `Cat` 与 `Animal`。

仅在**同一类型的两个实例**之间有效。不同泛型类型（如 `Producer<T>` 与 `FastProducer<U>`）比较时，仍执行结构化比较。

TypeScript 会**自动推断**泛型类型的方差。

在特殊情况下（如循环类型）推断可能不准确，可使用变体注解：

```ts
// 协变
interface Consumer<in T> {
  consume: (arg: T) => void;
}
// 逆变
interface Producer<out T> {
  make(): T;
}
// 不变
interface ProducerConsumer<in out T> {
  consume: (arg: T) => void;
  make(): T;
}
```

方差注解的注意事项

- **仅当结构行为确实不同**时使用方差注解。
- **不要写与结构方差不匹配的注解**。
- 注解仅在**基于实例化的比较中有效**，在结构化比较中无效。
- 注解不会改变结构行为，只在特定情况下参考。
- 只有在完全理解其作用与局限时才应使用。
- TypeScript 的类型检查方式可能变化，因此注解必须与结构行为一致。
- **不要使用方差注解来强制变体**。

实践建议

- TypeScript 能自动推断方差，几乎无需显式注解。
- 注解不会改变结构行为。
- 不应使用方差注解来修改类型检查逻辑。
- 方差注解主要用于**类型调试**（TypeScript 会检查错误注解）。
- 注解可比实际方差更严格（如实际协变时使用 `in out`）。
- 调试后应**删除方差注解**。

性能提示

仅在以下情况**可能**使用方差注解以获得微小性能提升：

1. 已运行分析器；
2. 已定位到类型检查性能瓶颈；
3. 已确认方差推断速度较慢；
4. 已仔细验证注解正确。

**不要尝试使用方差注解来改变类型检查行为**； 这不是它们的用途。
