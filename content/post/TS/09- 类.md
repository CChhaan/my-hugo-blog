---
# 文章标题
title: 09- 类
# 文章内容摘要
# description: 本
# 文章内容关键字
keywords: TypeScript, 类，面向对象，类继承，访问修饰符，静态成员，抽象类，this 类型
# 发表日期
date: 2025-07-25
summary: 本节详细介绍了 TypeScript 中类的定义、继承、访问修饰符、抽象类等概念，帮助读者更好地理解和使用 TypeScript 的面向对象编程。
# 分类
categories:
  - TS官方手册
# 标签
tags:
  - TypeScript
  - 类与面向对象
  - 前端开发
---

### 类的字段

字段是类存储数据的基础属性，其行为受类型、初始化规则和修饰符约束。

1. **基本特性**
   - 字段声明默认创建**公共可写属性**，类型可显式声明（如`x: number`）或通过初始化值推断（如`x = 0` → 推断为`number`）。
   - 未指定类型且无初始化值时，隐式为`any`（可通过`noImplicitAny`禁用，强制显式声明）。
2. **初始化相关**
   - **初始化器**：字段可直接赋值（如`x = 0`），实例化时自动运行，，优先级高于构造函数，TypeScript 会根据初始化值推断类型。
   - **strictPropertyInitialization 配置**：
     - 开启时，字段必须在**构造函数内或初始化器中**初始化，否则报错（防止访问未初始化的属性）。
     - 例外：用`!`（明确赋值断言）标记 “后续会初始化” 的字段（如`name!: string`，常用于依赖注入场景）。
   - **注意**：字段必须在构造函数内直接初始化，TypeScript 不会分析构造函数调用的方法（因派生类可能覆盖方法导致初始化失败）。
3. **readonly 修饰符**
   - 标记字段为只读，仅可在**初始化器或构造函数中**赋值，构造函数外修改会报错（编译时检查，运行时仍可通过类型断言绕过）。

### 构造函数

类的初始化函数，用于实例化时设置初始状态。

1. **与函数的异同**
   - 相似性：支持类型注释、默认值、重载（如多构造函数签名）。
   - 区别：
     - 不能有类型参数（类型参数属于外部类声明）；
     - 不能有返回类型注释（默认返回类实例类型）。
2. **super () 调用要求**
   - 派生类构造函数中，使用`this`前必须调用`super()`（调用基类构造函数），否则 TypeScript 报错。

### 方法与访问器

类的函数属性，用于定义行为和属性访问逻辑。

1. **方法**
   - 本质是类的函数属性，支持类型注释（参数和返回值）。
   - 方法体内访问字段 / 其他方法必须通过`this.`，否则引用外部变量。
2. **访问器**
   - 包括`get`（读取）和`set`（写入），封装属性访问逻辑（如验证、计算），替代直接暴露字段。
   - TypeScript 推断规则：
     - 仅有`get`时，属性自动为`readonly`；
     - 未指定`set`参数类型时，从`get`返回类型推断；
     - 4.3+ 版本支持`get`和`set`使用不同类型。
   - 注意：无额外逻辑的`get/set`对意义不大，建议直接用公共字段。

### 索引签名

类可声明索引签名，与对象类型索引签名规则一致。

- 示例：`class MyClass { [s: string]: boolean | ((s: string) => boolean); }`
- 注意：需覆盖方法类型，使用复杂，建议将索引数据存储在类实例外。

### 类继承

类可通过`implements`和`extends`实现接口约束或基类继承。

1. **implements 子句**
   - 检查类是否满足指定接口，未正确实现则报错（如`class Sonar implements Pingable { ping() {} }`）。
   - 注意：仅做类型检查，不改变类的类型或方法；不自动创建接口的可选属性。
2. **extends 子句**
   - 派生类继承基类的属性和方法，可新增或覆盖成员。
   - 覆盖规则：派生类方法必须兼容基类契约（如参数类型不能更严格，返回类型不能更宽松），否则报错。
   - `declare`关键字：用于重新声明继承字段的更精确类型（无运行时影响，如`declare resident: Dog`）。
3. **初始化顺序**
   基类字段初始化 → 基类构造函数运行 → 派生类字段初始化 → 派生类构造函数运行。
4. **继承内置类型（如 Error、Array）的问题**
   - 原因：内置类型构造函数依赖 ES6 的`new.target`调整原型链，而 ES5 及以下版本不支持`new.target`，导致原型链错乱（如`instanceof`检查失败）。
   - 解决：`super()`调用后手动修正原型（如`Object.setPrototypeOf(this, MyError.prototype)`）。

### 成员可见性（访问修饰符）

控制类成员在外部、子类中的访问范围。

1. **public**

   - 默认可见性，成员可在任何地方访问（如`public greet() {}`），可省略不写。

2. **protected**

   - 仅在声明类及其子类中可见（如`protected x = 1`）。
   - 派生类可将`protected`成员改为`public`（扩大可见性），但不能改为`private`。
   - 禁止访问兄弟类的`protected`成员（如`Derived2`不能访问`Derived1`的`protected`成员）。

3. **private**

   - 仅在声明类中可见，子类不可访问（如`private x = 1`）。

   - 允许同一类的不同实例互相访问`private`成员。

   - 与 JavaScript 私有字段（`#`）的区别：

     - TypeScript `private`仅类型检查时生效，运行时可通过括号访问（如`s["x"]`）；
     - JavaScript `#`为硬隐私，运行时不可访问，低版本编译目标下 TypeScript 会转换为`WeakMap`。

### 静态成员

属于类本身的成员，不与实例关联。

1. **定义与访问**
   - 用`static`关键字定义，通过类名访问（如`class MyClass { static x = 0; }`），实例无法访问。
   - 支持`public`/`protected`/`private`修饰符（如`private static x = 0`）。
   - 可被派生类继承（如`Derived.getGreeting()`继承自基类静态方法）。
2. **特殊注意**
   - 不可使用特殊名称（如`name`、`length`），会与函数原型属性冲突。
   - 无 “静态类”：可通过普通对象或顶层函数替代。
   - 静态成员不能使用`this`访问实例成员（`this`指向类本身）。
   - 静态块（`static {}`）：用于初始化逻辑，可访问类的私有成员（如初始化静态私有字段）。

### `this` 相关

类中`this`的类型和运行时行为。

1. **运行时 `this` 行为**
   - 方法的`this`取决于调用方式（可能指向实例外对象，如`obj.method()`中`this`为`obj`）。
   - 箭头函数可绑定`this`到实例（如`getName = () => this.name`），但每个实例都有独立函数副本（增加内存消耗）且无法用`super`调用。
2. **`this` 参数**
   - 方法中可声明`this`参数（如`getName(this: MyClass) {}`），编译时删除，用于静态检查`this`上下文。
3. **`this` 类型**
   - 动态引用当前类的类型，用于返回值或参数（如`set(): this { return this; }`），派生类中会自动适配子类类型。
4. **`this` 型防护**
   - 用`this is Type`缩小对象类型（如`isFile(): this is FileRep { ... }`），便于类型安全操作。

### 参数属性

简化构造函数参数到类属性的映射，通过可见性修饰符实现。

- 示例：`constructor(public x: number, private y: number) {}`（等价于定义`public x`和`private y`并赋值）。

### 类表达式

无名称的类定义，可赋值给变量。

- 示例：`const SomeClass = class<Type> { content: Type; constructor(value: Type) { this.content = value; } }`。

### 构造函数签名与 InstanceType

- 类通过`new`实例化，`InstanceType<typeof Class>`可获取类的实例类型（如`type PointInstance = InstanceType<typeof Point>`）。

### 抽象类与抽象成员

- **抽象类**：用`abstract`声明，不能实例化，需子类实现抽象成员（如`abstract class Base { abstract getName(): string; }`）。
- **抽象成员**：未提供实现的方法 / 字段，子类必须实现，否则报错。
- **与接口的区别**：抽象类可包含具体实现，接口仅定义形状（无实现）。

### 类之间的关系

- **结构比较**：类的兼容性基于结构（成员匹配），无显式继承也可存在子类型关系（如`Employee`可赋值给`Person`，因成员兼容）。
- **空类**：无成员的类是任何类型的超类型，任何值都可赋值给空类类型（不推荐使用）。
