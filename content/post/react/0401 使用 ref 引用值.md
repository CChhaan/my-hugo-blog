---
# 文章标题
title: 4.1 使用 ref 引用值
# 文章内容摘要
# description: 本文详细介绍了 Git 这一分布式版本控制系统的优点，对比了 Windows 与 macOS/Linux 系统下的常用命令，讲解了 vim 操作模式及常用命令，还阐述了 Git 的基本配置、特定项目配置和命令缩写设置等内容。
# 文章内容关键字
keywords: React ref, useRef 使用方法, ref 与 state 区别, React DOM 操作, ref.current, React 组件 ref, useImperativeHandle, ref 回调, React 获取 DOM 节点, React flushSync, React ref 最佳实践, React 外部 API 交互, React 多个 ref 管理, React 渲染阶段 提交阶段, React 状态管理, ref 使用场景
# 发表日期
date: 2025-10-16
summary: 本文介绍了 React 中使用 ref 引用值的方法，包括如何给组件添加 ref、ref 和 state 的不同之处、何时使用 ref 以及 ref 的最佳实践等内容。
# 分类
categories:
  - React文档阅读
# 标签
tags:
  - react
  - 前端框架
  - 前端开发
  - 组件化开发
---

## 给你的组件添加 ref

**ref 是一个可变的“秘密口袋”，React 不会追踪其变化。**

可通过 `useRef` 创建，并通过 `ref.current` 读取或写入。

使用方式：

1. 从 React 导入 `useRef`。
2. 在组件内调用 `useRef(initialValue)`。
3. 通过 `ref.current` 访问或修改值。

特点：

- ref 的值可以是任意类型：数字、字符串、对象、函数等。
- **更改 ref 不会触发重新渲染。**
- React 会在组件多次渲染之间保留 ref。

当信息会影响渲染**使用 state**。当信息仅在事件处理器中使用且不影响渲染**使用 ref**。

## ref 和 state 的不同之处

| ref                                                     | state                                         |
| ------------------------------------------------------- | --------------------------------------------- |
| `useRef(initialValue)` 返回 `{ current: initialValue }` | `useState(initialValue)` 返回当前值及设置函数 |
| 更改不会触发重新渲染                                    | 更改会触发重新渲染                            |
| 可变，可在渲染外修改 `current`                          | 不可变，需通过 setState 设置                  |
| 不应在渲染期间读取或写入 `current`                      | 可随时读取，每次渲染有独立快照                |

**`useRef` 原则上可以基于 `useState` 实现。**

## 何时使用 ref

当组件需要与外部 API 或浏览器交互时使用 ref。如果存储的值不影响 UI 渲染，应优先选择 ref。典型场景：

- 存储 timeout ID
- 存储和操作 DOM 元素
- 存储不用于计算 JSX 的其他对象

## ref 的最佳实践

原则：

- **将 ref 视为“脱围机制”。**
- **不要在渲染期间读取或写入 `ref.current`。**因为 React 不会追踪它的变化，会导致行为不可预测。

React state 的限制不适用于 ref，因为 **ref 是普通 JavaScript 对象**。

只要 ref 保存的信息不影响渲染，如何更新它都不会影响 React。

## 获取指向节点的 ref

要访问由 React 管理的 DOM 节点：

- 首先，引入 `useRef`。
- 然后，在组件中声明一个 ref。

- 最后，将 ref 作为 `ref` 属性传递给目标 JSX 标签。

**useRef**：用于访问由 React 管理的 DOM 节点。

**ref.current**：useRef 返回对象的属性，初始为 `null`，在 DOM 节点创建后保存对应节点引用。

React 创建对应 DOM 节点后，会将其引用赋值给 `myRef.current`。可在 **事件处理器** 中访问该 DOM 节点，并使用浏览器提供的 API。

## 使用 ref 回调管理 ref 列表

有时候，你需要为列表中每一项绑定 ref，但无法确定项数。

**Hook 只能在组件顶层调用**，不能在循环、条件语句或 `map()` 中调用 `useRef`。

不推荐方案：通过父元素 ref + `querySelectorAll` 查找子节点：结构脆弱，DOM 变化可能导致报错。

推荐方案：ref 回调，将函数传递给 `ref` 属性。React 在设置 ref 时传入 DOM 节点，在清除时传入 `null`。这使 得可使用自维护的数组或 **Map** 保存多个 ref。

开启严格模式后，ref 回调在开发环境中会运行 **两次**。

## 访问另一个组件的 DOM 节点

Ref 是一种**脱围机制**。手动操作其他组件 DOM 会导致代码脆弱。

你可以 将 ref 像 prop 一样从父组件传递到子组件。

**useImperativeHandle**：指定 ref 的返回值，使 ref 指向自定义对象而不是 DOM 节点。

## React 何时添加 refs

React 更新的两个阶段：

- **渲染阶段**：确定 UI 渲染内容。
- **提交阶段**：将变更应用到 DOM。

**渲染阶段不能访问 `ref.current`**（首次渲染为 `null`，更新时 DOM 未完成）。

React 在提交阶段才设置 `ref.current`。

**通常从事件处理器访问 refs**。如果没有特定事件，需要使用 effect。

## 用 flushSync 同步更新 state

React 中 state 更新是**排队异步处理**。

你可以强制 React 同步更新 DOM：从 `react-dom` 导入 `flushSync`。 并**将 state 更新包裹到 flushSync 中**，React 将在代码执行后立即同步更新 DOM。

## 使用 refs 操作 DOM 的最佳实践

Refs 是脱围机制，只在必须“跳出 React”时使用。

**避免更改 React 管理的 DOM 节点**（包括修改、添加或删除子元素）。

可以安全修改**React 不会更新的部分 DOM**。
