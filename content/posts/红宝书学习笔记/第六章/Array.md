ES数组每个槽位可以存储任意类型的数据。ES数组是动态大小的，会随着数据添加而自动增长

# 创建数组
使用Array构造函数：
```js
let colors = new Array()
```
如果知道数组中元素的数量，可以给构造函数传入一个数值，然后length属性就会被自动创建并设置为这个值。
也可以给构造函数传入一个要保存的元素。
也可以省略new操作符
```js
let colors = Array(3)	//包含3个元素的数组
let names = Array('Greg')	//一个只包含一个元素字符串Greg的数组
```

使用数组字面量表示法，即在中括号中包含以逗号分隔的元素列表。
```js
let colors = ['red','blue','green']
```

Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。

Array.from()用于将类数组结构转换为数组实例，第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构。
Array.from()还接受第二个可选的映射函数参数，用于增强新数组的值(相当于map方法)。还可以接收第三个可选参数，用于指定映射函数中this的值，在箭头函数中不适用。
```js
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, function(x){return x**this.exponent}, {exponent: 2})
```
Array.of()可以把一组参数转换为数组，用于替代ES6之前的Array.prototype.slice.call(arguments)写法
# 数组空位
使用数组字面量初始化数组时，可以用一串逗号来创建空位。ES会将逗号之间索引位置的值当成空位。
ES6新增的方法和迭代器普遍将这些空位当成存在的元素，只不过值为undefined
ES6之前的方法会忽略这个空位，具体行为因方法而异
由于行为不一致和存在性能隐患，要避免使用数组空位，如果确实需要，可以显式的用undefined代替
# 数组索引
要取得或设置数组的值,需要使用中括号并提供相应值的数字索引。
在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元素数，则返回存储在相应位置的元素，设置数组的方法也是一样的，就是替换指定位置的值。如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1。

数组中元素的数量保存在length属性中，这个属性始终返回0或大于0的值
数组length属性不是只读的，通过修改length属性可以从数组末尾删除或添加元素。
如果将length设置为大于数组元素的值，则新添加的元素都将以undefined填充。

使用length属性可以方便的向数组末尾添加元素，数组中最后一个元素的索引始终是length-1，因此下一个新增槽位的索引就是length。每次在数组最后一个元素后面新增一项，数组的length属性都会自动更新，以反映变化。新的长度会在新增元素被添加到当前数组外部的位置上时自动更新。

# 检测数组
```js
if(value instanceof Array)

if(Array.isArray(value))
```
Array.isArray()方法确定一个值是否为数组，不用管它是在哪个全局执行上下文中创建的。
# 迭代器方法
ES6中，Array原型上暴露了3个用于检索数组内容的方法：keys()返回数组索引的迭代器，values()返回数组元素的迭代器，entries()返回索引/值对的迭代器
# 复制和填充方法
ES6新增两个方法：批量复制方法copyWithin()和填充数组方法fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小

使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾，负值索引从数组末尾开始计算，也可以将负值索引想象成数组长度加上他得到的一个正索引
```js
const zeroes = [0, 0, 0, 0, 0]
//用8填充索引大于等于1且小于4的元素
zero.fill(8, -4, -1)	//[0, 8, 8, 8, 0]
zero.fill(0)	//[0, 0, 0, 0, 0]
```
copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。
```js
let ints,
	reset = () => inits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
reset()
	
//从ints中复制索引0开始到索引3结束的内容，插入到索引4开始的位置
ints.copyWithin(4, 0, 3)
reset()
```

fill()和copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围

# 转换方法
valueOf()返回的是数组本身，toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是对数组的每个值都会调用其toString()方法，以得到最终的字符串
toLocaleString()也可能返回相同的结果，但也不一定，他与另外两个方法的唯一区别是，为了得到最终的字符串，会调用数组每个值的toLocaleString()方法，而不是toString()方法。

如果想使用不同的分隔符，则可以使用join()方法，join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。如果不给join()传入任何参数，或者传入undefined，则仍然使用逗号作为分隔符

# 栈方法
栈：限制插入和删除项的数据结构。栈是一种后进先出的结构，也就是最近添加的项先被删除。数据项的插入和删除只在栈的一个地方发生，即栈顶。

push()方法接受任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。
pop()方法用于删除数组的最后一项，同时减少数组的length值，返回被删除的项

# 队列方法
队列：以先进先出形式限制访问，在列表末尾添加数据，从列表开头获取数据。

shift()方法会删除数组的第一项并返回它，然后数组长度减1。使用shift()和push()可以把数组当成队列来使用
unshift()会在数组开头添加多个值，然后返回新的数组长度。通过unshift()和pop()可以在相反方向上模拟队列

# 排序方法
reverse()将数组元素反向排列
sort()会按照升序重新排列数组元素，即最小的值在前，最大的值在后。sort()会在每一项上调用String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串在比较、排序
sort()方法可以接受一个比较函数，用于判断哪个值应该排在前面。
比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。
```js
//降序
function compare(value1, value2){
	return value2 - value1
}
```
# 操作方法

concat()方法可以在现有数组元素基础上创建一个新数组，它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则concat()会把这些数组的每一项都添加到结果数组，如果不是数组，则直接把它们添加到结果数组末尾

打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号symbol.isConcatSpreadable这个符号能够阻止concat()打平参数数组。相反，把这个值设置为true可以强制打平类数组对象
```js
newColors[Symbol.isConcatSpreadable] = false
```

方法slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。这个操作不影响原始数组。
如果slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置，如果结束位置小于开始位置，则返回空数组。

splice()的主要目的是在数组中间插入元素，但有3种不同的方式使用这个方法：
- 删除：需要给splice()传2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素。
- 插入：需要给splice()传3个参数：开始位置、要删除的元素数量和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。
- 替换：splice()可以在删除元素的同时在指定位置插入新元素，要插入的元素数量不一定跟删除的元素数量一致。

splice()方法始终返回这样一个数组，它包含从数组中被删除的元素，如果没有删除元素，则返回空数组

# 搜索和位置方法

## 严格相等搜索

indexOf()、lastIndexOf()和include()。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和include()方法从数组前头开始向后搜索，而lastIndexOf()从数组末尾开始向前搜索
indexOf()和lastIndexOf()都返回要查找的元素在数组中的位置，如果没有找到则返回-1。
includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每项时，会使用全等(===)比较，也就是说两项必须严格相等。

## 断言函数
ES允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配
断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配
find()和findIndex()方法使用了断言函数，这两个方法都从数组的最小索引开始。findIndex()返回第一个匹配元素的索引，find()返回第一个匹配的元素。这两个方法也都接收第二个可选的参数，用于指定断言函数内部this的值
```js
people.find((element, index, array) => element.age < 28)
```
# 迭代方法
ES为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象(影响函数中this的值)。传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。
- every()：对数组每一项都运行传入的函数，如果对每一项函数都返回true，则这个方法返回true
- filter()：对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回
- forEach()：对数组每一项都运行传入的函数，没有返回值
- map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组
- some()：对数组每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true

这些方法都不改变调用它们的数组

在这些方法中，every()和some()是最相似的，都是从数组中搜索符合某个条件的元素。对every()来说，传入的函数必须对每一项都返回true，它才会返回true；否则， 他就返回false。而对some()来说，只要有一项让传入的函数返回true，他就会返回true。

filter()这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。

map()方法也会返回一个数组，这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果

forEach()方法只会对每一项运行传入的函数，没有返回值，相当于使用for循环遍历数组。

# 归并方法
ES为数组提供了两个归并方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项，而reduceRight()从最后一项开始遍历至第一项。
这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给reduce()和reduceRight()的函数接收4个参数：上一个归并值、当前值、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数，则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。