> 本文深入解析了JavaScript的执行上下文和作用域机制。执行上下文分为全局和函数上下文，每个函数调用会创建新上下文并压入栈中。作用域链决定了变量访问顺序，内部可访问外部变量但反之不行。文章对比了var、let和const的特性：var存在变量提升，let提供块级作用域，const声明不可更改的常量。详细解释了标识符搜索规则，从当前作用域开始逐级向外查找，直至全局上下文。还介绍了with和try/catch语句对作用域链的临时影响。通过剖析上下文创建、销毁过程和变量查找机制，揭示了JavaScript的核心作用域工作原理。

变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在与这个对象上

全局上下文是最外层的上下文。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。全局上下文在应用程序退出前才会被销毁

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ES程序的执行流就是通过上下文栈控制的

上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象用作变量对象。活动对象最初之后一个定义变量：arguments。作用域中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符，此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量

内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索

函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则

---

虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。

通常会在两种情况下出现这个现象，即代码执行到下面任意一种情况时：

- try/catch语句的catch块
- with语句

这两种情况下，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明

---

在使用**var**声明变量时，变量会被自动添加到最接近的上下文，在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文

var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象叫做提升，提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用

---

**let**的作用域是块级的，块级作用域由最近的一对包含花括号决定

let与var的另一个不同之处是在同一作用域内不能声明两次，重复的var声明会被忽略，而重复的let声明会报错

let的行为非常适合在循环中声明迭代变量，使用var声明的迭代变量会泄露到循环外部

let在JS运行时也会被提升，但由于暂时性死区缘故，实际上不能在声明之前使用let变量

---

**const**声明的变量必须同时初始化为某个值，一经声明，在其生命周期的任何时候都不能再重新赋予新值。除此之外与let声明是一样的

const声明只应用到顶级原语或者对象，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不受影响

如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败

由于const声明按时变量的值是单一类型且不可修改，JS运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找

---

当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么，搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定，如果没有找到变量名，则继续沿作用域链搜索。（作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明

对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符

使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次

