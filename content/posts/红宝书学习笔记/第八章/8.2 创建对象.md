# 工厂模式
```js
function createPerson(name, age, job){
	let o = new	Object()
	o.name = name
	o.age = age
	o.job = job
	o.sayName = function(){
		console.log(this.name)
	}
	return o
}

let person1 = createPerson("Nicholas", 29, "Software Egineer")
let person2 = createPerson("Greg", 27, "Doctor")
```
这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。
# 构造函数模式
构造函数用于创建特定类型对象，可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
```js
function Person(name, age, job){
	this.name = name
	this.age = age
	this.job = job
	this.sayName = function(){
		console.log(this.name)
	}
}

let person1 = new Person("Nicholas", 29, "Software Egineer")
let person2 = new Person("Greg", 27, "Doctor")
```
构造函数和工厂函数的区别：
- 没有显式的创建对象
- 属性和方法直接赋值给了this
- 没有return

创建Person实例用new操作符，会执行如下操作：
- 在内存中创建一个新对象
- 这个新对象内部的\[\[Prototype]]特性被赋值为构造函数的prototype属性。
- 构造函数内部的this被赋值为这个新对象(即this指向新对象)
- 执行构造函数内部的代码(给新对象添加属性)
- 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

新创建的对象都有一个constructor属性指向构造函数
```js
person1.constructor == Person
```
constructor本来是用于标识对象类型的，不过，一般认为instanceof是更可靠的方式

定义自定义构造函数可以确保实例被标识为特定类型。
构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式可以表示构造函数

在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用对应的构造函数
## 构造函数也是函数
构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数

在调用一个函数而没有明确设置this值的情况下，this始终指向global对象。
## 构造函数的问题
构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。ES中函数是对象，因此每次定义函数时，都会初始化一个对象
解决这个问题，可以把函数定义转移到构造函数外部
虽然能解决相同逻辑函数重复定义的问题，但全局作用域因此搞乱了，导致自定义类型引用的代码不能很好的聚集在一起。
# 原型模式
每个函数都会创意一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。
与构造函数模式不同，使用原型模式定义的属性和方法是由所有实例共享的。

## 理解原型
无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性，指向原型对象。默认情况下，所有原型对象自动获得一个名为constructor属性，指回与之关联的构造函数，因构造函数而异，可能会给原型对象添加其他属性和方法。
在自定义构造函数时，原型对象默认只会获得constructor属性，其他的方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部\[\[Prototype]]指针就会被赋值为构造函数的原型对象。JS中没有访问这个\[\[Prototype]]的标准方式，有些浏览器会在对象上暴露\_\_proto\_\_属性，通过这个属性可以访问对象的原型。
可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上，isPrototype()会在传入参数的\[\[Prototype]]指向调用它的对象时返回true。
Object.getPrototypeOf()返回参数的内部特性\[\[prototype]]的值。
Object.setPrototypeOf()方法可以向实例的私有特性\[\[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系。
但是为了避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：
```js
let person = Object.create(bipe)	//Object.getPrototypeOf(person) === bipe
```
## 原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。
虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。
只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过，使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。
hasOwnProperty()方法用于确定某个属性是在实例上还是在原型上，这个方法继承自Object，会在属性存在于调用它的对象实例上时返回true
## 原型和in操作符
有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上。
在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举属性的实例属性也会返回。
要获得对象上的所有可枚举的实例属性可以使用Object.keys()方法，这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。
如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyName()

# 对象迭代
Object.value()和Object.entries()接收一个对象，返回它们内容的数组。前者返回对象值的数组，后者返回键值对的数组。非字符串属性会被转换为字符串输出，执行对象的浅复制。符号属性会被忽略
## 其他原型语法
可以直接通过一个包含所有属性和方法的对象字面量来重写原型，但这样重写之后constructor属性就不指向原构造函数了，指向了Object，虽然可以专门设置以下它的值，但又会造成constructor属性的Enumerable为true。可以用Object.defineProperty来解决。
```js
function Person(){}

Person.prototype = {
	name:'Nicholas',
	age: 29
}

Object.defineProperty(Person.prototype,"constructor",{
	enumerable:false,
	value:Person
})
```
## 原型的动态性
因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。
重写构造函数上的原型之后再创建的实例才会引用新的原型，而在此之前创建的实例仍然会引用最初的原型。
## 原生对象原型
所有原生引用类型的构造函数都在原型上定义了实例方法。
通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。

## 原型的问题
- 弱化了向构造函数传递初始化参数的能力
- 共享特性