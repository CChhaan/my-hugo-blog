> 本文系统介绍了JavaScript类的定义与继承机制。类可通过声明或表达式定义，具有块级作用域且不支持提升。类包含构造函数、实例方法、静态方法等，默认严格模式执行。构造函数使用new操作符实例化，遵循特定对象创建流程。类支持实例成员、原型方法和静态方法，可通过extends实现单继承，使用super访问父类。文章详细解析了继承规则、抽象基类实现、内置类型扩展及混入模式等高级特性，阐明了类与传统构造函数的区别，为面向对象编程提供了全面指导。

与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号

与函数表达式类似，类表达式在它们被求值前也不能引用，不过与函数定义不同的是，虽然函数声明可以提升，但类定义不能，函数受函数作用域限制，而类受块作用域限制

类可以包含构造函数方法、实例方法、获取函数、 设置函数和静态类方法，但这些都不是必须的，空的类定义照样有效，默认情况下，类定义中的代码都在严格模式下执行

类表达式的名称是可选的，在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串，但不能在类表达式作用域外部访问这个标识符

---

constructor关键字用于在类定义块内部创建类的构造函数，方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数

使用new操作符实例化操作等于使用new调用其构造函数，唯一可感知的不同之处是，JS解释器知道使用new和类意味着应该使用constructor函数进行实例化。

使用new调用类的构造函数会执行如下操作：

- 在内存中创建一个新对象
- 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性
- 构造函数内部的this被赋值为这个新对象
- 执行构造函数内部的代码
- 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的

默认情况下，类构造函数会在执行之后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改

类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数时如果忘了使用new则会抛出错误

类构造函数没有什么特殊之处，实例化之后，他会成为普通的实例方法，因此，实例化之后可以在实例上引用它，但作为类构造函数，依然要使用new调用

ES类就是一种特殊函数，类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身

与普通构造函数一样，可以使用instanceof操作符检查构造函数原型是否存在于实例的原型链中

类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当成构造函数，类中定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符时会返回false，但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof操作符的返回值会反转

类是JS一等公民，因此可以像其他对象或函数引用一样把类作为参数传递

与立即调用函数表达式类似，类也可以立即实例化

---

通过new调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例添加自有属性，至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员

每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享

为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据

类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键，类定义也支持获取和设置访问器，语法与行为跟普通对象一样

可以在类上定义静态方法，这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，静态类方法非常适合作为实例工厂

静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样

虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加

类定义语法支持在原型和类本身上定义生成器方法，因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象

---

ES6类支持单继承，使用extends关键字，就可以继承任何拥有[[Constructor]]和原型的对象，很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数。派生类都会通过原型链访问到类和原型上定义的方法，this的值会反映调用相应方法的实例或者类

派生类的方法可以通过super关键字引用它们的原型，这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数

在静态方法中可以通过super调用继承的类上定义的静态方法

ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象，这个指针是自动赋值的，而且只能在JS引擎内部访问。super始终会定义为[[HomeObject]]的原型

在使用super时要注意几个问题：

- super只能在派生类构造函数和静态方法中使用
- 不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法
- 调用super会调用父类构造函数，并将返回的实例赋值给this
- super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入
- 如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数
- 在类构造函数中，不能在调用super之前引用this
- 如果在派生类中显示定义了构造函数，则要么必须在其中调用super，要么必须在其中返回一个对象

有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。可以通过new.target实现，new.target保存通过new关键字调用的类或函数，通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化

通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法，因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this关键字来检查相应的方法

ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便的扩展内置类型

有些内置类型的方法，会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的，如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类

把不同类的行为集中到一个类是一种常见的JS模式，extends关键字后面是一个JS表达式，任何可以解析为一个类或一个构造函数的表达式都是有效的，这个表达式会在求值类定义时被求值。混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。可以定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数连缀调用，最终组合成超类表达式