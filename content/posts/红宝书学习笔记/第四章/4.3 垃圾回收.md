# 标记清理

当变量进入上下文，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能它们。当变量离开上下文时，也会被加上离开上下文的标记

垃圾回收程序运行的时候，会标记内存中存储的所有变量，然后它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存

# 引用计数

其思路是对每个值都记录它被引用的次数。声明变量并给他赋一个引用值时，这个值的引用数为1，如果同一个值又被赋给另一个变量，那么引用数加1.类似的，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全的收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存了。

循环引用：对象A由一个指针指向对象B，对象B也引用了对象A，它们的引用数永远不会变为0。

为避免循环引用的问题，应该在确保不使用的情况下切断互相引用的对象之间的连接，比如用null覆盖。

# 内存管理

优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用。这也可以叫解除引用。

局部变量在超出作用域后会被自动解除引用

## 通过const和let声明提升性能

const和let都以块为作用域，所以相比于使用var，使用这两个新关键字可能会更早的让垃圾回收程序介入，尽早回收应该回收的内存。

## 隐藏类和删除操作

```js
	function Article(){
    this.title='Ingauration Ceremony Features Kazoo Band'
}
let a1 = new Article()
let a2 = new Article()
```

V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好。
上面这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型

动态删除属性（用delete）和动态添加属性(对象.新属性=属性值)会让两个实例对应两个不同的隐藏类，可能对性能产生明显影响
解决方案是避免JS的先创建后补充式的动态属性赋值，并在构造函数中一次性声明所有属性。把不想要的属性设置为null。
## 内存泄漏
- 意外声明全局变量
- 定时器
- 闭包

## 静态分配与对象池
