每当用到某个原始值的方法或属性时,后台都会创建一个相应原始包装类型的对象,从而暴露出操作原始值的各种方法

```js
let s1 = 'some text'
let s2 = s1.substring(2)
```
当第二行访问s1时，是以读模式访问的，也就是要从内存中读取变量保存的值。
在以读模式访问字符串值的时候，后台都会执行以下3步：
1. 创建一个String类型的实例
2. 调用实例上的方法
3. 销毁实例

这种行为可以让原始值拥有对象的行为。

引用类型与原始值包装类型的主要区别在于对象的声明周期。在通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。

可以显示的使用Boolean、Number和String构造函数创建原始值包装对象。不过应该在确实必要时再这么做。
***所有原始值包装对象都会转换为布尔值true***
另外，Object构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。

# Boolean
Boolean的实例会重写valueOf()方法，返回一个原始值true或false。toString()方法被调用时也会被覆盖，返回字符串"true"或"false"
# Number
Number的实例重写了valueOf()方法，返回Number对象表示的原始数值，toString()方法可选的接收一个表示基数的参数，并返回相应基数形式的字符串

toFixed()方法返回包含指定小数点位数的数值字符串，如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位
toExponential()方法返回以科学计数法表示的数值字符串。接收参数表示结果中小数的位数
toPrecision()方法会根据情况返回最合理的结果，可能是固定长度，也可能是科学计数法形式，接收参数表示结果中数字的总位数，会向上或向下舍入
isInteger()方法用于辨别一个数值是否保存为整数
isSafeInteger()方法判断整数是否超出可表示范围