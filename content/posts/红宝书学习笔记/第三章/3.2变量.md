变量可以保存任何类型的数据，每个变量只不过是一个用于保存任意值的命名占位符

# var(函数作用域和变量提升)

定义变量可以使用var操作符，后跟变量名，可以用它保存任何类型的值。可以同时定义变量并保存它的值
```js
var message = 'hi'
```

之后，不仅可以改变保存的值，也可以改变值的类型

使用var操作符定义的变量会成为包含它的函数的局部变量，该变量将在函数退出时被销毁。
不过在函数内定义变量时省略var操作符，可以创建一个全局变量

如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量

var变量提升：var关键字声明的变量会自动提升到函数作用域顶部
反复多次使用var声明同一个变量也没有问题

----

# let(块作用域,暂时性死区,迭代变量)

let声明的范围是块作用域，var声明的范围是函数作用域

块作用域是函数作用域的子集，因此适用于var的作用域限制同样也适用于let

let不允许同一个作用域中出现冗余声明
嵌套使用相同的标识符不会报错，因为同一个块中没有重复声明
对声明冗余报错不会因混用let和var而受影响。

let声明的变量不会在作用域中被提升，在let生命之前的执行瞬间被称为“暂时性死区”。

let的全局作用域中声明的变量不会成为window对象的属性，var声明的变量则会

使用var声明变量时，由于变量会被提升，JS引擎会自动将多余的声明在作用域顶部合并成一个声明。let不会。

在使用let声明迭代变量时，JS引擎在后台会为每个迭代循环声明一个新的迭代变量。

----

# const

const的行为与let基本相同，用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。

const声明的限制只适用于它指向的变量的引用，如果const变量引用的是一个对象，那么修改这个对象内部的属性不违反const的限制

不能用const来声明迭代变量，因为迭代变量会自增

可以用const声明一个不会被修改的for循环变量，对for-of和for-in有意义

> 最佳实践：不使用var,const优先,let次之