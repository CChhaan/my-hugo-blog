---
title: "第七章 修改历史记录"
date: 2025-08-20T19:49:53
draft: false
---

## 修改历史信息

- **命令**：git rebase -i <基准commit>

- `-i`：进入互动模式，可编辑历史提交。

- `<基准commit>`：指定修改范围为 “当前分支中，该 commit 之后的所有提交”（不包含该 commit 本身）。

- **操作过程**：

- 执行命令后，弹出 vim 编辑器，列表中**从上到下为 “从旧到新” 的 commit**（与`git log`的 “从新到旧” 相反）。

- 每行开头为操作指令，将pick改成reword（或简写r），表示要改动该 commit 的信息，存档离开后，会弹出另一个 vim 编辑器，修改提交信息后保存，生成新 commit。

- **影响**：由于 commit 对象信息会影响 SHA-1 计算，Git 会生成新的 Commit 对象替代原来的，且该 commit 之后的所有 commit 都会重做新的对象替代旧的。

- **取消 rebase**：git reset ORIG_HEAD --hard

## 把多个 commit 合并成一个 commit

1. 执行`git rebase -i <最早要合并的commit的前一个哈希>`（如合并最近 3 个 commit，基准为`HEAD~4`）。
2. 在编辑器中，将目标 commit 的`pick`改为`squash`（或`fixup`）

3. 保存退出后，若用`squash`：弹出编辑器，合并所有 commit 信息为一个（`fixup`则直接使用上一个 commit 的信息）。

4. 完成后，多个 commit 被合并为一个，历史更简洁。

## 把一个 commit 拆解成多个 commit

1. 在 rebase 的互动模式下使用edit指令，继续执行 rebase，rebase 会在edit位置停下来。

1. 执行git reset HEAD^指令。

1. 重新 commit 拆出来的文件，再执行git rebase --continue让 rebase 继续即可。

## 在某些 commit 之间加新的 commit

1. 在 rebase 互动模式下，将目标 commit 改成edit，继续执行 rebase，让 rebase 停在该 commit 上。

1. 注意：处于 rebase 状态的 commit 列表与平常记录相反，需确认停下来的点正确。

1. 增加新的 commit，完成后执行git rebase --continue，即可在指定位置中间增加新 commit。

## 删除某几个 commit 或调整 commit 顺序

- **调整顺序**：在 rebase 交互模式下调整 commit 的位置，存档离开即可。

- **删除 commit**：在 rebase 交互模式下，把对应 commit 的pick改成drop，或直接删掉该记录即可。

## reset、revert 和 rebase 指令的区别

| 指令   | 特点                                                         | 适用场景                                                     |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| reset  | 将 HEAD 指针移动到指定 commit，可重置工作区 / 暂存区（`--hard`/`--mixed`/`--soft`） | 通常适用于尚未推出去的 commit                                |
| revert | 生成新 commit 抵消目标 commit 的修改，原 commit 保留         | 适用于已经推出去的 commit，或不允许使用 reset 和 rebase 修改历史记录的情景。例如取消最后的 commit：git revert HEAD --no-edit（--no-edit表示不编辑 commit 信息） |
| rebase | 重建 commit 历史（修改、合并、拆分、插入 commit）            | 通常只适用于尚未推出去的 commit                              |