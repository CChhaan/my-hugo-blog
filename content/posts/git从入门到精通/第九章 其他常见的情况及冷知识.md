#### 一、工作中途切换任务的处理（git stash）

`git stash`用于临时保存工作区和暂存区的修改（未提交的内容），以便切换分支处理其他任务，后续可恢复继续工作。

- **保存当前修改**：

```bash
git stash                  # 保存已跟踪文件的修改（默认不包含untracked文件）
git stash -u               # 同时保存untracked文件（新文件）
git stash -a               # 保存所有修改（包括untracked和ignored文件，谨慎使用）
git stash -m "描述信息"     # 给stash添加描述，便于区分（推荐）
```

- **查看保存的 stash**：

```bash
git stash list             # 列出所有stash，格式：stash@{n}: WIP on <分支名>: <描述>
# 示例：stash@{0}: WIP on feature/login: 完善表单验证
```

- **恢复 stash**：

  - `git stash pop <stash@{n}>`：恢复指定 stash 并从列表中删除（默认恢复最新的 stash@{0}）。
  - `git stash apply <stash@{n}>`：恢复指定 stash 但**不删除**（可多次应用，适合多分支复用）。

- **删除 stash**：

  ```bash
  git stash drop <stash@{n}>  # 删除指定stash
  git stash clear             # 清空所有stash（谨慎！）
  ```

#### 二、移除 Git 历史中的敏感信息（如账号密码）

当不慎提交敏感文件后，需彻底从历史中删除。

1. 推荐方法：`git filter-repo`（现代替代`filter-branch`）

`git filter-branch`因性能差、易出错已被官方推荐`git filter-repo`替代（需先安装：`pip install git-filter-repo`）。

- 移除历史中的敏感文件：

  ```bash
  # 彻底删除历史中所有"敏感文件路径"的痕迹
  git filter-repo --path "敏感文件路径" --invert-paths
  ```

  - `--path`：指定要删除的文件路径；
  - `--invert-paths`：保留除指定路径外的所有内容（即删除目标文件）。

2. **简单但粗暴的方法**

- 删除 `.git` 目录（丢失所有历史）→ 删除敏感文件 → 重新初始化仓库并提交。
- 优点：简单；缺点：丢失历史记录。

3. **传统方法：`git filter-branch`（git filter-branch）**

- 移除历史中指定文件：

  ```bash
  git filter-branch --tree-filter 'rm -f 敏感文件路径'
  ```

  （```--tree-filter```会在每个 commit 中执行删除指令，重新生成历史）

- 撤销操作（后悔时）：

  ```bash
  git reset refs/original/refs/heads/master --hard
  ```

  （```filter-branch```会备份原历史到```.git/refs/original/```）

#### 三、合并其他分支的特定提交（git cherry-pick）

用于**选择性合并**其他分支的单个或多个 commit（而非合并整个分支），适用于 “跨分支复用特定修改” 场景（如 bug 修复需同步到多个分支）。

1. **基本用法**
   - 合并单个 commit：`git cherry-pick <commit的SHA-1值>`
   - 合并多个 commit：`git cherry-pick <commit1> <commit2> ...`
2. **特性**
   - 并非移动原 commit，而是复制其内容并生成新 commit（原 commit 仍在原位）。
   - 选项 `--no-commit`：仅将修改放入暂存区，不自动提交。
   - **冲突处理**：cherry-pick 时若修改与当前分支冲突，需解决冲突后执行`git cherry-pick --continue`。

#### 四、彻底从 Git 中移除文件需结合 `filter-branch` 和垃圾回收机制。

1. 步骤

   - 强制移除文件并覆写备份：

     ```bash
     git filter-branch -f --tree-filter 'rm -f 文件名'
     ```

   - 删除原历史备份：`rm .git/refs/original/refs/heads/master`

   - 立即过期 reflog：`git reflog expire --all --expire=now`

   - 检查不可达对象：`git fsck --unreachable`

   - 手动触发垃圾回收：`git gc --prune=now`

#### 五、Git 的垃圾回收机制（git gc）

Git 会自动或手动清理无用对象，优化存储。

1. **对象类型**
   - **可达对象**：被分支、标签、HEAD 或 reflog 引用的对象（不会被清理）。
   - 不可达对象：
     - `unreachable`：无引用指向，但可能引用其他对象（如被删除的 commit 及其关联的 tree/blob）。
     - `dangling`：无引用指向且不引用其他对象（如孤立的 blob）。
       两者均为垃圾，会被`git gc`清理。
2. **触发方式**
   - 自动触发：当对象数量达到阈值时。
   - 手动触发：`git gc --prune=now`（立即清理过期对象）。

3. **相关指令**

- 查看不可达对象：`git fsck --unreachable --no-reflog`
- 立即过期 reflog：`git reflog expire --all --expire=now`

4. **产生垃圾对象的场景**

- 暂存后未提交又删除文件（Blob 无引用）。
- 多次 `git add` 同一文件的不同版本（旧版本 Blob 无引用）。
- 删除标签（Tag 对象无引用）。
- 变基（rebase）后原 commit 无引用。

#### 六、HEAD 断头状态（Detached HEAD）

指 HEAD 直接指向某个 commit 而非分支的状态。

1. **产生场景**

   - 直接 checkout 到某个无分支指向的 commit：`git checkout <commit的SHA-1>`
   - 变基（rebase）过程中。
   - 切换到未跟踪的远端分支（未用 `--track`）。

2. **特性**

   - 可提交，但新 commit 无分支指向，切换分支后易丢失（可能被垃圾回收）。

3. **解决方法**

   - **创建分支保留修改**：

     ```bash
     git checkout -b 新分支名  # 基于当前断头状态创建新分支，保留所有提交
     ```

   - **切换回正常分支**：

     ```bash
     git checkout 现有分支名    # 切换回已有分支（若有未提交修改，需先stash或commit）
     ```

   - 切换到远端分支时避免断头：`git checkout -t 远端分支名`（`-t` 即 `--track`，自动创建跟踪分支）。



