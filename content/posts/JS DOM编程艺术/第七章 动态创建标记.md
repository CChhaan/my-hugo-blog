---
title: "第七章 动态创建标记"
date: 2025-08-20T19:49:53
draft: false
---

###  一、传统文档操作方法

#### 1. `document.write()`

- **功能**：将字符串直接插入到文档中，语法简单（如 `document.write("<p>Hello</p>")`）。
- 缺点：
  - 违背 “行为与表现分离” 原则，需在 HTML 中嵌入 `<script>` 调用，导致代码耦合。
  - 可能引发文档验证错误，且与 `application/xhtml+xml` 类型文档不兼容（浏览器会忽略该方法）。

#### 2. `innerHTML`

- **功能**：读写元素内的 HTML 内容（如 `div.innerHTML = "<span>Hi</span>"` 可设置内容，`const html = div.innerHTML` 可读取内容）。
- 特点：
  - 简洁高效，适合批量操作 HTML 片段，但无法精确控制单个节点（会整体替换元素内容）。
  - 局限性：HTML 专有属性，不支持 XHTML 文档；安全性风险（可能引入 XSS 攻击，需谨慎处理用户输入）。
- **替代方案**：标准 DOM 方法（如 `createElement`、`appendChild`）虽代码量增加，但可精确控制节点，兼容性更强。

### 二、标准 DOM 操作方法

#### 1. 核心思想

- DOM 是文档的双向映射：既能读取文档结构（通过节点属性和方法），也能修改节点树（实时反映到浏览器渲染结果）。
- 浏览器显示的是 DOM 节点树，而非原始 HTML 代码，因此修改 DOM 会直接改变页面表现。

#### 2. 创建与插入节点

- **创建元素节点**：`document.createElement(tagName)`

  - 示例：`const newDiv = document.createElement("div");`（创建 `<div>` 元素，初始为 “文档碎片”，未插入文档）。

- **创建文本节点**：`document.createTextNode(text)`

  - 示例：`const textNode = document.createTextNode("Hello DOM");`（创建包含文本的节点）。

- **插入节点到文档**：

  parent.appendChild(child)：将子节点添加到父节点的子节点列表末尾。

  示例：

  ```js
  const parent = document.getElementById("container");
  parent.appendChild(newDiv); // 将 newDiv 插入到 container 中
  newDiv.appendChild(textNode); // 给 newDiv 添加文本内容
  ```

#### 3. 在指定位置插入节点

- `insertBefore(newNode, targetNode)`：

  将新节点插入到目标节点之前，语法为parent.insertBefore(newNode, targetNode)。

  - 参数：

    - `newNode`：要插入的新节点；
    - `targetNode`：目标节点（新节点将位于其前方）；
    - `parent`：目标节点的父元素（可通过 `targetNode.parentNode` 获取）。

  - 示例：

    ```js
    const parent = document.getElementById("list");
    const target = parent.querySelector("li:nth-child(2)"); // 目标节点
    parent.insertBefore(newLi, target); // 在第二个 li 前插入新 li
    ```

### 三、AJAX 技术

#### 1. 核心：`XMLHttpRequest` 对象

- **作用**：允许 JS 直接向服务器发送请求并处理响应，无需刷新页面，实现 “异步交互”。

#### 2. 基本使用步骤

1. **创建对象**：`const request = new XMLHttpRequest();`

2. 配置请求：

   ```
   request.open(method, url, async)
   ```

   - `method`：请求类型（`"GET"`、`"POST"` 等）；
   - `url`：请求的服务器资源地址（需与当前页面同域，否则引发跨域错误）；
   - `async`：是否异步（`true` 为异步，`false` 为同步，推荐异步）。

3. 监听响应：通过onreadystatechange事件处理函数捕获服务器响应：

   ```js
   request.onreadystatechange = function() {
     // readyState 为 4 表示响应完成
     if (request.readyState === 4) {
       // 处理响应数据
       const responseData = request.responseText; // 文本数据
       // 或 const xmlDoc = request.responseXML; // XML 数据（需服务器返回 text/xml 类型）
     }
   };
   ```

4. 发送请求：

   ```
   request.send(data)
   ```

   - `data`：POST 请求时的参数（GET 请求可省略或传 `null`）。

#### 3. `readyState` 属性

- 表示请求状态，共 5 个值：
  - 0：未初始化（未调用 `open`）；
  - 1：加载中（`open` 已调用，`send` 未调用）；
  - 2：加载完成（`send` 已调用，响应头接收完毕）；
  - 3：交互中（正在接收响应体）；
  - 4：完成（响应全部接收）。

#### 4. 注意事项

- **跨域限制**：`XMLHttpRequest` 只能请求同域资源（协议、域名、端口均相同），跨域需通过 CORS 等机制解决。
- **异步特性**：请求发送后，脚本会继续执行，需在 `onreadystatechange` 中处理响应（避免同步请求阻塞页面）。