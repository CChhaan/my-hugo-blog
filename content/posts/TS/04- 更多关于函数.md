---
title: "04  更多关于函数"
date: 2025-08-20T19:49:53
draft: false
---

### 1. 函数类型表达式

- **基本语法**：用箭头函数形式描述函数类型，如`(a: string) => void`（参数`a`为`string`类型，无返回值）。
  - 特点：参数名必须存在（仅用于标识，不影响类型匹配），未指定类型时隐式为`any`（可通过`noImplicitAny`禁用）。

- **示例**：

```ts
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}
function printToConsole(s: string) { console.log(s); }
greeter(printToConsole); // 符合函数类型要求
```

- **类型别名命名**：通过`type`给函数类型命名，提升可读性和复用性：

```ts
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) { /* ... */ }
```

- **类型兼容性（面试高频）**：函数类型兼容遵循 “参数少的可赋值给参数多的”（逆变原则简化版）：

```typescript
type F1 = (a: string) => void;
type F2 = (a: string, b: number) => void;
const f1: F1 = (a) => {};
const f2: F2 = f1; // 合法：F1参数更少，可兼容F2
```

### 2. 带属性的函数与调用签名

- **函数类型表达式的局限**：仅能描述函数的调用方式，无法声明函数自身的属性（如`fn.prop`）。

- **调用签名**：若需描述可调用且带属性的对象，可在对象类型中编写调用签名，参数列表与返回类型间用:分隔（而非=>）：

```ts
type DescribableFunction = {
  description: string;
  (someArg: number): boolean; // 调用签名
};
function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}
function myFunc(someArg: number) { return someArg > 3; }
myFunc.description = "default description";
doSomething(myFunc); // 符合带属性的函数类型
```

### 3. 构造函数与构造签名

- **构造函数**：可通过new运算符调用的函数，TypeScript 中用**构造签名**描述，即在调用签名前加new关键字：

```ts
type SomeConstructor = {
  new (s: string): SomeObject; // 构造签名
};
function fn(ctor: SomeConstructor) {
  return new ctor("hello"); // 符合构造函数调用方式
}
```

- **可同时调用与构造的函数**：如Date，可组合调用签名和构造签名（可直接调用`Date()`返回字符串，也可`new Date()`返回实例）：

```ts
interface CallOrConstruct {  
  (n?: number): string; // 普通调用签名
  new (s: string): Date; // 构造签名
} 
function fn(ctor: CallOrConstruct) {  
  console.log(ctor(10)); // 普通调用
  console.log(new ctor("10")); // 构造调用
} 
fn(Date); // Date符合该类型
```

### 4. 泛型函数

- **基本概念**：通过类型参数（如`<T>`）关联输入与输出类型，实现 “类型动态适配”

```ts
// 类型参数Type关联输入数组与返回值
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```

- **类型推断**：TS 会根据传入的实参自动推断类型参数，无需显式指定（复杂场景需手动指定）：

```ts
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}
const parsed = map(["1", "2", "3"], (n) => parseInt(n)); // 推断Input为string，Output为number
```

- **类型约束**：通过extends限制类型参数的范围，仅允许符合约束的类型：

```ts
// 限制Type必须有length属性
function longest<Type extends { length: number }>(a: Type, b: Type): Type {
  return a.length >= b.length ? a : b;
}
```

- **手动指定类型参数**：当类型推断不明确时，可手动指定：

```ts
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
const arr = combine<string | number>([1, 2, 3], ["hello"]); // 手动指定Type为string | number
```

**泛型函数设计原则（面试常问）**：

- 优先使用类型参数本身（如`T`），而非仅依赖约束（避免`T extends X`却只使用`X`的属性）。

- 减少类型参数数量（避免无意义的泛型，如仅出现一次的类型参数）。
- 避免过度约束（约束应最小化，满足需求即可）。

### 5. 参数处理

- **可选参数**：用`?`标记，未传递时为`undefined`，可与默认值结合：

```ts
function greet(name: string = "Guest") {
  console.log(`Hello, ${name}`);
}

function greet(name?: string) {
  console.log(`Hello, ${name ?? "Guest"}`);
}
```

- **多余参数**：JavaScript 中多余参数会被忽略，TypeScript 行为一致，参数少的函数可替代参数多的函数（类型相同）。

- 注意：可选参数必须位于必选参数之后，默认值参数可在任意位置（但建议放后面）。

- **回调函数参数**：避免给回调参数声明不必要的可选性，否则可能导致调用时参数不匹配

### 6. 函数重载

- **作用**：指定可通过不同方式调用的函数，由多个重载签名（描述调用方式）和一个实现签名组成（实际逻辑，不可直接调用）。

```ts
// 重载签名
function add(a: number, b: number): number;
function add(a: string, b: string): string;
// 实现签名（需兼容所有重载签名）
function add(a: number | string, b: number | string): number | string {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  }
  return a.toString() + b.toString();
}
```

- 注意事项（面试高频）：
  - 重载签名需从**具体到抽象**排序（TS 优先匹配靠前的签名）。
  - 优先使用联合类型而非重载，避免类型推断混乱。
  - 实现签名的参数类型必须是所有重载签名的超集（否则会报错）。

### 7. 特殊类型与返回值

- **this** **类型推断**：TypeScript 通过代码流分析自动推断函数中this的类型
  - 显式指定：通过函数第一个参数`this: Type`声明`this`类型（仅用于类型检查，不影响运行时）。

- **void**：表示函数无返回值，与undefined不同。上下文类型为void的函数可返回值但会被忽略；字面量定义为void的函数则不能返回内容。
  - `void`：函数 “无实际返回值”（可`return`或不`return`，返回值会被忽略）。

  - `undefined`：函数必须显式返回`undefined`（如`return`或`return undefined`）。

- **object**：指非基础值（string、number等），与{}和Object不同。函数类型属于object。

- **unknown**：代表任意值，比any安全，使用前需明确类型，适用于描述接受 / 返回任意值但需安全处理的函数。
  - `unknown`：更安全的 “任意类型”，使用前必须显式缩小类型（如`if (typeof x === 'string')`）。

  - `any`：完全关闭类型检查，不建议滥用。

- **never**：表示从未观察到的值，如函数抛出异常、无限循环或终止程序，也会出现在联合类型无剩余选项时。

- **Function**：包含函数的bind、call等属性，调用返回any，不安全，建议用() => void替代（若无需调用）。

### 8. 剩余参数与扩展语法

- **剩余参数**：位于所有参数之后，用`...`接收多个参数，类型需为数组或元组：

```ts
function sum(...nums: number[]): number {
  return nums.reduce((a, b) => a + b, 0);
}
```

- **扩展语法**：将数组 “展开” 为参数列表，需与函数参数类型匹配：

```ts
const numbers = [1, 2, 3];
sum(...numbers); // 等价于sum(1, 2, 3)
```

### 9. 参数解构

- 对参数对象解构时，直接在解构语法后添加类型注释：

```ts
function printCoordinates({ x, y }: { x: number; y: number }) {
  console.log(`x: ${x}, y: ${y}`);
}
```