### 一、条件类型

条件类型通过判断类型关系返回不同类型，基本形式为 `SomeType extends OtherType ? TrueType : FalseType`，核心价值在于与泛型结合实现灵活的类型逻辑。

#### 1. 基本用法

- 当SomeType可赋值给OtherType时，返回TrueType；否则返回FalseType

  ```ts
  type Example1 = Dog extends Animal ? number : string; // 若Dog是Animal的子类型，返回number
  ```

#### 2. 与泛型结合

条件类型与泛型结合可简化重载，实现类型与值的动态关联：

```ts
// 需求：输入number返回IdLabel，输入string返回NameLabel
type IdLabel = { id: number };
type NameLabel = { name: string };

// 条件类型关联输入与输出类型
type Label<T extends number | string> = T extends number ? IdLabel : NameLabel;

// 单个函数替代重载
function createLabel<T extends number | string>(value: T): Label<T> {
  return typeof value === 'number' ? { id: value } : { name: value } as Label<T>;
}

const label1 = createLabel(10); // 类型：IdLabel（{ id: number }）
const label2 = createLabel("Alice"); // 类型：NameLabel（{ name: string }）
```

#### 3. 类型推断与 `infer`

通过 `infer` 关键字在条件类型中**声明性推断类型**，无需显式指定提取逻辑：

- 示例 1：提取数组元素类型

  ```ts
  type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;
  type Str = Flatten<string[]>; // type Str = string（推断Item为string）
  type Num = Flatten<number>; // type Num = number（不满足数组，返回原类型）
  ```

- 示例 2：提取函数返回类型

  ```ts
  type GetReturnType<Type> = Type extends (...args: never[]) => infer Return ? Return : never;
  type Func = () => string;
  type FuncReturn = GetReturnType<Func>; // type FuncReturn = string
  ```

- 注意：从多签名类型（如重载函数）推断时，仅基于最后一个签名（最宽松的情况）。

#### 4. 对联合类型的分布性

条件类型作用于**泛型联合类型**时，会自动 “分布” 到每个联合成员，逐个处理后再合并结果：

```ts
type ToArray<Type> = Type extends any ? Type[] : never;
type StrArrOrNumArr = ToArray<string | number>; // type StrArrOrNumArr = string[] | number[]
```

- 避免分布性：用方括号包裹extends两侧

  ```ts
  type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;
  type ArrOfStrOrNum = ToArrayNonDist<string | number>; // type ArrOfStrOrNum = (string | number)[]
  ```

#### 5. 内置条件类型（面试高频）

TS 内置了基于条件类型的工具类型，需理解其实现原理：

- `Exclude<T, U>`：从 T 中排除可赋值给 U 的类型

  ```typescript
  type E = Exclude<string | number | boolean, number>; // string | boolean
  // 实现：type Exclude<T, U> = T extends U ? never : T
  ```

- `Extract<T, U>`：从 T 中提取可赋值给 U 的类型

  ```typescript
  type E = Extract<string | number | boolean, number>; // number
  // 实现：type Extract<T, U> = T extends U ? T : never
  ```

- `NonNullable<T>`：排除`null`和`undefined`

  ```typescript
  type N = NonNullable<string | null | undefined>; // string
  // 实现：type NonNullable<T> = T extends null | undefined ? never : T
  ```

### 二、映射类型

映射类型通过迭代对象类型的属性（`[Property in keyof Type]`）生成新类型，用于批量转换属性类型。

#### 1. 基本形式

```ts
// 将Type的所有属性值类型转为boolean
type OptionsFlags<Type> = {
  [Property in keyof Type]: boolean;
};

type Feature = { darkMode: unknown; newUser: unknown };
type FeatureOptions = OptionsFlags<Feature>; // { darkMode: boolean; newUser: boolean }
```

#### 2. 属性修饰符的添加与移除

通过 `+`/`-` 修饰符控制 `readonly` 和 `?`（可选）：

- 移除readonly

  ```ts
  type CreateMutable<Type> = {
    -readonly [Property in keyof Type]: Type[Property]; // -readonly 移除只读
  };
  type ReadonlyObj = { readonly a: number };
  type MutableObj = CreateMutable<ReadonlyObj>; // { a: number }
  ```

- 移除可选属性（?）

  ```ts
  type Concrete<Type> = {
    [Property in keyof Type]-?: Type[Property]; // -? 移除可选
  };
  type PartialObj = { a?: number };
  type ConcreteObj = Concrete<PartialObj>; // { a: number }
  ```

- **添加修饰符**：默认添加用`+`（可省略），如添加`readonly`：

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P]; // 等价于 +readonly
};
```

#### 3. 键的重映射（`as` 子句）

通过 `as` 子句修改属性键名，常结合**模板字面类型**实现动态重命名：

- 示例 1：生成getXxx格式的 getter 方法类型

  ```typescript
  type Getters<T> = {
    // 键名：`get${首字母大写的属性名}`，值：返回原属性类型的函数
    [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];
  };
  
  type Person = { name: string; age: number };
  type PersonGetters = Getters<Person>; 
  // { getName: () => string; getAge: () => number }
  ```

- 示例 2：过滤属性（生成 never移除键）

  ```ts
  type RemoveKindField<Type> = {
    [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]; // 排除"kind"键
  };
  type WithKind = { kind: string; value: number };
  type WithoutKind = RemoveKindField<WithKind>; // { value: number }
  ```

#### 4. 映射联合类型

映射类型可迭代联合类型（不限于 `string | number | symbol`）：

```ts
type EventConfig<Events extends { kind: string }> = {
  [E in Events as E["kind"]]: (event: E) => void; // 以event的kind为键
};

type SquareEvent = { kind: "square"; x: number };
type CircleEvent = { kind: "circle"; radius: number };
type Config = EventConfig<SquareEvent | CircleEvent>;
// { square: (event: SquareEvent) => void; circle: (event: CircleEvent) => void }
```

#### 5. 内置映射类型（面试必知）

TS 内置的常用映射类型及其实现：

- `Partial<T>`：所有属性变为可选

  ```typescript
  type Partial<T> = { [P in keyof T]?: T[P] };
  ```

- `Pick<T, K>`：从 T 中挑选 K 指定的属性

  ```typescript
  type Pick<T, K extends keyof T> = { [P in K]: T[P] };
  ```

### 三、模板字面类型

基于字符串字面类型，通过模板语法（`${}`）生成新字符串类型，支持联合扩展和内置字符串操作。

#### 1. 基本用法

```ts
type World = "world";
type Greeting = `hello ${World}`; // type Greeting = "hello world"（拼接字符串字面）
```

#### 2. 联合类型的扩展

当模板插值为联合类型时，会生成**所有可能组合**的字符串字面联合：

```ts
type EmailIDs = "welcome" | "heading";
type FooterIDs = "title" | "sendoff";
type AllIDs = `${EmailIDs | FooterIDs}_id`; 
// type AllIDs = "welcome_id" | "heading_id" | "title_id" | "sendoff_id"
```

#### 3. 结合映射类型的应用

通过模板字面类型动态生成属性名，如事件监听方法：

```ts
type PropEventSource<Type> = {
  on<Key extends string & keyof Type>(
    eventName: `${Key}Changed`, // 生成"xxxChanged"格式的事件名
    callback: (newValue: Type[Key]) => void
  ): void;
};

// 使用示例
const person = makeWatchedObject({ firstName: "Alice", age: 26 });
person.on("firstNameChanged", (newName) => {}); // newName类型为string
person.on("ageChanged", (newAge) => {}); // newAge类型为number
```

#### 4. 内置字符串操作类型

TypeScript 提供内置类型用于字符串转换：

- Uppercase\<StringType>：转换为大写

  ```ts
  type Upper = Uppercase<"hello">; // "HELLO"
  ```

- Lowercase\<StringType>：转换为小写

  ```ts
  type Lower = Lowercase<"HELLO">; // "hello"
  ```

- Capitalize\<StringType>：首字母大写

  ```ts
  type Cap = Capitalize<"hello">; // "Hello"
  ```

- Uncapitalize\<StringType>：首字母小写

  ```ts
  type Uncap = Uncapitalize<"Hello">; // "hello"
  ```
