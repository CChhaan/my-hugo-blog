---
title: "06  泛型"
date: 2025-08-20T19:49:53
draft: false
---

### 一、类型变量

类型变量是泛型的 “灵魂”，用于在**类型层面**建立关联（而非值层面），解决 “同一份逻辑适配多种类型” 的问题。

#### 基本用法

```ts
// 定义泛型函数：类型变量<Type>关联输入与输出类型
function identity<Type>(arg: Type): Type {
  return arg;
}

// 两种调用方式
let output1 = identity<string>("myString"); // 显式指定类型参数
let output2 = identity(42); // 类型推断（推荐）：编译器自动推断Type为number
```

- **核心价值**：避免重复编写不同类型的同名函数（如`identityString`、`identityNumber`），同时保持类型安全（对比`any`：`any`会丢失类型关联，泛型则保留输入与输出的类型一致性）。
- **类型推断**：编译器可通过传入的值自动推断类型参数，简化代码。复杂场景下若推断失败，需显式指定类型。
- **类型约束**：函数体内必须正确使用泛型参数（视为 “任意类型” 处理）。

### 二、泛型函数的类型定义

泛型函数的类型与非泛型函数类似，需先声明类型参数，有多种表达方式：

1. **直接作为函数类型**

   ```ts
   let myIdentity: <Type>(arg: Type) => Type = identity;
   ```

2. **使用不同名称的类型变量**（只要数量和使用方式一致）

   ```ts
   let myIdentity: <Input>(arg: Input) => Input = identity; // 合法：Input与Type作用相同
   ```

3. **对象字面量的调用签名**

   ```ts
   let myIdentity: { <Type>(arg: Type): Type } = identity;
   ```

4. **泛型接口**

   ```ts
   // 接口内声明泛型调用签名
   interface GenericIdentityFn {
     <Type>(arg: Type): Type;
   }
   let myIdentity: GenericIdentityFn = identity;
   
   // 接口本身泛型化（更常用）
   interface GenericIdentityFn<Type> {
     (arg: Type): Type;
   }
   let myIdentity: GenericIdentityFn<number> = identity; // 绑定类型参数为number
   ```

### 三、泛型类

泛型类在类名后通过`<>`声明类型参数，确保类的所有实例属性使用相同类型。

#### 基本用法

```ts
class GenericNumber<NumType> {
  zeroValue: NumType; // 实例属性使用泛型类型
  add: (x: NumType, y: NumType) => NumType; // 方法参数与返回值使用泛型类型
}

// 实例化时指定类型参数为number
let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = (x, y) => x + y;
```

#### 注意点

- 静态成员限制：泛型类的类型参数仅作用于实例端，静态成员不能使用类的类型参数，静态成员属于类本身，而非实例，无法关联实例的类型变量。

  ```ts
  class MyClass<T> {
    static prop: T; // 错误：静态成员不能使用类型参数T
  }
  ```

### 四、类型约束

通过`extends`关键字限制类型参数的范围，确保泛型参数具有特定属性或满足特定条件，避免函数体内因缺乏属性而报错。

#### 1. 基础约束

```ts
// 定义约束接口：必须包含length属性
interface Lengthwise {
  length: number;
}

// 泛型参数Type必须满足Lengthwise约束
function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
  console.log(arg.length); // 合法：确保有length属性
  return arg;
}

loggingIdentity("hello"); // 合法：string有length属性
loggingIdentity(123); // 错误：number无length属性
```

#### 2. 相互约束（类型参数受另一个类型参数约束）

```ts
// Key必须是Type的键（Key extends keyof Type）
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key]; // 安全：key一定是obj的有效键
}

let x = { a: 1, b: 2 };
getProperty(x, "a"); // 合法："a"是x的键
getProperty(x, "m"); // 错误："m"不是x的键
```

`keyof`与约束结合是实现 “类型安全的属性访问” 的核心

### 五、泛型工厂函数与类类型

创建泛型工厂函数时，需通过构造函数引用类类型，使用`{ new (): Type }`表示 “可实例化的类”。

```ts
// 工厂函数：接收类构造函数，返回实例
function create<Type>(c: { new (): Type }): Type {
  return new c();
}

// 示例：用于任何具有无参构造函数的类
class Foo { constructor() {} }
const foo = create(Foo); // foo类型为Foo
```

**扩展**：支持带参数的构造函数：

```typescript
function createWithArgs<T>(ctor: { new (name: string): T }, name: string): T {
  return new ctor(name);
}
class Person { constructor(public name: string) {} }
const person = createWithArgs(Person, "Bob"); // person.name为"Bob"
```

### 六、泛型参数默认值

为类型参数指定默认值，使其成为 “可选参数”，未显式指定时使用默认值（类似函数参数默认值）。

#### 基本用法

```ts
// T默认值为HTMLDivElement，U默认值为T[]
declare function create<
  T extends HTMLElement = HTMLDivElement,
  U extends HTMLElement[] = T[]
>(element?: T, children?: U): Container<T, U>;

const div = create(); // T=HTMLDivElement，U=HTMLDivElement[]
const p = create(new HTMLParagraphElement()); // T=HTMLParagraphElement，U=HTMLParagraphElement[]
```

#### 规则

- 带默认值的类型参数视为可选。
- 必需的类型参数不能跟在可选参数后。
- 默认类型必须满足类型参数的约束。
- 未指定的类型参数解析为默认值。
- 合并类 / 接口时，可给现有类型参数加默认值，或新增带默认值的类型参数。

### 七、方差

方差描述泛型类型在类型参数变化时的兼容性，分为**协变**、**逆变**和**不变**，TypeScript 会自动推断。

#### 1. 协变

- 关系与类型参数一致：若`T extends U`，则`Producer<T> extends Producer<U>`。

- 示例：返回值类型为泛型参数时通常是协变。

  ```ts
  interface Producer<out T> { make(): T; } // out表示协变（可省略，TypeScript自动推断）
  // Cat extends Animal → Producer<Cat> extends Producer<Animal>
  ```

#### 2. 逆变

- 关系与类型参数相反：若`T extends U`，则`Consumer<U> extends Consumer<T>`。

- 示例：参数类型为泛型参数时通常是逆变。

  ```ts
  interface Consumer<in T> { consume(arg: T): void; } // in表示逆变（可省略）
  // Cat extends Animal → Consumer<Animal> extends Consumer<Cat>
  ```

#### 3. 不变

- 仅当类型参数完全相同时才兼容：若`T extends U`，`ProducerConsumer<T>`与`ProducerConsumer<U>`互不兼容。

- 示例：同时包含协变和逆变成员的类型是不变的。

  ```ts
  interface ProducerConsumer<T> {
    make(): T; // 协变
    consume(arg: T): void; // 逆变 → 整体不变
  }
  ```

#### 方差注释注意事项

- TypeScript 自动推断方差，**几乎不需要手动注释**。
- 注释（`in`/`out`）仅在基于实例的比较中有效，不改变结构类型行为。
- 禁止编写与结构行为不符的注释（如给接收`T`参数的接口标`out`）。
- 仅在调试或极端性能优化时临时使用，调试后应删除。
