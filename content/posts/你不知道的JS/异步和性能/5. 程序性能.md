---
title: "5. 程序性能"
date: 2025-08-20T19:49:53
draft: false
---

### 一、Web Worker 基础

1. **定义与作用**：

   - Web Worker 是浏览器提供的多线程机制，允许 JS 主程序创建独立线程运行代码块（任务并行），避免主线程阻塞（如 UI 卡顿）。
   - 每个 Worker 是独立的 JS 引擎实例，运行在单独线程，与主程序及其他 Worker 隔离。

2. **创建与类型**：

   - **专用 Worker（Dedicated Worker）**：通过 `new Worker('script.js')` 创建，与主程序是一对一关系，仅能与创建它的程序通信。

   - 示例：

     ```js
     // 主程序中创建专用 Worker
     const w1 = new Worker('worker.js');
     ```

### 二、Worker 通信机制

1. **消息传递**：

   - 不共享作用域 / 资源，通过 **`message` 事件**双向通信，数据传递基于结构化克隆或所有权转移。

   - 主程序与 Worker 内部均通过postMessage(data)发送消息，通过onmessage监听消息：

     ```js
     // 主程序
     w1.postMessage('hello'); // 发送消息到 Worker
     w1.onmessage = (e) => console.log('收到 Worker 消息：', e.data);
     
     // worker.js 内部
     self.onmessage = (e) => {
       console.log('收到主程序消息：', e.data);
       self.postMessage('hi'); // 发送消息到主程序
     };
     ```

2. **终止 Worker**：

   - 主程序中调用 `w1.terminate()` 可立即终止 Worker（无清理机会）；
   - Worker 内部可调用 `self.close()` 主动终止自身。

### 三、Worker 运行环境

1. **限制与可用资源**：
   - 不可访问 DOM、主程序全局变量，但可使用 `navigator`、`location`、`JSON`、`setTimeout` 等，支持网络请求（如 `fetch`）。
   - 可通过 `importScripts('script1.js', 'script2.js')` 同步加载额外脚本（阻塞 Worker 执行直到加载完成）。
2. **典型应用场景**：
   - 密集型数学计算、大数据排序、数据预处理、高频网络通信等（避免阻塞主线程）。

### 四、数据传递方式

1. **结构化克隆**：

   - 传递对象时，JS 引擎自动克隆数据（支持大部分类型，如对象、数组、日期等），原始对象与克隆对象独立。

2. **Transferable 对象（所有权转移）**：

   - 适用于大数据集（如二进制缓冲区），通过转移所有权避免复制，提升性能。

   - 转移后，原对象不可用（变为空或不可访问），仅支持特定类型（如 `ArrayBuffer`）。

   - 示例：

     ```js
     // 主程序中传递 ArrayBuffer 给 Worker
     const buffer = new ArrayBuffer(1024);
     w1.postMessage(buffer, [buffer]); // 第二个参数指定转移的对象
     ```

   - 不支持的浏览器会降级为结构化克隆。

### 五、共享 Worker（SharedWorker）

1. **定义与创建**：

   - 可被同一站点的多个页面 / 程序共享的 Worker，通过 `new SharedWorker('script.js')` 创建。

2. **通信差异**：

   - 需通过 **`port` 对象**通信，且需初始化连接（`port.start()`）。

   - Worker 内部通过connect事件管理多连接，每个连接对应独立端口：

     ```js
     // 主程序
     const sw = new SharedWorker('shared-worker.js');
     sw.port.start(); // 初始化连接
     sw.port.postMessage('来自页面1的消息');
     sw.port.onmessage = (e) => console.log(e.data);
     
     // shared-worker.js 内部
     self.onconnect = (e) => {
       const port = e.ports[0]; // 获取当前连接的端口
       port.start();
       port.onmessage = (msg) => {
         port.postMessage(`收到：${msg.data}`); // 向对应端口回复
       };
     };
     ```

3. **生命周期**：

   - 只要有活跃连接，共享 Worker 就不会终止；所有连接关闭后才终止。

### 六、SIMD（单指令多数据）

- **定义**：一种数据并行技术，利用 CPU 向量指令同时处理多个数据（与 Web Worker 的任务并行不同）。
- **优势**：对数据密集型应用（如科学计算、图像处理）提升显著性能，通过底层指令级并行加速运算。

### 七、asm.js

- **定义**：JS 的一个高性能子集，通过避免难以优化的语法（如动态类型转换），让引擎可进行激进优化（接近原生代码速度）。
- **特点**：代码风格受限（如变量类型固定），适用于对性能要求极高的场景（如游戏引擎、数值计算）。

### 补充说明

- Worker 线程与主线程严格隔离，无法共享状态，通信是唯一交互方式。
- 共享 Worker 需注意跨页面通信的同步问题，通常用于共享缓存数据或协调多页面行为。
- SIMD 和 asm.js 目前在现代浏览器中应用较少，部分功能已被 WebAssembly 替代，但理解其原理有助于优化高性能 JS 代码。