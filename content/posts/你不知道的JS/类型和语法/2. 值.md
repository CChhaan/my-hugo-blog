### 一、数组

1. **特性**：
   - 可容纳任何类型的值，声明后可直接添加值，无需预先设定大小。
   - 使用`delete`运算符删除单元后，位置变为空白单元，数组`length`属性不变。
2. **稀疏数组**：
   - 指含有空白 / 空缺单元的数组，空白单元值为`undefined`，但与显式赋值为`undefined`的单元有区别（如`[,,]`与`[undefined, undefined]`行为不同）。
3. **索引与属性**：
   - 主要通过数字索引访问，但本质是对象，可包含字符串键值和属性（不计算在`length`内，`length`只计算数字索引的最大整数 + 1）。
   - 若字符串键值可强制转换为十进制数字，则会被当作数字索引处理。
4. **类数组转换**：
   - **类数组特征**：有`length`和数字索引，但无数组方法（如`arguments`、DOM 集合`NodeList`）
   - 可转换为真正的数组，常用方法：
     - `Array.prototype.slice.call(类数组)`
     - ES6 的`Array.from(类数组)`
     - 扩展运算符（需类数组为可迭代对象）

---

### 二、字符串

1. **与数组的区别**：
   - 是类数组（有`length`、`indexOf()`、`concat()`等），但并非字符数组。
   - 字符串不可变：成员函数不修改原始值，而是返回新字符串；数组可变：成员函数直接操作原始值。
2. **数组方法的借用**：
   - 可借用数组的非变更方法（如`Array.prototype.indexOf.call(str, 'a')`）处理字符串。
   - 不可借用数组的变更方法（因字符串不可变），需先通过`split('')`转为数组，处理后再用`join('')`转回字符串。

---

### 三、数字

1. **类型与格式**：
   - JS 只有一种数值类型`number`（双精度浮点数），包含整数（如`42.0`）和带小数的十进制数。
   - 字面量表示：
     - 十进制：可省略小数点前的 0（`.42`）或后多余的 0（`42.`）。
     - 特殊格式：指数形式（`1e3`）、二进制（`0b1010`）、八进制（`0o12`）、十六进制（`0xa`）。
2. **显示规则**：
   - 大部分数字默认以十进制显示，省略小数部分末尾的 0；特别大 / 小的数字默认用指数形式（同`toExponential()`）。
3. **Number 对象方法**：
   - `toFixed(n)`：指定小数部分显示位数，不足用 0 补齐（返回字符串）。
   - `toPrecision(n)`：指定有效数位的显示位数。
   - 注意：数字字面量调用方法时，需避免`.`被误判为数字一部分（如`42..toFixed(2)`或`42 .toFixed(2)`）。
4. **精度与范围**：
   - 精度问题：`0.1 + 0.2 !== 0.3`（浮点数二进制存储导致精度丢失），可通过`Math.abs(n1 - n2) < Number.EPSILON`（机器精度）判断近似相等。
   - 范围：
     - 最大浮点数：`Number.MAX_VALUE`；最小浮点数（接近 0 的正数）：`Number.MIN_VALUE`。
     - 安全整数范围：`Number.MIN_SAFE_INTEGER`（-2^53 + 1）到`Number.MAX_SAFE_INTEGER`（2^53 - 1），超出需用字符串处理。
     - **`BigInt`解决大整数**：用`n`后缀声明，支持超出安全范围的整数运算
     
     ```javascript
     const big = 9007199254740993n;
     big + 1n; // 9007199254740994n（精确计算）
     ```
5. **检测方法**：
   - `Number.isInteger(num)`：检测是否为整数（ES6+）。
   - `Number.isSafeInteger(num)`：检测是否为安全整数（ES6+）。

---

### 四、特殊数值

1. **null 与 undefined**：
   - 均为唯一值，名称即类型也即值。
   - 区别：
     - `null`：表示 “空值”（曾赋值，当前无值），不是标识符，不能作为变量赋值。
     - `undefined`：表示 “未赋值”，是内置标识符（不建议手动赋值，严格模式下可能报错）。
   - `void`运算符：表达式`void XXX`返回`undefined`，不改变表达式副作用（惯例用`void 0`获取`undefined`）。
2. **NaN（Not a Number）**：
   - 属于`number`类型，代表数学运算失败的警戒值。
   - 特性：与自身不相等（`NaN !== NaN`）。
   - 检测：`isNaN()`不可靠（误判非数字类型），`Number.isNaN()`更准确（仅检测`NaN`）。
3. **无穷数（Infinity）**：
   - 产生：正数除以 0 得`Infinity`，负数除以 0 得`-Infinity`；运算溢出时也会返回。
   - 特性：
     - `Infinity / Infinity`结果为`NaN`。
     - 有穷正数 /`Infinity`为 0，有穷负数 /`Infinity`为`-0`。
     - 溢出为无穷数后，无法再得到有穷数。
4. **负零（-0）**：
   - 产生：某些数学运算（如`-1 / Infinity`）的结果，加减法不会得到`-0`。
   - 特性：
     - 字符串化返回`"0"`，但从字符串转回数字时保留符号。
     - `-0 === 0`为`true`，ES6 的`Object.is(-0, 0)`为`false`（可准确区分）。

---

### 五、值和引用

1. **引用本质**：
   - JS 中引用指向值，而非变量；多个引用可指向同一值，但引用间无相互指向关系。
2. **赋值 / 传递规则**：
   - 由值的类型决定，与语法无关：
     - 基本类型（`null`、`undefined`、`string`、`number`、`boolean`、`symbol`）：通过**值复制**（赋值 / 传递的是值的副本）。
     - 复合值（对象、函数、数组等）：通过**引用复制**（赋值 / 传递的是指向值的引用）。
3. **操作特性**：
   - 引用无法修改另一个引用的指向（如`a = b`后修改`a`不影响`b`）。
   - 复合值的复制：需创建复本（如`a.slice()`返回数组浅复本），避免引用共享。
   - 基本类型的修改：若需在函数内修改基本类型，需封装到复合值中（通过引用传递）。
   - 基本类型不可变：其值无法被修改（如字符串的方法均返回新值）。
