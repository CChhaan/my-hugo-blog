---
title: "5. 语法"
date: 2025-08-20T19:49:53
draft: false
---

## 一、语句与表达式的基本概念

- **表达式**：能返回一个结果值的代码片段（如`1 + 2`返回`3`，`obj.prop`返回属性值）。
- **语句**：执行某种操作的代码（如`if`、`for`、`return`），**所有语句都有结果值**，但语法默认不允许直接获取。

### 语句的结果值

- 常见语句的结果值：
  - 赋值语句`a = b`：结果值为被赋予的值（即`b`的值）。
  - 变量声明`var a`：结果值为`undefined`（`let`/`const`同理）。
  - 代码块`{...}`：结果值为块内最后一个语句 / 表达式的结果（如`{1; 2; 3}`结果为`3`）。
- **获取语句结果值的方式**：语法不直接支持，但可通过`eval()`获取（如`eval('{a=1; b=2}')`返回`2`）。

## 二、表达式的副作用

副作用指表达式执行时对外部环境的改变（如修改变量、删除属性等）。

### 常见有副作用的表达式

- **函数调用**：最常见（如`console.log(1)`会输出内容，改变控制台状态）。
- 自增 / 自减运算符：
  - `a++`：先返回`a`的当前值，再将`a`加 1（副作用在后）。
  - `++a`：先将`a`加 1，再返回新值（副作用在前）。
  - 注意：`++a++`会报错（`ReferenceError`），因运算符需要可赋值的变量作为操作数。
- **逗号运算符**：将多个表达式串联为一个语句，返回最后一个表达式的结果（如`a=1, b=2, a+b`结果为`3`），副作用是执行所有表达式。
- delete 操作符：
  - 作用：删除对象属性或数组单元。
  - 结果值：成功删除（属性不存在或可配置）返回`true`；失败（不可配置属性）返回`false`或报错。
  - 副作用：实际移除属性 / 单元（如`delete obj.prop`后`obj.prop`为`undefined`）。
- **赋值语句**：`a = 42`结果为`42`，副作用是`a`被赋值为`42`；链式赋值（如`a = b = 42`）利用赋值表达式的结果值实现。

## 三、上下文规则

### 3.1 大括号`{}`的用法

- **对象常量**：定义对象字面量（如`{a: 1, b: 2}`）。

- 标签（label）：用于标记代码块，配合```break```/ ```continue```跳转：

  - `break 标签`：跳出标签标记的循环 / 代码块，执行后续代码（如跳出内层循环到外层）。
  - `continue 标签`：仅用于循环，跳转到标签标记的循环的下一轮（不能用于非循环代码块）。
  - 注意：标签不能用双引号；非循环代码块可使用`break 标签`，但不能用`continue 标签`。

- JSON 与 JSON-P：

  - JSON 是 JS 语法子集，但 JSON 的键需双引号，而 JS 标签不允许双引号，故 JSON 本身不是合法 JS 语法；
  - JSON-P：将 JSON 封装为函数调用（如`callback({ "a": 1 })`），使其成为合法 JS。

### 3.2 对象解构

- **解构赋值**：`{a, b} = obj`从对象中提取属性赋值给变量（`a = obj.a`，`b = obj.b`）。
- **函数参数解构**：`function fn({a, b}) {}`隐式用对象属性赋值给参数，简化传参（如`fn({a:1, b:2})`）。

### 3.3 else if 与可选代码块

- JS 无`else if`语法，实际是`if`的`else`块中嵌套`if`（如`if(...) { ... } else if(...) { ... }`等价于`if(...) { ... } else { if(...) { ... } }`）；
- `if`/`else`若仅包含单条语句，可省略大括号`{}`。

## 四、运算符优先级与短路

1. 圆括号（`()`）> 自增 / 自减 > 逻辑非（`!`）> 算术运算符（`*`/`+`等）> 比较运算符（`>`/`===`等）> 逻辑与（`&&`）> 逻辑或（`||`）> 三元运算符（`?:`）> 赋值运算符（`=`）> 逗号运算符（`,`）。
2. 优先级规则：
   - 逗号运算符（`,`）优先级最低；
   - `&&`优先级高于`=`；
   - `&&`执行先于`||`，`||`优先级高于三元运算符`?:`。
3. 短路现象：
   - `a && b`：若`a`为假值，直接返回`a`，不执行`b`；
   - `a || b`：若`a`为真值，直接返回`a`，不执行`b`；
   - 核心：左操作数已能决定结果时，忽略右操作数。

## 五、自动分号插入（ASI）

- **作用**：JS 解析器在换行符处自动补全缺失的分号，避免语法错误。

ASI只在换行符处起作用，而不会在代码行的中间插入分号

- 规则：
  - 仅在换行符处插入，不在代码行中间插入。
  - 仅当代码行末尾与换行符间只有空格 / 注释，且可能导致错误时插入。
  - **以`(`、`[`、`/`、`+`、`-`开头的行**：可能被解析为上一行的延续
  
- **典型场景**：
  - `do..while`循环后必须带分号，ASI 会自动补全；
  - `return`、`break`、`continue`、`yield`后换行：ASI 会在关键字后插入分号，导致后续代码不被包含（如`return\n1`被解析为`return; 1`，返回`undefined`）。

## 六、错误类型

### 6.1 早期错误（编译阶段）

- 代码执行前被发现的错误，导致解析 / 编译失败，无法用`try...catch`捕获。
- 例子：非法正则（`/[a-z/`）、对象常量重复属性（非严格模式允许，严格模式为早期错误）、函数参数重名（严格模式）。

### 6.2 暂时性死区（TDZ）

- 对于使用 `let`、`const` 或 `class` 声明的变量，变量**在声明之前访问变量**的区域称为暂时性死区
- 例子：
  - `let a`之前使用`a`在 TDZ 中，报错。
  - `typeof x`：`x`未声明时返回`"undefined"`；但`x`在 TDZ 中（如`let x; typeof x`前引用`x`）会报错。
  - 函数参数的默认值表达式中，后续参数不能引用前面未初始化的参数（因存在 TDZ）

## 七、函数参数

- 若参数被省略或为`undefined`，使用默认值（如`function fn(a=1) {}`，`fn()`中`a=1`）。

- ```arguments```与命名参数的偏差：

    - 非严格模式：ES5 中`arguments`与命名参数关联（修改其一影响另一）；ES6 默认值会打破关联（如`function fn(a=1) { arguments[0] = 2; console.log(a); } fn(3)`中`a`仍为`3`）。

    - 严格模式：`arguments`与命名参数无关联（始终独立）。


- 注意：避免同时访问命名参数和对应`arguments`单元（易混淆）。

## 八、try..finally

- **执行顺序**：`finally`中的代码始终执行（`try`后，`catch`后若有`catch`）。
- 特殊情况：
  - 若`try`/`catch`有`return`，函数返回值在`finally`执行后生效；
  - `finally`中抛出异常：函数终止，`try`/`catch`的`return`值被丢弃；
  - `finally`中的`return`会覆盖`try`/`catch`的`return`值；

## 九、switch 语句

- **匹配规则**：`case`表达式与`switch`表达式的匹配使用`===`（严格相等）。
- **case 表达式**：可使用任意表达式（结果与`switch`表达式比较，如`switch(true) { case a>1: ... }`）。
- **default**：可选，当所有`case`不匹配时执行；`break`规则对`default`有效（不写`break`会继续执行下一个`case`）。

