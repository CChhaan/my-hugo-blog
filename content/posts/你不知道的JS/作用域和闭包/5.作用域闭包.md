> 摘要：闭包是指函数能够记住并访问其词法作用域，即使在其作用域外执行。通过回调函数或将内部函数传递到外部都可形成闭包。示例展示了用IIFE解决循环变量共享问题，以及let在循环中的特殊行为。模块模式需满足：1)外部封闭函数被调用创建实例；2)返回内部函数形成闭包访问私有状态。ES6模块与函数模块不同，具有静态API检查机制，需定义在单独文件中，其内容如同在闭包中处理。

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包

只要使用了回调函数，实际上就是在使用闭包

> 一个需要调用的函数引用了其他作用域的变量，导致该作用域不会消失，并且函数可以随时引用这个作用域

```js
for (var i = 1; i < 5; i++) {
  (function (j) {
    setTimeout(function () {
        console.log(j); 
    }, j * 1000);
  }(i))
}
```

在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会包含有一个具有正确值的变量供我们访问！！！！！

for循环头部的let声明有一个特殊行为：变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量

---

最常见的实现模块模式的方法通常被称为模块暴露

模块模式需要具备两个必要条件：

- 必须有外部的封闭函数，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例
- 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

模块模式一个简单但强大的用法是命名将要作为公共API返回的对象

模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的API

基于函数的模块并不是一个能被静态识别的模式，可以在运行时修改一个模块的API，ES6模块API是静态的，编辑器可以在编译器检查对导入模块的API成员的引用是否真实存在，而不会等到运行期再动态解析

ES6模块没有行内格式，必须被定义在独立的文件中，模块中的内容会被当做好像包含在作用域闭包中一样来处理

