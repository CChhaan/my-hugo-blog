> JS中的变量和函数声明会在代码执行前被"提升"。引擎在编译阶段会将所有声明提前处理，但赋值操作保留原位。函数声明优先于变量声明，且会被提升到作用域顶部。需要注意的是，函数表达式不会被提升，块级函数声明也存在提升问题。开发者应避免在块内部声明函数，且重复声明时后面的函数会覆盖前面的。这些机制体现了JS编译阶段和执行阶段的差异性。

### 一、变量和函数声明的提升机制

1. **提升的本质**：
   引擎在编译阶段会提前处理所有变量和函数声明，将其 “移动” 到所在作用域的顶部（仅声明被提升，赋值及运行逻辑留在原地）。
2. **作用域范围**：每个作用域（全局、函数、块作用域）都会独立进行提升操作。

### 二、函数声明与变量声明的提升优先级

1. 函数声明优先：
   - 函数声明的提升优先级高于变量声明，会被提升到作用域更顶部。
   - 示例：若同时存在`function a() {}`和`var a`，函数声明会先被提升，变量声明因重复被忽略（但变量赋值会覆盖函数）。
2. 函数表达式不提升：
   - 函数表达式（如`var fn = function() {}`）的变量声明会提升，但函数赋值留在原地，因此在赋值前调用会得到`undefined`。
   - 具名函数表达式（如`var fn = function named() {}`）的名称标识符仅在函数内部有效，外部作用域中无法提前使用。

### 三、特殊情况与注意事项

1. 重复声明的覆盖：
   - 变量重复声明（如`var a = 1; var a = 2`）会被忽略前序，保留最后一次赋值；
   - 函数重复声明（如`function a() {}; function a() {}`）后序声明会覆盖前序。
2. 块级函数声明的问题：
   - 普通块内部的函数声明（如`if (true) { function a() {} }`）可能被提升到所在作用域顶部（不同 JS 环境处理有差异），易导致逻辑混乱，**应避免在块内声明函数**。