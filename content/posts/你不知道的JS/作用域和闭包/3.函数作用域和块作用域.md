---
title: "3.函数作用域和块作用域"
date: 2025-08-20T19:49:53
draft: false
---

> 《你不了解的JS》第一部分第三章探讨了函数和块作用域的概念。函数作用域允许变量在函数内部复用，并可通过隐藏内部实现遵循最小特权原则，避免命名冲突。函数声明与表达式的主要区别在于标识符绑定位置，建议为函数表达式命名以便调试。IIFE（立即执行函数表达式）是常见模式，可用于传递参数和解决变量覆盖问题。块作用域通过let和const实现变量本地化，let在循环中每次迭代重新绑定变量，const则创建不可变绑定。这些机制有助于优化变量生命周期和避免提升问题。

### 一、函数作用域的核心特性

1. **定义与复用**：函数内部声明的变量，可在整个函数范围内（包括嵌套作用域）使用和复用。
2. 隐藏内部实现：
   - 通过函数作用域封装变量和函数，遵循**最小特权原则**（仅暴露必要内容，隐藏细节），减少命名冲突。
   - 第三方库通常通过**命名空间对象**（将功能作为对象属性暴露）或**模块管理器**（避免全局作用域污染）防止冲突。

---

### 二、函数声明与表达式的区别

1. 区分方法：
   - 若`function`是声明的第一个词，则为**函数声明**；否则为**函数表达式**。
2. 关键差异：
   - 函数声明的名称标识符绑定在**所在作用域**中；
   - 函数表达式的名称标识符绑定在**自身函数内部**（外部不可直接访问）。
3. 匿名函数表达式的缺点：
   - 栈追踪无有意义名称，调试困难；
   - 无法通过名称自引用（依赖`arguments.callee`，已过时）；
   - 降低代码可读性。
   - **最佳实践**：始终为函数表达式命名（如`const fn = function namedFn() {}`）。

### 三、立即执行函数表达式（IIFE）

1. **定义**：函数表达式被声明后立即执行（如`(function() { ... })()`）。

2. 常见用途

   ：

   - 传递参数，隔离作用域（避免污染外部）；
   - 确保`undefined`标识符的准确性（通过参数占位，如`(function(undef) { ... })()`）；
   - 倒置代码执行顺序（将主逻辑作为参数传递给 IIFE）。

---

### 四、块作用域的特性与实现

1. **核心作用**：将变量本地化，扩展最小授权原则，从函数级隐藏扩展到块级隐藏。
2. 块作用域的优势：变量声明靠近使用位置，减少作用域污染，优化变量生命周期，避免提升带来的意外行为。
3. 实现方式：
   - **with 语句**：为对象创建临时块作用域（仅在`with`内部有效）；
   - **try/catch**：`catch`分句创建块作用域，内部变量仅在`catch`中有效；
   - let 关键字：
     - 将变量绑定到所在块作用域（如`if`、`for`块）；
     - 无提升特性（声明前访问会报错）；
     - `for`循环中，`let`会将变量**重新绑定到每个迭代**（确保迭代值独立）。
   - const 关键字：
     - 同`let`的块作用域特性，但值为常量（修改会报错）。
4. 原书中P34最上方 “点击事件因闭包导致变量问题” 的描述有误：实际是`var`声明的变量属于函数 / 全局作用域，生命周期长，导致循环中共享同一变量；而`let`通过块作用域解决此问题。
