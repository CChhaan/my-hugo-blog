---
title: "2.词法作用域"
date: 2025-08-20T19:49:53
draft: false
---

> 《你不了解的JS》笔记：词法作用域与欺骗词法
>
> 词法作用域由代码书写位置决定，查找从内向外进行，存在遮蔽效应。全局变量可通过window对象间接访问。欺骗词法的方式包括eval和with：eval动态修改作用域（严格模式除外），with将对象处理为临时作用域。两者都会影响性能，eval在严格模式下有独立作用域，with会将var声明泄漏到函数作用域。这些特性都可能导致代码运行效率下降。

### 一、词法作用域的核心特性

1. **定义与本质**：
   词法作用域是在代码**书写阶段**就确定的作用域，由变量、块作用域及函数的声明位置决定，与函数的调用位置无关。
2. **查找规则**：
   - 作用域查找从**最内部作用域**开始，逐级向外（向上）进行，直到找到第一个匹配的标识符后停止（即 “就近匹配”）。
   - 仅查找**一级标识符**（如`a`，不会自动查找对象属性链如`obj.a`）。
3. **遮蔽效应**：
   在多层嵌套作用域中，内层作用域的标识符可遮蔽外层同名标识符（如内层`var a = 1`会遮蔽外层的`var a = 2`）。
4. **全局变量的特殊访问**：
   全局变量会成为全局对象（如浏览器中的`window`）的属性，可通过`window.a`访问被内层同名变量遮蔽的全局变量。
5. **函数的词法作用域**：
   函数的词法作用域仅由其**声明时所处的位置**决定，与调用位置、调用方式无关。

---

### 二、欺骗词法作用域的方式

#### 1. eval 函数

- **功能**：接收字符串参数，将其视为代码片段插入到当前位置执行，仿佛该代码在书写时就存在于此。
- 对作用域的影响：
  - 默认情况下，若`eval`中的代码包含变量 / 函数声明，会**修改其所处的词法作用域**（新增或覆盖标识符）。
  - 严格模式下，`eval`有**独立的词法作用域**，内部声明不会影响外部作用域。
- **常见用途**：执行动态生成的代码（如拼接字符串形成的逻辑）。

#### 2. with 语句

- **功能**：作为访问对象多个属性的快捷方式，避免重复书写对象名（如`with(obj) { a = 1; b = 2 }`等效于`obj.a = 1; obj.b = 2`）。
- 对作用域的影响：
  - 将传入的对象视为一个**临时的词法作用域**，对象的属性被当作该作用域中的标识符。
  - 块内的`var`声明不会被限制在`with`块中，而是**泄漏到外层函数作用域**。
- **本质**：根据传入对象 “凭空创建” 全新的词法作用域，与`eval`修改现有作用域的行为不同。

### 三、副作用与风险

1. **性能问题**：
   `eval`和`with`会破坏 JS 引擎的**词法作用域静态分析**（无法提前确定变量查找规则），导致无法优化代码执行，显著降低运行效率。
2. **代码可读性与维护性**：
   动态修改作用域会使变量的查找逻辑变得模糊，增加调试难度，不符合词法作用域的设计初衷。
3. **严格模式限制**：
   严格模式下`eval`的作用域被隔离，`with`被完全禁止（直接抛出错误），进一步体现了对 “欺骗词法” 行为的不推荐。